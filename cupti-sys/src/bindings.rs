#![rustfmt::skip]
#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8)
                .offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8)
                .offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!(
            (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len(),
        );
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!(
            (bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>(),
        );
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!(
            (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len(),
        );
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!(
            (bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>(),
        );
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
pub const CUPTI_API_VERSION: u32 = 130001;
pub const CUPTI_SUBSCRIBER_NAME_MAX_LEN: u32 = 53;
pub const CUPTI_OLD_SUBSCRIBER_NAME_MIN_LEN: u32 = 64;
pub const CUPTILP64: u32 = 1;
pub const CUPTI_SOURCE_LOCATOR_ID_UNKNOWN: u32 = 0;
pub const CUPTI_FUNCTION_INDEX_ID_INVALID: u32 = 0;
pub const CUPTI_CORRELATION_ID_UNKNOWN: u32 = 0;
pub const CUPTI_GRID_ID_UNKNOWN: u32 = 0;
pub const CUPTI_TIMESTAMP_UNKNOWN: u32 = 0;
pub const CUPTI_AUTO_BOOST_INVALID_CLIENT_PID: u32 = 0;
pub const CUPTI_NVLINK_INVALID_PORT: i32 = -1;
pub const CUPTI_MAX_NVLINK_PORTS: u32 = 32;
pub const CUPTI_DECOMPRESSED_BYTES_UNKNOWN: u32 = 0;
pub const CUPTI_MAX_GPUS: u32 = 32;
pub const CUPTI_STALL_REASON_STRING_SIZE: u32 = 128;
pub type CUdevice_v1 = ::std::os::raw::c_int;
pub type CUdevice = CUdevice_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUctx_st {
    _unused: [u8; 0],
}
pub type CUcontext = *mut CUctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUevent_st {
    _unused: [u8; 0],
}
pub type CUevent = *mut CUevent_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstream_st {
    _unused: [u8; 0],
}
pub type CUstream = *mut CUstream_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraph_st {
    _unused: [u8; 0],
}
pub type CUgraph = *mut CUgraph_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphNode_st {
    _unused: [u8; 0],
}
pub type CUgraphNode = *mut CUgraphNode_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphExec_st {
    _unused: [u8; 0],
}
pub type CUgraphExec = *mut CUgraphExec_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphDeviceUpdatableNode_st {
    _unused: [u8; 0],
}
pub type CUgraphDeviceNode = *mut CUgraphDeviceUpdatableNode_st;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUuuid_st {
    pub bytes: [::std::os::raw::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUuuid_st"][::std::mem::size_of::<CUuuid_st>() - 16usize];
    ["Alignment of CUuuid_st"][::std::mem::align_of::<CUuuid_st>() - 1usize];
    [
        "Offset of field: CUuuid_st::bytes",
    ][::std::mem::offset_of!(CUuuid_st, bytes) - 0usize];
};
pub type CUuuid = CUuuid_st;
///< Maximum number of threads per block
pub const CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK: CUdevice_attribute_enum = 1;
///< Maximum block dimension X
pub const CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X: CUdevice_attribute_enum = 2;
///< Maximum block dimension Y
pub const CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y: CUdevice_attribute_enum = 3;
///< Maximum block dimension Z
pub const CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z: CUdevice_attribute_enum = 4;
///< Maximum grid dimension X
pub const CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X: CUdevice_attribute_enum = 5;
///< Maximum grid dimension Y
pub const CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y: CUdevice_attribute_enum = 6;
///< Maximum grid dimension Z
pub const CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z: CUdevice_attribute_enum = 7;
///< Maximum shared memory available per block in bytes
pub const CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK: CUdevice_attribute_enum = 8;
///< Deprecated, use CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK
pub const CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK: CUdevice_attribute_enum = 8;
///< Memory available on device for __constant__ variables in a CUDA C kernel in bytes
pub const CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY: CUdevice_attribute_enum = 9;
///< Warp size in threads
pub const CU_DEVICE_ATTRIBUTE_WARP_SIZE: CUdevice_attribute_enum = 10;
///< Maximum pitch in bytes allowed by memory copies
pub const CU_DEVICE_ATTRIBUTE_MAX_PITCH: CUdevice_attribute_enum = 11;
///< Maximum number of 32-bit registers available per block
pub const CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK: CUdevice_attribute_enum = 12;
///< Deprecated, use CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK
pub const CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK: CUdevice_attribute_enum = 12;
///< Typical clock frequency in kilohertz
pub const CU_DEVICE_ATTRIBUTE_CLOCK_RATE: CUdevice_attribute_enum = 13;
///< Alignment requirement for textures
pub const CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT: CUdevice_attribute_enum = 14;
///< Device can possibly copy memory and execute a kernel concurrently. Deprecated. Use instead CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT.
pub const CU_DEVICE_ATTRIBUTE_GPU_OVERLAP: CUdevice_attribute_enum = 15;
///< Number of multiprocessors on device
pub const CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT: CUdevice_attribute_enum = 16;
///< Specifies whether there is a run time limit on kernels
pub const CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT: CUdevice_attribute_enum = 17;
///< Device is integrated with host memory
pub const CU_DEVICE_ATTRIBUTE_INTEGRATED: CUdevice_attribute_enum = 18;
///< Device can map host memory into CUDA address space
pub const CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY: CUdevice_attribute_enum = 19;
///< Compute mode (See ::CUcomputemode for details)
pub const CU_DEVICE_ATTRIBUTE_COMPUTE_MODE: CUdevice_attribute_enum = 20;
///< Maximum 1D texture width
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH: CUdevice_attribute_enum = 21;
///< Maximum 2D texture width
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH: CUdevice_attribute_enum = 22;
///< Maximum 2D texture height
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT: CUdevice_attribute_enum = 23;
///< Maximum 3D texture width
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH: CUdevice_attribute_enum = 24;
///< Maximum 3D texture height
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT: CUdevice_attribute_enum = 25;
///< Maximum 3D texture depth
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH: CUdevice_attribute_enum = 26;
///< Maximum 2D layered texture width
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH: CUdevice_attribute_enum = 27;
///< Maximum 2D layered texture height
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT: CUdevice_attribute_enum = 28;
///< Maximum layers in a 2D layered texture
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS: CUdevice_attribute_enum = 29;
///< Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH: CUdevice_attribute_enum = 27;
///< Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT: CUdevice_attribute_enum = 28;
///< Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES: CUdevice_attribute_enum = 29;
///< Alignment requirement for surfaces
pub const CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT: CUdevice_attribute_enum = 30;
///< Device can possibly execute multiple kernels concurrently
pub const CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS: CUdevice_attribute_enum = 31;
///< Device has ECC support enabled
pub const CU_DEVICE_ATTRIBUTE_ECC_ENABLED: CUdevice_attribute_enum = 32;
///< PCI bus ID of the device
pub const CU_DEVICE_ATTRIBUTE_PCI_BUS_ID: CUdevice_attribute_enum = 33;
///< PCI device ID of the device
pub const CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID: CUdevice_attribute_enum = 34;
///< Device is using TCC driver model
pub const CU_DEVICE_ATTRIBUTE_TCC_DRIVER: CUdevice_attribute_enum = 35;
///< Peak memory clock frequency in kilohertz
pub const CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE: CUdevice_attribute_enum = 36;
///< Global memory bus width in bits
pub const CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH: CUdevice_attribute_enum = 37;
///< Size of L2 cache in bytes
pub const CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE: CUdevice_attribute_enum = 38;
///< Maximum resident threads per multiprocessor
pub const CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR: CUdevice_attribute_enum = 39;
///< Number of asynchronous engines
pub const CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT: CUdevice_attribute_enum = 40;
///< Device shares a unified address space with the host
pub const CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING: CUdevice_attribute_enum = 41;
///< Maximum 1D layered texture width
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH: CUdevice_attribute_enum = 42;
///< Maximum layers in a 1D layered texture
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS: CUdevice_attribute_enum = 43;
///< Deprecated, do not use.
pub const CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER: CUdevice_attribute_enum = 44;
///< Maximum 2D texture width if CUDA_ARRAY3D_TEXTURE_GATHER is set
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH: CUdevice_attribute_enum = 45;
///< Maximum 2D texture height if CUDA_ARRAY3D_TEXTURE_GATHER is set
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT: CUdevice_attribute_enum = 46;
///< Alternate maximum 3D texture width
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE: CUdevice_attribute_enum = 47;
///< Alternate maximum 3D texture height
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE: CUdevice_attribute_enum = 48;
///< Alternate maximum 3D texture depth
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE: CUdevice_attribute_enum = 49;
///< PCI domain ID of the device
pub const CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID: CUdevice_attribute_enum = 50;
///< Pitch alignment requirement for textures
pub const CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT: CUdevice_attribute_enum = 51;
///< Maximum cubemap texture width/height
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH: CUdevice_attribute_enum = 52;
///< Maximum cubemap layered texture width/height
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH: CUdevice_attribute_enum = 53;
///< Maximum layers in a cubemap layered texture
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS: CUdevice_attribute_enum = 54;
///< Maximum 1D surface width
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH: CUdevice_attribute_enum = 55;
///< Maximum 2D surface width
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH: CUdevice_attribute_enum = 56;
///< Maximum 2D surface height
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT: CUdevice_attribute_enum = 57;
///< Maximum 3D surface width
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH: CUdevice_attribute_enum = 58;
///< Maximum 3D surface height
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT: CUdevice_attribute_enum = 59;
///< Maximum 3D surface depth
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH: CUdevice_attribute_enum = 60;
///< Maximum 1D layered surface width
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH: CUdevice_attribute_enum = 61;
///< Maximum layers in a 1D layered surface
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS: CUdevice_attribute_enum = 62;
///< Maximum 2D layered surface width
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH: CUdevice_attribute_enum = 63;
///< Maximum 2D layered surface height
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT: CUdevice_attribute_enum = 64;
///< Maximum layers in a 2D layered surface
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS: CUdevice_attribute_enum = 65;
///< Maximum cubemap surface width
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH: CUdevice_attribute_enum = 66;
///< Maximum cubemap layered surface width
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH: CUdevice_attribute_enum = 67;
///< Maximum layers in a cubemap layered surface
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS: CUdevice_attribute_enum = 68;
///< Deprecated, do not use. Use cudaDeviceGetTexture1DLinearMaxWidth() or cuDeviceGetTexture1DLinearMaxWidth() instead.
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH: CUdevice_attribute_enum = 69;
///< Maximum 2D linear texture width
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH: CUdevice_attribute_enum = 70;
///< Maximum 2D linear texture height
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT: CUdevice_attribute_enum = 71;
///< Maximum 2D linear texture pitch in bytes
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH: CUdevice_attribute_enum = 72;
///< Maximum mipmapped 2D texture width
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH: CUdevice_attribute_enum = 73;
///< Maximum mipmapped 2D texture height
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT: CUdevice_attribute_enum = 74;
///< Major compute capability version number
pub const CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR: CUdevice_attribute_enum = 75;
///< Minor compute capability version number
pub const CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR: CUdevice_attribute_enum = 76;
///< Maximum mipmapped 1D texture width
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH: CUdevice_attribute_enum = 77;
///< Device supports stream priorities
pub const CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED: CUdevice_attribute_enum = 78;
///< Device supports caching globals in L1
pub const CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED: CUdevice_attribute_enum = 79;
///< Device supports caching locals in L1
pub const CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED: CUdevice_attribute_enum = 80;
///< Maximum shared memory available per multiprocessor in bytes
pub const CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR: CUdevice_attribute_enum = 81;
///< Maximum number of 32-bit registers available per multiprocessor
pub const CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR: CUdevice_attribute_enum = 82;
///< Device can allocate managed memory on this system
pub const CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY: CUdevice_attribute_enum = 83;
///< Device is on a multi-GPU board
pub const CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD: CUdevice_attribute_enum = 84;
///< Unique id for a group of devices on the same multi-GPU board
pub const CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID: CUdevice_attribute_enum = 85;
///< Link between the device and the host supports all native atomic operations
pub const CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED: CUdevice_attribute_enum = 86;
///< Ratio of single precision performance (in floating-point operations per second) to double precision performance
pub const CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO: CUdevice_attribute_enum = 87;
///< Device supports coherently accessing pageable memory without calling cudaHostRegister on it
pub const CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS: CUdevice_attribute_enum = 88;
///< Device can coherently access managed memory concurrently with the CPU
pub const CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS: CUdevice_attribute_enum = 89;
///< Device supports compute preemption.
pub const CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED: CUdevice_attribute_enum = 90;
///< Device can access host registered memory at the same virtual address as the CPU
pub const CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM: CUdevice_attribute_enum = 91;
///< Deprecated, along with v1 MemOps API, ::cuStreamBatchMemOp and related APIs are supported.
pub const CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS_V1: CUdevice_attribute_enum = 92;
///< Deprecated, along with v1 MemOps API, 64-bit operations are supported in ::cuStreamBatchMemOp and related APIs.
pub const CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS_V1: CUdevice_attribute_enum = 93;
///< Deprecated, along with v1 MemOps API, ::CU_STREAM_WAIT_VALUE_NOR is supported.
pub const CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR_V1: CUdevice_attribute_enum = 94;
///< Device supports launching cooperative kernels via ::cuLaunchCooperativeKernel
pub const CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH: CUdevice_attribute_enum = 95;
///< Deprecated, ::cuLaunchCooperativeKernelMultiDevice is deprecated.
pub const CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH: CUdevice_attribute_enum = 96;
///< Maximum optin shared memory per block
pub const CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN: CUdevice_attribute_enum = 97;
///< The ::CU_STREAM_WAIT_VALUE_FLUSH flag and the ::CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES MemOp are supported on the device. See \ref CUDA_MEMOP for additional details.
pub const CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES: CUdevice_attribute_enum = 98;
///< Device supports host memory registration via ::cudaHostRegister.
pub const CU_DEVICE_ATTRIBUTE_HOST_REGISTER_SUPPORTED: CUdevice_attribute_enum = 99;
///< Device accesses pageable memory via the host's page tables.
pub const CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES: CUdevice_attribute_enum = 100;
///< The host can directly access managed memory on the device without migration.
pub const CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST: CUdevice_attribute_enum = 101;
///< Deprecated, Use CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED
pub const CU_DEVICE_ATTRIBUTE_VIRTUAL_ADDRESS_MANAGEMENT_SUPPORTED: CUdevice_attribute_enum = 102;
///< Device supports virtual memory management APIs like ::cuMemAddressReserve, ::cuMemCreate, ::cuMemMap and related APIs
pub const CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED: CUdevice_attribute_enum = 102;
///< Device supports exporting memory to a posix file descriptor with ::cuMemExportToShareableHandle, if requested via ::cuMemCreate
pub const CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED: CUdevice_attribute_enum = 103;
///< Device supports exporting memory to a Win32 NT handle with ::cuMemExportToShareableHandle, if requested via ::cuMemCreate
pub const CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED: CUdevice_attribute_enum = 104;
///< Device supports exporting memory to a Win32 KMT handle with ::cuMemExportToShareableHandle, if requested via ::cuMemCreate
pub const CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED: CUdevice_attribute_enum = 105;
///< Maximum number of blocks per multiprocessor
pub const CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR: CUdevice_attribute_enum = 106;
///< Device supports compression of memory
pub const CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED: CUdevice_attribute_enum = 107;
///< Maximum L2 persisting lines capacity setting in bytes.
pub const CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE: CUdevice_attribute_enum = 108;
///< Maximum value of CUaccessPolicyWindow::num_bytes.
pub const CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE: CUdevice_attribute_enum = 109;
///< Device supports specifying the GPUDirect RDMA flag with ::cuMemCreate
pub const CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED: CUdevice_attribute_enum = 110;
///< Shared memory reserved by CUDA driver per block in bytes
pub const CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK: CUdevice_attribute_enum = 111;
///< Device supports sparse CUDA arrays and sparse CUDA mipmapped arrays
pub const CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED: CUdevice_attribute_enum = 112;
///< Device supports using the ::cuMemHostRegister flag ::CU_MEMHOSTERGISTER_READ_ONLY to register memory that must be mapped as read-only to the GPU
pub const CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED: CUdevice_attribute_enum = 113;
///< External timeline semaphore interop is supported on the device
pub const CU_DEVICE_ATTRIBUTE_TIMELINE_SEMAPHORE_INTEROP_SUPPORTED: CUdevice_attribute_enum = 114;
///< Device supports using the ::cuMemAllocAsync and ::cuMemPool family of APIs
pub const CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED: CUdevice_attribute_enum = 115;
///< Device supports GPUDirect RDMA APIs, like nvidia_p2p_get_pages (see https://docs.nvidia.com/cuda/gpudirect-rdma for more information)
pub const CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED: CUdevice_attribute_enum = 116;
///< The returned attribute shall be interpreted as a bitmask, where the individual bits are described by the ::CUflushGPUDirectRDMAWritesOptions enum
pub const CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS: CUdevice_attribute_enum = 117;
///< GPUDirect RDMA writes to the device do not need to be flushed for consumers within the scope indicated by the returned attribute. See ::CUGPUDirectRDMAWritesOrdering for the numerical values returned here.
pub const CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING: CUdevice_attribute_enum = 118;
///< Handle types supported with mempool based IPC
pub const CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES: CUdevice_attribute_enum = 119;
///< Indicates device supports cluster launch
pub const CU_DEVICE_ATTRIBUTE_CLUSTER_LAUNCH: CUdevice_attribute_enum = 120;
///< Device supports deferred mapping CUDA arrays and CUDA mipmapped arrays
pub const CU_DEVICE_ATTRIBUTE_DEFERRED_MAPPING_CUDA_ARRAY_SUPPORTED: CUdevice_attribute_enum = 121;
///< 64-bit operations are supported in ::cuStreamBatchMemOp and related MemOp APIs.
pub const CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS: CUdevice_attribute_enum = 122;
///< ::CU_STREAM_WAIT_VALUE_NOR is supported by MemOp APIs.
pub const CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR: CUdevice_attribute_enum = 123;
///< Device supports buffer sharing with dma_buf mechanism.
pub const CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED: CUdevice_attribute_enum = 124;
///< Device supports IPC Events.
pub const CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED: CUdevice_attribute_enum = 125;
///< Number of memory domains the device supports.
pub const CU_DEVICE_ATTRIBUTE_MEM_SYNC_DOMAIN_COUNT: CUdevice_attribute_enum = 126;
///< Device supports accessing memory using Tensor Map.
pub const CU_DEVICE_ATTRIBUTE_TENSOR_MAP_ACCESS_SUPPORTED: CUdevice_attribute_enum = 127;
///< Device supports exporting memory to a fabric handle with cuMemExportToShareableHandle() or requested with cuMemCreate()
pub const CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_FABRIC_SUPPORTED: CUdevice_attribute_enum = 128;
///< Device supports unified function pointers.
pub const CU_DEVICE_ATTRIBUTE_UNIFIED_FUNCTION_POINTERS: CUdevice_attribute_enum = 129;
///< NUMA configuration of a device: value is of type ::CUdeviceNumaConfig enum
pub const CU_DEVICE_ATTRIBUTE_NUMA_CONFIG: CUdevice_attribute_enum = 130;
///< NUMA node ID of the GPU memory
pub const CU_DEVICE_ATTRIBUTE_NUMA_ID: CUdevice_attribute_enum = 131;
///< Device supports switch multicast and reduction operations.
pub const CU_DEVICE_ATTRIBUTE_MULTICAST_SUPPORTED: CUdevice_attribute_enum = 132;
///< Indicates if contexts created on this device will be shared via MPS
pub const CU_DEVICE_ATTRIBUTE_MPS_ENABLED: CUdevice_attribute_enum = 133;
///< NUMA ID of the host node closest to the device. Returns -1 when system does not support NUMA.
pub const CU_DEVICE_ATTRIBUTE_HOST_NUMA_ID: CUdevice_attribute_enum = 134;
///< Device supports CIG with D3D12.
pub const CU_DEVICE_ATTRIBUTE_D3D12_CIG_SUPPORTED: CUdevice_attribute_enum = 135;
///< The returned valued shall be interpreted as a bitmask, where the individual bits are described by the ::CUmemDecompressAlgorithm enum.
pub const CU_DEVICE_ATTRIBUTE_MEM_DECOMPRESS_ALGORITHM_MASK: CUdevice_attribute_enum = 136;
///< The returned valued is the maximum length in bytes of a single decompress operation that is allowed.
pub const CU_DEVICE_ATTRIBUTE_MEM_DECOMPRESS_MAXIMUM_LENGTH: CUdevice_attribute_enum = 137;
///< Device supports CIG with Vulkan.
pub const CU_DEVICE_ATTRIBUTE_VULKAN_CIG_SUPPORTED: CUdevice_attribute_enum = 138;
///< The combined 16-bit PCI device ID and 16-bit PCI vendor ID.
pub const CU_DEVICE_ATTRIBUTE_GPU_PCI_DEVICE_ID: CUdevice_attribute_enum = 139;
///< The combined 16-bit PCI subsystem ID and 16-bit PCI subsystem vendor ID.
pub const CU_DEVICE_ATTRIBUTE_GPU_PCI_SUBSYSTEM_ID: CUdevice_attribute_enum = 140;
///< Device supports HOST_NUMA location with the virtual memory management APIs like ::cuMemCreate, ::cuMemMap and related APIs
pub const CU_DEVICE_ATTRIBUTE_HOST_NUMA_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED: CUdevice_attribute_enum = 141;
///< Device supports HOST_NUMA location with the ::cuMemAllocAsync and ::cuMemPool family of APIs
pub const CU_DEVICE_ATTRIBUTE_HOST_NUMA_MEMORY_POOLS_SUPPORTED: CUdevice_attribute_enum = 142;
///< Device supports HOST_NUMA location IPC between nodes in a multi-node system.
pub const CU_DEVICE_ATTRIBUTE_HOST_NUMA_MULTINODE_IPC_SUPPORTED: CUdevice_attribute_enum = 143;
///< Device suports HOST location with the ::cuMemAllocAsync and ::cuMemPool family of APIs
pub const CU_DEVICE_ATTRIBUTE_HOST_MEMORY_POOLS_SUPPORTED: CUdevice_attribute_enum = 144;
///< Device supports HOST location with the virtual memory management APIs like ::cuMemCreate, ::cuMemMap and related APIs
pub const CU_DEVICE_ATTRIBUTE_HOST_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED: CUdevice_attribute_enum = 145;
///< Device supports page-locked host memory buffer sharing with dma_buf mechanism.
pub const CU_DEVICE_ATTRIBUTE_HOST_ALLOC_DMA_BUF_SUPPORTED: CUdevice_attribute_enum = 146;
///< Link between the device and the host supports only some native atomic operations
pub const CU_DEVICE_ATTRIBUTE_ONLY_PARTIAL_HOST_NATIVE_ATOMIC_SUPPORTED: CUdevice_attribute_enum = 147;
pub const CU_DEVICE_ATTRIBUTE_MAX: CUdevice_attribute_enum = 148;
/// Device properties
pub type CUdevice_attribute_enum = ::std::os::raw::c_uint;
/// Device properties
pub use self::CUdevice_attribute_enum as CUdevice_attribute;
///< Normal cache persistence.
pub const CU_ACCESS_PROPERTY_NORMAL: CUaccessProperty_enum = 0;
///< Streaming access is less likely to persit from cache.
pub const CU_ACCESS_PROPERTY_STREAMING: CUaccessProperty_enum = 1;
///< Persisting access is more likely to persist in cache.
pub const CU_ACCESS_PROPERTY_PERSISTING: CUaccessProperty_enum = 2;
/// Specifies performance hint with ::CUaccessPolicyWindow for hitProp and missProp members.
pub type CUaccessProperty_enum = ::std::os::raw::c_uint;
/// Specifies performance hint with ::CUaccessPolicyWindow for hitProp and missProp members.
pub use self::CUaccessProperty_enum as CUaccessProperty;
/** Specifies an access policy for a window, a contiguous extent of memory
 beginning at base_ptr and ending at base_ptr + num_bytes.
 num_bytes is limited by CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE.
 Partition into many segments and assign segments such that:
 sum of "hit segments" / window == approx. ratio.
 sum of "miss segments" / window == approx 1-ratio.
 Segments and ratio specifications are fitted to the capabilities of
 the architecture.
 Accesses in a hit segment apply the hitProp access policy.
 Accesses in a miss segment apply the missProp access policy.*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUaccessPolicyWindow_st {
    ///< Starting address of the access policy window. CUDA driver may align it.
    pub base_ptr: *mut ::std::os::raw::c_void,
    ///< Size in bytes of the window policy. CUDA driver may restrict the maximum size and alignment.
    pub num_bytes: usize,
    ///< hitRatio specifies percentage of lines assigned hitProp, rest are assigned missProp.
    pub hitRatio: f32,
    ///< ::CUaccessProperty set for hit.
    pub hitProp: CUaccessProperty,
    ///< ::CUaccessProperty set for miss. Must be either NORMAL or STREAMING
    pub missProp: CUaccessProperty,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUaccessPolicyWindow_st",
    ][::std::mem::size_of::<CUaccessPolicyWindow_st>() - 32usize];
    [
        "Alignment of CUaccessPolicyWindow_st",
    ][::std::mem::align_of::<CUaccessPolicyWindow_st>() - 8usize];
    [
        "Offset of field: CUaccessPolicyWindow_st::base_ptr",
    ][::std::mem::offset_of!(CUaccessPolicyWindow_st, base_ptr) - 0usize];
    [
        "Offset of field: CUaccessPolicyWindow_st::num_bytes",
    ][::std::mem::offset_of!(CUaccessPolicyWindow_st, num_bytes) - 8usize];
    [
        "Offset of field: CUaccessPolicyWindow_st::hitRatio",
    ][::std::mem::offset_of!(CUaccessPolicyWindow_st, hitRatio) - 16usize];
    [
        "Offset of field: CUaccessPolicyWindow_st::hitProp",
    ][::std::mem::offset_of!(CUaccessPolicyWindow_st, hitProp) - 20usize];
    [
        "Offset of field: CUaccessPolicyWindow_st::missProp",
    ][::std::mem::offset_of!(CUaccessPolicyWindow_st, missProp) - 24usize];
};
impl Default for CUaccessPolicyWindow_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** Specifies an access policy for a window, a contiguous extent of memory
 beginning at base_ptr and ending at base_ptr + num_bytes.
 num_bytes is limited by CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE.
 Partition into many segments and assign segments such that:
 sum of "hit segments" / window == approx. ratio.
 sum of "miss segments" / window == approx 1-ratio.
 Segments and ratio specifications are fitted to the capabilities of
 the architecture.
 Accesses in a hit segment apply the hitProp access policy.
 Accesses in a miss segment apply the missProp access policy.*/
pub type CUaccessPolicyWindow_v1 = CUaccessPolicyWindow_st;
/// Access policy window
pub type CUaccessPolicyWindow = CUaccessPolicyWindow_v1;
///< GPU kernel node
pub const CU_GRAPH_NODE_TYPE_KERNEL: CUgraphNodeType_enum = 0;
///< Memcpy node
pub const CU_GRAPH_NODE_TYPE_MEMCPY: CUgraphNodeType_enum = 1;
///< Memset node
pub const CU_GRAPH_NODE_TYPE_MEMSET: CUgraphNodeType_enum = 2;
///< Host (executable) node
pub const CU_GRAPH_NODE_TYPE_HOST: CUgraphNodeType_enum = 3;
///< Node which executes an embedded graph
pub const CU_GRAPH_NODE_TYPE_GRAPH: CUgraphNodeType_enum = 4;
///< Empty (no-op) node
pub const CU_GRAPH_NODE_TYPE_EMPTY: CUgraphNodeType_enum = 5;
///< External event wait node
pub const CU_GRAPH_NODE_TYPE_WAIT_EVENT: CUgraphNodeType_enum = 6;
///< External event record node
pub const CU_GRAPH_NODE_TYPE_EVENT_RECORD: CUgraphNodeType_enum = 7;
///< External semaphore signal node
pub const CU_GRAPH_NODE_TYPE_EXT_SEMAS_SIGNAL: CUgraphNodeType_enum = 8;
///< External semaphore wait node
pub const CU_GRAPH_NODE_TYPE_EXT_SEMAS_WAIT: CUgraphNodeType_enum = 9;
///< Memory Allocation Node
pub const CU_GRAPH_NODE_TYPE_MEM_ALLOC: CUgraphNodeType_enum = 10;
///< Memory Free Node
pub const CU_GRAPH_NODE_TYPE_MEM_FREE: CUgraphNodeType_enum = 11;
/**< Batch MemOp Node
See ::cuStreamBatchMemOp and ::CUstreamBatchMemOpType for what these nodes can do.*/
pub const CU_GRAPH_NODE_TYPE_BATCH_MEM_OP: CUgraphNodeType_enum = 12;
/**< Conditional Node

May be used to implement a conditional execution path or loop
inside of a graph. The graph(s) contained within the body of the conditional node
can be selectively executed or iterated upon based on the value of a conditional
variable.

Handles must be created in advance of creating the node
using ::cuGraphConditionalHandleCreate.

The following restrictions apply to graphs which contain conditional nodes:
The graph cannot be used in a child node.
Only one instantiation of the graph may exist at any point in time.
The graph cannot be cloned.

To set the control value, supply a default value when creating the handle and/or
call ::cudaGraphSetConditional from device code.*/
pub const CU_GRAPH_NODE_TYPE_CONDITIONAL: CUgraphNodeType_enum = 13;
/// Graph node types
pub type CUgraphNodeType_enum = ::std::os::raw::c_uint;
/// Graph node types
pub use self::CUgraphNodeType_enum as CUgraphNodeType;
pub const CU_SYNC_POLICY_AUTO: CUsynchronizationPolicy_enum = 1;
pub const CU_SYNC_POLICY_SPIN: CUsynchronizationPolicy_enum = 2;
pub const CU_SYNC_POLICY_YIELD: CUsynchronizationPolicy_enum = 3;
pub const CU_SYNC_POLICY_BLOCKING_SYNC: CUsynchronizationPolicy_enum = 4;
pub type CUsynchronizationPolicy_enum = ::std::os::raw::c_uint;
pub use self::CUsynchronizationPolicy_enum as CUsynchronizationPolicy;
///< the default policy
pub const CU_CLUSTER_SCHEDULING_POLICY_DEFAULT: CUclusterSchedulingPolicy_enum = 0;
///< spread the blocks within a cluster to the SMs
pub const CU_CLUSTER_SCHEDULING_POLICY_SPREAD: CUclusterSchedulingPolicy_enum = 1;
///< allow the hardware to load-balance the blocks in a cluster to the SMs
pub const CU_CLUSTER_SCHEDULING_POLICY_LOAD_BALANCING: CUclusterSchedulingPolicy_enum = 2;
/// Cluster scheduling policies. These may be passed to ::cuFuncSetAttribute or ::cuKernelSetAttribute
pub type CUclusterSchedulingPolicy_enum = ::std::os::raw::c_uint;
/// Cluster scheduling policies. These may be passed to ::cuFuncSetAttribute or ::cuKernelSetAttribute
pub use self::CUclusterSchedulingPolicy_enum as CUclusterSchedulingPolicy;
///< Launch kernels in the default domain
pub const CU_LAUNCH_MEM_SYNC_DOMAIN_DEFAULT: CUlaunchMemSyncDomain_enum = 0;
///< Launch kernels in the remote domain
pub const CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE: CUlaunchMemSyncDomain_enum = 1;
/** Memory Synchronization Domain

 A kernel can be launched in a specified memory synchronization domain that affects all memory operations issued by
 that kernel. A memory barrier issued in one domain will only order memory operations in that domain, thus eliminating
 latency increase from memory barriers ordering unrelated traffic.

 By default, kernels are launched in domain 0. Kernel launched with ::CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE will have a
 different domain ID. User may also alter the domain ID with ::CUlaunchMemSyncDomainMap for a specific stream /
 graph node / kernel launch. See ::CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN, ::cuStreamSetAttribute, ::cuLaunchKernelEx,
 ::cuGraphKernelNodeSetAttribute.

 Memory operations done in kernels launched in different domains are considered system-scope distanced. In other
 words, a GPU scoped memory synchronization is not sufficient for memory order to be observed by kernels in another
 memory synchronization domain even if they are on the same GPU.*/
pub type CUlaunchMemSyncDomain_enum = ::std::os::raw::c_uint;
/** Memory Synchronization Domain

 A kernel can be launched in a specified memory synchronization domain that affects all memory operations issued by
 that kernel. A memory barrier issued in one domain will only order memory operations in that domain, thus eliminating
 latency increase from memory barriers ordering unrelated traffic.

 By default, kernels are launched in domain 0. Kernel launched with ::CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE will have a
 different domain ID. User may also alter the domain ID with ::CUlaunchMemSyncDomainMap for a specific stream /
 graph node / kernel launch. See ::CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN, ::cuStreamSetAttribute, ::cuLaunchKernelEx,
 ::cuGraphKernelNodeSetAttribute.

 Memory operations done in kernels launched in different domains are considered system-scope distanced. In other
 words, a GPU scoped memory synchronization is not sufficient for memory order to be observed by kernels in another
 memory synchronization domain even if they are on the same GPU.*/
pub use self::CUlaunchMemSyncDomain_enum as CUlaunchMemSyncDomain;
/** Memory Synchronization Domain map

 See ::cudaLaunchMemSyncDomain.

 By default, kernels are launched in domain 0. Kernel launched with ::CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE will have a
 different domain ID. User may also alter the domain ID with ::CUlaunchMemSyncDomainMap for a specific stream /
 graph node / kernel launch. See ::CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP.

 Domain ID range is available through ::CU_DEVICE_ATTRIBUTE_MEM_SYNC_DOMAIN_COUNT.*/
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUlaunchMemSyncDomainMap_st {
    ///< The default domain ID to use for designated kernels
    pub default_: ::std::os::raw::c_uchar,
    ///< The remote domain ID to use for designated kernels
    pub remote: ::std::os::raw::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUlaunchMemSyncDomainMap_st",
    ][::std::mem::size_of::<CUlaunchMemSyncDomainMap_st>() - 2usize];
    [
        "Alignment of CUlaunchMemSyncDomainMap_st",
    ][::std::mem::align_of::<CUlaunchMemSyncDomainMap_st>() - 1usize];
    [
        "Offset of field: CUlaunchMemSyncDomainMap_st::default_",
    ][::std::mem::offset_of!(CUlaunchMemSyncDomainMap_st, default_) - 0usize];
    [
        "Offset of field: CUlaunchMemSyncDomainMap_st::remote",
    ][::std::mem::offset_of!(CUlaunchMemSyncDomainMap_st, remote) - 1usize];
};
/** Memory Synchronization Domain map

 See ::cudaLaunchMemSyncDomain.

 By default, kernels are launched in domain 0. Kernel launched with ::CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE will have a
 different domain ID. User may also alter the domain ID with ::CUlaunchMemSyncDomainMap for a specific stream /
 graph node / kernel launch. See ::CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP.

 Domain ID range is available through ::CU_DEVICE_ATTRIBUTE_MEM_SYNC_DOMAIN_COUNT.*/
pub type CUlaunchMemSyncDomainMap = CUlaunchMemSyncDomainMap_st;
///< Ignored entry, for convenient composition
pub const CU_LAUNCH_ATTRIBUTE_IGNORE: CUlaunchAttributeID_enum = 0;
/**< Valid for streams, graph nodes, launches. See
::CUlaunchAttributeValue::accessPolicyWindow.*/
pub const CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW: CUlaunchAttributeID_enum = 1;
/**< Valid for graph nodes, launches. See
::CUlaunchAttributeValue::cooperative.*/
pub const CU_LAUNCH_ATTRIBUTE_COOPERATIVE: CUlaunchAttributeID_enum = 2;
/**< Valid for streams. See
::CUlaunchAttributeValue::syncPolicy.*/
pub const CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY: CUlaunchAttributeID_enum = 3;
///< Valid for graph nodes, launches. See ::CUlaunchAttributeValue::clusterDim.
pub const CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION: CUlaunchAttributeID_enum = 4;
///< Valid for graph nodes, launches. See ::CUlaunchAttributeValue::clusterSchedulingPolicyPreference.
pub const CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE: CUlaunchAttributeID_enum = 5;
/**< Valid for launches. Setting
::CUlaunchAttributeValue::programmaticStreamSerializationAllowed
to non-0 signals that the kernel will use programmatic
means to resolve its stream dependency, so that the
CUDA runtime should opportunistically allow the grid's
execution to overlap with the previous kernel in the
stream, if that kernel requests the overlap. The
dependent launches can choose to wait on the
dependency using the programmatic sync
(cudaGridDependencySynchronize() or equivalent PTX
instructions).*/
pub const CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION: CUlaunchAttributeID_enum = 6;
/**< Valid for launches. Set
::CUlaunchAttributeValue::programmaticEvent to
record the event. Event recorded through this
launch attribute is guaranteed to only trigger
after all block in the associated kernel trigger
the event. A block can trigger the event through
PTX launchdep.release or CUDA builtin function
cudaTriggerProgrammaticLaunchCompletion(). A
trigger can also be inserted at the beginning of
each block's execution if triggerAtBlockStart is
set to non-0. The dependent launches can choose to
wait on the dependency using the programmatic sync
(cudaGridDependencySynchronize() or equivalent PTX
instructions). Note that dependents (including the
CPU thread calling cuEventSynchronize()) are not
guaranteed to observe the release precisely when
it is released.  For example, cuEventSynchronize()
may only observe the event trigger long after the
associated kernel has completed. This recording
type is primarily meant for establishing
programmatic dependency between device tasks. Note
also this type of dependency allows, but does not
guarantee, concurrent execution of tasks.
<br>
The event supplied must not be an interprocess or
interop event. The event must disable timing (i.e.
must be created with the ::CU_EVENT_DISABLE_TIMING
flag set).*/
pub const CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT: CUlaunchAttributeID_enum = 7;
/**< Valid for streams, graph nodes, launches. See
::CUlaunchAttributeValue::priority.*/
pub const CU_LAUNCH_ATTRIBUTE_PRIORITY: CUlaunchAttributeID_enum = 8;
/**< Valid for streams, graph nodes, launches. See
::CUlaunchAttributeValue::memSyncDomainMap.*/
pub const CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP: CUlaunchAttributeID_enum = 9;
/**< Valid for streams, graph nodes, launches. See
::CUlaunchAttributeValue::memSyncDomain.*/
pub const CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN: CUlaunchAttributeID_enum = 10;
/**< Valid for graph nodes, launches. Set
::CUlaunchAttributeValue::preferredClusterDim
to allow the kernel launch to specify a preferred substitute
cluster dimension. Blocks may be grouped according to either
the dimensions specified with this attribute (grouped into a
"preferred substitute cluster"), or the one specified with
::CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION attribute (grouped
into a "regular cluster"). The cluster dimensions of a
"preferred substitute cluster" shall be an integer multiple
greater than zero of the regular cluster dimensions. The
device will attempt - on a best-effort basis - to group
thread blocks into preferred clusters over grouping them
into regular clusters. When it deems necessary (primarily
when the device temporarily runs out of physical resources
to launch the larger preferred clusters), the device may
switch to launch the regular clusters instead to attempt to
utilize as much of the physical device resources as possible.
<br>
Each type of cluster will have its enumeration / coordinate
setup as if the grid consists solely of its type of cluster.
For example, if the preferred substitute cluster dimensions
double the regular cluster dimensions, there might be
simultaneously a regular cluster indexed at (1,0,0), and a
preferred cluster indexed at (1,0,0). In this example, the
preferred substitute cluster (1,0,0) replaces regular
clusters (2,0,0) and (3,0,0) and groups their blocks.
<br>
This attribute will only take effect when a regular cluster
dimension has been specified. The preferred substitute
cluster dimension must be an integer multiple greater than
zero of the regular cluster dimension and must divide the
grid. It must also be no more than `maxBlocksPerCluster`, if
it is set in the kernel's `__launch_bounds__`. Otherwise it
must be less than the maximum value the driver can support.
Otherwise, setting this attribute to a value physically
unable to fit on any particular device is permitted.*/
pub const CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION: CUlaunchAttributeID_enum = 11;
/**< Valid for launches. Set
::CUlaunchAttributeValue::launchCompletionEvent to record the
event.
<br>
Nominally, the event is triggered once all blocks of the kernel
have begun execution. Currently this is a best effort. If a kernel
B has a launch completion dependency on a kernel A, B may wait
until A is complete. Alternatively, blocks of B may begin before
all blocks of A have begun, for example if B can claim execution
resources unavailable to A (e.g. they run on different GPUs) or
if B is a higher priority than A.
Exercise caution if such an ordering inversion could lead
to deadlock.
<br>
A launch completion event is nominally similar to a programmatic
event with \c triggerAtBlockStart set except that it is not
visible to \c cudaGridDependencySynchronize() and can be used with
compute capability less than 9.0.
<br>
The event supplied must not be an interprocess or interop
event. The event must disable timing (i.e. must be created
with the ::CU_EVENT_DISABLE_TIMING flag set).*/
pub const CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT: CUlaunchAttributeID_enum = 12;
/**< Valid for graph nodes, launches. This attribute is graphs-only,
and passing it to a launch in a non-capturing stream will result
in an error.
<br>
::CUlaunchAttributeValue::deviceUpdatableKernelNode::deviceUpdatable can
only be set to 0 or 1. Setting the field to 1 indicates that the
corresponding kernel node should be device-updatable. On success, a handle
will be returned via
::CUlaunchAttributeValue::deviceUpdatableKernelNode::devNode which can be
passed to the various device-side update functions to update the node's
kernel parameters from within another kernel. For more information on the
types of device updates that can be made, as well as the relevant limitations
thereof, see ::cudaGraphKernelNodeUpdatesApply.
<br>
Nodes which are device-updatable have additional restrictions compared to
regular kernel nodes. Firstly, device-updatable nodes cannot be removed
from their graph via ::cuGraphDestroyNode. Additionally, once opted-in
to this functionality, a node cannot opt out, and any attempt to set the
deviceUpdatable attribute to 0 will result in an error. Device-updatable
kernel nodes also cannot have their attributes copied to/from another kernel
node via ::cuGraphKernelNodeCopyAttributes. Graphs containing one or more
device-updatable nodes also do not allow multiple instantiation, and neither
the graph nor its instantiated version can be passed to ::cuGraphExecUpdate.
<br>
If a graph contains device-updatable nodes and updates those nodes from the device
from within the graph, the graph must be uploaded with ::cuGraphUpload before it
is launched. For such a graph, if host-side executable graph updates are made to the
device-updatable nodes, the graph must be uploaded before it is launched again.*/
pub const CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE: CUlaunchAttributeID_enum = 13;
/**< Valid for launches. On devices where the L1 cache and shared memory use the
same hardware resources, setting ::CUlaunchAttributeValue::sharedMemCarveout to a
percentage between 0-100 signals the CUDA driver to set the shared memory carveout
preference, in percent of the total shared memory for that kernel launch.
This attribute takes precedence over ::CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT.
This is only a hint, and the CUDA driver can choose a different configuration if
required for the launch.*/
pub const CU_LAUNCH_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT: CUlaunchAttributeID_enum = 14;
/**< Valid for streams, graph nodes, launches. This attribute is a hint to the CUDA runtime that the
launch should attempt to make the kernel maximize its NVLINK utilization.
<br>
When possible to honor this hint, CUDA will assume each block in the grid launch will carry out an even amount
of NVLINK traffic, and make a best-effort attempt to adjust the kernel launch based on that assumption.
<br>
This attribute is a hint only. CUDA makes no functional or performance guarantee. Its applicability can be
affected by many different factors, including driver version (i.e. CUDA doesn't guarantee the performance
characteristics will be maintained between driver versions or a driver update could alter or regress
previously observed perf characteristics.) It also doesn't guarantee a successful result, i.e. applying
the attribute may not improve the performance of either the targeted kernel or the encapsulating application.
<br>
Valid values for ::CUlaunchAttributeValue::nvlinkUtilCentricScheduling are 0 (disabled) and 1 (enabled).*/
pub const CU_LAUNCH_ATTRIBUTE_NVLINK_UTIL_CENTRIC_SCHEDULING: CUlaunchAttributeID_enum = 16;
/// Launch attributes enum; used as id field of ::CUlaunchAttribute
pub type CUlaunchAttributeID_enum = ::std::os::raw::c_uint;
/// Launch attributes enum; used as id field of ::CUlaunchAttribute
pub use self::CUlaunchAttributeID_enum as CUlaunchAttributeID;
/// Launch attributes union; used as value field of ::CUlaunchAttribute
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUlaunchAttributeValue_union {
    pub pad: [::std::os::raw::c_char; 64usize],
    ///< Value of launch attribute ::CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW.
    pub accessPolicyWindow: CUaccessPolicyWindow,
    /**< Value of launch attribute ::CU_LAUNCH_ATTRIBUTE_COOPERATIVE. Nonzero indicates a cooperative
kernel (see ::cuLaunchCooperativeKernel).*/
    pub cooperative: ::std::os::raw::c_int,
    /**< Value of launch attribute
::CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY. ::CUsynchronizationPolicy for
work queued up in this stream*/
    pub syncPolicy: CUsynchronizationPolicy,
    pub clusterDim: CUlaunchAttributeValue_union__bindgen_ty_1,
    /**< Value of launch attribute
::CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE. Cluster
scheduling policy preference for the kernel.*/
    pub clusterSchedulingPolicyPreference: CUclusterSchedulingPolicy,
    /**< Value of launch attribute
::CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION.*/
    pub programmaticStreamSerializationAllowed: ::std::os::raw::c_int,
    pub programmaticEvent: CUlaunchAttributeValue_union__bindgen_ty_2,
    pub launchCompletionEvent: CUlaunchAttributeValue_union__bindgen_ty_3,
    ///< Value of launch attribute ::CU_LAUNCH_ATTRIBUTE_PRIORITY. Execution priority of the kernel.
    pub priority: ::std::os::raw::c_int,
    /**< Value of launch attribute
::CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP. See
::CUlaunchMemSyncDomainMap.*/
    pub memSyncDomainMap: CUlaunchMemSyncDomainMap,
    /**< Value of launch attribute
::CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN. See::CUlaunchMemSyncDomain*/
    pub memSyncDomain: CUlaunchMemSyncDomain,
    pub preferredClusterDim: CUlaunchAttributeValue_union__bindgen_ty_4,
    pub deviceUpdatableKernelNode: CUlaunchAttributeValue_union__bindgen_ty_5,
    ///< Value of launch attribute ::CU_LAUNCH_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT.
    pub sharedMemCarveout: ::std::os::raw::c_uint,
    pub nvlinkUtilCentricScheduling: ::std::os::raw::c_uint,
}
/**  Value of launch attribute ::CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION that
  represents the desired cluster dimensions for the kernel. Opaque type
  with the following fields:
      - \p x - The X dimension of the cluster, in blocks. Must be a divisor
               of the grid X dimension.
      - \p y - The Y dimension of the cluster, in blocks. Must be a divisor
               of the grid Y dimension.
      - \p z - The Z dimension of the cluster, in blocks. Must be a divisor
               of the grid Z dimension.*/
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUlaunchAttributeValue_union__bindgen_ty_1 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
    pub z: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUlaunchAttributeValue_union__bindgen_ty_1",
    ][::std::mem::size_of::<CUlaunchAttributeValue_union__bindgen_ty_1>() - 12usize];
    [
        "Alignment of CUlaunchAttributeValue_union__bindgen_ty_1",
    ][::std::mem::align_of::<CUlaunchAttributeValue_union__bindgen_ty_1>() - 4usize];
    [
        "Offset of field: CUlaunchAttributeValue_union__bindgen_ty_1::x",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union__bindgen_ty_1, x) - 0usize];
    [
        "Offset of field: CUlaunchAttributeValue_union__bindgen_ty_1::y",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union__bindgen_ty_1, y) - 4usize];
    [
        "Offset of field: CUlaunchAttributeValue_union__bindgen_ty_1::z",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union__bindgen_ty_1, z) - 8usize];
};
/**  Value of launch attribute ::CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT
  with the following fields:
      - \p CUevent event - Event to fire when all blocks trigger it.
      - \p Event record flags, see ::cuEventRecordWithFlags. Does not accept :CU_EVENT_RECORD_EXTERNAL.
      - \p triggerAtBlockStart - If this is set to non-0, each block launch will automatically trigger the event.*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlaunchAttributeValue_union__bindgen_ty_2 {
    pub event: CUevent,
    pub flags: ::std::os::raw::c_int,
    pub triggerAtBlockStart: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUlaunchAttributeValue_union__bindgen_ty_2",
    ][::std::mem::size_of::<CUlaunchAttributeValue_union__bindgen_ty_2>() - 16usize];
    [
        "Alignment of CUlaunchAttributeValue_union__bindgen_ty_2",
    ][::std::mem::align_of::<CUlaunchAttributeValue_union__bindgen_ty_2>() - 8usize];
    [
        "Offset of field: CUlaunchAttributeValue_union__bindgen_ty_2::event",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union__bindgen_ty_2, event)
        - 0usize];
    [
        "Offset of field: CUlaunchAttributeValue_union__bindgen_ty_2::flags",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union__bindgen_ty_2, flags)
        - 8usize];
    [
        "Offset of field: CUlaunchAttributeValue_union__bindgen_ty_2::triggerAtBlockStart",
    ][::std::mem::offset_of!(
        CUlaunchAttributeValue_union__bindgen_ty_2, triggerAtBlockStart
    ) - 12usize];
};
impl Default for CUlaunchAttributeValue_union__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** Value of launch attribute ::CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT
 with the following fields:
     - \p CUevent event - Event to fire when the last block launches
     - \p int flags; - Event record flags, see ::cuEventRecordWithFlags. Does not accept ::CU_EVENT_RECORD_EXTERNAL.*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlaunchAttributeValue_union__bindgen_ty_3 {
    pub event: CUevent,
    pub flags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUlaunchAttributeValue_union__bindgen_ty_3",
    ][::std::mem::size_of::<CUlaunchAttributeValue_union__bindgen_ty_3>() - 16usize];
    [
        "Alignment of CUlaunchAttributeValue_union__bindgen_ty_3",
    ][::std::mem::align_of::<CUlaunchAttributeValue_union__bindgen_ty_3>() - 8usize];
    [
        "Offset of field: CUlaunchAttributeValue_union__bindgen_ty_3::event",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union__bindgen_ty_3, event)
        - 0usize];
    [
        "Offset of field: CUlaunchAttributeValue_union__bindgen_ty_3::flags",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union__bindgen_ty_3, flags)
        - 8usize];
};
impl Default for CUlaunchAttributeValue_union__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/**  Value of launch attribute ::CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION
  that represents the desired preferred cluster dimensions for the kernel.
  Opaque type with the following fields:
      - \p x - The X dimension of the preferred cluster, in blocks. Must
               be a divisor of the grid X dimension, and must be a
               multiple of the \p x field of ::CUlaunchAttributeValue::clusterDim.
      - \p y - The Y dimension of the preferred cluster, in blocks. Must
               be a divisor of the grid Y dimension, and must be a
               multiple of the \p y field of ::CUlaunchAttributeValue::clusterDim.
      - \p z - The Z dimension of the preferred cluster, in blocks. Must be
               equal to the \p z field of ::CUlaunchAttributeValue::clusterDim.*/
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUlaunchAttributeValue_union__bindgen_ty_4 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
    pub z: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUlaunchAttributeValue_union__bindgen_ty_4",
    ][::std::mem::size_of::<CUlaunchAttributeValue_union__bindgen_ty_4>() - 12usize];
    [
        "Alignment of CUlaunchAttributeValue_union__bindgen_ty_4",
    ][::std::mem::align_of::<CUlaunchAttributeValue_union__bindgen_ty_4>() - 4usize];
    [
        "Offset of field: CUlaunchAttributeValue_union__bindgen_ty_4::x",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union__bindgen_ty_4, x) - 0usize];
    [
        "Offset of field: CUlaunchAttributeValue_union__bindgen_ty_4::y",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union__bindgen_ty_4, y) - 4usize];
    [
        "Offset of field: CUlaunchAttributeValue_union__bindgen_ty_4::z",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union__bindgen_ty_4, z) - 8usize];
};
/**  Value of launch attribute ::CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE.
  with the following fields:
      - \p int deviceUpdatable - Whether or not the resulting kernel node should be device-updatable.
      - \p CUgraphDeviceNode devNode - Returns a handle to pass to the various device-side update functions.*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlaunchAttributeValue_union__bindgen_ty_5 {
    pub deviceUpdatable: ::std::os::raw::c_int,
    pub devNode: CUgraphDeviceNode,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUlaunchAttributeValue_union__bindgen_ty_5",
    ][::std::mem::size_of::<CUlaunchAttributeValue_union__bindgen_ty_5>() - 16usize];
    [
        "Alignment of CUlaunchAttributeValue_union__bindgen_ty_5",
    ][::std::mem::align_of::<CUlaunchAttributeValue_union__bindgen_ty_5>() - 8usize];
    [
        "Offset of field: CUlaunchAttributeValue_union__bindgen_ty_5::deviceUpdatable",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union__bindgen_ty_5, deviceUpdatable)
        - 0usize];
    [
        "Offset of field: CUlaunchAttributeValue_union__bindgen_ty_5::devNode",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union__bindgen_ty_5, devNode)
        - 8usize];
};
impl Default for CUlaunchAttributeValue_union__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUlaunchAttributeValue_union",
    ][::std::mem::size_of::<CUlaunchAttributeValue_union>() - 64usize];
    [
        "Alignment of CUlaunchAttributeValue_union",
    ][::std::mem::align_of::<CUlaunchAttributeValue_union>() - 8usize];
    [
        "Offset of field: CUlaunchAttributeValue_union::pad",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union, pad) - 0usize];
    [
        "Offset of field: CUlaunchAttributeValue_union::accessPolicyWindow",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union, accessPolicyWindow) - 0usize];
    [
        "Offset of field: CUlaunchAttributeValue_union::cooperative",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union, cooperative) - 0usize];
    [
        "Offset of field: CUlaunchAttributeValue_union::syncPolicy",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union, syncPolicy) - 0usize];
    [
        "Offset of field: CUlaunchAttributeValue_union::clusterDim",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union, clusterDim) - 0usize];
    [
        "Offset of field: CUlaunchAttributeValue_union::clusterSchedulingPolicyPreference",
    ][::std::mem::offset_of!(
        CUlaunchAttributeValue_union, clusterSchedulingPolicyPreference
    ) - 0usize];
    [
        "Offset of field: CUlaunchAttributeValue_union::programmaticStreamSerializationAllowed",
    ][::std::mem::offset_of!(
        CUlaunchAttributeValue_union, programmaticStreamSerializationAllowed
    ) - 0usize];
    [
        "Offset of field: CUlaunchAttributeValue_union::programmaticEvent",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union, programmaticEvent) - 0usize];
    [
        "Offset of field: CUlaunchAttributeValue_union::launchCompletionEvent",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union, launchCompletionEvent)
        - 0usize];
    [
        "Offset of field: CUlaunchAttributeValue_union::priority",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union, priority) - 0usize];
    [
        "Offset of field: CUlaunchAttributeValue_union::memSyncDomainMap",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union, memSyncDomainMap) - 0usize];
    [
        "Offset of field: CUlaunchAttributeValue_union::memSyncDomain",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union, memSyncDomain) - 0usize];
    [
        "Offset of field: CUlaunchAttributeValue_union::preferredClusterDim",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union, preferredClusterDim)
        - 0usize];
    [
        "Offset of field: CUlaunchAttributeValue_union::deviceUpdatableKernelNode",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union, deviceUpdatableKernelNode)
        - 0usize];
    [
        "Offset of field: CUlaunchAttributeValue_union::sharedMemCarveout",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union, sharedMemCarveout) - 0usize];
    [
        "Offset of field: CUlaunchAttributeValue_union::nvlinkUtilCentricScheduling",
    ][::std::mem::offset_of!(CUlaunchAttributeValue_union, nvlinkUtilCentricScheduling)
        - 0usize];
};
impl Default for CUlaunchAttributeValue_union {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUlaunchAttributeValue_union {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUlaunchAttributeValue_union {{ union }}")
    }
}
/// Launch attributes union; used as value field of ::CUlaunchAttribute
pub type CUlaunchAttributeValue = CUlaunchAttributeValue_union;
/// Launch attributes enum; used as id field of ::CUlaunchAttribute
pub use self::CUlaunchAttributeID as CUstreamAttrID;
/// Launch attributes union; used as value field of ::CUlaunchAttribute
pub type CUstreamAttrValue_v1 = CUlaunchAttributeValue;
/// Launch attributes union; used as value field of ::CUlaunchAttribute
pub type CUstreamAttrValue = CUstreamAttrValue_v1;
/// No error.
pub const CUPTI_SUCCESS: CUptiResult = 0;
/// One or more of the parameters is invalid.
pub const CUPTI_ERROR_INVALID_PARAMETER: CUptiResult = 1;
/// The device does not correspond to a valid CUDA device.
pub const CUPTI_ERROR_INVALID_DEVICE: CUptiResult = 2;
/// The context is NULL or not valid.
pub const CUPTI_ERROR_INVALID_CONTEXT: CUptiResult = 3;
/// The event domain id is invalid.
pub const CUPTI_ERROR_INVALID_EVENT_DOMAIN_ID: CUptiResult = 4;
/// The event id is invalid.
pub const CUPTI_ERROR_INVALID_EVENT_ID: CUptiResult = 5;
/// The event name is invalid.
pub const CUPTI_ERROR_INVALID_EVENT_NAME: CUptiResult = 6;
/** The current operation cannot be performed due to dependency on
 other factors.*/
pub const CUPTI_ERROR_INVALID_OPERATION: CUptiResult = 7;
/** Unable to allocate enough memory to perform the requested
 operation.*/
pub const CUPTI_ERROR_OUT_OF_MEMORY: CUptiResult = 8;
/// An error occurred on the performance monitoring hardware.
pub const CUPTI_ERROR_HARDWARE: CUptiResult = 9;
/** The output buffer size is not sufficient to return all
 requested data.*/
pub const CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT: CUptiResult = 10;
/// API is not implemented.
pub const CUPTI_ERROR_API_NOT_IMPLEMENTED: CUptiResult = 11;
/// The maximum limit is reached.
pub const CUPTI_ERROR_MAX_LIMIT_REACHED: CUptiResult = 12;
/// The object is not yet ready to perform the requested operation.
pub const CUPTI_ERROR_NOT_READY: CUptiResult = 13;
/** The current operation is not compatible with the current state
 of the object*/
pub const CUPTI_ERROR_NOT_COMPATIBLE: CUptiResult = 14;
/** CUPTI is unable to initialize its connection to the CUDA
 driver.*/
pub const CUPTI_ERROR_NOT_INITIALIZED: CUptiResult = 15;
/// The metric id is invalid.
pub const CUPTI_ERROR_INVALID_METRIC_ID: CUptiResult = 16;
/// The metric name is invalid.
pub const CUPTI_ERROR_INVALID_METRIC_NAME: CUptiResult = 17;
/// The queue is empty.
pub const CUPTI_ERROR_QUEUE_EMPTY: CUptiResult = 18;
/// Invalid handle (internal?).
pub const CUPTI_ERROR_INVALID_HANDLE: CUptiResult = 19;
/// Invalid stream.
pub const CUPTI_ERROR_INVALID_STREAM: CUptiResult = 20;
/// Invalid kind.
pub const CUPTI_ERROR_INVALID_KIND: CUptiResult = 21;
/// Invalid event value.
pub const CUPTI_ERROR_INVALID_EVENT_VALUE: CUptiResult = 22;
/// CUPTI is disabled due to conflicts with other enabled profilers
pub const CUPTI_ERROR_DISABLED: CUptiResult = 23;
/// Invalid module.
pub const CUPTI_ERROR_INVALID_MODULE: CUptiResult = 24;
/// Invalid metric value.
pub const CUPTI_ERROR_INVALID_METRIC_VALUE: CUptiResult = 25;
/// The performance monitoring hardware is in use by other client.
pub const CUPTI_ERROR_HARDWARE_BUSY: CUptiResult = 26;
/** The attempted operation is not supported on the current
 system or device.*/
pub const CUPTI_ERROR_NOT_SUPPORTED: CUptiResult = 27;
/** Unified memory profiling is not supported on the system.
 Potential reason could be unsupported OS or architecture.*/
pub const CUPTI_ERROR_UM_PROFILING_NOT_SUPPORTED: CUptiResult = 28;
/// Unified memory profiling is not supported on the device
pub const CUPTI_ERROR_UM_PROFILING_NOT_SUPPORTED_ON_DEVICE: CUptiResult = 29;
/** Unified memory profiling is not supported on a multi-GPU
 configuration without P2P support between any pair of devices*/
pub const CUPTI_ERROR_UM_PROFILING_NOT_SUPPORTED_ON_NON_P2P_DEVICES: CUptiResult = 30;
/** Unified memory profiling is not supported under the
 Multi-Process Service (MPS) environment. CUDA 7.5 removes this
 restriction.*/
pub const CUPTI_ERROR_UM_PROFILING_NOT_SUPPORTED_WITH_MPS: CUptiResult = 31;
/** In CUDA 9.0, devices with compute capability 7.0 don't
 support CDP tracing*/
pub const CUPTI_ERROR_CDP_TRACING_NOT_SUPPORTED: CUptiResult = 32;
/// Profiling on virtualized GPU is not supported.
pub const CUPTI_ERROR_VIRTUALIZED_DEVICE_NOT_SUPPORTED: CUptiResult = 33;
/** Profiling results might be incorrect for CUDA applications
 compiled with nvcc version older than 9.0 for devices with
 compute capability 6.0 and 6.1.
 Profiling session will continue and CUPTI will notify it using this error code.
 User is advised to recompile the application code with nvcc version 9.0 or later.
 Ignore this warning if code is already compiled with the recommended nvcc version.*/
pub const CUPTI_ERROR_CUDA_COMPILER_NOT_COMPATIBLE: CUptiResult = 34;
/** User doesn't have sufficient privileges which are required to
 start the profiling session.
 One possible reason for this may be that the NVIDIA driver or your system
 administrator may have restricted access to the NVIDIA GPU performance counters.
 To learn how to resolve this issue and find more information, please visit
 https://developer.nvidia.com/CUPTI_ERROR_INSUFFICIENT_PRIVILEGES*/
pub const CUPTI_ERROR_INSUFFICIENT_PRIVILEGES: CUptiResult = 35;
/** Legacy CUPTI Profiling API i.e. event API from the header cupti_events.h and
 metric API from the header cupti_metrics.h are not compatible with the
 Profiling API in the header cupti_profiler_target.h and Perfworks metrics API
 in the headers nvperf_host.h and nvperf_target.h.*/
pub const CUPTI_ERROR_OLD_PROFILER_API_INITIALIZED: CUptiResult = 36;
/** Missing definition of the OpenACC API routine in the linked OpenACC library.

 One possible reason is that OpenACC library is linked statically in the
 user application, which might not have the definition of all the OpenACC
 API routines needed for the OpenACC profiling, as compiler might ignore
 definitions for the functions not used in the application. This issue
 can be mitigated by linking the OpenACC library dynamically.*/
pub const CUPTI_ERROR_OPENACC_UNDEFINED_ROUTINE: CUptiResult = 37;
/** Legacy CUPTI Profiling API i.e. event API from the header cupti_events.h and
 metric API from the header cupti_metrics.h are not supported on devices with
 compute capability 7.5 and higher (i.e. Turing and later GPU architectures).
 These APIs were deprecated in CUDA 12.8 and removed in CUDA 13.0.
 These are replaced by the host profiling API in the header cupti_profiler_host.h and
 target profiling API in the header cupti_range_profiler.h which are supported on
 devices with compute capability 7.5 and higher (i.e. Turing and later GPU
 architectures).
 Further, the PC Sampling Activity API and the source/SASS level metrics from the header
 cupti_activity.h are removed in CUDA 13.0.*/
pub const CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED: CUptiResult = 38;
/** CUPTI doesn't allow multiple callback subscribers. Only a single subscriber
 can be registered at a time.
 Same error code is used when application is launched using NVIDIA tools
 like Nsight Systems, Nsight Compute, and cuda-gdb.*/
pub const CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED: CUptiResult = 39;
/// Profiling on virtualized GPU is not allowed by hypervisor.
pub const CUPTI_ERROR_VIRTUALIZED_DEVICE_INSUFFICIENT_PRIVILEGES: CUptiResult = 40;
/** Profiling and tracing are not allowed when confidential computing mode
 is enabled.*/
pub const CUPTI_ERROR_CONFIDENTIAL_COMPUTING_NOT_SUPPORTED: CUptiResult = 41;
/** CUPTI does not support NVIDIA Crypto Mining Processors (CMP).
 For more information, please visit https://developer.nvidia.com/ERR_NVCMPGPU*/
pub const CUPTI_ERROR_CMP_DEVICE_NOT_SUPPORTED: CUptiResult = 42;
/// Profiling on Multi-instance GPU (MIG) is not supported.
pub const CUPTI_ERROR_MIG_DEVICE_NOT_SUPPORTED: CUptiResult = 43;
/// Profiling on SLI device is not supported.
pub const CUPTI_ERROR_SLI_DEVICE_NOT_SUPPORTED: CUptiResult = 44;
/// Profiling on WSL device is not supported.
pub const CUPTI_ERROR_WSL_DEVICE_NOT_SUPPORTED: CUptiResult = 45;
/// For invalid or unsupported chip name passed to cuptiProfilerHostInitialize.
pub const CUPTI_ERROR_INVALID_CHIP_NAME: CUptiResult = 46;
/// An unknown internal error has occurred.
pub const CUPTI_ERROR_UNKNOWN: CUptiResult = 999;
/// An unknown internal error has occurred.
pub const CUPTI_ERROR_FORCE_INT: CUptiResult = 2147483647;
/** \brief CUPTI result codes.

 Error and result codes returned by CUPTI functions.*/
pub type CUptiResult = ::std::os::raw::c_uint;
unsafe extern "C" {
    /** \brief Get the descriptive string for a CUptiResult.

 Return the descriptive string for a CUptiResult in \p *str.
 \note \b Thread-safety: this function is thread safe.

 \param result The result to get the string for
 \param str Returns the string

 \retval CUPTI_SUCCESS on success
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p str is NULL or \p
 result is not a valid CUptiResult*/
    pub fn cuptiGetResultString(
        result: CUptiResult,
        str_: *mut *const ::std::os::raw::c_char,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** @brief Get the descriptive message corresponding to error codes returned
 by CUPTI.

 Return the descriptive error message for a CUptiResult in \p *str.
 \note \b Thread-safety: this function is thread safe.

 \param result The result to get the descriptive error message for
 \param str Returns the error message string

 \retval CUPTI_SUCCESS on success
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p str is NULL or \p
 result is not a valid CUptiResult
*/
    pub fn cuptiGetErrorMessage(
        result: CUptiResult,
        str_: *mut *const ::std::os::raw::c_char,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get the CUPTI API version.

 Return the API version in \p *version.

 \param version Returns the version

 \retval CUPTI_SUCCESS on success
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p version is NULL
 \sa CUPTI_API_VERSION*/
    pub fn cuptiGetVersion(version: *mut u32) -> CUptiResult;
}
/// The callback is at the entry of the API call.
pub const CUPTI_API_ENTER: CUpti_ApiCallbackSite = 0;
/// The callback is at the exit of the API call.
pub const CUPTI_API_EXIT: CUpti_ApiCallbackSite = 1;
/// The callback is at the exit of the API call.
pub const CUPTI_API_CBSITE_FORCE_INT: CUpti_ApiCallbackSite = 2147483647;
/** \brief Specifies the point in an API call that a callback is issued.

 Specifies the point in an API call that a callback is issued. This
 value is communicated to the callback function via \ref
 CUpti_CallbackData::callbackSite.*/
pub type CUpti_ApiCallbackSite = ::std::os::raw::c_uint;
/// Invalid domain.
pub const CUPTI_CB_DOMAIN_INVALID: CUpti_CallbackDomain = 0;
/// Domain containing callback points for all driver API functions.
pub const CUPTI_CB_DOMAIN_DRIVER_API: CUpti_CallbackDomain = 1;
/** Domain containing callback points for all runtime API
 functions.*/
pub const CUPTI_CB_DOMAIN_RUNTIME_API: CUpti_CallbackDomain = 2;
/// Domain containing callback points for CUDA resource tracking.
pub const CUPTI_CB_DOMAIN_RESOURCE: CUpti_CallbackDomain = 3;
/// Domain containing callback points for CUDA synchronization.
pub const CUPTI_CB_DOMAIN_SYNCHRONIZE: CUpti_CallbackDomain = 4;
/// Domain containing callback points for NVTX API functions.
pub const CUPTI_CB_DOMAIN_NVTX: CUpti_CallbackDomain = 5;
/// Domain containing callback points for various states.
pub const CUPTI_CB_DOMAIN_STATE: CUpti_CallbackDomain = 6;
/// Domain containing callback points for various states.
pub const CUPTI_CB_DOMAIN_SIZE: CUpti_CallbackDomain = 7;
/// Domain containing callback points for various states.
pub const CUPTI_CB_DOMAIN_FORCE_INT: CUpti_CallbackDomain = 2147483647;
/** \brief Callback domains.

 Callback domains. Each domain represents callback points for a
 group of related API functions or CUDA driver activity.*/
pub type CUpti_CallbackDomain = ::std::os::raw::c_uint;
/// Invalid resource callback ID.
pub const CUPTI_CBID_RESOURCE_INVALID: CUpti_CallbackIdResource = 0;
/// A new context has been created.
pub const CUPTI_CBID_RESOURCE_CONTEXT_CREATED: CUpti_CallbackIdResource = 1;
/// A context is about to be destroyed.
pub const CUPTI_CBID_RESOURCE_CONTEXT_DESTROY_STARTING: CUpti_CallbackIdResource = 2;
/// A new stream has been created.
pub const CUPTI_CBID_RESOURCE_STREAM_CREATED: CUpti_CallbackIdResource = 3;
/// A stream is about to be destroyed.
pub const CUPTI_CBID_RESOURCE_STREAM_DESTROY_STARTING: CUpti_CallbackIdResource = 4;
/// The driver has finished initializing.
pub const CUPTI_CBID_RESOURCE_CU_INIT_FINISHED: CUpti_CallbackIdResource = 5;
/// A module has been loaded.
pub const CUPTI_CBID_RESOURCE_MODULE_LOADED: CUpti_CallbackIdResource = 6;
/// A module is about to be unloaded.
pub const CUPTI_CBID_RESOURCE_MODULE_UNLOAD_STARTING: CUpti_CallbackIdResource = 7;
/// The current module which is being profiled.
pub const CUPTI_CBID_RESOURCE_MODULE_PROFILED: CUpti_CallbackIdResource = 8;
/// CUDA graph has been created.
pub const CUPTI_CBID_RESOURCE_GRAPH_CREATED: CUpti_CallbackIdResource = 9;
/// CUDA graph is about to be destroyed.
pub const CUPTI_CBID_RESOURCE_GRAPH_DESTROY_STARTING: CUpti_CallbackIdResource = 10;
/// CUDA graph is cloned.
pub const CUPTI_CBID_RESOURCE_GRAPH_CLONED: CUpti_CallbackIdResource = 11;
/// CUDA graph node is about to be created
pub const CUPTI_CBID_RESOURCE_GRAPHNODE_CREATE_STARTING: CUpti_CallbackIdResource = 12;
/// CUDA graph node is created.
pub const CUPTI_CBID_RESOURCE_GRAPHNODE_CREATED: CUpti_CallbackIdResource = 13;
/// CUDA graph node is about to be destroyed.
pub const CUPTI_CBID_RESOURCE_GRAPHNODE_DESTROY_STARTING: CUpti_CallbackIdResource = 14;
/// Dependency on a CUDA graph node is created.
pub const CUPTI_CBID_RESOURCE_GRAPHNODE_DEPENDENCY_CREATED: CUpti_CallbackIdResource = 15;
/// Dependency on a CUDA graph node is destroyed.
pub const CUPTI_CBID_RESOURCE_GRAPHNODE_DEPENDENCY_DESTROY_STARTING: CUpti_CallbackIdResource = 16;
/// An executable CUDA graph is about to be created.
pub const CUPTI_CBID_RESOURCE_GRAPHEXEC_CREATE_STARTING: CUpti_CallbackIdResource = 17;
/// An executable CUDA graph is created.
pub const CUPTI_CBID_RESOURCE_GRAPHEXEC_CREATED: CUpti_CallbackIdResource = 18;
/// An executable CUDA graph is about to be destroyed.
pub const CUPTI_CBID_RESOURCE_GRAPHEXEC_DESTROY_STARTING: CUpti_CallbackIdResource = 19;
/// CUDA graph node is cloned.
pub const CUPTI_CBID_RESOURCE_GRAPHNODE_CLONED: CUpti_CallbackIdResource = 20;
/// CUDA stream attribute is changed.
pub const CUPTI_CBID_RESOURCE_STREAM_ATTRIBUTE_CHANGED: CUpti_CallbackIdResource = 21;
/// CUDA graph node is updated.
pub const CUPTI_CBID_RESOURCE_GRAPH_NODE_UPDATED: CUpti_CallbackIdResource = 22;
/// Params are set for the CUDA graph node in the executable graph.
pub const CUPTI_CBID_RESOURCE_GRAPH_NODE_SET_PARAMS: CUpti_CallbackIdResource = 23;
/// Params are set for the CUDA graph node in the executable graph.
pub const CUPTI_CBID_RESOURCE_SIZE: CUpti_CallbackIdResource = 24;
/// Params are set for the CUDA graph node in the executable graph.
pub const CUPTI_CBID_RESOURCE_FORCE_INT: CUpti_CallbackIdResource = 2147483647;
/** \brief Callback IDs for resource domain.

 Callback IDs for resource domain, CUPTI_CB_DOMAIN_RESOURCE.  This
 value is communicated to the callback function via the \p cbid
 parameter.*/
pub type CUpti_CallbackIdResource = ::std::os::raw::c_uint;
/// Invalid synchronize callback ID.
pub const CUPTI_CBID_SYNCHRONIZE_INVALID: CUpti_CallbackIdSync = 0;
/// Stream synchronization has completed for the stream.
pub const CUPTI_CBID_SYNCHRONIZE_STREAM_SYNCHRONIZED: CUpti_CallbackIdSync = 1;
/// Context synchronization has completed for the context.
pub const CUPTI_CBID_SYNCHRONIZE_CONTEXT_SYNCHRONIZED: CUpti_CallbackIdSync = 2;
/// Context synchronization has completed for the context.
pub const CUPTI_CBID_SYNCHRONIZE_SIZE: CUpti_CallbackIdSync = 3;
/// Context synchronization has completed for the context.
pub const CUPTI_CBID_SYNCHRONIZE_FORCE_INT: CUpti_CallbackIdSync = 2147483647;
/** \brief Callback IDs for synchronization domain.

 Callback IDs for synchronization domain,
 CUPTI_CB_DOMAIN_SYNCHRONIZE.  This value is communicated to the
 callback function via the \p cbid parameter.*/
pub type CUpti_CallbackIdSync = ::std::os::raw::c_uint;
/// Invalid state callback ID.
pub const CUPTI_CBID_STATE_INVALID: CUpti_CallbackIdState = 0;
/** Notification of fatal errors - high impact, non-recoverable
 When encountered, CUPTI automatically invokes cuptiFinalize()
 User can control behavior of the application in future from
 receiving this callback - such as continuing without profiling, or
 terminating the whole application.*/
pub const CUPTI_CBID_STATE_FATAL_ERROR: CUpti_CallbackIdState = 1;
/** Notification of non fatal errors - high impact, but recoverable
 This notification is not issued in the current release.*/
pub const CUPTI_CBID_STATE_ERROR: CUpti_CallbackIdState = 2;
/// Notification of warnings - low impact, recoverable.
pub const CUPTI_CBID_STATE_WARNING: CUpti_CallbackIdState = 3;
/// Notification of warnings - low impact, recoverable.
pub const CUPTI_CBID_STATE_SIZE: CUpti_CallbackIdState = 4;
/// Notification of warnings - low impact, recoverable.
pub const CUPTI_CBID_STATE_FORCE_INT: CUpti_CallbackIdState = 2147483647;
/** \brief Callback IDs for state domain.

 Callback IDs for state domain,
 CUPTI_CB_DOMAIN_STATE. This value is communicated to the
 callback function via the \p cbid parameter.*/
pub type CUpti_CallbackIdState = ::std::os::raw::c_uint;
/** \brief Data passed into a runtime or driver API callback function.

 Data passed into a runtime or driver API callback function as the
 \p cbdata argument to \ref CUpti_CallbackFunc. The \p cbdata will
 be this type for \p domain equal to CUPTI_CB_DOMAIN_DRIVER_API or
 CUPTI_CB_DOMAIN_RUNTIME_API. The callback data is valid only within
 the invocation of the callback function that is passed the data. If
 you need to retain some data for use outside of the callback, you
 must make a copy of that data. For example, if you make a shallow
 copy of CUpti_CallbackData within a callback, you cannot
 dereference \p functionParams outside of that callback to access
 the function parameters. \p functionName is an exception: the
 string pointed to by \p functionName is a global constant and so
 may be accessed outside of the callback.*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_CallbackData {
    /** Point in the runtime or driver function from where the callback
 was issued.*/
    pub callbackSite: CUpti_ApiCallbackSite,
    /** Name of the runtime or driver API function which issued the
 callback. This string is a global constant and so may be
 accessed outside of the callback.*/
    pub functionName: *const ::std::os::raw::c_char,
    /** Pointer to the arguments passed to the runtime or driver API
 call. See generated_cuda_runtime_api_meta.h and
 generated_cuda_meta.h for structure definitions for the
 parameters for each runtime and driver API function.*/
    pub functionParams: *const ::std::os::raw::c_void,
    /** Pointer to the return value of the runtime or driver API
 call. This field is only valid within the exit::CUPTI_API_EXIT
 callback. For a runtime API \p functionReturnValue points to a
 \p cudaError_t. For a driver API \p functionReturnValue points
 to a \p CUresult.*/
    pub functionReturnValue: *mut ::std::os::raw::c_void,
    /** Name of the symbol operated on by the runtime or driver API
 function which issued the callback. This entry is valid only for
 driver and runtime launch callbacks, where it returns the name of
 the kernel.*/
    pub symbolName: *const ::std::os::raw::c_char,
    /** Driver context current to the thread, or null if no context is
 current. This value can change from the entry to exit callback
 of a runtime API function if the runtime initializes a context.*/
    pub context: CUcontext,
    /** Unique ID for the CUDA context associated with the thread. The
 UIDs are assigned sequentially as contexts are created and are
 unique within a process.*/
    pub contextUid: u32,
    /** Pointer to data shared between the entry and exit callbacks of
 a given runtime or drive API function invocation. This field
 can be used to pass 64-bit values from the entry callback to
 the corresponding exit callback.*/
    pub correlationData: *mut u64,
    /** The activity record correlation ID for this callback. For a
 driver domain callback (i.e. \p domain
 CUPTI_CB_DOMAIN_DRIVER_API) this ID will equal the correlation ID
 in the CUpti_ActivityAPI record corresponding to the CUDA driver
 function call. For a runtime domain callback (i.e. \p domain
 CUPTI_CB_DOMAIN_RUNTIME_API) this ID will equal the correlation
 ID in the CUpti_ActivityAPI record corresponding to the CUDA
 runtime function call. Within the callback, this ID can be
 recorded to correlate user data with the activity record. This
 field is new in 4.1.*/
    pub correlationId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_CallbackData",
    ][::std::mem::size_of::<CUpti_CallbackData>() - 72usize];
    [
        "Alignment of CUpti_CallbackData",
    ][::std::mem::align_of::<CUpti_CallbackData>() - 8usize];
    [
        "Offset of field: CUpti_CallbackData::callbackSite",
    ][::std::mem::offset_of!(CUpti_CallbackData, callbackSite) - 0usize];
    [
        "Offset of field: CUpti_CallbackData::functionName",
    ][::std::mem::offset_of!(CUpti_CallbackData, functionName) - 8usize];
    [
        "Offset of field: CUpti_CallbackData::functionParams",
    ][::std::mem::offset_of!(CUpti_CallbackData, functionParams) - 16usize];
    [
        "Offset of field: CUpti_CallbackData::functionReturnValue",
    ][::std::mem::offset_of!(CUpti_CallbackData, functionReturnValue) - 24usize];
    [
        "Offset of field: CUpti_CallbackData::symbolName",
    ][::std::mem::offset_of!(CUpti_CallbackData, symbolName) - 32usize];
    [
        "Offset of field: CUpti_CallbackData::context",
    ][::std::mem::offset_of!(CUpti_CallbackData, context) - 40usize];
    [
        "Offset of field: CUpti_CallbackData::contextUid",
    ][::std::mem::offset_of!(CUpti_CallbackData, contextUid) - 48usize];
    [
        "Offset of field: CUpti_CallbackData::correlationData",
    ][::std::mem::offset_of!(CUpti_CallbackData, correlationData) - 56usize];
    [
        "Offset of field: CUpti_CallbackData::correlationId",
    ][::std::mem::offset_of!(CUpti_CallbackData, correlationId) - 64usize];
};
impl Default for CUpti_CallbackData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief Data passed into a resource callback function.

 Data passed into a resource callback function as the \p cbdata
 argument to \ref CUpti_CallbackFunc. The \p cbdata will be this
 type for \p domain equal to CUPTI_CB_DOMAIN_RESOURCE. The callback
 data is valid only within the invocation of the callback function
 that is passed the data. If you need to retain some data for use
 outside of the callback, you must make a copy of that data.*/
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUpti_ResourceData {
    /** For CUPTI_CBID_RESOURCE_CONTEXT_CREATED and
 CUPTI_CBID_RESOURCE_CONTEXT_DESTROY_STARTING, the context being
 created or destroyed. For CUPTI_CBID_RESOURCE_STREAM_CREATED and
 CUPTI_CBID_RESOURCE_STREAM_DESTROY_STARTING, the context
 containing the stream being created or destroyed.*/
    pub context: CUcontext,
    pub resourceHandle: CUpti_ResourceData__bindgen_ty_1,
    /// Reserved for future use.
    pub resourceDescriptor: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ResourceData__bindgen_ty_1 {
    /** For CUPTI_CBID_RESOURCE_STREAM_CREATED and
 CUPTI_CBID_RESOURCE_STREAM_DESTROY_STARTING, the stream being
 created or destroyed.*/
    pub stream: CUstream,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ResourceData__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ResourceData__bindgen_ty_1>() - 8usize];
    [
        "Alignment of CUpti_ResourceData__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ResourceData__bindgen_ty_1>() - 8usize];
    [
        "Offset of field: CUpti_ResourceData__bindgen_ty_1::stream",
    ][::std::mem::offset_of!(CUpti_ResourceData__bindgen_ty_1, stream) - 0usize];
};
impl Default for CUpti_ResourceData__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ResourceData__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ResourceData__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ResourceData",
    ][::std::mem::size_of::<CUpti_ResourceData>() - 24usize];
    [
        "Alignment of CUpti_ResourceData",
    ][::std::mem::align_of::<CUpti_ResourceData>() - 8usize];
    [
        "Offset of field: CUpti_ResourceData::context",
    ][::std::mem::offset_of!(CUpti_ResourceData, context) - 0usize];
    [
        "Offset of field: CUpti_ResourceData::resourceHandle",
    ][::std::mem::offset_of!(CUpti_ResourceData, resourceHandle) - 8usize];
    [
        "Offset of field: CUpti_ResourceData::resourceDescriptor",
    ][::std::mem::offset_of!(CUpti_ResourceData, resourceDescriptor) - 16usize];
};
impl Default for CUpti_ResourceData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ResourceData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ResourceData {{ context: {:?}, resourceHandle: {:?}, resourceDescriptor: {:?} }}",
            self.context,
            self.resourceHandle,
            self.resourceDescriptor,
        )
    }
}
/** \brief Module data passed into a resource callback function.

 CUDA module data passed into a resource callback function as the \p cbdata
 argument to \ref CUpti_CallbackFunc. The \p cbdata will be this
 type for \p domain equal to CUPTI_CB_DOMAIN_RESOURCE. The module
 data is valid only within the invocation of the callback function
 that is passed the data. If you need to retain some data for use
 outside of the callback, you must make a copy of that data.*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ModuleResourceData {
    /// Identifier to associate with the CUDA module.
    pub moduleId: u32,
    /// The size of the cubin.
    pub cubinSize: usize,
    /// Pointer to the associated cubin.
    pub pCubin: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ModuleResourceData",
    ][::std::mem::size_of::<CUpti_ModuleResourceData>() - 24usize];
    [
        "Alignment of CUpti_ModuleResourceData",
    ][::std::mem::align_of::<CUpti_ModuleResourceData>() - 8usize];
    [
        "Offset of field: CUpti_ModuleResourceData::moduleId",
    ][::std::mem::offset_of!(CUpti_ModuleResourceData, moduleId) - 0usize];
    [
        "Offset of field: CUpti_ModuleResourceData::cubinSize",
    ][::std::mem::offset_of!(CUpti_ModuleResourceData, cubinSize) - 8usize];
    [
        "Offset of field: CUpti_ModuleResourceData::pCubin",
    ][::std::mem::offset_of!(CUpti_ModuleResourceData, pCubin) - 16usize];
};
impl Default for CUpti_ModuleResourceData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief CUDA graphs data passed into a resource callback function.

 CUDA graphs data passed into a resource callback function as the \p cbdata
 argument to \ref CUpti_CallbackFunc. The \p cbdata will be this
 type for \p domain equal to CUPTI_CB_DOMAIN_RESOURCE. The graph
 data is valid only within the invocation of the callback function
 that is passed the data. If you need to retain some data for use
 outside of the callback, you must make a copy of that data.*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_GraphData {
    /// CUDA graph
    pub graph: CUgraph,
    /// The original CUDA graph from which \param graph is cloned
    pub originalGraph: CUgraph,
    /// CUDA graph node
    pub node: CUgraphNode,
    /// The original CUDA graph node from which \param node is cloned
    pub originalNode: CUgraphNode,
    /// Type of the \param node
    pub nodeType: CUgraphNodeType,
    /// The dependent graph node
    pub dependency: CUgraphNode,
    /// CUDA executable graph
    pub graphExec: CUgraphExec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_GraphData"][::std::mem::size_of::<CUpti_GraphData>() - 56usize];
    ["Alignment of CUpti_GraphData"][::std::mem::align_of::<CUpti_GraphData>() - 8usize];
    [
        "Offset of field: CUpti_GraphData::graph",
    ][::std::mem::offset_of!(CUpti_GraphData, graph) - 0usize];
    [
        "Offset of field: CUpti_GraphData::originalGraph",
    ][::std::mem::offset_of!(CUpti_GraphData, originalGraph) - 8usize];
    [
        "Offset of field: CUpti_GraphData::node",
    ][::std::mem::offset_of!(CUpti_GraphData, node) - 16usize];
    [
        "Offset of field: CUpti_GraphData::originalNode",
    ][::std::mem::offset_of!(CUpti_GraphData, originalNode) - 24usize];
    [
        "Offset of field: CUpti_GraphData::nodeType",
    ][::std::mem::offset_of!(CUpti_GraphData, nodeType) - 32usize];
    [
        "Offset of field: CUpti_GraphData::dependency",
    ][::std::mem::offset_of!(CUpti_GraphData, dependency) - 40usize];
    [
        "Offset of field: CUpti_GraphData::graphExec",
    ][::std::mem::offset_of!(CUpti_GraphData, graphExec) - 48usize];
};
impl Default for CUpti_GraphData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief Data passed into a synchronize callback function.

 Data passed into a synchronize callback function as the \p cbdata
 argument to \ref CUpti_CallbackFunc. The \p cbdata will be this
 type for \p domain equal to CUPTI_CB_DOMAIN_SYNCHRONIZE. The
 callback data is valid only within the invocation of the callback
 function that is passed the data. If you need to retain some data
 for use outside of the callback, you must make a copy of that data.*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_SynchronizeData {
    /// The context of the stream being synchronized.
    pub context: CUcontext,
    /// The stream being synchronized.
    pub stream: CUstream,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_SynchronizeData",
    ][::std::mem::size_of::<CUpti_SynchronizeData>() - 16usize];
    [
        "Alignment of CUpti_SynchronizeData",
    ][::std::mem::align_of::<CUpti_SynchronizeData>() - 8usize];
    [
        "Offset of field: CUpti_SynchronizeData::context",
    ][::std::mem::offset_of!(CUpti_SynchronizeData, context) - 0usize];
    [
        "Offset of field: CUpti_SynchronizeData::stream",
    ][::std::mem::offset_of!(CUpti_SynchronizeData, stream) - 8usize];
};
impl Default for CUpti_SynchronizeData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief Data passed into a NVTX callback function.

 Data passed into a NVTX callback function as the \p cbdata argument
 to \ref CUpti_CallbackFunc. The \p cbdata will be this type for \p
 domain equal to CUPTI_CB_DOMAIN_NVTX. Unless otherwise notes, the
 callback data is valid only within the invocation of the callback
 function that is passed the data. If you need to retain some data
 for use outside of the callback, you must make a copy of that data.*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_NvtxData {
    /** Name of the NVTX API function which issued the callback. This
 string is a global constant and so may be accessed outside of the
 callback.*/
    pub functionName: *const ::std::os::raw::c_char,
    /** Pointer to the arguments passed to the NVTX API call. See
 generated_nvtx_meta.h for structure definitions for the
 parameters for each NVTX API function.*/
    pub functionParams: *const ::std::os::raw::c_void,
    /** Pointer to the return value of the NVTX API call. See
 nvToolsExt.h for each NVTX API function's return value.*/
    pub functionReturnValue: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_NvtxData"][::std::mem::size_of::<CUpti_NvtxData>() - 24usize];
    ["Alignment of CUpti_NvtxData"][::std::mem::align_of::<CUpti_NvtxData>() - 8usize];
    [
        "Offset of field: CUpti_NvtxData::functionName",
    ][::std::mem::offset_of!(CUpti_NvtxData, functionName) - 0usize];
    [
        "Offset of field: CUpti_NvtxData::functionParams",
    ][::std::mem::offset_of!(CUpti_NvtxData, functionParams) - 8usize];
    [
        "Offset of field: CUpti_NvtxData::functionReturnValue",
    ][::std::mem::offset_of!(CUpti_NvtxData, functionReturnValue) - 16usize];
};
impl Default for CUpti_NvtxData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief Stream attribute data passed into a resource callback function
 for CUPTI_CBID_RESOURCE_STREAM_ATTRIBUTE_CHANGED callback

 Data passed into a resource callback function as the \p cbdata
 argument to \ref CUpti_CallbackFunc. The \p cbdata will be this
 type for \p domain equal to CUPTI_CB_DOMAIN_RESOURCE. The
 stream attribute data is valid only within the invocation of the callback
 function that is passed the data. If you need to retain some data
 for use outside of the callback, you must make a copy of that data.*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_StreamAttrData {
    /// The CUDA stream handle for the attribute
    pub stream: CUstream,
    /// The type of the CUDA stream attribute
    pub attr: CUstreamAttrID,
    /// The value of the CUDA stream attribute
    pub value: *const CUstreamAttrValue,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_StreamAttrData",
    ][::std::mem::size_of::<CUpti_StreamAttrData>() - 24usize];
    [
        "Alignment of CUpti_StreamAttrData",
    ][::std::mem::align_of::<CUpti_StreamAttrData>() - 8usize];
    [
        "Offset of field: CUpti_StreamAttrData::stream",
    ][::std::mem::offset_of!(CUpti_StreamAttrData, stream) - 0usize];
    [
        "Offset of field: CUpti_StreamAttrData::attr",
    ][::std::mem::offset_of!(CUpti_StreamAttrData, attr) - 8usize];
    [
        "Offset of field: CUpti_StreamAttrData::value",
    ][::std::mem::offset_of!(CUpti_StreamAttrData, value) - 16usize];
};
impl Default for CUpti_StreamAttrData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief Data passed into a State callback function.

 Data passed into a State callback function as the \p cbdata argument
 to \ref CUpti_CallbackFunc. The \p cbdata will be this type for \p
 domain equal to CUPTI_CB_DOMAIN_STATE and callback Ids belonging to CUpti_CallbackIdState.
 Unless otherwise noted, the callback data is valid only within the invocation of the callback
 function that is passed the data. If you need to retain some data
 for use outside of the callback, you must make a copy of that data.*/
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUpti_StateData {
    pub __bindgen_anon_1: CUpti_StateData__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_StateData__bindgen_ty_1 {
    pub notification: CUpti_StateData__bindgen_ty_1__bindgen_ty_1,
}
/** Data passed along with the callback Ids
 Enum CUpti_CallbackIdState used to denote callback ids*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_StateData__bindgen_ty_1__bindgen_ty_1 {
    /// Error code
    pub result: CUptiResult,
    /// String containing more details. It can be NULL.
    pub message: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_StateData__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_StateData__bindgen_ty_1__bindgen_ty_1>() - 16usize];
    [
        "Alignment of CUpti_StateData__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_StateData__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    [
        "Offset of field: CUpti_StateData__bindgen_ty_1__bindgen_ty_1::result",
    ][::std::mem::offset_of!(CUpti_StateData__bindgen_ty_1__bindgen_ty_1, result)
        - 0usize];
    [
        "Offset of field: CUpti_StateData__bindgen_ty_1__bindgen_ty_1::message",
    ][::std::mem::offset_of!(CUpti_StateData__bindgen_ty_1__bindgen_ty_1, message)
        - 8usize];
};
impl Default for CUpti_StateData__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_StateData__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_StateData__bindgen_ty_1>() - 16usize];
    [
        "Alignment of CUpti_StateData__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_StateData__bindgen_ty_1>() - 8usize];
    [
        "Offset of field: CUpti_StateData__bindgen_ty_1::notification",
    ][::std::mem::offset_of!(CUpti_StateData__bindgen_ty_1, notification) - 0usize];
};
impl Default for CUpti_StateData__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_StateData__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_StateData__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_StateData"][::std::mem::size_of::<CUpti_StateData>() - 16usize];
    ["Alignment of CUpti_StateData"][::std::mem::align_of::<CUpti_StateData>() - 8usize];
};
impl Default for CUpti_StateData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_StateData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_StateData {{ __bindgen_anon_1: {:?} }}", self.__bindgen_anon_1)
    }
}
/** \brief An ID for a driver API, runtime API, resource or
 synchronization callback.

 An ID for a driver API, runtime API, resource or synchronization
 callback. Within a driver API callback this should be interpreted
 as a CUpti_driver_api_trace_cbid value (these values are defined in
 cupti_driver_cbid.h). Within a runtime API callback this should be
 interpreted as a CUpti_runtime_api_trace_cbid value (these values
 are defined in cupti_runtime_cbid.h). Within a resource API
 callback this should be interpreted as a \ref
 CUpti_CallbackIdResource value. Within a synchronize API callback
 this should be interpreted as a \ref CUpti_CallbackIdSync value.*/
pub type CUpti_CallbackId = u32;
/** \brief Function type for a callback.

 Function type for a callback. The type of the data passed to the
 callback in \p cbdata depends on the \p domain. If \p domain is
 CUPTI_CB_DOMAIN_DRIVER_API or CUPTI_CB_DOMAIN_RUNTIME_API the type
 of \p cbdata will be CUpti_CallbackData. If \p domain is
 CUPTI_CB_DOMAIN_RESOURCE the type of \p cbdata will be
 CUpti_ResourceData. If \p domain is CUPTI_CB_DOMAIN_SYNCHRONIZE the
 type of \p cbdata will be CUpti_SynchronizeData. If \p domain is
 CUPTI_CB_DOMAIN_NVTX the type of \p cbdata will be CUpti_NvtxData.

 \param userdata User data supplied at subscription of the callback
 \param domain The domain of the callback
 \param cbid The ID of the callback
 \param cbdata Data passed to the callback.*/
pub type CUpti_CallbackFunc = ::std::option::Option<
    unsafe extern "C" fn(
        userdata: *mut ::std::os::raw::c_void,
        domain: CUpti_CallbackDomain,
        cbid: CUpti_CallbackId,
        cbdata: *const ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Subscriber_st {
    _unused: [u8; 0],
}
/// \brief A callback subscriber.
pub type CUpti_SubscriberHandle = *mut CUpti_Subscriber_st;
/// \brief Pointer to an array of callback domains.
pub type CUpti_DomainTable = *mut CUpti_CallbackDomain;
unsafe extern "C" {
    /** \brief Get the available callback domains.

 Returns in \p *domainTable an array of size \p *domainCount of all
 the available callback domains.
 \note \b Thread-safety: this function is thread safe.

 \param domainCount Returns number of callback domains
 \param domainTable Returns pointer to array of available callback domains

 \retval CUPTI_SUCCESS on success
 \retval CUPTI_ERROR_NOT_INITIALIZED if unable to initialize CUPTI
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p domainCount or \p domainTable are NULL*/
    pub fn cuptiSupportedDomains(
        domainCount: *mut usize,
        domainTable: *mut CUpti_DomainTable,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Initialize a callback subscriber with a callback function
 and user data.

 Initializes a callback subscriber with a callback function and
 (optionally) a pointer to user data. The returned subscriber handle
 can be used to enable and disable the callback for specific domains
 and callback IDs.
 \note Only a single subscriber can be registered at a time. To ensure
 that no other CUPTI client interrupts the profiling session, it's the
 responsibility of all the CUPTI clients to call this function before
 starting the profling session. In case profiling session is already
 started by another CUPTI client, this function returns the error code
 CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED.
 Note that this function returns the same error when application is
 launched using NVIDIA tools like Nsight Systems,
 Nsight Compute, cuda-gdb and cuda-memcheck.
 \note This function does not enable any callbacks.
 \note \b Thread-safety: this function is thread safe.
 \note While this API is fully supported and remains available, we recommend transitioning to the new API cuptiSubscribe_v2 moving forward.

 \param subscriber Returns handle to initialize subscriber
 \param callback The callback function
 \param userdata A pointer to user data. This data will be passed to
 the callback function via the \p userdata parameter.

 \retval CUPTI_SUCCESS on success
 \retval CUPTI_ERROR_NOT_INITIALIZED if unable to initialize CUPTI
 \retval CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED if there is already a CUPTI subscriber,
         or if the application is launched with NVIDIA tools like Nsight Systems, Nsight Compute, cuda-gdb and cuda-memcheck.
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p subscriber is NULL*/
    pub fn cuptiSubscribe(
        subscriber: *mut CUpti_SubscriberHandle,
        callback: CUpti_CallbackFunc,
        userdata: *mut ::std::os::raw::c_void,
    ) -> CUptiResult;
}
/// \brief Params for cuptiSubscribe_v2
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_SubscriberParams {
    /** Size of the data structure. CUPTI client should set the size of the structure.
 It will be used in CUPTI to check what fields are available in the structure.
 Used to preserve backward compatibility.*/
    pub structSize: usize,
    /** Name given to the subscriber. The subscriber name need not include the "CUPTI" prefix, as the CUPTI library automatically adds it as "CUPTI for <subscriberName>".
 Can be NULL. An internal copy is created. Size must not exceed CUPTI_SUBSCRIBER_NAME_MAX_LEN to avoid truncation.*/
    pub subscriberName: *const ::std::os::raw::c_char,
    /** In case of CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED return code, the name of the incompatible tool or the
 existing CUPTI subscriber will be written to this location. Size should be greater than or equal to CUPTI_OLD_SUBSCRIBER_NAME_MIN_LEN to avoid truncation.
 Can be NULL.*/
    pub oldSubscriberName: *mut ::std::os::raw::c_char,
    /// Size of oldSubscriberName. Minimum size should be CUPTI_OLD_SUBSCRIBER_NAME_MIN_LEN to avoid truncation.
    pub oldSubscriberSize: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_SubscriberParams",
    ][::std::mem::size_of::<CUpti_SubscriberParams>() - 32usize];
    [
        "Alignment of CUpti_SubscriberParams",
    ][::std::mem::align_of::<CUpti_SubscriberParams>() - 8usize];
    [
        "Offset of field: CUpti_SubscriberParams::structSize",
    ][::std::mem::offset_of!(CUpti_SubscriberParams, structSize) - 0usize];
    [
        "Offset of field: CUpti_SubscriberParams::subscriberName",
    ][::std::mem::offset_of!(CUpti_SubscriberParams, subscriberName) - 8usize];
    [
        "Offset of field: CUpti_SubscriberParams::oldSubscriberName",
    ][::std::mem::offset_of!(CUpti_SubscriberParams, oldSubscriberName) - 16usize];
    [
        "Offset of field: CUpti_SubscriberParams::oldSubscriberSize",
    ][::std::mem::offset_of!(CUpti_SubscriberParams, oldSubscriberSize) - 24usize];
};
impl Default for CUpti_SubscriberParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Initialize a callback subscriber with a callback function
 and user data.

 Initializes a callback subscriber with a callback function and
 (optionally) a pointer to user data. The returned subscriber handle
 can be used to enable and disable the callback for specific domains
 and callback IDs.
 \note Only a single subscriber can be registered at a time. To ensure
 that no other CUPTI client interrupts the profiling session, it's the
 responsibility of all the CUPTI clients to call this function before
 starting the profling session. In case profiling session is already
 started by another CUPTI client, this function returns the error code
 CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED.
 Note that this function returns the same error when application is
 launched using NVIDIA tools like Nsight Systems,
 Nsight Compute, cuda-gdb and cuda-memcheck.
 \note This function does not enable any callbacks.
 \note \b Thread-safety: this function is thread safe.

 \param subscriber Returns handle to initialize subscriber
 \param callback The callback function
 \param userdata A pointer to user data. This data will be passed to
 the callback function via the \p userdata parameter.
 \param pParams A pointer to \ref CUpti_SubscriberParams. Can be NULL.

 \retval CUPTI_SUCCESS on success
 \retval CUPTI_ERROR_NOT_INITIALIZED if unable to initialize CUPTI
 \retval CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED if there is already a CUPTI subscriber,
         or if the application is launched with NVIDIA tools like Nsight Systems, Nsight Compute, cuda-gdb and cuda-memcheck.
 \retval CUPTI_ERROR_INVALID_PARAMETER if:
 - \p pParams.structSize is not filled with the size of the structure*/
    pub fn cuptiSubscribe_v2(
        subscriber: *mut CUpti_SubscriberHandle,
        callback: CUpti_CallbackFunc,
        userdata: *mut ::std::os::raw::c_void,
        pParams: *mut CUpti_SubscriberParams,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Unregister a callback subscriber.

 Removes a callback subscriber so that no future callbacks will be
 issued to that subscriber.
 \note \b Thread-safety: this function is thread safe.

 \param subscriber Handle to the initialize subscriber

 \retval CUPTI_SUCCESS on success
 \retval CUPTI_ERROR_NOT_INITIALIZED if unable to initialized CUPTI
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p subscriber is NULL or not initialized*/
    pub fn cuptiUnsubscribe(subscriber: CUpti_SubscriberHandle) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get the current enabled/disabled state of a callback for a specific
 domain and function ID.

 Returns non-zero in \p *enable if the callback for a domain and
 callback ID is enabled, and zero if not enabled.

 \note \b Thread-safety: a subscriber must serialize access to
 cuptiGetCallbackState, cuptiEnableCallback, cuptiEnableDomain, and
 cuptiEnableAllDomains. For example, if cuptiGetCallbackState(sub,
 d, c) and cuptiEnableCallback(sub, d, c) are called concurrently,
 the results are undefined.

 \param enable Returns non-zero if callback enabled, zero if not enabled
 \param subscriber Handle to the initialize subscriber
 \param domain The domain of the callback
 \param cbid The ID of the callback

 \retval CUPTI_SUCCESS on success
 \retval CUPTI_ERROR_NOT_INITIALIZED if unable to initialized CUPTI
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p enabled is NULL, or if \p
 subscriber, \p domain or \p cbid is invalid.*/
    pub fn cuptiGetCallbackState(
        enable: *mut u32,
        subscriber: CUpti_SubscriberHandle,
        domain: CUpti_CallbackDomain,
        cbid: CUpti_CallbackId,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Enable or disabled callbacks for a specific domain and
 callback ID.

 Enable or disabled callbacks for a subscriber for a specific domain
 and callback ID.

 \note \b Thread-safety: a subscriber must serialize access to
 cuptiGetCallbackState, cuptiEnableCallback, cuptiEnableDomain, and
 cuptiEnableAllDomains. For example, if cuptiGetCallbackState(sub,
 d, c) and cuptiEnableCallback(sub, d, c) are called concurrently,
 the results are undefined.

 \param enable New enable state for the callback. Zero disables the
 callback, non-zero enables the callback.
 \param subscriber - Handle to callback subscription
 \param domain The domain of the callback
 \param cbid The ID of the callback

 \retval CUPTI_SUCCESS on success
 \retval CUPTI_ERROR_NOT_INITIALIZED if unable to initialized CUPTI
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p subscriber, \p domain or \p
 cbid is invalid.*/
    pub fn cuptiEnableCallback(
        enable: u32,
        subscriber: CUpti_SubscriberHandle,
        domain: CUpti_CallbackDomain,
        cbid: CUpti_CallbackId,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Enable or disabled all callbacks for a specific domain.

 Enable or disabled all callbacks for a specific domain.

 \note \b Thread-safety: a subscriber must serialize access to
 cuptiGetCallbackState, cuptiEnableCallback, cuptiEnableDomain, and
 cuptiEnableAllDomains. For example, if cuptiGetCallbackEnabled(sub,
 d, *) and cuptiEnableDomain(sub, d) are called concurrently, the
 results are undefined.

 \param enable New enable state for all callbacks in the
 domain. Zero disables all callbacks, non-zero enables all
 callbacks.
 \param subscriber - Handle to callback subscription
 \param domain The domain of the callback

 \retval CUPTI_SUCCESS on success
 \retval CUPTI_ERROR_NOT_INITIALIZED if unable to initialized CUPTI
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p subscriber or \p domain is invalid*/
    pub fn cuptiEnableDomain(
        enable: u32,
        subscriber: CUpti_SubscriberHandle,
        domain: CUpti_CallbackDomain,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Enable or disable all callbacks in all domains.

 Enable or disable all callbacks in all domains.

 \note \b Thread-safety: a subscriber must serialize access to
 cuptiGetCallbackState, cuptiEnableCallback, cuptiEnableDomain, and
 cuptiEnableAllDomains. For example, if cuptiGetCallbackState(sub,
 d, *) and cuptiEnableAllDomains(sub) are called concurrently, the
 results are undefined.

 \param enable New enable state for all callbacks in all
 domain. Zero disables all callbacks, non-zero enables all
 callbacks.
 \param subscriber - Handle to callback subscription

 \retval CUPTI_SUCCESS on success
 \retval CUPTI_ERROR_NOT_INITIALIZED if unable to initialized CUPTI
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p subscriber is invalid*/
    pub fn cuptiEnableAllDomains(
        enable: u32,
        subscriber: CUpti_SubscriberHandle,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get the name of a callback for a specific domain and callback ID.

 Returns a pointer to the name c_string in \p **name.

 \note \b Names are available only for the DRIVER and RUNTIME domains.

 \param domain The domain of the callback
 \param cbid The ID of the callback
 \param name Returns pointer to the name string on success, NULL otherwise

 \retval CUPTI_SUCCESS on success
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p name is NULL, or if
 \p domain or \p cbid is invalid.*/
    pub fn cuptiGetCallbackName(
        domain: CUpti_CallbackDomain,
        cbid: u32,
        name: *mut *const ::std::os::raw::c_char,
    ) -> CUptiResult;
}
/** \brief ID for an event.

 An event represents a countable activity, action, or occurrence on
 the device.*/
pub type CUpti_EventID = u32;
/** \brief ID for an event domain.

 ID for an event domain. An event domain represents a group of
 related events. A device may have multiple instances of a domain,
 indicating that the device can simultaneously record multiple
 instances of each event within that domain.*/
pub type CUpti_EventDomainID = u32;
/** \brief A group of events.

 An event group is a collection of events that are managed
 together. All events in an event group must belong to the same
 domain.*/
pub type CUpti_EventGroup = *mut ::std::os::raw::c_void;
pub const CUPTI_DEVICE_ATTR_DEVICE_CLASS_TESLA: CUpti_DeviceAttributeDeviceClass = 0;
pub const CUPTI_DEVICE_ATTR_DEVICE_CLASS_QUADRO: CUpti_DeviceAttributeDeviceClass = 1;
pub const CUPTI_DEVICE_ATTR_DEVICE_CLASS_GEFORCE: CUpti_DeviceAttributeDeviceClass = 2;
pub const CUPTI_DEVICE_ATTR_DEVICE_CLASS_TEGRA: CUpti_DeviceAttributeDeviceClass = 3;
/** \brief Device class.

 Enumeration of device classes for device attribute
 CUPTI_DEVICE_ATTR_DEVICE_CLASS.*/
pub type CUpti_DeviceAttributeDeviceClass = ::std::os::raw::c_uint;
/// Number of event IDs for a device. Value is a uint32_t.
pub const CUPTI_DEVICE_ATTR_MAX_EVENT_ID: CUpti_DeviceAttribute = 1;
/// Number of event domain IDs for a device. Value is a uint32_t.
pub const CUPTI_DEVICE_ATTR_MAX_EVENT_DOMAIN_ID: CUpti_DeviceAttribute = 2;
/// Get global memory bandwidth in Kbytes/sec. Value is a uint64_t.
pub const CUPTI_DEVICE_ATTR_GLOBAL_MEMORY_BANDWIDTH: CUpti_DeviceAttribute = 3;
/** Get theoretical maximum number of instructions per cycle. Value
 is a uint32_t.*/
pub const CUPTI_DEVICE_ATTR_INSTRUCTION_PER_CYCLE: CUpti_DeviceAttribute = 4;
/** Get theoretical maximum number of single precision instructions
 that can be executed per second. Value is a uint64_t.*/
pub const CUPTI_DEVICE_ATTR_INSTRUCTION_THROUGHPUT_SINGLE_PRECISION: CUpti_DeviceAttribute = 5;
/// Get number of frame buffers for device.  Value is a uint64_t.
pub const CUPTI_DEVICE_ATTR_MAX_FRAME_BUFFERS: CUpti_DeviceAttribute = 6;
/** Get PCIE link rate in Mega bits/sec for device. Return 0 if bus-type
 is non-PCIE. Value is a uint64_t.*/
pub const CUPTI_DEVICE_ATTR_PCIE_LINK_RATE: CUpti_DeviceAttribute = 7;
/** Get PCIE link width for device. Return 0 if bus-type
 is non-PCIE. Value is a uint64_t.*/
pub const CUPTI_DEVICE_ATTR_PCIE_LINK_WIDTH: CUpti_DeviceAttribute = 8;
/** Get PCIE generation for device. Return 0 if bus-type
 is non-PCIE. Value is a uint64_t.*/
pub const CUPTI_DEVICE_ATTR_PCIE_GEN: CUpti_DeviceAttribute = 9;
/** Get the class for the device. Value is a
 CUpti_DeviceAttributeDeviceClass.*/
pub const CUPTI_DEVICE_ATTR_DEVICE_CLASS: CUpti_DeviceAttribute = 10;
/// Get the peak single precision flop per cycle. Value is a uint64_t.
pub const CUPTI_DEVICE_ATTR_FLOP_SP_PER_CYCLE: CUpti_DeviceAttribute = 11;
/// Get the peak double precision flop per cycle. Value is a uint64_t.
pub const CUPTI_DEVICE_ATTR_FLOP_DP_PER_CYCLE: CUpti_DeviceAttribute = 12;
/// Get number of L2 units. Value is a uint64_t.
pub const CUPTI_DEVICE_ATTR_MAX_L2_UNITS: CUpti_DeviceAttribute = 13;
/** Get the maximum shared memory for the CU_FUNC_CACHE_PREFER_SHARED
 preference. Value is a uint64_t.*/
pub const CUPTI_DEVICE_ATTR_MAX_SHARED_MEMORY_CACHE_CONFIG_PREFER_SHARED: CUpti_DeviceAttribute = 14;
/** Get the maximum shared memory for the CU_FUNC_CACHE_PREFER_L1
 preference. Value is a uint64_t.*/
pub const CUPTI_DEVICE_ATTR_MAX_SHARED_MEMORY_CACHE_CONFIG_PREFER_L1: CUpti_DeviceAttribute = 15;
/** Get the maximum shared memory for the CU_FUNC_CACHE_PREFER_EQUAL
 preference. Value is a uint64_t.*/
pub const CUPTI_DEVICE_ATTR_MAX_SHARED_MEMORY_CACHE_CONFIG_PREFER_EQUAL: CUpti_DeviceAttribute = 16;
/// Get the peak half precision flop per cycle. Value is a uint64_t.
pub const CUPTI_DEVICE_ATTR_FLOP_HP_PER_CYCLE: CUpti_DeviceAttribute = 17;
/** Check if Nvlink is connected to device. Returns 1, if at least one
 Nvlink is connected to the device, returns 0 otherwise.
 Value is a uint32_t.*/
pub const CUPTI_DEVICE_ATTR_NVLINK_PRESENT: CUpti_DeviceAttribute = 18;
/** Check if Nvlink is present between GPU and CPU. Returns Bandwidth,
 in Bytes/sec, if Nvlink is present, returns 0 otherwise.
 Value is a uint64_t.*/
pub const CUPTI_DEVICE_ATTR_GPU_CPU_NVLINK_BW: CUpti_DeviceAttribute = 19;
/** Check if NVSwitch is present in the underlying topology.
 Returns 1, if present, returns 0 otherwise.
 Value is a uint32_t.*/
pub const CUPTI_DEVICE_ATTR_NVSWITCH_PRESENT: CUpti_DeviceAttribute = 20;
/** Check if NVSwitch is present in the underlying topology.
 Returns 1, if present, returns 0 otherwise.
 Value is a uint32_t.*/
pub const CUPTI_DEVICE_ATTR_FORCE_INT: CUpti_DeviceAttribute = 2147483647;
/** \brief Device attributes.

 CUPTI device attributes. These attributes can be read using \ref
 cuptiDeviceGetAttribute.*/
pub type CUpti_DeviceAttribute = ::std::os::raw::c_uint;
/// Event domain name. Value is a null terminated const c-string.
pub const CUPTI_EVENT_DOMAIN_ATTR_NAME: CUpti_EventDomainAttribute = 0;
/** Number of instances of the domain for which event counts will be
 collected.  The domain may have additional instances that cannot
 be profiled (see CUPTI_EVENT_DOMAIN_ATTR_TOTAL_INSTANCE_COUNT).
 Can be read only with \ref
 cuptiDeviceGetEventDomainAttribute. Value is a uint32_t.*/
pub const CUPTI_EVENT_DOMAIN_ATTR_INSTANCE_COUNT: CUpti_EventDomainAttribute = 1;
/** Total number of instances of the domain, including instances that
 cannot be profiled.  Use CUPTI_EVENT_DOMAIN_ATTR_INSTANCE_COUNT
 to get the number of instances that can be profiled. Can be read
 only with \ref cuptiDeviceGetEventDomainAttribute. Value is a
 uint32_t.*/
pub const CUPTI_EVENT_DOMAIN_ATTR_TOTAL_INSTANCE_COUNT: CUpti_EventDomainAttribute = 3;
/** Collection method used for events contained in the event domain.
 Value is a \ref CUpti_EventCollectionMethod.*/
pub const CUPTI_EVENT_DOMAIN_ATTR_COLLECTION_METHOD: CUpti_EventDomainAttribute = 4;
/** Collection method used for events contained in the event domain.
 Value is a \ref CUpti_EventCollectionMethod.*/
pub const CUPTI_EVENT_DOMAIN_ATTR_FORCE_INT: CUpti_EventDomainAttribute = 2147483647;
/** \brief Event domain attributes.

 Event domain attributes. Except where noted, all the attributes can
 be read using either \ref cuptiDeviceGetEventDomainAttribute or
 \ref cuptiEventDomainGetAttribute.*/
pub type CUpti_EventDomainAttribute = ::std::os::raw::c_uint;
/// Event is collected using a hardware global performance monitor.
pub const CUPTI_EVENT_COLLECTION_METHOD_PM: CUpti_EventCollectionMethod = 0;
/// Event is collected using a hardware SM performance monitor.
pub const CUPTI_EVENT_COLLECTION_METHOD_SM: CUpti_EventCollectionMethod = 1;
/// Event is collected using software instrumentation.
pub const CUPTI_EVENT_COLLECTION_METHOD_INSTRUMENTED: CUpti_EventCollectionMethod = 2;
/// Event is collected using NvLink throughput counter method.
pub const CUPTI_EVENT_COLLECTION_METHOD_NVLINK_TC: CUpti_EventCollectionMethod = 3;
/// Event is collected using NvLink throughput counter method.
pub const CUPTI_EVENT_COLLECTION_METHOD_FORCE_INT: CUpti_EventCollectionMethod = 2147483647;
/** \brief The collection method used for an event.

 The collection method indicates how an event is collected.*/
pub type CUpti_EventCollectionMethod = ::std::os::raw::c_uint;
/** The domain to which the event group is bound. This attribute is
 set when the first event is added to the group.  Value is a
 CUpti_EventDomainID.*/
pub const CUPTI_EVENT_GROUP_ATTR_EVENT_DOMAIN_ID: CUpti_EventGroupAttribute = 0;
/** [rw] Profile all the instances of the domain for this
 eventgroup. This feature can be used to get load balancing
 across all instances of a domain. Value is an integer.*/
pub const CUPTI_EVENT_GROUP_ATTR_PROFILE_ALL_DOMAIN_INSTANCES: CUpti_EventGroupAttribute = 1;
/// [rw] Reserved for user data.
pub const CUPTI_EVENT_GROUP_ATTR_USER_DATA: CUpti_EventGroupAttribute = 2;
/// Number of events in the group. Value is a uint32_t.
pub const CUPTI_EVENT_GROUP_ATTR_NUM_EVENTS: CUpti_EventGroupAttribute = 3;
/** Enumerates events in the group. Value is a pointer to buffer of
 size sizeof(CUpti_EventID) * num_of_events in the eventgroup.
 num_of_events can be queried using
 CUPTI_EVENT_GROUP_ATTR_NUM_EVENTS.*/
pub const CUPTI_EVENT_GROUP_ATTR_EVENTS: CUpti_EventGroupAttribute = 4;
/** Number of instances of the domain bound to this event group that
 will be counted.  Value is a uint32_t.*/
pub const CUPTI_EVENT_GROUP_ATTR_INSTANCE_COUNT: CUpti_EventGroupAttribute = 5;
/** Event group scope can be set to CUPTI_EVENT_PROFILING_SCOPE_DEVICE or
 CUPTI_EVENT_PROFILING_SCOPE_CONTEXT for an eventGroup, before
 adding any event.
 Sets the scope of eventgroup as CUPTI_EVENT_PROFILING_SCOPE_DEVICE or
 CUPTI_EVENT_PROFILING_SCOPE_CONTEXT when the scope of the events
 that will be added is CUPTI_EVENT_PROFILING_SCOPE_BOTH.
 If profiling scope of event is either
 CUPTI_EVENT_PROFILING_SCOPE_DEVICE or CUPTI_EVENT_PROFILING_SCOPE_CONTEXT
 then setting this attribute will not affect the default scope.
 It is not allowed to add events of different scope to same eventgroup.
 Value is a uint32_t.*/
pub const CUPTI_EVENT_GROUP_ATTR_PROFILING_SCOPE: CUpti_EventGroupAttribute = 6;
/** Event group scope can be set to CUPTI_EVENT_PROFILING_SCOPE_DEVICE or
 CUPTI_EVENT_PROFILING_SCOPE_CONTEXT for an eventGroup, before
 adding any event.
 Sets the scope of eventgroup as CUPTI_EVENT_PROFILING_SCOPE_DEVICE or
 CUPTI_EVENT_PROFILING_SCOPE_CONTEXT when the scope of the events
 that will be added is CUPTI_EVENT_PROFILING_SCOPE_BOTH.
 If profiling scope of event is either
 CUPTI_EVENT_PROFILING_SCOPE_DEVICE or CUPTI_EVENT_PROFILING_SCOPE_CONTEXT
 then setting this attribute will not affect the default scope.
 It is not allowed to add events of different scope to same eventgroup.
 Value is a uint32_t.*/
pub const CUPTI_EVENT_GROUP_ATTR_FORCE_INT: CUpti_EventGroupAttribute = 2147483647;
/** \brief Event group attributes.

 Event group attributes. These attributes can be read using \ref
 cuptiEventGroupGetAttribute. Attributes marked [rw] can also be
 written using \ref cuptiEventGroupSetAttribute.*/
pub type CUpti_EventGroupAttribute = ::std::os::raw::c_uint;
/// Event is collected at context scope.
pub const CUPTI_EVENT_PROFILING_SCOPE_CONTEXT: CUpti_EventProfilingScope = 0;
/// Event is collected at device scope.
pub const CUPTI_EVENT_PROFILING_SCOPE_DEVICE: CUpti_EventProfilingScope = 1;
/** Event can be collected at device or context scope.
 The scope can be set using \ref cuptiEventGroupSetAttribute API.*/
pub const CUPTI_EVENT_PROFILING_SCOPE_BOTH: CUpti_EventProfilingScope = 2;
/** Event can be collected at device or context scope.
 The scope can be set using \ref cuptiEventGroupSetAttribute API.*/
pub const CUPTI_EVENT_PROFILING_SCOPE_FORCE_INT: CUpti_EventProfilingScope = 2147483647;
/** \brief Profiling scope for event.

 Profiling scope of event indicates if the event can be collected at context
 scope or device scope or both i.e. it can be collected at any of context or
 device scope.*/
pub type CUpti_EventProfilingScope = ::std::os::raw::c_uint;
/// Event name. Value is a null terminated const c-string.
pub const CUPTI_EVENT_ATTR_NAME: CUpti_EventAttribute = 0;
/** Short description of event. Value is a null terminated const
 c-string.*/
pub const CUPTI_EVENT_ATTR_SHORT_DESCRIPTION: CUpti_EventAttribute = 1;
/** Long description of event. Value is a null terminated const
 c-string.*/
pub const CUPTI_EVENT_ATTR_LONG_DESCRIPTION: CUpti_EventAttribute = 2;
/// Category of event. Value is CUpti_EventCategory.
pub const CUPTI_EVENT_ATTR_CATEGORY: CUpti_EventAttribute = 3;
/** Profiling scope of the events. It can be either device or context or both.
 Value is a \ref CUpti_EventProfilingScope.*/
pub const CUPTI_EVENT_ATTR_PROFILING_SCOPE: CUpti_EventAttribute = 5;
/** Profiling scope of the events. It can be either device or context or both.
 Value is a \ref CUpti_EventProfilingScope.*/
pub const CUPTI_EVENT_ATTR_FORCE_INT: CUpti_EventAttribute = 2147483647;
/** \brief Event attributes.

 Event attributes. These attributes can be read using \ref
 cuptiEventGetAttribute.*/
pub type CUpti_EventAttribute = ::std::os::raw::c_uint;
/** Events are collected for the entire duration between the
 cuptiEventGroupEnable and cuptiEventGroupDisable calls.
 Event values are reset when the events are read.
 For CUDA toolkit v6.0 and older this was the default mode.*/
pub const CUPTI_EVENT_COLLECTION_MODE_CONTINUOUS: CUpti_EventCollectionMode = 0;
/** Events are collected only for the durations of kernel executions
 that occur between the cuptiEventGroupEnable and
 cuptiEventGroupDisable calls. Event collection begins when a
 kernel execution begins, and stops when kernel execution
 completes. Event values are reset to zero when each kernel
 execution begins. If multiple kernel executions occur between the
 cuptiEventGroupEnable and cuptiEventGroupDisable calls then the
 event values must be read after each kernel launch if those
 events need to be associated with the specific kernel launch.
 Note that collection in this mode may significantly change the
 overall performance characteristics of the application because
 kernel executions that occur between the cuptiEventGroupEnable and
 cuptiEventGroupDisable calls are serialized on the GPU.
 This is the default mode from CUDA toolkit v6.5*/
pub const CUPTI_EVENT_COLLECTION_MODE_KERNEL: CUpti_EventCollectionMode = 1;
/** Events are collected only for the durations of kernel executions
 that occur between the cuptiEventGroupEnable and
 cuptiEventGroupDisable calls. Event collection begins when a
 kernel execution begins, and stops when kernel execution
 completes. Event values are reset to zero when each kernel
 execution begins. If multiple kernel executions occur between the
 cuptiEventGroupEnable and cuptiEventGroupDisable calls then the
 event values must be read after each kernel launch if those
 events need to be associated with the specific kernel launch.
 Note that collection in this mode may significantly change the
 overall performance characteristics of the application because
 kernel executions that occur between the cuptiEventGroupEnable and
 cuptiEventGroupDisable calls are serialized on the GPU.
 This is the default mode from CUDA toolkit v6.5*/
pub const CUPTI_EVENT_COLLECTION_MODE_FORCE_INT: CUpti_EventCollectionMode = 2147483647;
/** \brief Event collection modes.

 The event collection mode determines the period over which the
 events within the enabled event groups will be collected.*/
pub type CUpti_EventCollectionMode = ::std::os::raw::c_uint;
/// An instruction related event.
pub const CUPTI_EVENT_CATEGORY_INSTRUCTION: CUpti_EventCategory = 0;
/// A memory related event.
pub const CUPTI_EVENT_CATEGORY_MEMORY: CUpti_EventCategory = 1;
/// A cache related event.
pub const CUPTI_EVENT_CATEGORY_CACHE: CUpti_EventCategory = 2;
/// A profile-trigger event.
pub const CUPTI_EVENT_CATEGORY_PROFILE_TRIGGER: CUpti_EventCategory = 3;
/// A system event.
pub const CUPTI_EVENT_CATEGORY_SYSTEM: CUpti_EventCategory = 4;
/// A system event.
pub const CUPTI_EVENT_CATEGORY_FORCE_INT: CUpti_EventCategory = 2147483647;
/** \brief An event category.

 Each event is assigned to a category that represents the general
 type of the event. A event's category is accessed using \ref
 cuptiEventGetAttribute and the CUPTI_EVENT_ATTR_CATEGORY attribute.*/
pub type CUpti_EventCategory = ::std::os::raw::c_uint;
/// No flags.
pub const CUPTI_EVENT_READ_FLAG_NONE: CUpti_ReadEventFlags = 0;
/// No flags.
pub const CUPTI_EVENT_READ_FLAG_FORCE_INT: CUpti_ReadEventFlags = 2147483647;
/** \brief Flags for cuptiEventGroupReadEvent an
 cuptiEventGroupReadAllEvents.

 Flags for \ref cuptiEventGroupReadEvent an \ref
 cuptiEventGroupReadAllEvents.*/
pub type CUpti_ReadEventFlags = ::std::os::raw::c_uint;
/** \brief A set of event groups.

 A set of event groups. When returned by \ref
 cuptiEventGroupSetsCreate and \ref cuptiMetricCreateEventGroupSets
 a set indicates that event groups that can be enabled at the same
 time (i.e. all the events in the set can be collected
 simultaneously).*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_EventGroupSet {
    /// The number of event groups in the set.
    pub numEventGroups: u32,
    /// An array of \p numEventGroups event groups.
    pub eventGroups: *mut CUpti_EventGroup,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_EventGroupSet",
    ][::std::mem::size_of::<CUpti_EventGroupSet>() - 16usize];
    [
        "Alignment of CUpti_EventGroupSet",
    ][::std::mem::align_of::<CUpti_EventGroupSet>() - 8usize];
    [
        "Offset of field: CUpti_EventGroupSet::numEventGroups",
    ][::std::mem::offset_of!(CUpti_EventGroupSet, numEventGroups) - 0usize];
    [
        "Offset of field: CUpti_EventGroupSet::eventGroups",
    ][::std::mem::offset_of!(CUpti_EventGroupSet, eventGroups) - 8usize];
};
impl Default for CUpti_EventGroupSet {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief A set of event group sets.

 A set of event group sets. When returned by \ref
 cuptiEventGroupSetsCreate and \ref cuptiMetricCreateEventGroupSets
 a CUpti_EventGroupSets indicates the number of passes required to
 collect all the events, and the event groups that should be
 collected during each pass.*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_EventGroupSets {
    /// Number of event group sets.
    pub numSets: u32,
    /// An array of \p numSets event group sets.
    pub sets: *mut CUpti_EventGroupSet,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_EventGroupSets",
    ][::std::mem::size_of::<CUpti_EventGroupSets>() - 16usize];
    [
        "Alignment of CUpti_EventGroupSets",
    ][::std::mem::align_of::<CUpti_EventGroupSets>() - 8usize];
    [
        "Offset of field: CUpti_EventGroupSets::numSets",
    ][::std::mem::offset_of!(CUpti_EventGroupSets, numSets) - 0usize];
    [
        "Offset of field: CUpti_EventGroupSets::sets",
    ][::std::mem::offset_of!(CUpti_EventGroupSets, sets) - 8usize];
};
impl Default for CUpti_EventGroupSets {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Set the event collection mode.

 Set the event collection mode for a \p context.  The \p mode
 controls the event collection behavior of all events in event
 groups created in the \p context. This API is invalid in kernel
 replay mode.
 \note \b Thread-safety: this function is thread safe.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param context The context
 \param mode The event collection mode

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_CONTEXT
 \retval CUPTI_ERROR_INVALID_OPERATION if called when replay mode is enabled
 \retval CUPTI_ERROR_NOT_SUPPORTED if mode is not supported on the device*/
    pub fn cuptiSetEventCollectionMode(
        context: CUcontext,
        mode: CUpti_EventCollectionMode,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Read a device attribute.

 Read a device attribute and return it in \p *value.
 \note \b Thread-safety: this function is thread safe.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param device CUDA device
 \param attrib The attribute to read
 \param valueSize Size of buffer pointed by the value, and
 returns the number of bytes written to \p value
 \param value Returns the value of the attribute

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_DEVICE
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p valueSize or \p value
 is NULL, or if \p attrib is not a device attribute
 \retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT For non-c-string
 attribute values, indicates that the \p value buffer is too small
 to hold the attribute value.*/
    pub fn cuptiDeviceGetAttribute(
        device: CUdevice,
        attrib: CUpti_DeviceAttribute,
        valueSize: *mut usize,
        value: *mut ::std::os::raw::c_void,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get the number of domains for a device.

 Returns the number of domains in \p numDomains for a device.
 \note \b Thread-safety: this function is thread safe.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param device CUDA device
 \param numDomains Returns the number of domains

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_DEVICE
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p numDomains is NULL*/
    pub fn cuptiDeviceGetNumEventDomains(
        device: CUdevice,
        numDomains: *mut u32,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get the event domains for a device.

 Returns the event domains IDs in \p domainArray for a device.  The
 size of the \p domainArray buffer is given by \p
 *arraySizeBytes. The size of the \p domainArray buffer must be at
 least \p numdomains * sizeof(CUpti_EventDomainID) or else all
 domains will not be returned. The value returned in \p
 *arraySizeBytes contains the number of bytes returned in \p
 domainArray.
 \note \b Thread-safety: this function is thread safe.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param device CUDA device
 \param arraySizeBytes The size of \p domainArray in bytes, and
 returns the number of bytes written to \p domainArray
 \param domainArray Returns the IDs of the event domains for the device

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_DEVICE
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p arraySizeBytes or
 \p domainArray are NULL*/
    pub fn cuptiDeviceEnumEventDomains(
        device: CUdevice,
        arraySizeBytes: *mut usize,
        domainArray: *mut CUpti_EventDomainID,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Read an event domain attribute.

 Returns an event domain attribute in \p *value. The size of the \p
 value buffer is given by \p *valueSize. The value returned in \p
 *valueSize contains the number of bytes returned in \p value.

 If the attribute value is a c-string that is longer than \p
 *valueSize, then only the first \p *valueSize characters will be
 returned and there will be no terminating null byte.
 \note \b Thread-safety: this function is thread safe.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param device CUDA device
 \param eventDomain ID of the event domain
 \param attrib The event domain attribute to read
 \param valueSize The size of the \p value buffer in bytes, and
 returns the number of bytes written to \p value
 \param value Returns the attribute's value

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_DEVICE
 \retval CUPTI_ERROR_INVALID_EVENT_DOMAIN_ID
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p valueSize or \p value
 is NULL, or if \p attrib is not an event domain attribute
 \retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT For non-c-string
 attribute values, indicates that the \p value buffer is too small
 to hold the attribute value.*/
    pub fn cuptiDeviceGetEventDomainAttribute(
        device: CUdevice,
        eventDomain: CUpti_EventDomainID,
        attrib: CUpti_EventDomainAttribute,
        valueSize: *mut usize,
        value: *mut ::std::os::raw::c_void,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get the number of event domains available on any device.

 Returns the total number of event domains available on any
 CUDA-capable device.
 \note \b Thread-safety: this function is thread safe.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param numDomains Returns the number of domains

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p numDomains is NULL*/
    pub fn cuptiGetNumEventDomains(numDomains: *mut u32) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get the event domains available on any device.

 Returns all the event domains available on any CUDA-capable device.
 Event domain IDs are returned in \p domainArray. The size of the \p
 domainArray buffer is given by \p *arraySizeBytes. The size of the
 \p domainArray buffer must be at least \p numDomains *
 sizeof(CUpti_EventDomainID) or all domains will not be
 returned. The value returned in \p *arraySizeBytes contains the
 number of bytes returned in \p domainArray.
 \note \b Thread-safety: this function is thread safe.

 \param arraySizeBytes The size of \p domainArray in bytes, and
 returns the number of bytes written to \p domainArray
 \param domainArray Returns all the event domains

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p arraySizeBytes or
 \p domainArray are NULL*/
    pub fn cuptiEnumEventDomains(
        arraySizeBytes: *mut usize,
        domainArray: *mut CUpti_EventDomainID,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Read an event domain attribute.

 Returns an event domain attribute in \p *value. The size of the \p
 value buffer is given by \p *valueSize. The value returned in \p
 *valueSize contains the number of bytes returned in \p value.

 If the attribute value is a c-string that is longer than \p
 *valueSize, then only the first \p *valueSize characters will be
 returned and there will be no terminating null byte.
 \note \b Thread-safety: this function is thread safe.

 \param eventDomain ID of the event domain
 \param attrib The event domain attribute to read
 \param valueSize The size of the \p value buffer in bytes, and
 returns the number of bytes written to \p value
 \param value Returns the attribute's value

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_EVENT_DOMAIN_ID
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p valueSize or \p value
 is NULL, or if \p attrib is not an event domain attribute
 \retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT For non-c-string
 attribute values, indicates that the \p value buffer is too small
 to hold the attribute value.*/
    pub fn cuptiEventDomainGetAttribute(
        eventDomain: CUpti_EventDomainID,
        attrib: CUpti_EventDomainAttribute,
        valueSize: *mut usize,
        value: *mut ::std::os::raw::c_void,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get number of events in a domain.

 Returns the number of events in \p numEvents for a domain.
 \note \b Thread-safety: this function is thread safe.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param eventDomain ID of the event domain
 \param numEvents Returns the number of events in the domain

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_EVENT_DOMAIN_ID
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p numEvents is NULL*/
    pub fn cuptiEventDomainGetNumEvents(
        eventDomain: CUpti_EventDomainID,
        numEvents: *mut u32,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get the events in a domain.

 Returns the event IDs in \p eventArray for a domain.  The size of
 the \p eventArray buffer is given by \p *arraySizeBytes. The size
 of the \p eventArray buffer must be at least \p numdomainevents *
 sizeof(CUpti_EventID) or else all events will not be returned. The
 value returned in \p *arraySizeBytes contains the number of bytes
 returned in \p eventArray.
 \note \b Thread-safety: this function is thread safe.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param eventDomain ID of the event domain
 \param arraySizeBytes The size of \p eventArray in bytes, and
 returns the number of bytes written to \p eventArray
 \param eventArray Returns the IDs of the events in the domain

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_EVENT_DOMAIN_ID
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p arraySizeBytes or \p
 eventArray are NULL*/
    pub fn cuptiEventDomainEnumEvents(
        eventDomain: CUpti_EventDomainID,
        arraySizeBytes: *mut usize,
        eventArray: *mut CUpti_EventID,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get an event attribute.

 Returns an event attribute in \p *value. The size of the \p
 value buffer is given by \p *valueSize. The value returned in \p
 *valueSize contains the number of bytes returned in \p value.

 If the attribute value is a c-string that is longer than \p
 *valueSize, then only the first \p *valueSize characters will be
 returned and there will be no terminating null byte.
 \note \b Thread-safety: this function is thread safe.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param event ID of the event
 \param attrib The event attribute to read
 \param valueSize The size of the \p value buffer in bytes, and
 returns the number of bytes written to \p value
 \param value Returns the attribute's value

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_EVENT_ID
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p valueSize or \p value
 is NULL, or if \p attrib is not an event attribute
 \retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT For non-c-string
 attribute values, indicates that the \p value buffer is too small
 to hold the attribute value.*/
    pub fn cuptiEventGetAttribute(
        event: CUpti_EventID,
        attrib: CUpti_EventAttribute,
        valueSize: *mut usize,
        value: *mut ::std::os::raw::c_void,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Find an event by name.

 Find an event by name and return the event ID in \p *event.
 \note \b Thread-safety: this function is thread safe.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param device CUDA device
 \param eventName The name of the event to find
 \param event Returns the ID of the found event or undefined if
 unable to find the event

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_DEVICE
 \retval CUPTI_ERROR_INVALID_EVENT_NAME if unable to find an event
 with name \p eventName. In this case \p *event is undefined
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p eventName or \p event are NULL*/
    pub fn cuptiEventGetIdFromName(
        device: CUdevice,
        eventName: *const ::std::os::raw::c_char,
        event: *mut CUpti_EventID,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Create a new event group for a context.

 Creates a new event group for \p context and returns the new group
 in \p *eventGroup.
 \note \p flags are reserved for future use and should be set to zero.
 \note \b Thread-safety: this function is thread safe.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param context The context for the event group
 \param eventGroup Returns the new event group
 \param flags Reserved - must be zero

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_CONTEXT
 \retval CUPTI_ERROR_OUT_OF_MEMORY
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p eventGroup is NULL*/
    pub fn cuptiEventGroupCreate(
        context: CUcontext,
        eventGroup: *mut CUpti_EventGroup,
        flags: u32,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Destroy an event group.

 Destroy an \p eventGroup and free its resources. An event group
 cannot be destroyed if it is enabled.
 \note \b Thread-safety: this function is thread safe.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param eventGroup The event group to destroy

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_OPERATION if the event group is enabled
 \retval CUPTI_ERROR_INVALID_PARAMETER if eventGroup is NULL*/
    pub fn cuptiEventGroupDestroy(eventGroup: CUpti_EventGroup) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Read an event group attribute.

 Read an event group attribute and return it in \p *value.
 \note \b Thread-safety: this function is thread safe but client
 must guard against simultaneous destruction or modification of \p
 eventGroup (for example, client must guard against simultaneous
 calls to \ref cuptiEventGroupDestroy, \ref cuptiEventGroupAddEvent,
 etc.), and must guard against simultaneous destruction of the
 context in which \p eventGroup was created (for example, client
 must guard against simultaneous calls to cudaDeviceReset,
 cuCtxDestroy, etc.).

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param eventGroup The event group
 \param attrib The attribute to read
 \param valueSize Size of buffer pointed by the value, and
 returns the number of bytes written to \p value
 \param value Returns the value of the attribute

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p valueSize or \p value
 is NULL, or if \p attrib is not an eventgroup attribute
 \retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT For non-c-string
 attribute values, indicates that the \p value buffer is too small
 to hold the attribute value.*/
    pub fn cuptiEventGroupGetAttribute(
        eventGroup: CUpti_EventGroup,
        attrib: CUpti_EventGroupAttribute,
        valueSize: *mut usize,
        value: *mut ::std::os::raw::c_void,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Write an event group attribute.

 Write an event group attribute.
 \note \b Thread-safety: this function is thread safe.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param eventGroup The event group
 \param attrib The attribute to write
 \param valueSize The size, in bytes, of the value
 \param value The attribute value to write

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p valueSize or \p value
 is NULL, or if \p attrib is not an event group attribute, or if
 \p attrib is not a writable attribute
 \retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT Indicates that
 the \p value buffer is too small to hold the attribute value.*/
    pub fn cuptiEventGroupSetAttribute(
        eventGroup: CUpti_EventGroup,
        attrib: CUpti_EventGroupAttribute,
        valueSize: usize,
        value: *mut ::std::os::raw::c_void,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Add an event to an event group.

 Add an event to an event group. The event add can fail for a number of reasons:
 \li The event group is enabled
 \li The event does not belong to the same event domain as the
 events that are already in the event group
 \li Device limitations on the events that can belong to the same group
 \li The event group is full

 \note \b Thread-safety: this function is thread safe.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param eventGroup The event group
 \param event The event to add to the group

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_EVENT_ID
 \retval CUPTI_ERROR_OUT_OF_MEMORY
 \retval CUPTI_ERROR_INVALID_OPERATION if \p eventGroup is enabled
 \retval CUPTI_ERROR_NOT_COMPATIBLE if \p event belongs to a
 different event domain than the events already in \p eventGroup, or
 if a device limitation prevents \p event from being collected at
 the same time as the events already in \p eventGroup
 \retval CUPTI_ERROR_MAX_LIMIT_REACHED if \p eventGroup is full
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p eventGroup is NULL*/
    pub fn cuptiEventGroupAddEvent(
        eventGroup: CUpti_EventGroup,
        event: CUpti_EventID,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Remove an event from an event group.

 Remove \p event from the an event group. The event cannot be
 removed if the event group is enabled.
 \note \b Thread-safety: this function is thread safe.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param eventGroup The event group
 \param event The event to remove from the group

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_EVENT_ID
 \retval CUPTI_ERROR_INVALID_OPERATION if \p eventGroup is enabled
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p eventGroup is NULL*/
    pub fn cuptiEventGroupRemoveEvent(
        eventGroup: CUpti_EventGroup,
        event: CUpti_EventID,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Remove all events from an event group.

 Remove all events from an event group. Events cannot be removed if
 the event group is enabled.
 \note \b Thread-safety: this function is thread safe.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param eventGroup The event group

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_OPERATION if \p eventGroup is enabled
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p eventGroup is NULL*/
    pub fn cuptiEventGroupRemoveAllEvents(eventGroup: CUpti_EventGroup) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Zero all the event counts in an event group.

 Zero all the event counts in an event group.
 \note \b Thread-safety: this function is thread safe but client
 must guard against simultaneous destruction or modification of \p
 eventGroup (for example, client must guard against simultaneous
 calls to \ref cuptiEventGroupDestroy, \ref cuptiEventGroupAddEvent,
 etc.), and must guard against simultaneous destruction of the
 context in which \p eventGroup was created (for example, client
 must guard against simultaneous calls to cudaDeviceReset,
 cuCtxDestroy, etc.).

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param eventGroup The event group

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_HARDWARE
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p eventGroup is NULL*/
    pub fn cuptiEventGroupResetAllEvents(eventGroup: CUpti_EventGroup) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Enable an event group.

 Enable an event group. Enabling an event group zeros the value of
 all the events in the group and then starts collection of those
 events.
 \note \b Thread-safety: this function is thread safe.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param eventGroup The event group

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_HARDWARE
 \retval CUPTI_ERROR_NOT_READY if \p eventGroup does not contain any events
 \retval CUPTI_ERROR_NOT_COMPATIBLE if \p eventGroup cannot be
 enabled due to other already enabled event groups
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p eventGroup is NULL
 \retval CUPTI_ERROR_HARDWARE_BUSY if another client is profiling
 and hardware is busy*/
    pub fn cuptiEventGroupEnable(eventGroup: CUpti_EventGroup) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Disable an event group.

 Disable an event group. Disabling an event group stops collection
 of events contained in the group.
 \note \b Thread-safety: this function is thread safe.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param eventGroup The event group

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_HARDWARE
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p eventGroup is NULL*/
    pub fn cuptiEventGroupDisable(eventGroup: CUpti_EventGroup) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Read the value for an event in an event group.

 Read the value for an event in an event group. The event value is
 returned in the \p eventValueBuffer buffer. \p
 eventValueBufferSizeBytes indicates the size of the \p
 eventValueBuffer buffer. The buffer must be at least sizeof(uint64)
 if ::CUPTI_EVENT_GROUP_ATTR_PROFILE_ALL_DOMAIN_INSTANCES is not set
 on the group containing the event.  The buffer must be at least
 (sizeof(uint64) * number of domain instances) if
 ::CUPTI_EVENT_GROUP_ATTR_PROFILE_ALL_DOMAIN_INSTANCES is set on the
 group.

 If any instance of an event counter overflows, the value returned
 for that event instance will be ::CUPTI_EVENT_OVERFLOW.

 The only allowed value for \p flags is ::CUPTI_EVENT_READ_FLAG_NONE.

 Reading an event from a disabled event group is not allowed. After
 being read, an event's value is reset to zero.
 \note \b Thread-safety: this function is thread safe but client
 must guard against simultaneous destruction or modification of \p
 eventGroup (for example, client must guard against simultaneous
 calls to \ref cuptiEventGroupDestroy, \ref cuptiEventGroupAddEvent,
 etc.), and must guard against simultaneous destruction of the
 context in which \p eventGroup was created (for example, client
 must guard against simultaneous calls to cudaDeviceReset,
 cuCtxDestroy, etc.). If \ref cuptiEventGroupResetAllEvents is
 called simultaneously with this function, then returned event
 values are undefined.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param eventGroup The event group
 \param flags Flags controlling the reading mode
 \param event The event to read
 \param eventValueBufferSizeBytes The size of \p eventValueBuffer
 in bytes, and returns the number of bytes written to \p
 eventValueBuffer
 \param eventValueBuffer Returns the event value(s)

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_EVENT_ID
 \retval CUPTI_ERROR_HARDWARE
 \retval CUPTI_ERROR_INVALID_OPERATION if \p eventGroup is disabled
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p eventGroup, \p
 eventValueBufferSizeBytes or \p eventValueBuffer is NULL
 \retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT if size of \p eventValueBuffer
 is not sufficient*/
    pub fn cuptiEventGroupReadEvent(
        eventGroup: CUpti_EventGroup,
        flags: CUpti_ReadEventFlags,
        event: CUpti_EventID,
        eventValueBufferSizeBytes: *mut usize,
        eventValueBuffer: *mut u64,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Read the values for all the events in an event group.

 Read the values for all the events in an event group. The event
 values are returned in the \p eventValueBuffer buffer. \p
 eventValueBufferSizeBytes indicates the size of \p
 eventValueBuffer.  The buffer must be at least (sizeof(uint64) *
 number of events in group) if
 ::CUPTI_EVENT_GROUP_ATTR_PROFILE_ALL_DOMAIN_INSTANCES is not set on
 the group containing the events.  The buffer must be at least
 (sizeof(uint64) * number of domain instances * number of events in
 group) if ::CUPTI_EVENT_GROUP_ATTR_PROFILE_ALL_DOMAIN_INSTANCES is
 set on the group.

 The data format returned in \p eventValueBuffer is:
    - domain instance 0: event0 event1 ... eventN
    - domain instance 1: event0 event1 ... eventN
    - ...
    - domain instance M: event0 event1 ... eventN

 The event order in \p eventValueBuffer is returned in \p
 eventIdArray. The size of \p eventIdArray is specified in \p
 eventIdArraySizeBytes. The size should be at least
 (sizeof(CUpti_EventID) * number of events in group).

 If any instance of any event counter overflows, the value returned
 for that event instance will be ::CUPTI_EVENT_OVERFLOW.

 The only allowed value for \p flags is ::CUPTI_EVENT_READ_FLAG_NONE.

 Reading events from a disabled event group is not allowed. After
 being read, an event's value is reset to zero.
 \note \b Thread-safety: this function is thread safe but client
 must guard against simultaneous destruction or modification of \p
 eventGroup (for example, client must guard against simultaneous
 calls to \ref cuptiEventGroupDestroy, \ref cuptiEventGroupAddEvent,
 etc.), and must guard against simultaneous destruction of the
 context in which \p eventGroup was created (for example, client
 must guard against simultaneous calls to cudaDeviceReset,
 cuCtxDestroy, etc.). If \ref cuptiEventGroupResetAllEvents is
 called simultaneously with this function, then returned event
 values are undefined.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param eventGroup The event group
 \param flags Flags controlling the reading mode
 \param eventValueBufferSizeBytes The size of \p eventValueBuffer in
 bytes, and returns the number of bytes written to \p
 eventValueBuffer
 \param eventValueBuffer Returns the event values
 \param eventIdArraySizeBytes The size of \p eventIdArray in bytes,
 and returns the number of bytes written to \p eventIdArray
 \param eventIdArray Returns the IDs of the events in the same order
 as the values return in eventValueBuffer.
 \param numEventIdsRead Returns the number of event IDs returned
 in \p eventIdArray

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_HARDWARE
 \retval CUPTI_ERROR_INVALID_OPERATION if \p eventGroup is disabled
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p eventGroup, \p
 eventValueBufferSizeBytes, \p eventValueBuffer, \p
 eventIdArraySizeBytes, \p eventIdArray or \p numEventIdsRead is
 NULL
 \retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT if size of \p eventValueBuffer
 or \p eventIdArray is not sufficient*/
    pub fn cuptiEventGroupReadAllEvents(
        eventGroup: CUpti_EventGroup,
        flags: CUpti_ReadEventFlags,
        eventValueBufferSizeBytes: *mut usize,
        eventValueBuffer: *mut u64,
        eventIdArraySizeBytes: *mut usize,
        eventIdArray: *mut CUpti_EventID,
        numEventIdsRead: *mut usize,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief For a set of events, get the grouping that indicates the
 number of passes and the event groups necessary to collect the
 events.

 The number of events that can be collected simultaneously varies by
 device and by the type of the events. When events can be collected
 simultaneously, they may need to be grouped into multiple event
 groups because they are from different event domains. This function
 takes a set of events and determines how many passes are required
 to collect all those events, and which events can be collected
 simultaneously in each pass.

 The CUpti_EventGroupSets returned in \p eventGroupPasses indicates
 how many passes are required to collect the events with the \p
 numSets field. Within each event group set, the \p sets array
 indicates the event groups that should be collected on each pass.
 \note \b Thread-safety: this function is thread safe, but client
 must guard against another thread simultaneously destroying \p
 context.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param context The context for event collection
 \param eventIdArraySizeBytes Size of \p eventIdArray in bytes
 \param eventIdArray Array of event IDs that need to be grouped
 \param eventGroupPasses Returns a CUpti_EventGroupSets object that
 indicates the number of passes required to collect the events and
 the events to collect on each pass

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_CONTEXT
 \retval CUPTI_ERROR_INVALID_EVENT_ID
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p eventIdArray or
 \p eventGroupPasses is NULL*/
    pub fn cuptiEventGroupSetsCreate(
        context: CUcontext,
        eventIdArraySizeBytes: usize,
        eventIdArray: *mut CUpti_EventID,
        eventGroupPasses: *mut *mut CUpti_EventGroupSets,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Destroy a event group sets object.

 Destroy a CUpti_EventGroupSets object.
 \note \b Thread-safety: this function is thread safe.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param eventGroupSets The object to destroy

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_OPERATION if any of the event groups
 contained in the sets is enabled
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p eventGroupSets is NULL*/
    pub fn cuptiEventGroupSetsDestroy(
        eventGroupSets: *mut CUpti_EventGroupSets,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Enable an event group set.

 Enable a set of event groups. Enabling a set of event groups zeros the value of
 all the events in all the groups and then starts collection of those events.
 \note \b Thread-safety: this function is thread safe.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param eventGroupSet The pointer to the event group set

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_HARDWARE
 \retval CUPTI_ERROR_NOT_READY if \p eventGroup does not contain any events
 \retval CUPTI_ERROR_NOT_COMPATIBLE if \p eventGroup cannot be
 enabled due to other already enabled event groups
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p eventGroupSet is NULL
 \retval CUPTI_ERROR_HARDWARE_BUSY if other client is profiling and hardware is
 busy*/
    pub fn cuptiEventGroupSetEnable(
        eventGroupSet: *mut CUpti_EventGroupSet,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Disable an event group set.

 Disable a set of event groups. Disabling a set of event groups
 stops collection of events contained in the groups.
 \note \b Thread-safety: this function is thread safe.
 \note \b If this call fails, some of the event groups in the set may be disabled
 and other event groups may remain enabled.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param eventGroupSet The pointer to the event group set
 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_HARDWARE
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p eventGroupSet is NULL*/
    pub fn cuptiEventGroupSetDisable(
        eventGroupSet: *mut CUpti_EventGroupSet,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Enable kernel replay mode.

 Set profiling mode for the context to replay mode. In this mode,
 any number of events can be collected in one run of the kernel. The
 event collection mode will automatically switch to
 CUPTI_EVENT_COLLECTION_MODE_KERNEL.  In this mode, \ref
 cuptiSetEventCollectionMode will return
 CUPTI_ERROR_INVALID_OPERATION.
 \note \b Kernels might take longer to run if many events are enabled.
 \note \b Thread-safety: this function is thread safe.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param context The context
 \retval CUPTI_SUCCESS*/
    pub fn cuptiEnableKernelReplayMode(context: CUcontext) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Disable kernel replay mode.

 Set profiling mode for the context to non-replay (default)
 mode. Event collection mode will be set to
 CUPTI_EVENT_COLLECTION_MODE_KERNEL.  All previously enabled
 event groups and event group sets will be disabled.
 \note \b Thread-safety: this function is thread safe.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param context The context
 \retval CUPTI_SUCCESS*/
    pub fn cuptiDisableKernelReplayMode(context: CUcontext) -> CUptiResult;
}
/** \brief Function type for getting updates on kernel replay.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param kernelName The mangled kernel name
 \param numReplaysDone Number of replays done so far
 \param customData Pointer of any custom data passed in when subscribing*/
pub type CUpti_KernelReplayUpdateFunc = ::std::option::Option<
    unsafe extern "C" fn(
        kernelName: *const ::std::os::raw::c_char,
        numReplaysDone: ::std::os::raw::c_int,
        customData: *mut ::std::os::raw::c_void,
    ),
>;
unsafe extern "C" {
    /** \brief Subscribe to kernel replay updates.

 When subscribed, the function pointer passed in will be called each time a
 kernel run is finished during kernel replay. Previously subscribed function
 pointer will be replaced. Pass in NULL as the function pointer unsubscribes
 the update.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param updateFunc The update function pointer
 \param customData Pointer to any custom data
 \retval CUPTI_SUCCESS*/
    pub fn cuptiKernelReplaySubscribeUpdate(
        updateFunc: CUpti_KernelReplayUpdateFunc,
        customData: *mut ::std::os::raw::c_void,
    ) -> CUptiResult;
}
/** \brief ID for a metric.

 A metric provides a measure of some aspect of the device.*/
pub type CUpti_MetricID = u32;
/// A memory related metric.
pub const CUPTI_METRIC_CATEGORY_MEMORY: CUpti_MetricCategory = 0;
/// An instruction related metric.
pub const CUPTI_METRIC_CATEGORY_INSTRUCTION: CUpti_MetricCategory = 1;
/// A multiprocessor related metric.
pub const CUPTI_METRIC_CATEGORY_MULTIPROCESSOR: CUpti_MetricCategory = 2;
/// A cache related metric.
pub const CUPTI_METRIC_CATEGORY_CACHE: CUpti_MetricCategory = 3;
/// A texture related metric.
pub const CUPTI_METRIC_CATEGORY_TEXTURE: CUpti_MetricCategory = 4;
///A Nvlink related metric.
pub const CUPTI_METRIC_CATEGORY_NVLINK: CUpti_MetricCategory = 5;
///A PCIe related metric.
pub const CUPTI_METRIC_CATEGORY_PCIE: CUpti_MetricCategory = 6;
///A PCIe related metric.
pub const CUPTI_METRIC_CATEGORY_FORCE_INT: CUpti_MetricCategory = 2147483647;
/** \brief A metric category.

 Each metric is assigned to a category that represents the general
 type of the metric. A metric's category is accessed using \ref
 cuptiMetricGetAttribute and the CUPTI_METRIC_ATTR_CATEGORY
 attribute.*/
pub type CUpti_MetricCategory = ::std::os::raw::c_uint;
/** If this bit is set, the metric can be profiled for each instance of the
 domain. The event values passed to \ref cuptiMetricGetValue can contain
 values for one instance of the domain. And \ref cuptiMetricGetValue can
 be called for each instance.*/
pub const CUPTI_METRIC_EVALUATION_MODE_PER_INSTANCE: CUpti_MetricEvaluationMode = 1;
/** If this bit is set, the metric can be profiled over all instances. The
 event values passed to \ref cuptiMetricGetValue can be aggregated values
 of events for all instances of the domain.*/
pub const CUPTI_METRIC_EVALUATION_MODE_AGGREGATE: CUpti_MetricEvaluationMode = 2;
/** If this bit is set, the metric can be profiled over all instances. The
 event values passed to \ref cuptiMetricGetValue can be aggregated values
 of events for all instances of the domain.*/
pub const CUPTI_METRIC_EVALUATION_MODE_FORCE_INT: CUpti_MetricEvaluationMode = 2147483647;
/** \brief A metric evaluation mode.

 A metric can be evaluated per hardware instance to know the load balancing
 across instances of a domain or the metric can be evaluated in aggregate mode
 when the events involved in metric evaluation are from different event
 domains. It might be possible to evaluate some metrics in both
 modes for convenience. A metric's evaluation mode is accessed using \ref
 CUpti_MetricEvaluationMode and the CUPTI_METRIC_ATTR_EVALUATION_MODE
 attribute.*/
pub type CUpti_MetricEvaluationMode = ::std::os::raw::c_uint;
/// The metric value is a 64-bit double.
pub const CUPTI_METRIC_VALUE_KIND_DOUBLE: CUpti_MetricValueKind = 0;
/// The metric value is a 64-bit unsigned integer.
pub const CUPTI_METRIC_VALUE_KIND_UINT64: CUpti_MetricValueKind = 1;
/** The metric value is a percentage represented by a 64-bit
 double. For example, 57.5% is represented by the value 57.5.*/
pub const CUPTI_METRIC_VALUE_KIND_PERCENT: CUpti_MetricValueKind = 2;
/** The metric value is a throughput represented by a 64-bit
 integer. The unit for throughput values is bytes/second.*/
pub const CUPTI_METRIC_VALUE_KIND_THROUGHPUT: CUpti_MetricValueKind = 3;
/// The metric value is a 64-bit signed integer.
pub const CUPTI_METRIC_VALUE_KIND_INT64: CUpti_MetricValueKind = 4;
/** The metric value is a utilization level, as represented by
 CUpti_MetricValueUtilizationLevel.*/
pub const CUPTI_METRIC_VALUE_KIND_UTILIZATION_LEVEL: CUpti_MetricValueKind = 5;
/** The metric value is a pointer to a NVTX extended payload.
 nvtxPayloadData_t is the structure that contains the payload data.*/
pub const CUPTI_METRIC_VALUE_KIND_NVTX_EXTENDED_PAYLOAD: CUpti_MetricValueKind = 6;
/** The metric value is a pointer to a NVTX extended payload.
 nvtxPayloadData_t is the structure that contains the payload data.*/
pub const CUPTI_METRIC_VALUE_KIND_FORCE_INT: CUpti_MetricValueKind = 2147483647;
/** \brief Kinds of metric values.

 Metric values can be one of several different kinds. Corresponding
 to each kind is a member of the CUpti_MetricValue union. The metric
 value returned by \ref cuptiMetricGetValue should be accessed using
 the appropriate member of that union based on its value kind.*/
pub type CUpti_MetricValueKind = ::std::os::raw::c_uint;
pub const CUPTI_METRIC_VALUE_UTILIZATION_IDLE: CUpti_MetricValueUtilizationLevel = 0;
pub const CUPTI_METRIC_VALUE_UTILIZATION_LOW: CUpti_MetricValueUtilizationLevel = 2;
pub const CUPTI_METRIC_VALUE_UTILIZATION_MID: CUpti_MetricValueUtilizationLevel = 5;
pub const CUPTI_METRIC_VALUE_UTILIZATION_HIGH: CUpti_MetricValueUtilizationLevel = 8;
pub const CUPTI_METRIC_VALUE_UTILIZATION_MAX: CUpti_MetricValueUtilizationLevel = 10;
pub const CUPTI_METRIC_VALUE_UTILIZATION_FORCE_INT: CUpti_MetricValueUtilizationLevel = 2147483647;
/** \brief Enumeration of utilization levels for metrics values of kind
 CUPTI_METRIC_VALUE_KIND_UTILIZATION_LEVEL. Utilization values can
 vary from IDLE (0) to MAX (10) but the enumeration only provides
 specific names for a few values.*/
pub type CUpti_MetricValueUtilizationLevel = ::std::os::raw::c_uint;
/// Metric name. Value is a null terminated const c-string.
pub const CUPTI_METRIC_ATTR_NAME: CUpti_MetricAttribute = 0;
/// Short description of metric. Value is a null terminated const c-string.
pub const CUPTI_METRIC_ATTR_SHORT_DESCRIPTION: CUpti_MetricAttribute = 1;
/// Long description of metric. Value is a null terminated const c-string.
pub const CUPTI_METRIC_ATTR_LONG_DESCRIPTION: CUpti_MetricAttribute = 2;
/// Category of the metric. Value is of type CUpti_MetricCategory.
pub const CUPTI_METRIC_ATTR_CATEGORY: CUpti_MetricAttribute = 3;
/// Value type of the metric. Value is of type CUpti_MetricValueKind.
pub const CUPTI_METRIC_ATTR_VALUE_KIND: CUpti_MetricAttribute = 4;
/// Metric evaluation mode. Value is of type CUpti_MetricEvaluationMode.
pub const CUPTI_METRIC_ATTR_EVALUATION_MODE: CUpti_MetricAttribute = 5;
/// Metric evaluation mode. Value is of type CUpti_MetricEvaluationMode.
pub const CUPTI_METRIC_ATTR_FORCE_INT: CUpti_MetricAttribute = 2147483647;
/** \brief Metric attributes.

 Metric attributes describe properties of a metric. These attributes
 can be read using \ref cuptiMetricGetAttribute.*/
pub type CUpti_MetricAttribute = ::std::os::raw::c_uint;
/** \brief A metric value.

 Metric values can be one of several different kinds. Corresponding
 to each kind is a member of the CUpti_MetricValue union. The metric
 value returned by \ref cuptiMetricGetValue should be accessed using
 the appropriate member of that union based on its value kind.*/
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_MetricValue {
    pub metricValueDouble: f64,
    pub metricValueUint64: u64,
    pub metricValueInt64: i64,
    pub metricValuePercent: f64,
    pub metricValueThroughput: u64,
    pub metricValueUtilizationLevel: CUpti_MetricValueUtilizationLevel,
    /// Value for CUPTI_METRIC_VALUE_KIND_NVTX_EXTENDED_PAYLOAD.
    pub metricValueNvtxExtendedPayload: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_MetricValue"][::std::mem::size_of::<CUpti_MetricValue>() - 8usize];
    [
        "Alignment of CUpti_MetricValue",
    ][::std::mem::align_of::<CUpti_MetricValue>() - 8usize];
    [
        "Offset of field: CUpti_MetricValue::metricValueDouble",
    ][::std::mem::offset_of!(CUpti_MetricValue, metricValueDouble) - 0usize];
    [
        "Offset of field: CUpti_MetricValue::metricValueUint64",
    ][::std::mem::offset_of!(CUpti_MetricValue, metricValueUint64) - 0usize];
    [
        "Offset of field: CUpti_MetricValue::metricValueInt64",
    ][::std::mem::offset_of!(CUpti_MetricValue, metricValueInt64) - 0usize];
    [
        "Offset of field: CUpti_MetricValue::metricValuePercent",
    ][::std::mem::offset_of!(CUpti_MetricValue, metricValuePercent) - 0usize];
    [
        "Offset of field: CUpti_MetricValue::metricValueThroughput",
    ][::std::mem::offset_of!(CUpti_MetricValue, metricValueThroughput) - 0usize];
    [
        "Offset of field: CUpti_MetricValue::metricValueUtilizationLevel",
    ][::std::mem::offset_of!(CUpti_MetricValue, metricValueUtilizationLevel) - 0usize];
    [
        "Offset of field: CUpti_MetricValue::metricValueNvtxExtendedPayload",
    ][::std::mem::offset_of!(CUpti_MetricValue, metricValueNvtxExtendedPayload)
        - 0usize];
};
impl Default for CUpti_MetricValue {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_MetricValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_MetricValue {{ union }}")
    }
}
pub const CUPTI_METRIC_PROPERTY_DEVICE_CLASS_TESLA: CUpti_MetricPropertyDeviceClass = 0;
pub const CUPTI_METRIC_PROPERTY_DEVICE_CLASS_QUADRO: CUpti_MetricPropertyDeviceClass = 1;
pub const CUPTI_METRIC_PROPERTY_DEVICE_CLASS_GEFORCE: CUpti_MetricPropertyDeviceClass = 2;
pub const CUPTI_METRIC_PROPERTY_DEVICE_CLASS_TEGRA: CUpti_MetricPropertyDeviceClass = 3;
/** \brief Device class.

 Enumeration of device classes for metric property
 CUPTI_METRIC_PROPERTY_DEVICE_CLASS.*/
pub type CUpti_MetricPropertyDeviceClass = ::std::os::raw::c_uint;
pub const CUPTI_METRIC_PROPERTY_MULTIPROCESSOR_COUNT: CUpti_MetricPropertyID = 0;
pub const CUPTI_METRIC_PROPERTY_WARPS_PER_MULTIPROCESSOR: CUpti_MetricPropertyID = 1;
pub const CUPTI_METRIC_PROPERTY_KERNEL_GPU_TIME: CUpti_MetricPropertyID = 2;
pub const CUPTI_METRIC_PROPERTY_CLOCK_RATE: CUpti_MetricPropertyID = 3;
pub const CUPTI_METRIC_PROPERTY_FRAME_BUFFER_COUNT: CUpti_MetricPropertyID = 4;
pub const CUPTI_METRIC_PROPERTY_GLOBAL_MEMORY_BANDWIDTH: CUpti_MetricPropertyID = 5;
pub const CUPTI_METRIC_PROPERTY_PCIE_LINK_RATE: CUpti_MetricPropertyID = 6;
pub const CUPTI_METRIC_PROPERTY_PCIE_LINK_WIDTH: CUpti_MetricPropertyID = 7;
pub const CUPTI_METRIC_PROPERTY_PCIE_GEN: CUpti_MetricPropertyID = 8;
pub const CUPTI_METRIC_PROPERTY_DEVICE_CLASS: CUpti_MetricPropertyID = 9;
pub const CUPTI_METRIC_PROPERTY_FLOP_SP_PER_CYCLE: CUpti_MetricPropertyID = 10;
pub const CUPTI_METRIC_PROPERTY_FLOP_DP_PER_CYCLE: CUpti_MetricPropertyID = 11;
pub const CUPTI_METRIC_PROPERTY_L2_UNITS: CUpti_MetricPropertyID = 12;
pub const CUPTI_METRIC_PROPERTY_ECC_ENABLED: CUpti_MetricPropertyID = 13;
pub const CUPTI_METRIC_PROPERTY_FLOP_HP_PER_CYCLE: CUpti_MetricPropertyID = 14;
pub const CUPTI_METRIC_PROPERTY_GPU_CPU_NVLINK_BANDWIDTH: CUpti_MetricPropertyID = 15;
/** \brief Metric device properties.

 Metric device properties describe device properties which are needed for a metric.
 Some of these properties can be collected using cuDeviceGetAttribute.*/
pub type CUpti_MetricPropertyID = ::std::os::raw::c_uint;
unsafe extern "C" {
    /** \brief Get the total number of metrics available on any device.

 Returns the total number of metrics available on any CUDA-capable
 devices.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param numMetrics Returns the number of metrics

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p numMetrics is NULL*/
    pub fn cuptiGetNumMetrics(numMetrics: *mut u32) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get all the metrics available on any device.

 Returns the metric IDs in \p metricArray for all CUDA-capable
 devices.  The size of the \p metricArray buffer is given by \p
 *arraySizeBytes. The size of the \p metricArray buffer must be at
 least \p numMetrics * sizeof(CUpti_MetricID) or all metric IDs will
 not be returned. The value returned in \p *arraySizeBytes contains
 the number of bytes returned in \p metricArray.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param arraySizeBytes The size of \p metricArray in bytes, and
 returns the number of bytes written to \p metricArray
 \param metricArray Returns the IDs of the metrics

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p arraySizeBytes or
 \p metricArray are NULL*/
    pub fn cuptiEnumMetrics(
        arraySizeBytes: *mut usize,
        metricArray: *mut CUpti_MetricID,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get the number of metrics for a device.

 Returns the number of metrics available for a device.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param device The CUDA device
 \param numMetrics Returns the number of metrics available for the
 device

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_DEVICE
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p numMetrics is NULL*/
    pub fn cuptiDeviceGetNumMetrics(
        device: CUdevice,
        numMetrics: *mut u32,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get the metrics for a device.

 Returns the metric IDs in \p metricArray for a device.  The size of
 the \p metricArray buffer is given by \p *arraySizeBytes. The size
 of the \p metricArray buffer must be at least \p numMetrics *
 sizeof(CUpti_MetricID) or else all metric IDs will not be
 returned. The value returned in \p *arraySizeBytes contains the
 number of bytes returned in \p metricArray.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param device The CUDA device
 \param arraySizeBytes The size of \p metricArray in bytes, and
 returns the number of bytes written to \p metricArray
 \param metricArray Returns the IDs of the metrics for the device

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_DEVICE
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p arraySizeBytes or
 \p metricArray are NULL*/
    pub fn cuptiDeviceEnumMetrics(
        device: CUdevice,
        arraySizeBytes: *mut usize,
        metricArray: *mut CUpti_MetricID,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get a metric attribute.

 Returns a metric attribute in \p *value. The size of the \p
 value buffer is given by \p *valueSize. The value returned in \p
 *valueSize contains the number of bytes returned in \p value.

 If the attribute value is a c-string that is longer than \p
 *valueSize, then only the first \p *valueSize characters will be
 returned and there will be no terminating null byte.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param metric ID of the metric
 \param attrib The metric attribute to read
 \param valueSize The size of the \p value buffer in bytes, and
 returns the number of bytes written to \p value
 \param value Returns the attribute's value

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_METRIC_ID
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p valueSize or \p value
 is NULL, or if \p attrib is not a metric attribute
 \retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT For non-c-string
 attribute values, indicates that the \p value buffer is too small
 to hold the attribute value.*/
    pub fn cuptiMetricGetAttribute(
        metric: CUpti_MetricID,
        attrib: CUpti_MetricAttribute,
        valueSize: *mut usize,
        value: *mut ::std::os::raw::c_void,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Find an metric by name.

 Find a metric by name and return the metric ID in \p *metric.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param device The CUDA device
 \param metricName The name of metric to find
 \param metric Returns the ID of the found metric or undefined if
 unable to find the metric

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_DEVICE
 \retval CUPTI_ERROR_INVALID_METRIC_NAME if unable to find a metric
 with name \p metricName. In this case \p *metric is undefined
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p metricName or \p
 metric are NULL.*/
    pub fn cuptiMetricGetIdFromName(
        device: CUdevice,
        metricName: *const ::std::os::raw::c_char,
        metric: *mut CUpti_MetricID,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get number of events required to calculate a metric.

 Returns the number of events in \p numEvents that are required to
 calculate a metric.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param metric ID of the metric
 \param numEvents Returns the number of events required for the metric

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_METRIC_ID
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p numEvents is NULL*/
    pub fn cuptiMetricGetNumEvents(
        metric: CUpti_MetricID,
        numEvents: *mut u32,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get the events required to calculating a metric.

 Gets the event IDs in \p eventIdArray required to calculate a \p
 metric. The size of the \p eventIdArray buffer is given by \p
 *eventIdArraySizeBytes and must be at least \p numEvents *
 sizeof(CUpti_EventID) or all events will not be returned. The value
 returned in \p *eventIdArraySizeBytes contains the number of bytes
 returned in \p eventIdArray.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param metric ID of the metric
 \param eventIdArraySizeBytes The size of \p eventIdArray in bytes,
 and returns the number of bytes written to \p eventIdArray
 \param eventIdArray Returns the IDs of the events required to
 calculate \p metric

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_METRIC_ID
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p eventIdArraySizeBytes or \p
 eventIdArray are NULL.*/
    pub fn cuptiMetricEnumEvents(
        metric: CUpti_MetricID,
        eventIdArraySizeBytes: *mut usize,
        eventIdArray: *mut CUpti_EventID,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get number of properties required to calculate a metric.

 Returns the number of properties in \p numProp that are required to
 calculate a metric.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param metric ID of the metric
 \param numProp Returns the number of properties required for the
 metric

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_METRIC_ID
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p numProp is NULL*/
    pub fn cuptiMetricGetNumProperties(
        metric: CUpti_MetricID,
        numProp: *mut u32,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get the properties required to calculating a metric.

 Gets the property IDs in \p propIdArray required to calculate a \p
 metric. The size of the \p propIdArray buffer is given by \p
 *propIdArraySizeBytes and must be at least \p numProp *
 sizeof(CUpti_DeviceAttribute) or all properties will not be
 returned. The value returned in \p *propIdArraySizeBytes contains
 the number of bytes returned in \p propIdArray.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param metric ID of the metric
 \param propIdArraySizeBytes The size of \p propIdArray in bytes,
 and returns the number of bytes written to \p propIdArray
 \param propIdArray Returns the IDs of the properties required to
 calculate \p metric

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_METRIC_ID
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p propIdArraySizeBytes or \p
 propIdArray are NULL.*/
    pub fn cuptiMetricEnumProperties(
        metric: CUpti_MetricID,
        propIdArraySizeBytes: *mut usize,
        propIdArray: *mut CUpti_MetricPropertyID,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief For a metric get the groups of events that must be collected
 in the same pass.

 For a metric get the groups of events that must be collected in the
 same pass to ensure that the metric is calculated correctly. If the
 events are not collected as specified then the metric value may be
 inaccurate.

 The function returns NULL if a metric does not have any required
 event group. In this case the events needed for the metric can be
 grouped in any manner for collection.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param context The context for event collection
 \param metric The metric ID
 \param eventGroupSets Returns a CUpti_EventGroupSets object that
 indicates the events that must be collected in the same pass to
 ensure the metric is calculated correctly.  Returns NULL if no
 grouping is required for metric
 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_METRIC_ID*/
    pub fn cuptiMetricGetRequiredEventGroupSets(
        context: CUcontext,
        metric: CUpti_MetricID,
        eventGroupSets: *mut *mut CUpti_EventGroupSets,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief For a set of metrics, get the grouping that indicates the
 number of passes and the event groups necessary to collect the
 events required for those metrics.

 For a set of metrics, get the grouping that indicates the number of
 passes and the event groups necessary to collect the events
 required for those metrics.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \see cuptiEventGroupSetsCreate for details on event group set
 creation.

 \param context The context for event collection
 \param metricIdArraySizeBytes Size of the metricIdArray in bytes
 \param metricIdArray Array of metric IDs
 \param eventGroupPasses Returns a CUpti_EventGroupSets object that
 indicates the number of passes required to collect the events and
 the events to collect on each pass

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_CONTEXT
 \retval CUPTI_ERROR_INVALID_METRIC_ID
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p metricIdArray or
 \p eventGroupPasses is NULL*/
    pub fn cuptiMetricCreateEventGroupSets(
        context: CUcontext,
        metricIdArraySizeBytes: usize,
        metricIdArray: *mut CUpti_MetricID,
        eventGroupPasses: *mut *mut CUpti_EventGroupSets,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Calculate the value for a metric.

 Use the events collected for a metric to calculate the metric
 value. Metric value evaluation depends on the evaluation mode
 \ref CUpti_MetricEvaluationMode that the metric supports.
 If a metric has evaluation mode as CUPTI_METRIC_EVALUATION_MODE_PER_INSTANCE,
 then it assumes that the input event value is for one domain instance.
 If a metric has evaluation mode as CUPTI_METRIC_EVALUATION_MODE_AGGREGATE,
 it assumes that input event values are
 normalized to represent all domain instances on a device. For the
 most accurate metric collection, the events required for the metric
 should be collected for all profiled domain instances. For example,
 to collect all instances of an event, set the
 CUPTI_EVENT_GROUP_ATTR_PROFILE_ALL_DOMAIN_INSTANCES attribute on
 the group containing the event to 1. The normalized value for the
 event is then: (\p sum_event_values * \p totalInstanceCount) / \p
 instanceCount, where \p sum_event_values is the summation of the
 event values across all profiled domain instances, \p
 totalInstanceCount is obtained from querying
 CUPTI_EVENT_DOMAIN_ATTR_TOTAL_INSTANCE_COUNT and \p instanceCount
 is obtained from querying CUPTI_EVENT_GROUP_ATTR_INSTANCE_COUNT (or
 CUPTI_EVENT_DOMAIN_ATTR_INSTANCE_COUNT).

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param device The CUDA device that the metric is being calculated for
 \param metric The metric ID
 \param eventIdArraySizeBytes The size of \p eventIdArray in bytes
 \param eventIdArray The event IDs required to calculate \p metric
 \param eventValueArraySizeBytes The size of \p eventValueArray in bytes
 \param eventValueArray The normalized event values required to
 calculate \p metric. The values must be order to match the order of
 events in \p eventIdArray
 \param timeDuration The duration over which the events were
 collected, in ns
 \param metricValue Returns the value for the metric

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_METRIC_ID
 \retval CUPTI_ERROR_INVALID_OPERATION
 \retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT if the
 eventIdArray does not contain all the events needed for metric
 \retval CUPTI_ERROR_INVALID_EVENT_VALUE if any of the
 event values required for the metric is CUPTI_EVENT_OVERFLOW
 \retval CUPTI_ERROR_INVALID_METRIC_VALUE if the computed metric value
 cannot be represented in the metric's value type. For example,
 if the metric value type is unsigned and the computed metric value is negative
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p metricValue,
 \p eventIdArray or \p eventValueArray is NULL*/
    pub fn cuptiMetricGetValue(
        device: CUdevice,
        metric: CUpti_MetricID,
        eventIdArraySizeBytes: usize,
        eventIdArray: *mut CUpti_EventID,
        eventValueArraySizeBytes: usize,
        eventValueArray: *mut u64,
        timeDuration: u64,
        metricValue: *mut CUpti_MetricValue,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Calculate the value for a metric.

 Use the events and properties collected for a metric to calculate
 the metric value. Metric value evaluation depends on the evaluation
 mode \ref CUpti_MetricEvaluationMode that the metric supports.  If
 a metric has evaluation mode as
 CUPTI_METRIC_EVALUATION_MODE_PER_INSTANCE, then it assumes that the
 input event value is for one domain instance.  If a metric has
 evaluation mode as CUPTI_METRIC_EVALUATION_MODE_AGGREGATE, it
 assumes that input event values are normalized to represent all
 domain instances on a device. For the most accurate metric
 collection, the events required for the metric should be collected
 for all profiled domain instances. For example, to collect all
 instances of an event, set the
 CUPTI_EVENT_GROUP_ATTR_PROFILE_ALL_DOMAIN_INSTANCES attribute on
 the group containing the event to 1. The normalized value for the
 event is then: (\p sum_event_values * \p totalInstanceCount) / \p
 instanceCount, where \p sum_event_values is the summation of the
 event values across all profiled domain instances, \p
 totalInstanceCount is obtained from querying
 CUPTI_EVENT_DOMAIN_ATTR_TOTAL_INSTANCE_COUNT and \p instanceCount
 is obtained from querying CUPTI_EVENT_GROUP_ATTR_INSTANCE_COUNT (or
 CUPTI_EVENT_DOMAIN_ATTR_INSTANCE_COUNT).

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param metric The metric ID
 \param eventIdArraySizeBytes The size of \p eventIdArray in bytes
 \param eventIdArray The event IDs required to calculate \p metric
 \param eventValueArraySizeBytes The size of \p eventValueArray in bytes
 \param eventValueArray The normalized event values required to
 calculate \p metric. The values must be order to match the order of
 events in \p eventIdArray
 \param propIdArraySizeBytes The size of \p propIdArray in bytes
 \param propIdArray The metric property IDs required to calculate \p metric
 \param propValueArraySizeBytes The size of \p propValueArray in bytes
 \param propValueArray The metric property values required to
 calculate \p metric. The values must be order to match the order of
 metric properties in \p propIdArray
 \param metricValue Returns the value for the metric

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_METRIC_ID
 \retval CUPTI_ERROR_INVALID_OPERATION
 \retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT if the
 eventIdArray does not contain all the events needed for metric
 \retval CUPTI_ERROR_INVALID_EVENT_VALUE if any of the
 event values required for the metric is CUPTI_EVENT_OVERFLOW
 \retval CUPTI_ERROR_NOT_COMPATIBLE if the computed metric value
 cannot be represented in the metric's value type. For example,
 if the metric value type is unsigned and the computed metric value is negative
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p metricValue,
 \p eventIdArray or \p eventValueArray is NULL*/
    pub fn cuptiMetricGetValue2(
        metric: CUpti_MetricID,
        eventIdArraySizeBytes: usize,
        eventIdArray: *mut CUpti_EventID,
        eventValueArraySizeBytes: usize,
        eventValueArray: *mut u64,
        propIdArraySizeBytes: usize,
        propIdArray: *mut CUpti_MetricPropertyID,
        propValueArraySizeBytes: usize,
        propValueArray: *mut u64,
        metricValue: *mut CUpti_MetricValue,
    ) -> CUptiResult;
}
/// The activity record is invalid.
pub const CUPTI_ACTIVITY_KIND_INVALID: CUpti_ActivityKind = 0;
/** A host<->host, host<->device, or device<->device memory copy.
 For peer to peer memory copy, use the kind CUPTI_ACTIVITY_KIND_MEMCPY2.
 The corresponding activity record structure is \ref
 CUpti_ActivityMemcpy6.*/
pub const CUPTI_ACTIVITY_KIND_MEMCPY: CUpti_ActivityKind = 1;
/** A memory set executing on the GPU. The corresponding activity
 record structure is \ref CUpti_ActivityMemset4.*/
pub const CUPTI_ACTIVITY_KIND_MEMSET: CUpti_ActivityKind = 2;
/** A kernel executing on the GPU. This activity kind may significantly change
 the overall performance characteristics of the application because all
 kernel executions are serialized on the GPU. Other activity kind for kernel
 CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL doesn't break kernel concurrency.
 The corresponding activity record structure is \ref CUpti_ActivityKernel10.*/
pub const CUPTI_ACTIVITY_KIND_KERNEL: CUpti_ActivityKind = 3;
/** A CUDA driver API function execution. The corresponding activity
 record structure is \ref CUpti_ActivityAPI.*/
pub const CUPTI_ACTIVITY_KIND_DRIVER: CUpti_ActivityKind = 4;
/** A CUDA runtime API function execution. The corresponding activity
 record structure is \ref CUpti_ActivityAPI.*/
pub const CUPTI_ACTIVITY_KIND_RUNTIME: CUpti_ActivityKind = 5;
/** A performance counter (aka event) value. The corresponding activity record
 structure is \ref CUpti_ActivityEvent. This activity cannot be directly
 enabled or disabled. Information collected using the Event API.
 can be stored in the corresponding activity record.
 Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.*/
pub const CUPTI_ACTIVITY_KIND_EVENT: CUpti_ActivityKind = 6;
/** A performance metric value. The corresponding activity record structure is
 \ref CUpti_ActivityMetric. This activity cannot be directly
 enabled or disabled. Information collected using the Metric API.
 can be stored in the corresponding activity record.
 Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.*/
pub const CUPTI_ACTIVITY_KIND_METRIC: CUpti_ActivityKind = 7;
/** Information about a CUDA device. The corresponding activity record
 structure is \ref CUpti_ActivityDevice5.*/
pub const CUPTI_ACTIVITY_KIND_DEVICE: CUpti_ActivityKind = 8;
/** Information about a CUDA context. The corresponding activity record
 structure is \ref CUpti_ActivityContext3.*/
pub const CUPTI_ACTIVITY_KIND_CONTEXT: CUpti_ActivityKind = 9;
/** A kernel executing on the GPU. This activity kind doesn't break
 kernel concurrency. The corresponding activity record structure
 is \ref CUpti_ActivityKernel10.*/
pub const CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL: CUpti_ActivityKind = 10;
/** Resource naming done via NVTX APIs for thread, device, context, etc.
 The corresponding activity record structure is \ref CUpti_ActivityName.*/
pub const CUPTI_ACTIVITY_KIND_NAME: CUpti_ActivityKind = 11;
/** Instantaneous, start, or end NVTX marker. The corresponding activity
 record structure is \ref CUpti_ActivityMarker2.*/
pub const CUPTI_ACTIVITY_KIND_MARKER: CUpti_ActivityKind = 12;
/** Extended, optional, data about a NVTX marker. User must enable
 CUPTI_ACTIVITY_KIND_MARKER as well to get records for marker data.
 The corresponding activity record structure is \ref CUpti_ActivityMarkerData2.*/
pub const CUPTI_ACTIVITY_KIND_MARKER_DATA: CUpti_ActivityKind = 13;
/** Source information about source level result. The corresponding
 activity record structure is \ref CUpti_ActivitySourceLocator.
 Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.
 Enabling it will return the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.
 Instead, use the SASS Metric APIs from the cupti_sass_metrics.h header.*/
pub const CUPTI_ACTIVITY_KIND_SOURCE_LOCATOR: CUpti_ActivityKind = 14;
/** Results for source-level global access. The
 corresponding activity record structure is \ref
 CUpti_ActivityGlobalAccess3.
 Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.
 Enabling it will return the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.
 Instead, use the SASS Metric APIs from the cupti_sass_metrics.h header.*/
pub const CUPTI_ACTIVITY_KIND_GLOBAL_ACCESS: CUpti_ActivityKind = 15;
/** Results for source-level branch. The corresponding
 activity record structure is \ref CUpti_ActivityBranch2.
 Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.
 Enabling it will return the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.
 Instead, use the SASS Metric APIs from the cupti_sass_metrics.h header.*/
pub const CUPTI_ACTIVITY_KIND_BRANCH: CUpti_ActivityKind = 16;
/** Overhead added by CUPTI, Compiler, CUDA driver etc. The
 corresponding activity record structure is
 \ref CUpti_ActivityOverhead3.*/
pub const CUPTI_ACTIVITY_KIND_OVERHEAD: CUpti_ActivityKind = 17;
/** A CDP (CUDA Dynamic Parallel) kernel executing on the GPU. The
 corresponding activity record structure is \ref
 CUpti_ActivityCdpKernel. This activity cannot be directly
 enabled or disabled. It is enabled and disabled through
 concurrent kernel activity i.e. _CONCURRENT_KERNEL.*/
pub const CUPTI_ACTIVITY_KIND_CDP_KERNEL: CUpti_ActivityKind = 18;
/** Preemption activity record indicating a preemption of a CDP (CUDA
 Dynamic Parallel) kernel executing on the GPU. The corresponding
 activity record structure is \ref CUpti_ActivityPreemption.*/
pub const CUPTI_ACTIVITY_KIND_PREEMPTION: CUpti_ActivityKind = 19;
/** Environment activity records indicating power, clock, thermal,
 etc. levels of the GPU. The corresponding activity record
 structure is \ref CUpti_ActivityEnvironment.*/
pub const CUPTI_ACTIVITY_KIND_ENVIRONMENT: CUpti_ActivityKind = 20;
/** An performance counter value associated with a specific event domain
 instance. The corresponding activity record structure is \ref
 CUpti_ActivityEventInstance. This activity cannot be directly
 enabled or disabled. Information collected using the Event API.
 can be stored in the corresponding activity record.
 Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.*/
pub const CUPTI_ACTIVITY_KIND_EVENT_INSTANCE: CUpti_ActivityKind = 21;
/** A peer to peer memory copy. The corresponding activity record
 structure is \ref CUpti_ActivityMemcpyPtoP4.*/
pub const CUPTI_ACTIVITY_KIND_MEMCPY2: CUpti_ActivityKind = 22;
/** A performance metric value associated with a specific metric domain
 instance. The corresponding activity record structure is \ref
 CUpti_ActivityMetricInstance. This activity cannot be directly
 enabled or disabled. Information collected using the Metric API.
 can be stored in the corresponding activity record.
 Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.*/
pub const CUPTI_ACTIVITY_KIND_METRIC_INSTANCE: CUpti_ActivityKind = 23;
/** Results for source-level instruction execution.
 The corresponding activity record structure is \ref
 CUpti_ActivityInstructionExecution.
 Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.
 Enabling it will return the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.
 Instead, use the SASS Metric APIs from the cupti_sass_metrics.h header.*/
pub const CUPTI_ACTIVITY_KIND_INSTRUCTION_EXECUTION: CUpti_ActivityKind = 24;
/** Unified Memory counter record. The corresponding activity
 record structure is \ref CUpti_ActivityUnifiedMemoryCounter3.*/
pub const CUPTI_ACTIVITY_KIND_UNIFIED_MEMORY_COUNTER: CUpti_ActivityKind = 25;
/** Device global/function record. The corresponding activity
 record structure is \ref CUpti_ActivityFunction.*/
pub const CUPTI_ACTIVITY_KIND_FUNCTION: CUpti_ActivityKind = 26;
/** CUDA Module record. The corresponding activity
 record structure is \ref CUpti_ActivityModule.
 This activity cannot be directly enabled or disabled.
 Information collected using the module callback can be
 be stored in the corresponding activity record.*/
pub const CUPTI_ACTIVITY_KIND_MODULE: CUpti_ActivityKind = 27;
/** A device attribute value. The corresponding activity record
 structure is \ref CUpti_ActivityDeviceAttribute.
 This activity cannot be directly enabled or disabled.
 Information collected using attributes CUpti_DeviceAttribute
 or CUdevice_attribute can be stored in the corresponding activity record.*/
pub const CUPTI_ACTIVITY_KIND_DEVICE_ATTRIBUTE: CUpti_ActivityKind = 28;
/** Results for source-level shared access. The
 corresponding activity record structure is \ref
 CUpti_ActivitySharedAccess.
 Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.
 Enabling it will return the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.
 Instead, use the SASS Metric APIs from the cupti_sass_metrics.h header.*/
pub const CUPTI_ACTIVITY_KIND_SHARED_ACCESS: CUpti_ActivityKind = 29;
/** PC sampling information for kernels. This will serialize
 kernels. The corresponding activity record structure
 is \ref CUpti_ActivityPCSampling3.
 Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.
 Enabling it will return the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.
 Instead, use the PC Sampling API from the cupti_pcsampling.h header, which
 allows concurrent kernel execution.*/
pub const CUPTI_ACTIVITY_KIND_PC_SAMPLING: CUpti_ActivityKind = 30;
/** Summary information about PC sampling records. The
 corresponding activity record structure is \ref
 CUpti_ActivityPCSamplingRecordInfo.
 Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.
 Enabling it will return the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.
 Instead, use the PC Sampling API from the cupti_pcsampling.h header.*/
pub const CUPTI_ACTIVITY_KIND_PC_SAMPLING_RECORD_INFO: CUpti_ActivityKind = 31;
/** SASS/Source line-by-line correlation record.
 This will generate sass/source correlation for functions that have source
 level analysis or pc sampling results. The records will be generated only
 when either of source level analysis or pc sampling activity is enabled.
 The corresponding activity record structure is \ref
 CUpti_ActivityInstructionCorrelation.
 Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.
 Enabling it will return the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.
 Instead, use the SASS Metric APIs from the cupti_sass_metrics.h header.*/
pub const CUPTI_ACTIVITY_KIND_INSTRUCTION_CORRELATION: CUpti_ActivityKind = 32;
/** OpenACC data events.
 The corresponding activity record structure is \ref
 CUpti_ActivityOpenAccData.*/
pub const CUPTI_ACTIVITY_KIND_OPENACC_DATA: CUpti_ActivityKind = 33;
/** OpenACC launch events.
 The corresponding activity record structure is \ref
 CUpti_ActivityOpenAccLaunch.*/
pub const CUPTI_ACTIVITY_KIND_OPENACC_LAUNCH: CUpti_ActivityKind = 34;
/** OpenACC other events.
 The corresponding activity record structure is \ref
 CUpti_ActivityOpenAccOther.*/
pub const CUPTI_ACTIVITY_KIND_OPENACC_OTHER: CUpti_ActivityKind = 35;
/** Information about a CUDA event (cudaEvent).
 The corresponding activity record structure is \ref
 CUpti_ActivityCudaEvent2.*/
pub const CUPTI_ACTIVITY_KIND_CUDA_EVENT: CUpti_ActivityKind = 36;
/** Information about a CUDA stream. The
 corresponding activity record structure is \ref
 CUpti_ActivityStream.*/
pub const CUPTI_ACTIVITY_KIND_STREAM: CUpti_ActivityKind = 37;
/** Records for CUDA synchronization primitives. The
 corresponding activity record structure is \ref
 CUpti_ActivitySynchronization2.*/
pub const CUPTI_ACTIVITY_KIND_SYNCHRONIZATION: CUpti_ActivityKind = 38;
/** Records for correlation of different programming APIs. The
 corresponding activity record structure is \ref
 CUpti_ActivityExternalCorrelation.*/
pub const CUPTI_ACTIVITY_KIND_EXTERNAL_CORRELATION: CUpti_ActivityKind = 39;
/** NVLink topology information.
 The corresponding activity record structure is \ref
 CUpti_ActivityNvLink4.*/
pub const CUPTI_ACTIVITY_KIND_NVLINK: CUpti_ActivityKind = 40;
/** Instantaneous Event information.
 The corresponding activity record structure is \ref
 CUpti_ActivityInstantaneousEvent.
 This activity can not be directly enabled or disabled.
 Information collected using the Event API can be stored
 in the corresponding activity record.
 Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.*/
pub const CUPTI_ACTIVITY_KIND_INSTANTANEOUS_EVENT: CUpti_ActivityKind = 41;
/** Instantaneous Event information for a specific event
 domain instance.
 The corresponding activity record structure is \ref
 CUpti_ActivityInstantaneousEventInstance.
 This activity can not be directly enabled or disabled.
 Information collected using the Event API can be stored
 in the corresponding activity record.
 Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.*/
pub const CUPTI_ACTIVITY_KIND_INSTANTANEOUS_EVENT_INSTANCE: CUpti_ActivityKind = 42;
/** Instantaneous Metric information
 The corresponding activity record structure is \ref
 CUpti_ActivityInstantaneousMetric.
 This activity cannot be directly enabled or disabled.
 Information collected using the Metric API can be stored
 in the corresponding activity record.
 Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.*/
pub const CUPTI_ACTIVITY_KIND_INSTANTANEOUS_METRIC: CUpti_ActivityKind = 43;
/** Instantaneous Metric information for a specific metric
 domain instance.
 The corresponding activity record structure is \ref
 CUpti_ActivityInstantaneousMetricInstance.
 This activity cannot be directly enabled or disabled.
 Information collected using the Metric API can be stored
 in the corresponding activity record.
 Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.*/
pub const CUPTI_ACTIVITY_KIND_INSTANTANEOUS_METRIC_INSTANCE: CUpti_ActivityKind = 44;
/** Memory activity tracking allocation and freeing of the memory
 The corresponding activity record structure is \ref
 CUpti_ActivityMemory.*/
pub const CUPTI_ACTIVITY_KIND_MEMORY: CUpti_ActivityKind = 45;
/** PCI devices information used for PCI topology.
 The corresponding activity record structure is \ref
 CUpti_ActivityPcie.*/
pub const CUPTI_ACTIVITY_KIND_PCIE: CUpti_ActivityKind = 46;
/** OpenMP parallel events.
 The corresponding activity record structure is \ref
 CUpti_ActivityOpenMp.*/
pub const CUPTI_ACTIVITY_KIND_OPENMP: CUpti_ActivityKind = 47;
/** A CUDA driver kernel launch occurring outside of any
 public API function execution. Tools can handle these
 like records for driver API launch functions, although
 the cbid field is not used here.
 The corresponding activity record structure is \ref
 CUpti_ActivityAPI.*/
pub const CUPTI_ACTIVITY_KIND_INTERNAL_LAUNCH_API: CUpti_ActivityKind = 48;
/** Memory activity tracking allocation and freeing of the memory
 The corresponding activity record structure is \ref
 CUpti_ActivityMemory4.*/
pub const CUPTI_ACTIVITY_KIND_MEMORY2: CUpti_ActivityKind = 49;
/** Memory pool activity tracking creation, destruction and
 trimming of the memory pool.
 The corresponding activity record structure is \ref
 CUpti_ActivityMemoryPool3.*/
pub const CUPTI_ACTIVITY_KIND_MEMORY_POOL: CUpti_ActivityKind = 50;
/** Activity record for graph-level information.
 The corresponding activity record structure is
 \ref CUpti_ActivityGraphTrace2.*/
pub const CUPTI_ACTIVITY_KIND_GRAPH_TRACE: CUpti_ActivityKind = 51;
/** JIT (Just-in-time) operation tracking.
 The corresponding activity record structure is \ref
 CUpti_ActivityJit.*/
pub const CUPTI_ACTIVITY_KIND_JIT: CUpti_ActivityKind = 52;
/** This activity can not be directly enabled or disabled.
 It is enabled when CUPTI_ACTIVITY_KIND_GRAPH_TRACE is enabled
 and device graph trace is enabled through API cuptiActivityEnableDeviceGraph().
 The corresponding activity record structure is
 \ref CUpti_ActivityDeviceGraphTrace.*/
pub const CUPTI_ACTIVITY_KIND_DEVICE_GRAPH_TRACE: CUpti_ActivityKind = 53;
/** Tracing batches of copies that are to be decompressed.
 The corresponding activity record structure is \ref
 CUpti_ActivityMemDecompress.*/
pub const CUPTI_ACTIVITY_KIND_MEM_DECOMPRESS: CUpti_ActivityKind = 54;
/** Tracing new overheads introduced on some hardware due when
 confidential computing is enabled.
 The corresponding activity record structure is \ref
 CUpti_ActivityConfidentialComputeRotation.*/
pub const CUPTI_ACTIVITY_KIND_CONFIDENTIAL_COMPUTE_ROTATION: CUpti_ActivityKind = 55;
/// Count of supported activity kinds.
pub const CUPTI_ACTIVITY_KIND_COUNT: CUpti_ActivityKind = 56;
/// Count of supported activity kinds.
pub const CUPTI_ACTIVITY_KIND_FORCE_INT: CUpti_ActivityKind = 2147483647;
/** \brief The kinds of activity records.

 Each activity record kind represents information about a GPU or an
 activity occurring on a CPU or GPU. Each kind is associated with a
 activity record structure that holds the information associated
 with the kind.
 \see CUpti_Activity
 \see CUpti_ActivityAPI
 \see CUpti_ActivityContext
 \see CUpti_ActivityContext2
 \see CUpti_ActivityContext3
 \see CUpti_ActivityDevice
 \see CUpti_ActivityDevice2
 \see CUpti_ActivityDevice3
 \see CUpti_ActivityDevice4
 \see CUpti_ActivityDevice5
 \see CUpti_ActivityDeviceAttribute
 \see CUpti_ActivityEvent
 \see CUpti_ActivityEventInstance
 \see CUpti_ActivityKernel
 \see CUpti_ActivityKernel2
 \see CUpti_ActivityKernel3
 \see CUpti_ActivityKernel4
 \see CUpti_ActivityKernel5
 \see CUpti_ActivityKernel6
 \see CUpti_ActivityKernel7
 \see CUpti_ActivityKernel8
 \see CUpti_ActivityKernel9
 \see CUpti_ActivityKernel10
 \see CUpti_ActivityCdpKernel
 \see CUpti_ActivityPreemption
 \see CUpti_ActivityMemcpy
 \see CUpti_ActivityMemcpy3
 \see CUpti_ActivityMemcpy4
 \see CUpti_ActivityMemcpy5
 \see CUpti_ActivityMemcpy6
 \see CUpti_ActivityMemcpyPtoP
 \see CUpti_ActivityMemcpyPtoP2
 \see CUpti_ActivityMemcpyPtoP3
 \see CUpti_ActivityMemcpyPtoP4
 \see CUpti_ActivityMemset
 \see CUpti_ActivityMemset2
 \see CUpti_ActivityMemset3
 \see CUpti_ActivityMemset4
 \see CUpti_ActivityMemory
 \see CUpti_ActivityMemory2
 \see CUpti_ActivityMemory3
 \see CUpti_ActivityMemory4
 \see CUpti_ActivityMemoryPool
 \see CUpti_ActivityMemoryPool2
 \see CUpti_ActivityMemoryPool3
 \see CUpti_ActivityMetric
 \see CUpti_ActivityMetricInstance
 \see CUpti_ActivityName
 \see CUpti_ActivityMarker
 \see CUpti_ActivityMarker2
 \see CUpti_ActivityMarkerData
 \see CUpti_ActivitySourceLocator
 \see CUpti_ActivityGlobalAccess
 \see CUpti_ActivityGlobalAccess2
 \see CUpti_ActivityGlobalAccess3
 \see CUpti_ActivityBranch
 \see CUpti_ActivityBranch2
 \see CUpti_ActivityOverhead3
 \see CUpti_ActivityEnvironment
 \see CUpti_ActivityInstructionExecution
 \see CUpti_ActivityUnifiedMemoryCounter
 \see CUpti_ActivityFunction
 \see CUpti_ActivityModule
 \see CUpti_ActivitySharedAccess
 \see CUpti_ActivityPCSampling
 \see CUpti_ActivityPCSampling2
 \see CUpti_ActivityPCSampling3
 \see CUpti_ActivityPCSamplingRecordInfo
 \see CUpti_ActivityCudaEvent2
 \see CUpti_ActivityStream
 \see CUpti_ActivitySynchronization2
 \see CUpti_ActivityInstructionCorrelation
 \see CUpti_ActivityExternalCorrelation
 \see CUpti_ActivityUnifiedMemoryCounter3
 \see CUpti_ActivityOpenAccData
 \see CUpti_ActivityOpenAccLaunch
 \see CUpti_ActivityOpenAccOther
 \see CUpti_ActivityOpenMp
 \see CUpti_ActivityNvLink
 \see CUpti_ActivityNvLink2
 \see CUpti_ActivityNvLink3
 \see CUpti_ActivityNvLink4
 \see CUpti_ActivityPcie
 \see CUpti_ActivityConfidentialComputeRotation*/
pub type CUpti_ActivityKind = ::std::os::raw::c_uint;
/// The object kind is not known.
pub const CUPTI_ACTIVITY_OBJECT_UNKNOWN: CUpti_ActivityObjectKind = 0;
/// A process.
pub const CUPTI_ACTIVITY_OBJECT_PROCESS: CUpti_ActivityObjectKind = 1;
/// A thread.
pub const CUPTI_ACTIVITY_OBJECT_THREAD: CUpti_ActivityObjectKind = 2;
/// A device.
pub const CUPTI_ACTIVITY_OBJECT_DEVICE: CUpti_ActivityObjectKind = 3;
/// A context.
pub const CUPTI_ACTIVITY_OBJECT_CONTEXT: CUpti_ActivityObjectKind = 4;
/// A stream.
pub const CUPTI_ACTIVITY_OBJECT_STREAM: CUpti_ActivityObjectKind = 5;
/// A stream.
pub const CUPTI_ACTIVITY_OBJECT_FORCE_INT: CUpti_ActivityObjectKind = 2147483647;
/** \brief The kinds of activity objects.
 \see CUpti_ActivityObjectKindId*/
pub type CUpti_ActivityObjectKind = ::std::os::raw::c_uint;
/** \brief Identifiers for object kinds as specified by
 CUpti_ActivityObjectKind.
 \see CUpti_ActivityObjectKind*/
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityObjectKindId {
    pub pt: CUpti_ActivityObjectKindId__bindgen_ty_1,
    pub dcs: CUpti_ActivityObjectKindId__bindgen_ty_2,
}
/** A process object requires that we identify the process ID. A
 thread object requires that we identify both the process and
 thread ID.*/
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityObjectKindId__bindgen_ty_1 {
    pub processId: u32,
    pub threadId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityObjectKindId__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityObjectKindId__bindgen_ty_1>() - 8usize];
    [
        "Alignment of CUpti_ActivityObjectKindId__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityObjectKindId__bindgen_ty_1>() - 4usize];
    [
        "Offset of field: CUpti_ActivityObjectKindId__bindgen_ty_1::processId",
    ][::std::mem::offset_of!(CUpti_ActivityObjectKindId__bindgen_ty_1, processId)
        - 0usize];
    [
        "Offset of field: CUpti_ActivityObjectKindId__bindgen_ty_1::threadId",
    ][::std::mem::offset_of!(CUpti_ActivityObjectKindId__bindgen_ty_1, threadId)
        - 4usize];
};
/** A device object requires that we identify the device ID. A
 context object requires that we identify both the device and
 context ID. A stream object requires that we identify device,
 context, and stream ID.*/
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityObjectKindId__bindgen_ty_2 {
    pub deviceId: u32,
    pub contextId: u32,
    pub streamId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityObjectKindId__bindgen_ty_2",
    ][::std::mem::size_of::<CUpti_ActivityObjectKindId__bindgen_ty_2>() - 12usize];
    [
        "Alignment of CUpti_ActivityObjectKindId__bindgen_ty_2",
    ][::std::mem::align_of::<CUpti_ActivityObjectKindId__bindgen_ty_2>() - 4usize];
    [
        "Offset of field: CUpti_ActivityObjectKindId__bindgen_ty_2::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityObjectKindId__bindgen_ty_2, deviceId)
        - 0usize];
    [
        "Offset of field: CUpti_ActivityObjectKindId__bindgen_ty_2::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityObjectKindId__bindgen_ty_2, contextId)
        - 4usize];
    [
        "Offset of field: CUpti_ActivityObjectKindId__bindgen_ty_2::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityObjectKindId__bindgen_ty_2, streamId)
        - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityObjectKindId",
    ][::std::mem::size_of::<CUpti_ActivityObjectKindId>() - 12usize];
    [
        "Alignment of CUpti_ActivityObjectKindId",
    ][::std::mem::align_of::<CUpti_ActivityObjectKindId>() - 4usize];
    [
        "Offset of field: CUpti_ActivityObjectKindId::pt",
    ][::std::mem::offset_of!(CUpti_ActivityObjectKindId, pt) - 0usize];
    [
        "Offset of field: CUpti_ActivityObjectKindId::dcs",
    ][::std::mem::offset_of!(CUpti_ActivityObjectKindId, dcs) - 0usize];
};
impl Default for CUpti_ActivityObjectKindId {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityObjectKindId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityObjectKindId {{ union }}")
    }
}
/// \brief The structure to provide additional data for CUPTI_ACTIVITY_OVERHEAD_COMMAND_BUFFER_FULL.
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityOverheadCommandBufferFullData {
    /** The remaining space in the command buffer. This field will always be zero
 when the command buffer is full, making it not useful in such cases.
*/
    pub commandBufferLength: u32,
    /** The channel ID of the command buffer.
*/
    pub channelID: u32,
    /** The channel type of the command buffer.
*/
    pub channelType: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityOverheadCommandBufferFullData",
    ][::std::mem::size_of::<CUpti_ActivityOverheadCommandBufferFullData>() - 12usize];
    [
        "Alignment of CUpti_ActivityOverheadCommandBufferFullData",
    ][::std::mem::align_of::<CUpti_ActivityOverheadCommandBufferFullData>() - 4usize];
    [
        "Offset of field: CUpti_ActivityOverheadCommandBufferFullData::commandBufferLength",
    ][::std::mem::offset_of!(
        CUpti_ActivityOverheadCommandBufferFullData, commandBufferLength
    ) - 0usize];
    [
        "Offset of field: CUpti_ActivityOverheadCommandBufferFullData::channelID",
    ][::std::mem::offset_of!(CUpti_ActivityOverheadCommandBufferFullData, channelID)
        - 4usize];
    [
        "Offset of field: CUpti_ActivityOverheadCommandBufferFullData::channelType",
    ][::std::mem::offset_of!(CUpti_ActivityOverheadCommandBufferFullData, channelType)
        - 8usize];
};
/// The overhead kind is not known.
pub const CUPTI_ACTIVITY_OVERHEAD_UNKNOWN: CUpti_ActivityOverheadKind = 0;
/// Compiler overhead.
pub const CUPTI_ACTIVITY_OVERHEAD_DRIVER_COMPILER: CUpti_ActivityOverheadKind = 1;
/// Activity buffer flush overhead.
pub const CUPTI_ACTIVITY_OVERHEAD_CUPTI_BUFFER_FLUSH: CUpti_ActivityOverheadKind = 65536;
/// CUPTI instrumentation overhead.
pub const CUPTI_ACTIVITY_OVERHEAD_CUPTI_INSTRUMENTATION: CUpti_ActivityOverheadKind = 131072;
/// CUPTI resource creation and destruction overhead.
pub const CUPTI_ACTIVITY_OVERHEAD_CUPTI_RESOURCE: CUpti_ActivityOverheadKind = 196608;
/// CUDA Runtime triggered module loading overhead.
pub const CUPTI_ACTIVITY_OVERHEAD_RUNTIME_TRIGGERED_MODULE_LOADING: CUpti_ActivityOverheadKind = 262144;
/// Lazy function loading overhead.
pub const CUPTI_ACTIVITY_OVERHEAD_LAZY_FUNCTION_LOADING: CUpti_ActivityOverheadKind = 327680;
/** Overhead due to lack of command buffer space.
 Refer CUpti_ActivityOverheadCommandBufferFullData for more details.*/
pub const CUPTI_ACTIVITY_OVERHEAD_COMMAND_BUFFER_FULL: CUpti_ActivityOverheadKind = 393216;
/// Overhead due to activity buffer request.
pub const CUPTI_ACTIVITY_OVERHEAD_ACTIVITY_BUFFER_REQUEST: CUpti_ActivityOverheadKind = 458752;
/// Overhead due to UVM activity initialization.
pub const CUPTI_ACTIVITY_OVERHEAD_UVM_ACTIVITY_INIT: CUpti_ActivityOverheadKind = 524288;
/// Overhead due to UVM activity initialization.
pub const CUPTI_ACTIVITY_OVERHEAD_FORCE_INT: CUpti_ActivityOverheadKind = 2147483647;
/// \brief The kinds of activity overhead.
pub type CUpti_ActivityOverheadKind = ::std::os::raw::c_uint;
/// The compute API is not known.
pub const CUPTI_ACTIVITY_COMPUTE_API_UNKNOWN: CUpti_ActivityComputeApiKind = 0;
/// The compute APIs are for CUDA.
pub const CUPTI_ACTIVITY_COMPUTE_API_CUDA: CUpti_ActivityComputeApiKind = 1;
/** The compute APIs are for CUDA running
 in MPS (Multi-Process Service) environment.*/
pub const CUPTI_ACTIVITY_COMPUTE_API_CUDA_MPS: CUpti_ActivityComputeApiKind = 2;
/** The compute APIs are for CUDA running
 in MPS (Multi-Process Service) environment.*/
pub const CUPTI_ACTIVITY_COMPUTE_API_FORCE_INT: CUpti_ActivityComputeApiKind = 2147483647;
/// \brief The kind of a compute API.
pub type CUpti_ActivityComputeApiKind = ::std::os::raw::c_uint;
/// Indicates the activity record has no flags.
pub const CUPTI_ACTIVITY_FLAG_NONE: CUpti_ActivityFlag = 0;
/** Indicates the activity represents a device that supports
 concurrent kernel execution. Valid for
 CUPTI_ACTIVITY_KIND_DEVICE.*/
pub const CUPTI_ACTIVITY_FLAG_DEVICE_CONCURRENT_KERNELS: CUpti_ActivityFlag = 1;
/** Indicates if the activity represents a CUdevice_attribute value
 or a CUpti_DeviceAttribute value. Valid for
 CUPTI_ACTIVITY_KIND_DEVICE_ATTRIBUTE.*/
pub const CUPTI_ACTIVITY_FLAG_DEVICE_ATTRIBUTE_CUDEVICE: CUpti_ActivityFlag = 1;
/** Indicates the activity represents an asynchronous memcpy
 operation. Valid for CUPTI_ACTIVITY_KIND_MEMCPY.*/
pub const CUPTI_ACTIVITY_FLAG_MEMCPY_ASYNC: CUpti_ActivityFlag = 1;
/** Indicates the activity represents an instantaneous marker. Valid
 for CUPTI_ACTIVITY_KIND_MARKER.*/
pub const CUPTI_ACTIVITY_FLAG_MARKER_INSTANTANEOUS: CUpti_ActivityFlag = 1;
/** Indicates the activity represents a region start marker. Valid
 for CUPTI_ACTIVITY_KIND_MARKER.*/
pub const CUPTI_ACTIVITY_FLAG_MARKER_START: CUpti_ActivityFlag = 2;
/** Indicates the activity represents a region end marker. Valid for
 CUPTI_ACTIVITY_KIND_MARKER.*/
pub const CUPTI_ACTIVITY_FLAG_MARKER_END: CUpti_ActivityFlag = 4;
/** Indicates the activity represents an attempt to acquire a user
 defined synchronization object.
 Valid for CUPTI_ACTIVITY_KIND_MARKER.*/
pub const CUPTI_ACTIVITY_FLAG_MARKER_SYNC_ACQUIRE: CUpti_ActivityFlag = 8;
/** Indicates the activity represents success in acquiring the
 user defined synchronization object.
 Valid for CUPTI_ACTIVITY_KIND_MARKER.*/
pub const CUPTI_ACTIVITY_FLAG_MARKER_SYNC_ACQUIRE_SUCCESS: CUpti_ActivityFlag = 16;
/** Indicates the activity represents failure in acquiring the
 user defined synchronization object.
 Valid for CUPTI_ACTIVITY_KIND_MARKER.*/
pub const CUPTI_ACTIVITY_FLAG_MARKER_SYNC_ACQUIRE_FAILED: CUpti_ActivityFlag = 32;
/** Indicates the activity represents releasing a reservation on
 user defined synchronization object.
 Valid for CUPTI_ACTIVITY_KIND_MARKER.*/
pub const CUPTI_ACTIVITY_FLAG_MARKER_SYNC_RELEASE: CUpti_ActivityFlag = 64;
/** Indicates the activity represents a marker that does not specify
 a color. Valid for CUPTI_ACTIVITY_KIND_MARKER_DATA.*/
pub const CUPTI_ACTIVITY_FLAG_MARKER_COLOR_NONE: CUpti_ActivityFlag = 1;
/** Indicates the activity represents a marker that specifies a color
 in alpha-red-green-blue format. Valid for
 CUPTI_ACTIVITY_KIND_MARKER_DATA.*/
pub const CUPTI_ACTIVITY_FLAG_MARKER_COLOR_ARGB: CUpti_ActivityFlag = 2;
/** The number of bytes requested by each thread
 Valid for CUpti_ActivityGlobalAccess3.*/
pub const CUPTI_ACTIVITY_FLAG_GLOBAL_ACCESS_KIND_SIZE_MASK: CUpti_ActivityFlag = 255;
/** If bit in this flag is set, the access was load, else it is a
 store access. Valid for CUpti_ActivityGlobalAccess3.*/
pub const CUPTI_ACTIVITY_FLAG_GLOBAL_ACCESS_KIND_LOAD: CUpti_ActivityFlag = 256;
/** If this bit in flag is set, the load access was cached else it is
 uncached. Valid for CUpti_ActivityGlobalAccess3.*/
pub const CUPTI_ACTIVITY_FLAG_GLOBAL_ACCESS_KIND_CACHED: CUpti_ActivityFlag = 512;
/** If this bit in flag is set, the metric value overflowed. Valid
 for CUpti_ActivityMetric and CUpti_ActivityMetricInstance.*/
pub const CUPTI_ACTIVITY_FLAG_METRIC_OVERFLOWED: CUpti_ActivityFlag = 1;
/** If this bit in flag is set, the metric value couldn't be
 calculated. This occurs when a value(s) required to calculate the
 metric is missing.  Valid for CUpti_ActivityMetric and
 CUpti_ActivityMetricInstance.*/
pub const CUPTI_ACTIVITY_FLAG_METRIC_VALUE_INVALID: CUpti_ActivityFlag = 2;
/** If this bit in flag is set, the source level metric value couldn't be
 calculated. This occurs when a value(s) required to calculate the
 source level metric cannot be evaluated.
 Valid for CUpti_ActivityInstructionExecution.*/
pub const CUPTI_ACTIVITY_FLAG_INSTRUCTION_VALUE_INVALID: CUpti_ActivityFlag = 1;
/** The mask for the instruction class, \ref CUpti_ActivityInstructionClass
 Valid for CUpti_ActivityInstructionExecution and
 CUpti_ActivityInstructionCorrelation*/
pub const CUPTI_ACTIVITY_FLAG_INSTRUCTION_CLASS_MASK: CUpti_ActivityFlag = 510;
/** When calling cuptiActivityFlushAll, this flag
 can be set to force CUPTI to flush all records in the buffer, whether
 finished or not*/
pub const CUPTI_ACTIVITY_FLAG_FLUSH_FORCED: CUpti_ActivityFlag = 1;
/** The number of bytes requested by each thread
 Valid for CUpti_ActivitySharedAccess.*/
pub const CUPTI_ACTIVITY_FLAG_SHARED_ACCESS_KIND_SIZE_MASK: CUpti_ActivityFlag = 255;
/** If bit in this flag is set, the access was load, else it is a
 store access.  Valid for CUpti_ActivitySharedAccess.*/
pub const CUPTI_ACTIVITY_FLAG_SHARED_ACCESS_KIND_LOAD: CUpti_ActivityFlag = 256;
/** Indicates the activity represents an asynchronous memset
 operation. Valid for CUPTI_ACTIVITY_KIND_MEMSET.*/
pub const CUPTI_ACTIVITY_FLAG_MEMSET_ASYNC: CUpti_ActivityFlag = 1;
/** Indicates the activity represents thrashing in CPU.
 Valid for counter of kind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING in
 CUPTI_ACTIVITY_KIND_UNIFIED_MEMORY_COUNTER*/
pub const CUPTI_ACTIVITY_FLAG_THRASHING_IN_CPU: CUpti_ActivityFlag = 1;
/** Indicates the activity represents page throttling in CPU.
 Valid for counter of kind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING in
 CUPTI_ACTIVITY_KIND_UNIFIED_MEMORY_COUNTER*/
pub const CUPTI_ACTIVITY_FLAG_THROTTLING_IN_CPU: CUpti_ActivityFlag = 1;
/** Indicates the activity represents page throttling in CPU.
 Valid for counter of kind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING in
 CUPTI_ACTIVITY_KIND_UNIFIED_MEMORY_COUNTER*/
pub const CUPTI_ACTIVITY_FLAG_FORCE_INT: CUpti_ActivityFlag = 2147483647;
/** \brief Flags associated with activity records.

 Activity record flags. Flags can be combined by bitwise OR to
 associated multiple flags with an activity record. Each flag is
 specific to a certain activity kind, as noted below.*/
pub type CUpti_ActivityFlag = ::std::os::raw::c_uint;
/// Invalid reason
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_INVALID: CUpti_ActivityPCSamplingStallReason = 0;
/// No stall, instruction is selected for issue
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_NONE: CUpti_ActivityPCSamplingStallReason = 1;
/** Warp is blocked because next instruction is not yet available,
 because of instruction cache miss, or because of branching effects*/
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_INST_FETCH: CUpti_ActivityPCSamplingStallReason = 2;
/// Instruction is waiting on an arithmetic dependency
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_EXEC_DEPENDENCY: CUpti_ActivityPCSamplingStallReason = 3;
/// Warp is blocked because it is waiting for a memory access to complete.
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_MEMORY_DEPENDENCY: CUpti_ActivityPCSamplingStallReason = 4;
/// Texture sub-system is fully utilized or has too many outstanding requests.
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_TEXTURE: CUpti_ActivityPCSamplingStallReason = 5;
/// Warp is blocked as it is waiting at __syncthreads() or at memory barrier.
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_SYNC: CUpti_ActivityPCSamplingStallReason = 6;
/// Warp is blocked waiting for __constant__ memory and immediate memory access to complete.
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_CONSTANT_MEMORY_DEPENDENCY: CUpti_ActivityPCSamplingStallReason = 7;
/** Compute operation cannot be performed due to the required resources not
 being available.*/
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_PIPE_BUSY: CUpti_ActivityPCSamplingStallReason = 8;
/// Warp is blocked because there are too many pending memory operations.
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_MEMORY_THROTTLE: CUpti_ActivityPCSamplingStallReason = 9;
/// Warp was ready to issue, but some other warp issued instead.
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_NOT_SELECTED: CUpti_ActivityPCSamplingStallReason = 10;
/// Miscellaneous reasons
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_OTHER: CUpti_ActivityPCSamplingStallReason = 11;
/// Sleeping.
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_SLEEPING: CUpti_ActivityPCSamplingStallReason = 12;
/// Sleeping.
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_FORCE_INT: CUpti_ActivityPCSamplingStallReason = 2147483647;
/// \brief The stall reason for PC sampling activity.
pub type CUpti_ActivityPCSamplingStallReason = ::std::os::raw::c_uint;
/// The PC sampling period is not set.
pub const CUPTI_ACTIVITY_PC_SAMPLING_PERIOD_INVALID: CUpti_ActivityPCSamplingPeriod = 0;
/// Minimum sampling period available on the device.
pub const CUPTI_ACTIVITY_PC_SAMPLING_PERIOD_MIN: CUpti_ActivityPCSamplingPeriod = 1;
/// Sampling period in lower range.
pub const CUPTI_ACTIVITY_PC_SAMPLING_PERIOD_LOW: CUpti_ActivityPCSamplingPeriod = 2;
/// Medium sampling period.
pub const CUPTI_ACTIVITY_PC_SAMPLING_PERIOD_MID: CUpti_ActivityPCSamplingPeriod = 3;
/// Sampling period in higher range.
pub const CUPTI_ACTIVITY_PC_SAMPLING_PERIOD_HIGH: CUpti_ActivityPCSamplingPeriod = 4;
/// Maximum sampling period available on the device.
pub const CUPTI_ACTIVITY_PC_SAMPLING_PERIOD_MAX: CUpti_ActivityPCSamplingPeriod = 5;
/// Maximum sampling period available on the device.
pub const CUPTI_ACTIVITY_PC_SAMPLING_PERIOD_FORCE_INT: CUpti_ActivityPCSamplingPeriod = 2147483647;
/** \brief Sampling period for PC sampling method

 Sampling period can be set using \ref cuptiActivityConfigurePCSampling*/
pub type CUpti_ActivityPCSamplingPeriod = ::std::os::raw::c_uint;
/// The memory copy kind is not known.
pub const CUPTI_ACTIVITY_MEMCPY_KIND_UNKNOWN: CUpti_ActivityMemcpyKind = 0;
/// A host to device memory copy.
pub const CUPTI_ACTIVITY_MEMCPY_KIND_HTOD: CUpti_ActivityMemcpyKind = 1;
/// A device to host memory copy.
pub const CUPTI_ACTIVITY_MEMCPY_KIND_DTOH: CUpti_ActivityMemcpyKind = 2;
/// A host to device array memory copy.
pub const CUPTI_ACTIVITY_MEMCPY_KIND_HTOA: CUpti_ActivityMemcpyKind = 3;
/// A device array to host memory copy.
pub const CUPTI_ACTIVITY_MEMCPY_KIND_ATOH: CUpti_ActivityMemcpyKind = 4;
/// A device array to device array memory copy.
pub const CUPTI_ACTIVITY_MEMCPY_KIND_ATOA: CUpti_ActivityMemcpyKind = 5;
/// A device array to device memory copy.
pub const CUPTI_ACTIVITY_MEMCPY_KIND_ATOD: CUpti_ActivityMemcpyKind = 6;
/// A device to device array memory copy.
pub const CUPTI_ACTIVITY_MEMCPY_KIND_DTOA: CUpti_ActivityMemcpyKind = 7;
/// A device to device memory copy on the same device.
pub const CUPTI_ACTIVITY_MEMCPY_KIND_DTOD: CUpti_ActivityMemcpyKind = 8;
/// A host to host memory copy.
pub const CUPTI_ACTIVITY_MEMCPY_KIND_HTOH: CUpti_ActivityMemcpyKind = 9;
/// A peer to peer memory copy across different devices.
pub const CUPTI_ACTIVITY_MEMCPY_KIND_PTOP: CUpti_ActivityMemcpyKind = 10;
/// A peer to peer memory copy across different devices.
pub const CUPTI_ACTIVITY_MEMCPY_KIND_FORCE_INT: CUpti_ActivityMemcpyKind = 2147483647;
/** \brief The kind of a memory copy, indicating the source and
 destination targets of the copy.

 Each kind represents the source and destination targets of a memory
 copy. Targets are host, device, and array.*/
pub type CUpti_ActivityMemcpyKind = ::std::os::raw::c_uint;
/// The memory kind is unknown.
pub const CUPTI_ACTIVITY_MEMORY_KIND_UNKNOWN: CUpti_ActivityMemoryKind = 0;
/// The memory is pageable.
pub const CUPTI_ACTIVITY_MEMORY_KIND_PAGEABLE: CUpti_ActivityMemoryKind = 1;
/// The memory is pinned.
pub const CUPTI_ACTIVITY_MEMORY_KIND_PINNED: CUpti_ActivityMemoryKind = 2;
/// The memory is on the device.
pub const CUPTI_ACTIVITY_MEMORY_KIND_DEVICE: CUpti_ActivityMemoryKind = 3;
/// The memory is an array.
pub const CUPTI_ACTIVITY_MEMORY_KIND_ARRAY: CUpti_ActivityMemoryKind = 4;
/// The memory is managed
pub const CUPTI_ACTIVITY_MEMORY_KIND_MANAGED: CUpti_ActivityMemoryKind = 5;
/// The memory is device static
pub const CUPTI_ACTIVITY_MEMORY_KIND_DEVICE_STATIC: CUpti_ActivityMemoryKind = 6;
/// The memory is managed static
pub const CUPTI_ACTIVITY_MEMORY_KIND_MANAGED_STATIC: CUpti_ActivityMemoryKind = 7;
/// The memory is managed static
pub const CUPTI_ACTIVITY_MEMORY_KIND_FORCE_INT: CUpti_ActivityMemoryKind = 2147483647;
/** \brief The kinds of memory accessed by a memory operation/copy.

 Each kind represents the type of the memory
 accessed by a memory operation/copy.*/
pub type CUpti_ActivityMemoryKind = ::std::os::raw::c_uint;
/// The preemption kind is not known.
pub const CUPTI_ACTIVITY_PREEMPTION_KIND_UNKNOWN: CUpti_ActivityPreemptionKind = 0;
/// Preemption to save CDP block.
pub const CUPTI_ACTIVITY_PREEMPTION_KIND_SAVE: CUpti_ActivityPreemptionKind = 1;
/// Preemption to restore CDP block.
pub const CUPTI_ACTIVITY_PREEMPTION_KIND_RESTORE: CUpti_ActivityPreemptionKind = 2;
/// Preemption to restore CDP block.
pub const CUPTI_ACTIVITY_PREEMPTION_KIND_FORCE_INT: CUpti_ActivityPreemptionKind = 2147483647;
/// \brief The kind of a preemption activity.
pub type CUpti_ActivityPreemptionKind = ::std::os::raw::c_uint;
/// Unknown data.
pub const CUPTI_ACTIVITY_ENVIRONMENT_UNKNOWN: CUpti_ActivityEnvironmentKind = 0;
/// The environment data is related to speed.
pub const CUPTI_ACTIVITY_ENVIRONMENT_SPEED: CUpti_ActivityEnvironmentKind = 1;
/// The environment data is related to temperature.
pub const CUPTI_ACTIVITY_ENVIRONMENT_TEMPERATURE: CUpti_ActivityEnvironmentKind = 2;
/// The environment data is related to power.
pub const CUPTI_ACTIVITY_ENVIRONMENT_POWER: CUpti_ActivityEnvironmentKind = 3;
/// The environment data is related to cooling.
pub const CUPTI_ACTIVITY_ENVIRONMENT_COOLING: CUpti_ActivityEnvironmentKind = 4;
/// The environment data is related to cooling.
pub const CUPTI_ACTIVITY_ENVIRONMENT_COUNT: CUpti_ActivityEnvironmentKind = 5;
/// The environment data is related to cooling.
pub const CUPTI_ACTIVITY_ENVIRONMENT_KIND_FORCE_INT: CUpti_ActivityEnvironmentKind = 2147483647;
/** \brief The kind of environment data. Used to indicate what type of
 data is being reported by an environment activity record.*/
pub type CUpti_ActivityEnvironmentKind = ::std::os::raw::c_uint;
/** Nothing is running on the GPU and the clocks are dropping to idle
 state.*/
pub const CUPTI_CLOCKS_THROTTLE_REASON_GPU_IDLE: CUpti_EnvironmentClocksThrottleReason = 1;
/// The GPU clocks are limited by a user specified limit.
pub const CUPTI_CLOCKS_THROTTLE_REASON_USER_DEFINED_CLOCKS: CUpti_EnvironmentClocksThrottleReason = 2;
/** A software power scaling algorithm is reducing the clocks below
 requested clocks.*/
pub const CUPTI_CLOCKS_THROTTLE_REASON_SW_POWER_CAP: CUpti_EnvironmentClocksThrottleReason = 4;
/** Hardware slowdown to reduce the clock by a factor of two or more
 is engaged.  This is an indicator of one of the following: 1)
 Temperature is too high, 2) External power brake assertion is
 being triggered (e.g. by the system power supply), 3) Change in
 power state.*/
pub const CUPTI_CLOCKS_THROTTLE_REASON_HW_SLOWDOWN: CUpti_EnvironmentClocksThrottleReason = 8;
/// Some unspecified factor is reducing the clocks.
pub const CUPTI_CLOCKS_THROTTLE_REASON_UNKNOWN: CUpti_EnvironmentClocksThrottleReason = 2147483648;
/// Throttle reason is not supported for this GPU.
pub const CUPTI_CLOCKS_THROTTLE_REASON_UNSUPPORTED: CUpti_EnvironmentClocksThrottleReason = 1073741824;
/// No clock throttling.
pub const CUPTI_CLOCKS_THROTTLE_REASON_NONE: CUpti_EnvironmentClocksThrottleReason = 0;
/// No clock throttling.
pub const CUPTI_CLOCKS_THROTTLE_REASON_FORCE_INT: CUpti_EnvironmentClocksThrottleReason = 2147483647;
/** \brief Reasons for clock throttling.

 The possible reasons that a clock can be throttled. There can be
 more than one reason that a clock is being throttled so these types
 can be combined by bitwise OR.  These are used in the
 clocksThrottleReason field in the Environment Activity Record.*/
pub type CUpti_EnvironmentClocksThrottleReason = ::std::os::raw::c_uint;
/// The unified memory counter scope is not known.
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_SCOPE_UNKNOWN: CUpti_ActivityUnifiedMemoryCounterScope = 0;
/// Collect unified memory counter for single process on one device
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_SCOPE_PROCESS_SINGLE_DEVICE: CUpti_ActivityUnifiedMemoryCounterScope = 1;
/// Collect unified memory counter for single process across all devices
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_SCOPE_PROCESS_ALL_DEVICES: CUpti_ActivityUnifiedMemoryCounterScope = 2;
/// Collect unified memory counter for single process across all devices
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_SCOPE_COUNT: CUpti_ActivityUnifiedMemoryCounterScope = 3;
/// Collect unified memory counter for single process across all devices
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_SCOPE_FORCE_INT: CUpti_ActivityUnifiedMemoryCounterScope = 2147483647;
/// \brief Scope of the unified memory counter (deprecated in CUDA 7.0)
pub type CUpti_ActivityUnifiedMemoryCounterScope = ::std::os::raw::c_uint;
/// The unified memory counter kind is not known.
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_UNKNOWN: CUpti_ActivityUnifiedMemoryCounterKind = 0;
/// Number of bytes transferred from host to device
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD: CUpti_ActivityUnifiedMemoryCounterKind = 1;
/// Number of bytes transferred from device to host
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_DTOH: CUpti_ActivityUnifiedMemoryCounterKind = 2;
/** Number of CPU page faults, this is only supported on 64 bit
 Linux and Mac platforms*/
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT: CUpti_ActivityUnifiedMemoryCounterKind = 3;
/** Number of GPU page faults, this is only supported on devices with
 compute capability 6.0 and higher and 64 bit Linux platforms*/
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT: CUpti_ActivityUnifiedMemoryCounterKind = 4;
/** Thrashing occurs when data is frequently accessed by
 multiple processors and has to be constantly migrated around
 to achieve data locality. In this case the overhead of migration
 may exceed the benefits of locality.
 This is only supported on 64 bit Linux platforms.*/
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING: CUpti_ActivityUnifiedMemoryCounterKind = 5;
/** Throttling is a prevention technique used by the driver to avoid
 further thrashing. Here, the driver doesn't service the fault for
 one of the contending processors for a specific period of time,
 so that the other processor can run at full-speed.
 This is only supported on 64 bit Linux platforms.*/
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING: CUpti_ActivityUnifiedMemoryCounterKind = 6;
/** In case throttling does not help, the driver tries to pin the memory
 to a processor for a specific period of time. One of the contending
 processors will have slow  access to the memory, while the other will
 have fast access.
 This is only supported on 64 bit Linux platforms.*/
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_REMOTE_MAP: CUpti_ActivityUnifiedMemoryCounterKind = 7;
/** Number of bytes transferred from one device to another device.
 This is only supported on 64 bit Linux platforms.*/
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_DTOD: CUpti_ActivityUnifiedMemoryCounterKind = 8;
/** Number of bytes transferred from one device to another device.
 This is only supported on 64 bit Linux platforms.*/
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_COUNT: CUpti_ActivityUnifiedMemoryCounterKind = 9;
/** Number of bytes transferred from one device to another device.
 This is only supported on 64 bit Linux platforms.*/
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_FORCE_INT: CUpti_ActivityUnifiedMemoryCounterKind = 2147483647;
/** \brief Kind of the Unified Memory counter

 Many activities are associated with Unified Memory mechanism; among them
 are transfers from host to device, device to host, page fault at
 host side.*/
pub type CUpti_ActivityUnifiedMemoryCounterKind = ::std::os::raw::c_uint;
/// The unified memory access type is not known
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_ACCESS_TYPE_UNKNOWN: CUpti_ActivityUnifiedMemoryAccessType = 0;
/// The page fault was triggered by read memory instruction
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_ACCESS_TYPE_READ: CUpti_ActivityUnifiedMemoryAccessType = 1;
/// The page fault was triggered by write memory instruction
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_ACCESS_TYPE_WRITE: CUpti_ActivityUnifiedMemoryAccessType = 2;
/// The page fault was triggered by atomic memory instruction
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_ACCESS_TYPE_ATOMIC: CUpti_ActivityUnifiedMemoryAccessType = 3;
/// The page fault was triggered by memory prefetch operation
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_ACCESS_TYPE_PREFETCH: CUpti_ActivityUnifiedMemoryAccessType = 4;
/** \brief Memory access type for unified memory page faults

 This is valid for \ref CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT
 and \ref CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT*/
pub type CUpti_ActivityUnifiedMemoryAccessType = ::std::os::raw::c_uint;
/// The unified memory migration cause is not known
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_MIGRATION_CAUSE_UNKNOWN: CUpti_ActivityUnifiedMemoryMigrationCause = 0;
/** The unified memory migrated due to an explicit call from
 the user e.g. cudaMemPrefetchAsync*/
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_MIGRATION_CAUSE_USER: CUpti_ActivityUnifiedMemoryMigrationCause = 1;
/** The unified memory migrated to guarantee data coherence
 e.g. CPU/GPU faults on Pascal+ and kernel launch on pre-Pascal GPUs*/
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_MIGRATION_CAUSE_COHERENCE: CUpti_ActivityUnifiedMemoryMigrationCause = 2;
/** The unified memory was speculatively migrated by the UVM driver
 before being accessed by the destination processor to improve
 performance*/
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_MIGRATION_CAUSE_PREFETCH: CUpti_ActivityUnifiedMemoryMigrationCause = 3;
/** The unified memory migrated to the CPU because it was evicted to make
 room for another block of memory on the GPU*/
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_MIGRATION_CAUSE_EVICTION: CUpti_ActivityUnifiedMemoryMigrationCause = 4;
/** The unified memory migrated to another processor because of access counter
 notifications. Only frequently accessed pages are migrated between CPU and GPU, or
 between peer GPUs.*/
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_MIGRATION_CAUSE_ACCESS_COUNTERS: CUpti_ActivityUnifiedMemoryMigrationCause = 5;
/** \brief Migration cause of the Unified Memory counter

 This is valid for \ref CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD and
 \ref CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_DTOH*/
pub type CUpti_ActivityUnifiedMemoryMigrationCause = ::std::os::raw::c_uint;
/// The cause of mapping to remote memory was unknown
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_REMOTE_MAP_CAUSE_UNKNOWN: CUpti_ActivityUnifiedMemoryRemoteMapCause = 0;
/// Mapping to remote memory was added to maintain data coherence.
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_REMOTE_MAP_CAUSE_COHERENCE: CUpti_ActivityUnifiedMemoryRemoteMapCause = 1;
/// Mapping to remote memory was added to prevent further thrashing
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_REMOTE_MAP_CAUSE_THRASHING: CUpti_ActivityUnifiedMemoryRemoteMapCause = 2;
/** Mapping to remote memory was added to enforce the hints
 specified by the programmer or by performance heuristics of the
 UVM driver*/
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_REMOTE_MAP_CAUSE_POLICY: CUpti_ActivityUnifiedMemoryRemoteMapCause = 3;
/** Mapping to remote memory was added because there is no more
 memory available on the processor and eviction was not
 possible*/
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_REMOTE_MAP_CAUSE_OUT_OF_MEMORY: CUpti_ActivityUnifiedMemoryRemoteMapCause = 4;
/** Mapping to remote memory was added after the memory was
 evicted to make room for another block of memory on the GPU*/
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_REMOTE_MAP_CAUSE_EVICTION: CUpti_ActivityUnifiedMemoryRemoteMapCause = 5;
/** \brief Remote memory map cause of the Unified Memory counter

 This is valid for \ref CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_REMOTE_MAP*/
pub type CUpti_ActivityUnifiedMemoryRemoteMapCause = ::std::os::raw::c_uint;
/// The instruction class is not known.
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_UNKNOWN: CUpti_ActivityInstructionClass = 0;
/// Represents a 32 bit floating point operation.
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_FP_32: CUpti_ActivityInstructionClass = 1;
/// Represents a 64 bit floating point operation.
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_FP_64: CUpti_ActivityInstructionClass = 2;
/// Represents an integer operation.
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_INTEGER: CUpti_ActivityInstructionClass = 3;
/// Represents a bit conversion operation.
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_BIT_CONVERSION: CUpti_ActivityInstructionClass = 4;
/// Represents a control flow instruction.
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_CONTROL_FLOW: CUpti_ActivityInstructionClass = 5;
/// Represents a global load-store instruction.
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_GLOBAL: CUpti_ActivityInstructionClass = 6;
/// Represents a shared load-store instruction.
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_SHARED: CUpti_ActivityInstructionClass = 7;
/// Represents a local load-store instruction.
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_LOCAL: CUpti_ActivityInstructionClass = 8;
/// Represents a generic load-store instruction.
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_GENERIC: CUpti_ActivityInstructionClass = 9;
/// Represents a surface load-store instruction.
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_SURFACE: CUpti_ActivityInstructionClass = 10;
/// Represents a constant load instruction.
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_CONSTANT: CUpti_ActivityInstructionClass = 11;
/// Represents a texture load-store instruction.
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_TEXTURE: CUpti_ActivityInstructionClass = 12;
/// Represents a global atomic instruction.
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_GLOBAL_ATOMIC: CUpti_ActivityInstructionClass = 13;
/// Represents a shared atomic instruction.
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_SHARED_ATOMIC: CUpti_ActivityInstructionClass = 14;
/// Represents a surface atomic instruction.
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_SURFACE_ATOMIC: CUpti_ActivityInstructionClass = 15;
/// Represents a inter-thread communication instruction.
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_INTER_THREAD_COMMUNICATION: CUpti_ActivityInstructionClass = 16;
/// Represents a barrier instruction.
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_BARRIER: CUpti_ActivityInstructionClass = 17;
/// Represents some miscellaneous instructions which do not fit in the above classification.
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_MISCELLANEOUS: CUpti_ActivityInstructionClass = 18;
/// Represents a 16 bit floating point operation.
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_FP_16: CUpti_ActivityInstructionClass = 19;
/// Represents uniform instruction.
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_UNIFORM: CUpti_ActivityInstructionClass = 20;
/// Represents uniform instruction.
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_KIND_FORCE_INT: CUpti_ActivityInstructionClass = 2147483647;
/** \brief SASS instruction classification.

 The sass instruction are broadly divided into different class. Each enum represents a classification.*/
pub type CUpti_ActivityInstructionClass = ::std::os::raw::c_uint;
/// Partitioned global cache config unknown.
pub const CUPTI_ACTIVITY_PARTITIONED_GLOBAL_CACHE_CONFIG_UNKNOWN: CUpti_ActivityPartitionedGlobalCacheConfig = 0;
/// Partitioned global cache not supported.
pub const CUPTI_ACTIVITY_PARTITIONED_GLOBAL_CACHE_CONFIG_NOT_SUPPORTED: CUpti_ActivityPartitionedGlobalCacheConfig = 1;
/// Partitioned global cache config off.
pub const CUPTI_ACTIVITY_PARTITIONED_GLOBAL_CACHE_CONFIG_OFF: CUpti_ActivityPartitionedGlobalCacheConfig = 2;
/// Partitioned global cache config on.
pub const CUPTI_ACTIVITY_PARTITIONED_GLOBAL_CACHE_CONFIG_ON: CUpti_ActivityPartitionedGlobalCacheConfig = 3;
/// Partitioned global cache config on.
pub const CUPTI_ACTIVITY_PARTITIONED_GLOBAL_CACHE_CONFIG_FORCE_INT: CUpti_ActivityPartitionedGlobalCacheConfig = 2147483647;
/// \brief Partitioned global caching option
pub type CUpti_ActivityPartitionedGlobalCacheConfig = ::std::os::raw::c_uint;
/// Unknown data.
pub const CUPTI_ACTIVITY_SYNCHRONIZATION_TYPE_UNKNOWN: CUpti_ActivitySynchronizationType = 0;
/// Event synchronize API.
pub const CUPTI_ACTIVITY_SYNCHRONIZATION_TYPE_EVENT_SYNCHRONIZE: CUpti_ActivitySynchronizationType = 1;
/// Stream wait event API.
pub const CUPTI_ACTIVITY_SYNCHRONIZATION_TYPE_STREAM_WAIT_EVENT: CUpti_ActivitySynchronizationType = 2;
/// Stream synchronize API.
pub const CUPTI_ACTIVITY_SYNCHRONIZATION_TYPE_STREAM_SYNCHRONIZE: CUpti_ActivitySynchronizationType = 3;
/// Context synchronize API.
pub const CUPTI_ACTIVITY_SYNCHRONIZATION_TYPE_CONTEXT_SYNCHRONIZE: CUpti_ActivitySynchronizationType = 4;
/// Context synchronize API.
pub const CUPTI_ACTIVITY_SYNCHRONIZATION_TYPE_FORCE_INT: CUpti_ActivitySynchronizationType = 2147483647;
/** \brief Synchronization type.

 The types of synchronization to be used with
 CUpti_ActivitySynchronization2.*/
pub type CUpti_ActivitySynchronizationType = ::std::os::raw::c_uint;
/// Unknown data.
pub const CUPTI_ACTIVITY_STREAM_CREATE_FLAG_UNKNOWN: CUpti_ActivityStreamFlag = 0;
/// Default stream.
pub const CUPTI_ACTIVITY_STREAM_CREATE_FLAG_DEFAULT: CUpti_ActivityStreamFlag = 1;
/// Non-blocking stream.
pub const CUPTI_ACTIVITY_STREAM_CREATE_FLAG_NON_BLOCKING: CUpti_ActivityStreamFlag = 2;
/// Null stream.
pub const CUPTI_ACTIVITY_STREAM_CREATE_FLAG_NULL: CUpti_ActivityStreamFlag = 3;
/// Stream create Mask
pub const CUPTI_ACTIVITY_STREAM_CREATE_MASK: CUpti_ActivityStreamFlag = 65535;
/// Stream create Mask
pub const CUPTI_ACTIVITY_STREAM_CREATE_FLAG_FORCE_INT: CUpti_ActivityStreamFlag = 2147483647;
/** \brief stream type.

 The types of stream to be used with CUpti_ActivityStream.*/
pub type CUpti_ActivityStreamFlag = ::std::os::raw::c_uint;
/// The flag is invalid.
pub const CUPTI_LINK_FLAG_INVALID: CUpti_LinkFlag = 0;
/// Is peer to peer access supported by this link.
pub const CUPTI_LINK_FLAG_PEER_ACCESS: CUpti_LinkFlag = 2;
/// Is system memory access supported by this link.
pub const CUPTI_LINK_FLAG_SYSMEM_ACCESS: CUpti_LinkFlag = 4;
/// Is peer atomic access supported by this link.
pub const CUPTI_LINK_FLAG_PEER_ATOMICS: CUpti_LinkFlag = 8;
/// Is system memory atomic access supported by this link.
pub const CUPTI_LINK_FLAG_SYSMEM_ATOMICS: CUpti_LinkFlag = 16;
/// Is system memory atomic access supported by this link.
pub const CUPTI_LINK_FLAG_FORCE_INT: CUpti_LinkFlag = 2147483647;
/** \brief Link flags.

 Describes link properties, to be used with CUpti_ActivityNvLink.*/
pub type CUpti_LinkFlag = ::std::os::raw::c_uint;
/// The operation is invalid.
pub const CUPTI_ACTIVITY_MEMORY_OPERATION_TYPE_INVALID: CUpti_ActivityMemoryOperationType = 0;
/// Memory is allocated.
pub const CUPTI_ACTIVITY_MEMORY_OPERATION_TYPE_ALLOCATION: CUpti_ActivityMemoryOperationType = 1;
/// Memory is released.
pub const CUPTI_ACTIVITY_MEMORY_OPERATION_TYPE_RELEASE: CUpti_ActivityMemoryOperationType = 2;
/// Memory is released.
pub const CUPTI_ACTIVITY_MEMORY_OPERATION_TYPE_FORCE_INT: CUpti_ActivityMemoryOperationType = 2147483647;
/** \brief Memory operation types.

 Describes the type of memory operation, to be used with CUpti_ActivityMemory4.*/
pub type CUpti_ActivityMemoryOperationType = ::std::os::raw::c_uint;
/// The operation is invalid.
pub const CUPTI_ACTIVITY_MEMORY_POOL_TYPE_INVALID: CUpti_ActivityMemoryPoolType = 0;
/// Memory pool is local to the process.
pub const CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL: CUpti_ActivityMemoryPoolType = 1;
/// Memory pool is imported by the process.
pub const CUPTI_ACTIVITY_MEMORY_POOL_TYPE_IMPORTED: CUpti_ActivityMemoryPoolType = 2;
/// Memory pool is imported by the process.
pub const CUPTI_ACTIVITY_MEMORY_POOL_TYPE_FORCE_INT: CUpti_ActivityMemoryPoolType = 2147483647;
/** \brief Memory pool types.

 Describes the type of memory pool, to be used with CUpti_ActivityMemory4.*/
pub type CUpti_ActivityMemoryPoolType = ::std::os::raw::c_uint;
/// The operation is invalid.
pub const CUPTI_ACTIVITY_MEMORY_POOL_OPERATION_TYPE_INVALID: CUpti_ActivityMemoryPoolOperationType = 0;
/// Memory pool is created.
pub const CUPTI_ACTIVITY_MEMORY_POOL_OPERATION_TYPE_CREATED: CUpti_ActivityMemoryPoolOperationType = 1;
/// Memory pool is destroyed.
pub const CUPTI_ACTIVITY_MEMORY_POOL_OPERATION_TYPE_DESTROYED: CUpti_ActivityMemoryPoolOperationType = 2;
/// Memory pool is trimmed.
pub const CUPTI_ACTIVITY_MEMORY_POOL_OPERATION_TYPE_TRIMMED: CUpti_ActivityMemoryPoolOperationType = 3;
/// Memory pool is trimmed.
pub const CUPTI_ACTIVITY_MEMORY_POOL_OPERATION_TYPE_FORCE_INT: CUpti_ActivityMemoryPoolOperationType = 2147483647;
/** \brief Memory pool operation types.

 Describes the type of memory pool operation, to be used with CUpti_ActivityMemoryPool2.*/
pub type CUpti_ActivityMemoryPoolOperationType = ::std::os::raw::c_uint;
pub const CUPTI_CHANNEL_TYPE_INVALID: CUpti_ChannelType = 0;
/// Channel is used for standard work launch and tracking
pub const CUPTI_CHANNEL_TYPE_COMPUTE: CUpti_ChannelType = 1;
/** Channel is used by an asynchronous copy engine
 For confidential compute configurations, work launch and
 completion are done using the copy engines.*/
pub const CUPTI_CHANNEL_TYPE_ASYNC_MEMCPY: CUpti_ChannelType = 2;
/// Channel is used for memory decompression operations
pub const CUPTI_CHANNEL_TYPE_DECOMP: CUpti_ChannelType = 3;
/// Channel is used for memory decompression operations
pub const CUPTI_CHANNEL_TYPE_FORCE_INT: CUpti_ChannelType = 2147483647;
pub type CUpti_ChannelType = ::std::os::raw::c_uint;
/// Regular (non-CIG) mode
pub const CUPTI_CONTEXT_CIG_MODE_NONE: CUpti_ContextCigMode = 0;
/// CIG mode
pub const CUPTI_CONTEXT_CIG_MODE_CIG: CUpti_ContextCigMode = 1;
/// CIG fallback mode
pub const CUPTI_CONTEXT_CIG_MODE_CIG_FALLBACK: CUpti_ContextCigMode = 2;
/// CIG fallback mode
pub const CUPTI_CONTEXT_CIG_MODE_FORCE_INT: CUpti_ContextCigMode = 2147483647;
/** \brief CIG (CUDA in Graphics) Modes.

 Describes the CIG modes associated with the CUDA context.*/
pub type CUpti_ContextCigMode = ::std::os::raw::c_uint;
/// The payload type is not known.
pub const CUPTI_NVTX_EXT_PAYLOAD_TYPE_UNKNOWN: CUpti_NvtxExtPayloadType = 0;
/// The payload type is a schema.
pub const CUPTI_NVTX_EXT_PAYLOAD_TYPE_SCHEMA: CUpti_NvtxExtPayloadType = 1;
/// The payload type is an enum.
pub const CUPTI_NVTX_EXT_PAYLOAD_TYPE_ENUM: CUpti_NvtxExtPayloadType = 2;
/// The payload type is an enum.
pub const CUPTI_NVTX_EXT_PAYLOAD_TYPE_FORCE_INT: CUpti_NvtxExtPayloadType = 2147483647;
pub type CUpti_NvtxExtPayloadType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_NvtxExtPayloadAttr {
    /// Size of the struct in bytes.
    pub structSize: u32,
    /// The payload type. \ref CUpti_NvtxExtPayloadType
    pub type_: u32,
    /** The attributes of the payload.
 Depending on the type, typecast the pointer:
 CUPTI_NVTX_EXT_PAYLOAD_TYPE_SCHEMA: nvtxPayloadSchemaAttr_t
 CUPTI_NVTX_EXT_PAYLOAD_TYPE_ENUM: nvtxPayloadEnumAttr_t*/
    pub attributes: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_NvtxExtPayloadAttr",
    ][::std::mem::size_of::<CUpti_NvtxExtPayloadAttr>() - 16usize];
    [
        "Alignment of CUpti_NvtxExtPayloadAttr",
    ][::std::mem::align_of::<CUpti_NvtxExtPayloadAttr>() - 8usize];
    [
        "Offset of field: CUpti_NvtxExtPayloadAttr::structSize",
    ][::std::mem::offset_of!(CUpti_NvtxExtPayloadAttr, structSize) - 0usize];
    [
        "Offset of field: CUpti_NvtxExtPayloadAttr::type_",
    ][::std::mem::offset_of!(CUpti_NvtxExtPayloadAttr, type_) - 4usize];
    [
        "Offset of field: CUpti_NvtxExtPayloadAttr::attributes",
    ][::std::mem::offset_of!(CUpti_NvtxExtPayloadAttr, attributes) - 8usize];
};
impl Default for CUpti_NvtxExtPayloadAttr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief Unified Memory counters configuration structure

 This structure controls the enable/disable of the various
 Unified Memory counters consisting of scope, kind and other parameters.
 See function \ref cuptiActivityConfigureUnifiedMemoryCounter*/
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityUnifiedMemoryCounterConfig {
    /// Unified Memory counter Counter scope. (deprecated in CUDA 7.0)
    pub scope: CUpti_ActivityUnifiedMemoryCounterScope,
    /// Unified Memory counter Counter kind
    pub kind: CUpti_ActivityUnifiedMemoryCounterKind,
    /** Device id of the target device. This is relevant only
 for single device scopes. (deprecated in CUDA 7.0)*/
    pub deviceId: u32,
    /** Control to enable/disable the counter. To enable the counter
 set it to non-zero value while disable is indicated by zero.*/
    pub enable: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityUnifiedMemoryCounterConfig",
    ][::std::mem::size_of::<CUpti_ActivityUnifiedMemoryCounterConfig>() - 16usize];
    [
        "Alignment of CUpti_ActivityUnifiedMemoryCounterConfig",
    ][::std::mem::align_of::<CUpti_ActivityUnifiedMemoryCounterConfig>() - 8usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounterConfig::scope",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounterConfig, scope) - 0usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounterConfig::kind",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounterConfig, kind) - 4usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounterConfig::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounterConfig, deviceId)
        - 8usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounterConfig::enable",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounterConfig, enable)
        - 12usize];
};
impl Default for CUpti_ActivityUnifiedMemoryCounterConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief Device auto boost state structure

 This structure defines auto boost state for a device.
 See function \ref cuptiGetAutoBoostState*/
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityAutoBoostState {
    /** Returned auto boost state. 1 is returned in case auto boost is enabled, 0
 otherwise*/
    pub enabled: u32,
    /** Id of process that has set the current boost state. The value will be
 CUPTI_AUTO_BOOST_INVALID_CLIENT_PID if the user does not have the
 permission to query process ids or there is an error in querying the
 process id.*/
    pub pid: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityAutoBoostState",
    ][::std::mem::size_of::<CUpti_ActivityAutoBoostState>() - 8usize];
    [
        "Alignment of CUpti_ActivityAutoBoostState",
    ][::std::mem::align_of::<CUpti_ActivityAutoBoostState>() - 8usize];
    [
        "Offset of field: CUpti_ActivityAutoBoostState::enabled",
    ][::std::mem::offset_of!(CUpti_ActivityAutoBoostState, enabled) - 0usize];
    [
        "Offset of field: CUpti_ActivityAutoBoostState::pid",
    ][::std::mem::offset_of!(CUpti_ActivityAutoBoostState, pid) - 4usize];
};
/** \brief PC sampling configuration structure

 This structure defines the pc sampling configuration.

 See function \ref cuptiActivityConfigurePCSampling*/
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityPCSamplingConfig {
    /** Size of configuration structure.
 CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are
 available in the structure. Used to preserve backward compatibility.*/
    pub size: u32,
    /** There are 5 level provided for sampling period. The level
 internally maps to a period in terms of cycles. Same level can
 map to different number of cycles on different gpus. No of
 cycles will be chosen to minimize information loss. The period
 chosen will be given by samplingPeriodInCycles in
 \ref CUpti_ActivityPCSamplingRecordInfo for each kernel instance.*/
    pub samplingPeriod: CUpti_ActivityPCSamplingPeriod,
    /** This will override the period set by samplingPeriod. Value 0 in samplingPeriod2 will be
 considered as samplingPeriod2 should not be used and samplingPeriod should be used.
 Valid values for samplingPeriod2 are between 5 to 31 both inclusive.
 This will set the sampling period to (2^samplingPeriod2) cycles.*/
    pub samplingPeriod2: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityPCSamplingConfig",
    ][::std::mem::size_of::<CUpti_ActivityPCSamplingConfig>() - 16usize];
    [
        "Alignment of CUpti_ActivityPCSamplingConfig",
    ][::std::mem::align_of::<CUpti_ActivityPCSamplingConfig>() - 8usize];
    [
        "Offset of field: CUpti_ActivityPCSamplingConfig::size",
    ][::std::mem::offset_of!(CUpti_ActivityPCSamplingConfig, size) - 0usize];
    [
        "Offset of field: CUpti_ActivityPCSamplingConfig::samplingPeriod",
    ][::std::mem::offset_of!(CUpti_ActivityPCSamplingConfig, samplingPeriod) - 4usize];
    [
        "Offset of field: CUpti_ActivityPCSamplingConfig::samplingPeriod2",
    ][::std::mem::offset_of!(CUpti_ActivityPCSamplingConfig, samplingPeriod2) - 8usize];
};
impl Default for CUpti_ActivityPCSamplingConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The base activity record.

 The activity API uses a CUpti_Activity as a generic representation
 for any activity. The 'kind' field is used to determine the
 specific activity kind, and from that the CUpti_Activity object can
 be cast to the specific activity record type appropriate for that kind.

 Note that all activity record types are padded and aligned to
 ensure that each member of the record is naturally aligned.

 \see CUpti_ActivityKind*/
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Activity {
    /// The kind of this activity.
    pub kind: CUpti_ActivityKind,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Activity"][::std::mem::size_of::<CUpti_Activity>() - 8usize];
    ["Alignment of CUpti_Activity"][::std::mem::align_of::<CUpti_Activity>() - 8usize];
    [
        "Offset of field: CUpti_Activity::kind",
    ][::std::mem::offset_of!(CUpti_Activity, kind) - 0usize];
};
impl Default for CUpti_Activity {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for memory copies.

 This activity record represents a memory copy
 (CUPTI_ACTIVITY_KIND_MEMCPY).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemcpy6 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMCPY.
    pub kind: CUpti_ActivityKind,
    /** The kind of the memory copy, stored as a byte to reduce record
 size. \see CUpti_ActivityMemcpyKind*/
    pub copyKind: u8,
    /** The source memory kind read by the memory copy, stored as a byte
 to reduce record size. \see CUpti_ActivityMemoryKind*/
    pub srcKind: u8,
    /** The destination memory kind read by the memory copy, stored as a
 byte to reduce record size. \see CUpti_ActivityMemoryKind*/
    pub dstKind: u8,
    /// The flags associated with the memory copy. \see CUpti_ActivityFlag
    pub flags: u8,
    /// The number of bytes transferred by the memory copy.
    pub bytes: u64,
    /** The start timestamp for the memory copy, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory copy.*/
    pub start: u64,
    /** The end timestamp for the memory copy, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory copy.*/
    pub end: u64,
    /// The ID of the device where the memory copy is occurring.
    pub deviceId: u32,
    /// The ID of the context where the memory copy is occurring.
    pub contextId: u32,
    /// The ID of the stream where the memory copy is occurring.
    pub streamId: u32,
    /** The correlation ID of the memory copy. Each memory copy is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver API activity record that launched
 the memory copy.*/
    pub correlationId: u32,
    /** The runtime correlation ID of the memory copy. Each memory copy
 is assigned a unique runtime correlation ID that is identical to
 the correlation ID in the runtime API activity record that
 launched the memory copy.*/
    pub runtimeCorrelationId: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
    /** The unique ID of the graph node that executed this memcpy through graph launch.
 This field will be 0 if the memcpy is not done through graph launch.*/
    pub graphNodeId: u64,
    /** The unique ID of the graph that executed this memcpy through graph launch.
 This field will be 0 if the memcpy is not done through graph launch.*/
    pub graphId: u32,
    /// The ID of the HW channel on which the memory copy is occurring.
    pub channelID: u32,
    /// The type of the channel
    pub channelType: CUpti_ChannelType,
    /// This field is used to indicate if the memcpy operation is part of a device graph launch.
    pub isDeviceLaunched: u8,
    ///  Reserved for internal use.
    pub pad2: [u8; 3usize],
    /** The total number of memcopy operations traced in this record.
 This field is valid for memcpy operations happening using
 MemcpyBatchAsync APIs in CUDA.
 In MemcpyBatchAsync APIs, multiple memcpy operations are batched
 together for optimization purposes based on certain heuristics.
 For other memcpy operations, this field will be 1.*/
    pub copyCount: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemcpy6",
    ][::std::mem::size_of::<CUpti_ActivityMemcpy6>() - 96usize];
    [
        "Alignment of CUpti_ActivityMemcpy6",
    ][::std::mem::align_of::<CUpti_ActivityMemcpy6>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemcpy6::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy6, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMemcpy6::copyKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy6, copyKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityMemcpy6::srcKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy6, srcKind) - 5usize];
    [
        "Offset of field: CUpti_ActivityMemcpy6::dstKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy6, dstKind) - 6usize];
    [
        "Offset of field: CUpti_ActivityMemcpy6::flags",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy6, flags) - 7usize];
    [
        "Offset of field: CUpti_ActivityMemcpy6::bytes",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy6, bytes) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemcpy6::start",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy6, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityMemcpy6::end",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy6, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityMemcpy6::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy6, deviceId) - 32usize];
    [
        "Offset of field: CUpti_ActivityMemcpy6::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy6, contextId) - 36usize];
    [
        "Offset of field: CUpti_ActivityMemcpy6::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy6, streamId) - 40usize];
    [
        "Offset of field: CUpti_ActivityMemcpy6::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy6, correlationId) - 44usize];
    [
        "Offset of field: CUpti_ActivityMemcpy6::runtimeCorrelationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy6, runtimeCorrelationId) - 48usize];
    [
        "Offset of field: CUpti_ActivityMemcpy6::pad",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy6, pad) - 52usize];
    [
        "Offset of field: CUpti_ActivityMemcpy6::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy6, reserved0) - 56usize];
    [
        "Offset of field: CUpti_ActivityMemcpy6::graphNodeId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy6, graphNodeId) - 64usize];
    [
        "Offset of field: CUpti_ActivityMemcpy6::graphId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy6, graphId) - 72usize];
    [
        "Offset of field: CUpti_ActivityMemcpy6::channelID",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy6, channelID) - 76usize];
    [
        "Offset of field: CUpti_ActivityMemcpy6::channelType",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy6, channelType) - 80usize];
    [
        "Offset of field: CUpti_ActivityMemcpy6::isDeviceLaunched",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy6, isDeviceLaunched) - 84usize];
    [
        "Offset of field: CUpti_ActivityMemcpy6::pad2",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy6, pad2) - 85usize];
    [
        "Offset of field: CUpti_ActivityMemcpy6::copyCount",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy6, copyCount) - 88usize];
};
impl Default for CUpti_ActivityMemcpy6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for peer-to-peer memory copies.

 This activity record represents a peer-to-peer memory copy
 (CUPTI_ACTIVITY_KIND_MEMCPY2).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemcpyPtoP4 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMCPY2.
    pub kind: CUpti_ActivityKind,
    /** The kind of the memory copy, stored as a byte to reduce record
 size.  \see CUpti_ActivityMemcpyKind*/
    pub copyKind: u8,
    /** The source memory kind read by the memory copy, stored as a byte
 to reduce record size.  \see CUpti_ActivityMemoryKind*/
    pub srcKind: u8,
    /** The destination memory kind read by the memory copy, stored as a
 byte to reduce record size.  \see CUpti_ActivityMemoryKind*/
    pub dstKind: u8,
    /** The flags associated with the memory copy. \see
 CUpti_ActivityFlag*/
    pub flags: u8,
    /// The number of bytes transferred by the memory copy.
    pub bytes: u64,
    /** The start timestamp for the memory copy, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory copy.*/
    pub start: u64,
    /** The end timestamp for the memory copy, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory copy.*/
    pub end: u64,
    /// The ID of the device where the memory copy is occurring.
    pub deviceId: u32,
    /// The ID of the context where the memory copy is occurring.
    pub contextId: u32,
    /// The ID of the stream where the memory copy is occurring.
    pub streamId: u32,
    /// The ID of the device where memory is being copied from.
    pub srcDeviceId: u32,
    /// The ID of the context owning the memory being copied from.
    pub srcContextId: u32,
    /// The ID of the device where memory is being copied to.
    pub dstDeviceId: u32,
    /// The ID of the context owning the memory being copied to.
    pub dstContextId: u32,
    /** The correlation ID of the memory copy. Each memory copy is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver and runtime API activity record that
 launched the memory copy.*/
    pub correlationId: u32,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
    /** The unique ID of the graph node that executed the memcpy through graph launch.
 This field will be 0 if memcpy is not done using graph launch.*/
    pub graphNodeId: u64,
    /** The unique ID of the graph that executed this memcpy through graph launch.
 This field will be 0 if the memcpy is not done through graph launch.*/
    pub graphId: u32,
    /// The ID of the HW channel on which the memory copy is occurring.
    pub channelID: u32,
    /// The type of the channel
    pub channelType: CUpti_ChannelType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemcpyPtoP4",
    ][::std::mem::size_of::<CUpti_ActivityMemcpyPtoP4>() - 96usize];
    [
        "Alignment of CUpti_ActivityMemcpyPtoP4",
    ][::std::mem::align_of::<CUpti_ActivityMemcpyPtoP4>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP4::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP4::copyKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, copyKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP4::srcKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, srcKind) - 5usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP4::dstKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, dstKind) - 6usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP4::flags",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, flags) - 7usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP4::bytes",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, bytes) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP4::start",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP4::end",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP4::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, deviceId) - 32usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP4::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, contextId) - 36usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP4::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, streamId) - 40usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP4::srcDeviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, srcDeviceId) - 44usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP4::srcContextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, srcContextId) - 48usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP4::dstDeviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, dstDeviceId) - 52usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP4::dstContextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, dstContextId) - 56usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP4::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, correlationId) - 60usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP4::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, reserved0) - 64usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP4::graphNodeId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, graphNodeId) - 72usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP4::graphId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, graphId) - 80usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP4::channelID",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, channelID) - 84usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP4::channelType",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, channelType) - 88usize];
};
impl Default for CUpti_ActivityMemcpyPtoP4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for memset.

 This activity record represents a memory set operation
 (CUPTI_ACTIVITY_KIND_MEMSET).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemset4 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMSET.
    pub kind: CUpti_ActivityKind,
    /// The value being assigned to memory by the memory set.
    pub value: u32,
    /// The number of bytes being set by the memory set.
    pub bytes: u64,
    /** The start timestamp for the memory set, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory set.*/
    pub start: u64,
    /** The end timestamp for the memory set, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory set.*/
    pub end: u64,
    /// The ID of the device where the memory set is occurring.
    pub deviceId: u32,
    /// The ID of the context where the memory set is occurring.
    pub contextId: u32,
    /// The ID of the stream where the memory set is occurring.
    pub streamId: u32,
    /** The correlation ID of the memory set. Each memory set is assigned
 a unique correlation ID that is identical to the correlation ID
 in the driver API activity record that launched the memory set.*/
    pub correlationId: u32,
    /// The flags associated with the memset. \see CUpti_ActivityFlag
    pub flags: u16,
    /// The memory kind of the memory set \see CUpti_ActivityMemoryKind
    pub memoryKind: u16,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
    /** The unique ID of the graph node that executed this memset through graph launch.
 This field will be 0 if the memset is not executed through graph launch.*/
    pub graphNodeId: u64,
    /** The unique ID of the graph that executed this memset through graph launch.
 This field will be 0 if the memset is not executed through graph launch.*/
    pub graphId: u32,
    /// The ID of the HW channel on which the memory set is occurring.
    pub channelID: u32,
    /// The type of the channel
    pub channelType: CUpti_ChannelType,
    /// This field is used to indicate if the memset operation is part of a device graph launch.
    pub isDeviceLaunched: u8,
    ///  Undefined. Reserved for internal use
    pub pad2: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemset4",
    ][::std::mem::size_of::<CUpti_ActivityMemset4>() - 88usize];
    [
        "Alignment of CUpti_ActivityMemset4",
    ][::std::mem::align_of::<CUpti_ActivityMemset4>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemset4::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMemset4, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMemset4::value",
    ][::std::mem::offset_of!(CUpti_ActivityMemset4, value) - 4usize];
    [
        "Offset of field: CUpti_ActivityMemset4::bytes",
    ][::std::mem::offset_of!(CUpti_ActivityMemset4, bytes) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemset4::start",
    ][::std::mem::offset_of!(CUpti_ActivityMemset4, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityMemset4::end",
    ][::std::mem::offset_of!(CUpti_ActivityMemset4, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityMemset4::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemset4, deviceId) - 32usize];
    [
        "Offset of field: CUpti_ActivityMemset4::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemset4, contextId) - 36usize];
    [
        "Offset of field: CUpti_ActivityMemset4::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityMemset4, streamId) - 40usize];
    [
        "Offset of field: CUpti_ActivityMemset4::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemset4, correlationId) - 44usize];
    [
        "Offset of field: CUpti_ActivityMemset4::flags",
    ][::std::mem::offset_of!(CUpti_ActivityMemset4, flags) - 48usize];
    [
        "Offset of field: CUpti_ActivityMemset4::memoryKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemset4, memoryKind) - 50usize];
    [
        "Offset of field: CUpti_ActivityMemset4::pad",
    ][::std::mem::offset_of!(CUpti_ActivityMemset4, pad) - 52usize];
    [
        "Offset of field: CUpti_ActivityMemset4::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityMemset4, reserved0) - 56usize];
    [
        "Offset of field: CUpti_ActivityMemset4::graphNodeId",
    ][::std::mem::offset_of!(CUpti_ActivityMemset4, graphNodeId) - 64usize];
    [
        "Offset of field: CUpti_ActivityMemset4::graphId",
    ][::std::mem::offset_of!(CUpti_ActivityMemset4, graphId) - 72usize];
    [
        "Offset of field: CUpti_ActivityMemset4::channelID",
    ][::std::mem::offset_of!(CUpti_ActivityMemset4, channelID) - 76usize];
    [
        "Offset of field: CUpti_ActivityMemset4::channelType",
    ][::std::mem::offset_of!(CUpti_ActivityMemset4, channelType) - 80usize];
    [
        "Offset of field: CUpti_ActivityMemset4::isDeviceLaunched",
    ][::std::mem::offset_of!(CUpti_ActivityMemset4, isDeviceLaunched) - 84usize];
    [
        "Offset of field: CUpti_ActivityMemset4::pad2",
    ][::std::mem::offset_of!(CUpti_ActivityMemset4, pad2) - 85usize];
};
impl Default for CUpti_ActivityMemset4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for memory.

 This activity record represents a memory allocation and free operation
 (CUPTI_ACTIVITY_KIND_MEMORY).
 This activity record provides a single record for the memory
 allocation and memory release operations.

 Note: It is recommended to move to the new activity record \ref CUpti_ActivityMemory4
 enabled using the kind \ref CUPTI_ACTIVITY_KIND_MEMORY2.
 \ref CUpti_ActivityMemory4 provides separate records for memory
 allocation and memory release operations. This allows to correlate the
 corresponding driver and runtime API activity record with the memory operation.*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemory {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMORY
    pub kind: CUpti_ActivityKind,
    /// The memory kind requested by the user
    pub memoryKind: CUpti_ActivityMemoryKind,
    /// The virtual address of the allocation
    pub address: u64,
    /// The number of bytes of memory allocated.
    pub bytes: u64,
    /** The start timestamp for the memory operation, i.e.
 the time when memory was allocated, in ns.*/
    pub start: u64,
    /** The end timestamp for the memory operation, i.e.
 the time when memory was freed, in ns.
 This will be 0 if memory is not freed in the application*/
    pub end: u64,
    /// The program counter of the allocation of memory
    pub allocPC: u64,
    /** The program counter of the freeing of memory. This will
 be 0 if memory is not freed in the application*/
    pub freePC: u64,
    /// The ID of the process to which this record belongs to.
    pub processId: u32,
    /// The ID of the device where the memory allocation is taking place.
    pub deviceId: u32,
    /// The ID of the context. If context is NULL, \p contextId is set to CUPTI_INVALID_CONTEXT_ID.
    pub contextId: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
    /** Variable name. This name is shared across all activity
 records representing the same symbol, and so should not be
 modified.*/
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemory",
    ][::std::mem::size_of::<CUpti_ActivityMemory>() - 80usize];
    [
        "Alignment of CUpti_ActivityMemory",
    ][::std::mem::align_of::<CUpti_ActivityMemory>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemory::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMemory, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMemory::memoryKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemory, memoryKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityMemory::address",
    ][::std::mem::offset_of!(CUpti_ActivityMemory, address) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemory::bytes",
    ][::std::mem::offset_of!(CUpti_ActivityMemory, bytes) - 16usize];
    [
        "Offset of field: CUpti_ActivityMemory::start",
    ][::std::mem::offset_of!(CUpti_ActivityMemory, start) - 24usize];
    [
        "Offset of field: CUpti_ActivityMemory::end",
    ][::std::mem::offset_of!(CUpti_ActivityMemory, end) - 32usize];
    [
        "Offset of field: CUpti_ActivityMemory::allocPC",
    ][::std::mem::offset_of!(CUpti_ActivityMemory, allocPC) - 40usize];
    [
        "Offset of field: CUpti_ActivityMemory::freePC",
    ][::std::mem::offset_of!(CUpti_ActivityMemory, freePC) - 48usize];
    [
        "Offset of field: CUpti_ActivityMemory::processId",
    ][::std::mem::offset_of!(CUpti_ActivityMemory, processId) - 56usize];
    [
        "Offset of field: CUpti_ActivityMemory::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemory, deviceId) - 60usize];
    [
        "Offset of field: CUpti_ActivityMemory::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemory, contextId) - 64usize];
    [
        "Offset of field: CUpti_ActivityMemory::pad",
    ][::std::mem::offset_of!(CUpti_ActivityMemory, pad) - 68usize];
    [
        "Offset of field: CUpti_ActivityMemory::name",
    ][::std::mem::offset_of!(CUpti_ActivityMemory, name) - 72usize];
};
impl Default for CUpti_ActivityMemory {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for memory.

 This activity record represents a memory allocation and free operation
 (CUPTI_ACTIVITY_KIND_MEMORY2).
 This activity record provides separate records for memory allocation and
 memory release operations.
 This allows to correlate the corresponding driver and runtime API
 activity record with the memory operation.

 Note: This activity record is an upgrade over \ref CUpti_ActivityMemory
 enabled using the kind \ref CUPTI_ACTIVITY_KIND_MEMORY.
 \ref CUpti_ActivityMemory provides a single record for the memory
 allocation and memory release operations.*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMemory4 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMORY2
    pub kind: CUpti_ActivityKind,
    /// The memory operation requested by the user, \ref CUpti_ActivityMemoryOperationType.
    pub memoryOperationType: CUpti_ActivityMemoryOperationType,
    /// The memory kind requested by the user, \ref CUpti_ActivityMemoryKind.
    pub memoryKind: CUpti_ActivityMemoryKind,
    /** The correlation ID of the memory operation. Each memory operation is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver and runtime API activity record that
 launched the memory operation.*/
    pub correlationId: u32,
    /// The virtual address of the allocation.
    pub address: u64,
    /// The number of bytes of memory allocated.
    pub bytes: u64,
    /// The start timestamp for the memory operation, in ns.
    pub timestamp: u64,
    /// The program counter of the memory operation.
    pub PC: u64,
    /// The ID of the process to which this record belongs to.
    pub processId: u32,
    /// The ID of the device where the memory operation is taking place.
    pub deviceId: u32,
    /// The ID of the context. If context is NULL, \p contextId is set to CUPTI_INVALID_CONTEXT_ID.
    pub contextId: u32,
    /// The ID of the stream. If memory operation is not async, \p streamId is set to CUPTI_INVALID_STREAM_ID.
    pub streamId: u32,
    /** Variable name. This name is shared across all activity
 records representing the same symbol, and so should not be
 modified.*/
    pub name: *const ::std::os::raw::c_char,
    /// \p isAsync is set if memory operation happens through async memory APIs.
    pub isAsync: u32,
    /// Undefined. Reserved for internal use.
    pub pad1: u32,
    pub memoryPoolConfig: CUpti_ActivityMemory4__bindgen_ty_1,
    /// The shared object or binary that the memory allocation request comes from.
    pub source: *const ::std::os::raw::c_char,
}
/// The memory pool configuration used for the memory operations.
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMemory4__bindgen_ty_1 {
    /// The type of the memory pool, \ref CUpti_ActivityMemoryPoolType
    pub memoryPoolType: CUpti_ActivityMemoryPoolType,
    /// Undefined. Reserved for internal use.
    pub pad2: u32,
    /// The base address of the memory pool.
    pub address: u64,
    /** The release threshold of the memory pool in bytes. \p releaseThreshold is
 valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \ref CUpti_ActivityMemoryPoolType.*/
    pub releaseThreshold: u64,
    pub pool: CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1,
    /** The utilized size of the memory pool. \p utilizedSize is
 valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \ref CUpti_ActivityMemoryPoolType.*/
    pub utilizedSize: u64,
}
/** The size of memory pool in bytes and the processId of the memory pools
 \p size is valid if \p memoryPoolType is
 CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \ref CUpti_ActivityMemoryPoolType.
 \p processId is valid if \p memoryPoolType is
 CUPTI_ACTIVITY_MEMORY_POOL_TYPE_IMPORTED, \ref CUpti_ActivityMemoryPoolType*/
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1 {
    pub size: u64,
    pub processId: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1>()
        - 8usize];
    [
        "Alignment of CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1>()
        - 8usize];
    [
        "Offset of field: CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1::size",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1, size)
        - 0usize];
    [
        "Offset of field: CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1::processId",
    ][::std::mem::offset_of!(
        CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1, processId
    ) - 0usize];
};
impl Default for CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemory4__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityMemory4__bindgen_ty_1>() - 40usize];
    [
        "Alignment of CUpti_ActivityMemory4__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityMemory4__bindgen_ty_1>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemory4__bindgen_ty_1::memoryPoolType",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4__bindgen_ty_1, memoryPoolType)
        - 0usize];
    [
        "Offset of field: CUpti_ActivityMemory4__bindgen_ty_1::pad2",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4__bindgen_ty_1, pad2) - 4usize];
    [
        "Offset of field: CUpti_ActivityMemory4__bindgen_ty_1::address",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4__bindgen_ty_1, address) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemory4__bindgen_ty_1::releaseThreshold",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4__bindgen_ty_1, releaseThreshold)
        - 16usize];
    [
        "Offset of field: CUpti_ActivityMemory4__bindgen_ty_1::pool",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4__bindgen_ty_1, pool) - 24usize];
    [
        "Offset of field: CUpti_ActivityMemory4__bindgen_ty_1::utilizedSize",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4__bindgen_ty_1, utilizedSize)
        - 32usize];
};
impl Default for CUpti_ActivityMemory4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMemory4__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMemory4__bindgen_ty_1 {{ memoryPoolType: {:?}, pool: {:?} }}",
            self.memoryPoolType,
            self.pool,
        )
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemory4",
    ][::std::mem::size_of::<CUpti_ActivityMemory4>() - 128usize];
    [
        "Alignment of CUpti_ActivityMemory4",
    ][::std::mem::align_of::<CUpti_ActivityMemory4>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemory4::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMemory4::memoryOperationType",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4, memoryOperationType) - 4usize];
    [
        "Offset of field: CUpti_ActivityMemory4::memoryKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4, memoryKind) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemory4::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4, correlationId) - 12usize];
    [
        "Offset of field: CUpti_ActivityMemory4::address",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4, address) - 16usize];
    [
        "Offset of field: CUpti_ActivityMemory4::bytes",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4, bytes) - 24usize];
    [
        "Offset of field: CUpti_ActivityMemory4::timestamp",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4, timestamp) - 32usize];
    [
        "Offset of field: CUpti_ActivityMemory4::PC",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4, PC) - 40usize];
    [
        "Offset of field: CUpti_ActivityMemory4::processId",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4, processId) - 48usize];
    [
        "Offset of field: CUpti_ActivityMemory4::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4, deviceId) - 52usize];
    [
        "Offset of field: CUpti_ActivityMemory4::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4, contextId) - 56usize];
    [
        "Offset of field: CUpti_ActivityMemory4::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4, streamId) - 60usize];
    [
        "Offset of field: CUpti_ActivityMemory4::name",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4, name) - 64usize];
    [
        "Offset of field: CUpti_ActivityMemory4::isAsync",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4, isAsync) - 72usize];
    [
        "Offset of field: CUpti_ActivityMemory4::pad1",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4, pad1) - 76usize];
    [
        "Offset of field: CUpti_ActivityMemory4::memoryPoolConfig",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4, memoryPoolConfig) - 80usize];
    [
        "Offset of field: CUpti_ActivityMemory4::source",
    ][::std::mem::offset_of!(CUpti_ActivityMemory4, source) - 120usize];
};
impl Default for CUpti_ActivityMemory4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMemory4 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMemory4 {{ kind: {:?}, memoryOperationType: {:?}, memoryKind: {:?}, name: {:?}, memoryPoolConfig: {:?}, source: {:?} }}",
            self.kind,
            self.memoryOperationType,
            self.memoryKind,
            self.name,
            self.memoryPoolConfig,
            self.source,
        )
    }
}
/** \brief The activity record for memory pool.

 This activity record represents a memory pool creation, destruction and
 trimming (CUPTI_ACTIVITY_KIND_MEMORY_POOL).
 This activity record provides separate records for memory pool creation,
 destruction and trimming operations.
 This allows to correlate the corresponding driver and runtime API
 activity record with the memory pool operation.
*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemoryPool3 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMORY_POOL
    pub kind: CUpti_ActivityKind,
    /// The memory operation requested by the user, \ref CUpti_ActivityMemoryPoolOperationType.
    pub memoryPoolOperationType: CUpti_ActivityMemoryPoolOperationType,
    /// The type of the memory pool, \ref CUpti_ActivityMemoryPoolType
    pub memoryPoolType: CUpti_ActivityMemoryPoolType,
    /** The correlation ID of the memory pool operation. Each memory pool
 operation is assigned a unique correlation ID that is identical to the
 correlation ID in the driver and runtime API activity record that
 launched the memory operation.*/
    pub correlationId: u32,
    /// The ID of the process to which this record belongs to.
    pub processId: u32,
    /// The ID of the device where the memory pool is created.
    pub deviceId: u32,
    /** The minimum bytes to keep of the memory pool. \p minBytesToKeep is
 valid for CUPTI_ACTIVITY_MEMORY_POOL_OPERATION_TYPE_TRIMMED,
 \ref CUpti_ActivityMemoryPoolOperationType*/
    pub minBytesToKeep: usize,
    /// The virtual address of the allocation.
    pub address: u64,
    /** The size of the memory pool operation in bytes. \p size is
 valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \ref CUpti_ActivityMemoryPoolType.*/
    pub size: u64,
    /** The release threshold of the memory pool. \p releaseThreshold is
 valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \ref CUpti_ActivityMemoryPoolType.*/
    pub releaseThreshold: u64,
    /// The start timestamp for the memory operation, in ns.
    pub timestamp: u64,
    /** The utilized size of the memory pool. \p utilizedSize is
 valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \ref CUpti_ActivityMemoryPoolType.*/
    pub utilizedSize: u64,
    /** Whether the pool is of managed memory allocation or pinned memory allocation.
 If it is 0, it is pinned and if it is 1, the memory pool allocation is of managed memory type.*/
    pub isManagedPool: u8,
    /// Undefined. Reserved for internal use.
    pub pad2: [u8; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemoryPool3",
    ][::std::mem::size_of::<CUpti_ActivityMemoryPool3>() - 80usize];
    [
        "Alignment of CUpti_ActivityMemoryPool3",
    ][::std::mem::align_of::<CUpti_ActivityMemoryPool3>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool3::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool3, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool3::memoryPoolOperationType",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool3, memoryPoolOperationType)
        - 4usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool3::memoryPoolType",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool3, memoryPoolType) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool3::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool3, correlationId) - 12usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool3::processId",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool3, processId) - 16usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool3::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool3, deviceId) - 20usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool3::minBytesToKeep",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool3, minBytesToKeep) - 24usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool3::address",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool3, address) - 32usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool3::size",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool3, size) - 40usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool3::releaseThreshold",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool3, releaseThreshold) - 48usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool3::timestamp",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool3, timestamp) - 56usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool3::utilizedSize",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool3, utilizedSize) - 64usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool3::isManagedPool",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool3, isManagedPool) - 72usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool3::pad2",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool3, pad2) - 73usize];
};
impl Default for CUpti_ActivityMemoryPool3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// The kernel was launched via a regular kernel call
pub const CUPTI_ACTIVITY_LAUNCH_TYPE_REGULAR: CUpti_ActivityLaunchType = 0;
/** The kernel was launched via API \ref cudaLaunchCooperativeKernel() or
 \ref cuLaunchCooperativeKernel()*/
pub const CUPTI_ACTIVITY_LAUNCH_TYPE_COOPERATIVE_SINGLE_DEVICE: CUpti_ActivityLaunchType = 1;
/** The kernel was launched via API \ref cudaLaunchCooperativeKernelMultiDevice() or
 \ref cuLaunchCooperativeKernelMultiDevice()*/
pub const CUPTI_ACTIVITY_LAUNCH_TYPE_COOPERATIVE_MULTI_DEVICE: CUpti_ActivityLaunchType = 2;
/// The kernel was launched as a CBL commandlist
pub const CUPTI_ACTIVITY_LAUNCH_TYPE_CBL_COMMANDLIST: CUpti_ActivityLaunchType = 3;
/// \brief The type of the CUDA kernel launch.
pub type CUpti_ActivityLaunchType = ::std::os::raw::c_uint;
/// The shared memory limit config is default
pub const CUPTI_FUNC_SHMEM_LIMIT_DEFAULT: CUpti_FuncShmemLimitConfig = 0;
/** User has opted for a higher dynamic shared memory limit using function attribute
 'cudaFuncAttributeMaxDynamicSharedMemorySize' for runtime API or
 CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES for driver API*/
pub const CUPTI_FUNC_SHMEM_LIMIT_OPTIN: CUpti_FuncShmemLimitConfig = 1;
/** User has opted for a higher dynamic shared memory limit using function attribute
 'cudaFuncAttributeMaxDynamicSharedMemorySize' for runtime API or
 CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES for driver API*/
pub const CUPTI_FUNC_SHMEM_LIMIT_FORCE_INT: CUpti_FuncShmemLimitConfig = 2147483647;
/** \brief The shared memory limit per block config for a kernel
 This should be used to set 'cudaOccFuncShmemConfig' field in occupancy calculator API*/
pub type CUpti_FuncShmemLimitConfig = ::std::os::raw::c_uint;
/** \brief The activity record for kernel.

 This activity record represents a kernel execution
 (CUPTI_ACTIVITY_KIND_KERNEL and
 CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL)*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityKernel10 {
    /** The activity record kind, must be CUPTI_ACTIVITY_KIND_KERNEL or
 CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL.*/
    pub kind: CUpti_ActivityKind,
    pub cacheConfig: CUpti_ActivityKernel10__bindgen_ty_1,
    /** The shared memory configuration used for the kernel. The value is one of
 the CUsharedconfig enumeration values from cuda.h.*/
    pub sharedMemoryConfig: u8,
    /** The number of registers required for each thread executing the
 kernel.*/
    pub registersPerThread: u16,
    /** The partitioned global caching requested for the kernel. Partitioned
 global caching is required to enable caching on certain chips, such as
 devices with compute capability 5.2.*/
    pub partitionedGlobalCacheRequested: CUpti_ActivityPartitionedGlobalCacheConfig,
    /** The partitioned global caching executed for the kernel. Partitioned
 global caching is required to enable caching on certain chips, such as
 devices with compute capability 5.2. Partitioned global caching can be
 automatically disabled if the occupancy requirement of the launch cannot
 support caching.*/
    pub partitionedGlobalCacheExecuted: CUpti_ActivityPartitionedGlobalCacheConfig,
    /** The start timestamp for the kernel execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the kernel.*/
    pub start: u64,
    /** The end timestamp for the kernel execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the kernel.*/
    pub end: u64,
    /** The completed timestamp for the kernel execution, in ns.  It
 represents the completion of all it's child kernels and the
 kernel itself. A value of CUPTI_TIMESTAMP_UNKNOWN indicates that
 the completion time is unknown.*/
    pub completed: u64,
    /// The ID of the device where the kernel is executing.
    pub deviceId: u32,
    /// The ID of the context where the kernel is executing.
    pub contextId: u32,
    /// The ID of the stream where the kernel is executing.
    pub streamId: u32,
    /// The X-dimension grid size for the kernel.
    pub gridX: i32,
    /// The Y-dimension grid size for the kernel.
    pub gridY: i32,
    /// The Z-dimension grid size for the kernel.
    pub gridZ: i32,
    /// The X-dimension block size for the kernel.
    pub blockX: i32,
    /// The Y-dimension block size for the kernel.
    pub blockY: i32,
    /// The Z-dimension grid size for the kernel.
    pub blockZ: i32,
    /// The static shared memory allocated for the kernel, in bytes.
    pub staticSharedMemory: i32,
    /// The dynamic shared memory reserved for the kernel, in bytes.
    pub dynamicSharedMemory: i32,
    /// The amount of local memory reserved for each thread, in bytes.
    pub localMemoryPerThread: u32,
    /** The total amount of local memory reserved for the kernel, in
 bytes (deprecated in CUDA 11.8).
 Refer field localMemoryTotal_v2*/
    pub localMemoryTotal: u32,
    /** The correlation ID of the kernel. Each kernel execution is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver or runtime API activity record that
 launched the kernel.*/
    pub correlationId: u32,
    /** The grid ID of the kernel. Each kernel is assigned a unique
 grid ID at runtime.*/
    pub gridId: i64,
    /** The name of the kernel. This name is shared across all activity
 records representing the same kernel, and so should not be
 modified.*/
    pub name: *const ::std::os::raw::c_char,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
    /** The timestamp when the kernel is queued up in the command buffer, in ns.
 A value of CUPTI_TIMESTAMP_UNKNOWN indicates that the queued time
 could not be collected for the kernel. This timestamp is not collected
 by default. Use API \ref cuptiActivityEnableLatencyTimestamps() to
 enable collection.

 Command buffer is a buffer written by CUDA driver to send commands
 like kernel launch, memory copy etc to the GPU. All launches of CUDA
 kernels are asynchronous with respect to the host, the host requests
 the launch by writing commands into the command buffer, then returns
 without checking the GPU's progress.*/
    pub queued: u64,
    /** The timestamp when the command buffer containing the kernel launch
 is submitted to the GPU, in ns. A value of CUPTI_TIMESTAMP_UNKNOWN
 indicates that the submitted time could not be collected for the kernel.
 This timestamp is not collected by default. Use API \ref
 cuptiActivityEnableLatencyTimestamps() to enable collection.*/
    pub submitted: u64,
    /** The indicates if the kernel was executed via a regular launch or via a
 single/multi device cooperative launch. \see CUpti_ActivityLaunchType*/
    pub launchType: u8,
    /** This indicates if CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT was
 updated for the kernel launch*/
    pub isSharedMemoryCarveoutRequested: u8,
    /** Shared memory carveout value requested for the function in percentage of
 the total resource. The value will be updated only if field
 isSharedMemoryCarveoutRequested is set.*/
    pub sharedMemoryCarveoutRequested: u8,
    /// Undefined. Reserved for internal use.
    pub padding: u8,
    /// Shared memory size set by the driver.
    pub sharedMemoryExecuted: u32,
    /** The unique ID of the graph node that launched this kernel through graph launch APIs.
 This field will be 0 if the kernel is not launched through graph launch APIs.*/
    pub graphNodeId: u64,
    /** The shared memory limit config for the kernel. This field shows whether user has opted for a
 higher per block limit of dynamic shared memory.*/
    pub shmemLimitConfig: CUpti_FuncShmemLimitConfig,
    /** The unique ID of the graph that launched this kernel through graph launch APIs.
 This field will be 0 if the kernel is not launched through graph launch APIs.*/
    pub graphId: u32,
    /** The pointer to the access policy window. The structure CUaccessPolicyWindow is
 defined in cuda.h.*/
    pub pAccessPolicyWindow: *mut CUaccessPolicyWindow,
    /// The ID of the HW channel on which the kernel is launched.
    pub channelID: u32,
    /// The type of the channel
    pub channelType: CUpti_ChannelType,
    /** The X-dimension cluster size for the kernel.
 Field is valid for devices with compute capability 9.0 and higher*/
    pub clusterX: u32,
    /** The Y-dimension cluster size for the kernel.
 Field is valid for devices with compute capability 9.0 and higher*/
    pub clusterY: u32,
    /** The Z-dimension cluster size for the kernel.
 Field is valid for devices with compute capability 9.0 and higher*/
    pub clusterZ: u32,
    /** The cluster scheduling policy for the kernel. Refer CUclusterSchedulingPolicy
 Field is valid for devices with compute capability 9.0 and higher*/
    pub clusterSchedulingPolicy: u32,
    /** The total amount of local memory reserved for the kernel, in
 bytes.*/
    pub localMemoryTotal_v2: u64,
    /// The maximum cluster size for the kernel
    pub maxPotentialClusterSize: u32,
    /// The maximum clusters that could co-exist on the target device for the kernel
    pub maxActiveClusters: u32,
    /// This field is set to 1 if the kernel is part of a device launched graph.
    pub isDeviceLaunched: u8,
    pub padding3: [u8; 7usize],
}
/** For devices with compute capability 7.5+ cacheConfig values are not updated
 in case field isSharedMemoryCarveoutRequested is set*/
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityKernel10__bindgen_ty_1 {
    pub both: u8,
    pub config: CUpti_ActivityKernel10__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityKernel10__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel10__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityKernel10__bindgen_ty_1__bindgen_ty_1>()
        - 1usize];
    [
        "Alignment of CUpti_ActivityKernel10__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityKernel10__bindgen_ty_1__bindgen_ty_1>()
        - 1usize];
};
impl CUpti_ActivityKernel10__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn requested(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_requested(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn requested_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 1usize],
                >>::raw_get(::std::ptr::addr_of!((*this)._bitfield_1), 0usize, 4u8) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_requested_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 1usize],
            >>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn executed(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_executed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn executed_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 1usize],
                >>::raw_get(::std::ptr::addr_of!((*this)._bitfield_1), 4usize, 4u8) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_executed_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 1usize],
            >>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        requested: u8,
        executed: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit
            .set(
                0usize,
                4u8,
                {
                    let requested: u8 = unsafe { ::std::mem::transmute(requested) };
                    requested as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                4usize,
                4u8,
                {
                    let executed: u8 = unsafe { ::std::mem::transmute(executed) };
                    executed as u64
                },
            );
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel10__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityKernel10__bindgen_ty_1>() - 1usize];
    [
        "Alignment of CUpti_ActivityKernel10__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityKernel10__bindgen_ty_1>() - 1usize];
    [
        "Offset of field: CUpti_ActivityKernel10__bindgen_ty_1::both",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10__bindgen_ty_1, both) - 0usize];
    [
        "Offset of field: CUpti_ActivityKernel10__bindgen_ty_1::config",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10__bindgen_ty_1, config) - 0usize];
};
impl Default for CUpti_ActivityKernel10__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel10__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityKernel10__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel10",
    ][::std::mem::size_of::<CUpti_ActivityKernel10>() - 216usize];
    [
        "Alignment of CUpti_ActivityKernel10",
    ][::std::mem::align_of::<CUpti_ActivityKernel10>() - 8usize];
    [
        "Offset of field: CUpti_ActivityKernel10::kind",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityKernel10::cacheConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, cacheConfig) - 4usize];
    [
        "Offset of field: CUpti_ActivityKernel10::sharedMemoryConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, sharedMemoryConfig) - 5usize];
    [
        "Offset of field: CUpti_ActivityKernel10::registersPerThread",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, registersPerThread) - 6usize];
    [
        "Offset of field: CUpti_ActivityKernel10::partitionedGlobalCacheRequested",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, partitionedGlobalCacheRequested)
        - 8usize];
    [
        "Offset of field: CUpti_ActivityKernel10::partitionedGlobalCacheExecuted",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, partitionedGlobalCacheExecuted)
        - 12usize];
    [
        "Offset of field: CUpti_ActivityKernel10::start",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityKernel10::end",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityKernel10::completed",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, completed) - 32usize];
    [
        "Offset of field: CUpti_ActivityKernel10::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, deviceId) - 40usize];
    [
        "Offset of field: CUpti_ActivityKernel10::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, contextId) - 44usize];
    [
        "Offset of field: CUpti_ActivityKernel10::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, streamId) - 48usize];
    [
        "Offset of field: CUpti_ActivityKernel10::gridX",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, gridX) - 52usize];
    [
        "Offset of field: CUpti_ActivityKernel10::gridY",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, gridY) - 56usize];
    [
        "Offset of field: CUpti_ActivityKernel10::gridZ",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, gridZ) - 60usize];
    [
        "Offset of field: CUpti_ActivityKernel10::blockX",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, blockX) - 64usize];
    [
        "Offset of field: CUpti_ActivityKernel10::blockY",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, blockY) - 68usize];
    [
        "Offset of field: CUpti_ActivityKernel10::blockZ",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, blockZ) - 72usize];
    [
        "Offset of field: CUpti_ActivityKernel10::staticSharedMemory",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, staticSharedMemory) - 76usize];
    [
        "Offset of field: CUpti_ActivityKernel10::dynamicSharedMemory",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, dynamicSharedMemory) - 80usize];
    [
        "Offset of field: CUpti_ActivityKernel10::localMemoryPerThread",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, localMemoryPerThread) - 84usize];
    [
        "Offset of field: CUpti_ActivityKernel10::localMemoryTotal",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, localMemoryTotal) - 88usize];
    [
        "Offset of field: CUpti_ActivityKernel10::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, correlationId) - 92usize];
    [
        "Offset of field: CUpti_ActivityKernel10::gridId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, gridId) - 96usize];
    [
        "Offset of field: CUpti_ActivityKernel10::name",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, name) - 104usize];
    [
        "Offset of field: CUpti_ActivityKernel10::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, reserved0) - 112usize];
    [
        "Offset of field: CUpti_ActivityKernel10::queued",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, queued) - 120usize];
    [
        "Offset of field: CUpti_ActivityKernel10::submitted",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, submitted) - 128usize];
    [
        "Offset of field: CUpti_ActivityKernel10::launchType",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, launchType) - 136usize];
    [
        "Offset of field: CUpti_ActivityKernel10::isSharedMemoryCarveoutRequested",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, isSharedMemoryCarveoutRequested)
        - 137usize];
    [
        "Offset of field: CUpti_ActivityKernel10::sharedMemoryCarveoutRequested",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, sharedMemoryCarveoutRequested)
        - 138usize];
    [
        "Offset of field: CUpti_ActivityKernel10::padding",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, padding) - 139usize];
    [
        "Offset of field: CUpti_ActivityKernel10::sharedMemoryExecuted",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, sharedMemoryExecuted) - 140usize];
    [
        "Offset of field: CUpti_ActivityKernel10::graphNodeId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, graphNodeId) - 144usize];
    [
        "Offset of field: CUpti_ActivityKernel10::shmemLimitConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, shmemLimitConfig) - 152usize];
    [
        "Offset of field: CUpti_ActivityKernel10::graphId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, graphId) - 156usize];
    [
        "Offset of field: CUpti_ActivityKernel10::pAccessPolicyWindow",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, pAccessPolicyWindow) - 160usize];
    [
        "Offset of field: CUpti_ActivityKernel10::channelID",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, channelID) - 168usize];
    [
        "Offset of field: CUpti_ActivityKernel10::channelType",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, channelType) - 172usize];
    [
        "Offset of field: CUpti_ActivityKernel10::clusterX",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, clusterX) - 176usize];
    [
        "Offset of field: CUpti_ActivityKernel10::clusterY",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, clusterY) - 180usize];
    [
        "Offset of field: CUpti_ActivityKernel10::clusterZ",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, clusterZ) - 184usize];
    [
        "Offset of field: CUpti_ActivityKernel10::clusterSchedulingPolicy",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, clusterSchedulingPolicy)
        - 188usize];
    [
        "Offset of field: CUpti_ActivityKernel10::localMemoryTotal_v2",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, localMemoryTotal_v2) - 192usize];
    [
        "Offset of field: CUpti_ActivityKernel10::maxPotentialClusterSize",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, maxPotentialClusterSize)
        - 200usize];
    [
        "Offset of field: CUpti_ActivityKernel10::maxActiveClusters",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, maxActiveClusters) - 204usize];
    [
        "Offset of field: CUpti_ActivityKernel10::isDeviceLaunched",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, isDeviceLaunched) - 208usize];
    [
        "Offset of field: CUpti_ActivityKernel10::padding3",
    ][::std::mem::offset_of!(CUpti_ActivityKernel10, padding3) - 209usize];
};
impl Default for CUpti_ActivityKernel10 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel10 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityKernel10 {{ kind: {:?}, cacheConfig: {:?}, partitionedGlobalCacheRequested: {:?}, partitionedGlobalCacheExecuted: {:?}, name: {:?}, reserved0: {:?}, shmemLimitConfig: {:?}, pAccessPolicyWindow: {:?}, channelType: {:?}, padding3: {:?} }}",
            self.kind,
            self.cacheConfig,
            self.partitionedGlobalCacheRequested,
            self.partitionedGlobalCacheExecuted,
            self.name,
            self.reserved0,
            self.shmemLimitConfig,
            self.pAccessPolicyWindow,
            self.channelType,
            self.padding3,
        )
    }
}
/** \brief The activity record for CDP (CUDA Dynamic Parallelism)
 kernel.

 This activity record represents a CDP kernel execution.*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityCdpKernel {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_CDP_KERNEL
    pub kind: CUpti_ActivityKind,
    pub cacheConfig: CUpti_ActivityCdpKernel__bindgen_ty_1,
    /** The shared memory configuration used for the kernel. The value is one of
 the CUsharedconfig enumeration values from cuda.h.*/
    pub sharedMemoryConfig: u8,
    /** The number of registers required for each thread executing the
 kernel.*/
    pub registersPerThread: u16,
    /** The start timestamp for the kernel execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the kernel.*/
    pub start: u64,
    /** The end timestamp for the kernel execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the kernel.*/
    pub end: u64,
    /// The ID of the device where the kernel is executing.
    pub deviceId: u32,
    /// The ID of the context where the kernel is executing.
    pub contextId: u32,
    /// The ID of the stream where the kernel is executing.
    pub streamId: u32,
    /// The X-dimension grid size for the kernel.
    pub gridX: i32,
    /// The Y-dimension grid size for the kernel.
    pub gridY: i32,
    /// The Z-dimension grid size for the kernel.
    pub gridZ: i32,
    /// The X-dimension block size for the kernel.
    pub blockX: i32,
    /// The Y-dimension block size for the kernel.
    pub blockY: i32,
    /// The Z-dimension grid size for the kernel.
    pub blockZ: i32,
    /// The static shared memory allocated for the kernel, in bytes.
    pub staticSharedMemory: i32,
    /// The dynamic shared memory reserved for the kernel, in bytes.
    pub dynamicSharedMemory: i32,
    /// The amount of local memory reserved for each thread, in bytes.
    pub localMemoryPerThread: u32,
    /** The total amount of local memory reserved for the kernel, in
 bytes.*/
    pub localMemoryTotal: u32,
    /** The correlation ID of the kernel. Each kernel execution is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver API activity record that launched
 the kernel.*/
    pub correlationId: u32,
    /** The grid ID of the kernel. Each kernel execution
 is assigned a unique grid ID.*/
    pub gridId: i64,
    /// The grid ID of the parent kernel.
    pub parentGridId: i64,
    /** The timestamp when kernel is queued up, in ns. A value of
 CUPTI_TIMESTAMP_UNKNOWN indicates that the queued time is
 unknown.*/
    pub queued: u64,
    /** The timestamp when kernel is submitted to the gpu, in ns. A value
 of CUPTI_TIMESTAMP_UNKNOWN indicates that the submission time is
 unknown.*/
    pub submitted: u64,
    /** The timestamp when kernel is marked as completed, in ns. A value
 of CUPTI_TIMESTAMP_UNKNOWN indicates that the completion time is
 unknown.*/
    pub completed: u64,
    /// The X-dimension of the parent block.
    pub parentBlockX: u32,
    /// The Y-dimension of the parent block.
    pub parentBlockY: u32,
    /// The Z-dimension of the parent block.
    pub parentBlockZ: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
    /** The name of the kernel. This name is shared across all activity
 records representing the same kernel, and so should not be
 modified.*/
    pub name: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityCdpKernel__bindgen_ty_1 {
    pub both: u8,
    pub config: CUpti_ActivityCdpKernel__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityCdpKernel__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityCdpKernel__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityCdpKernel__bindgen_ty_1__bindgen_ty_1>()
        - 1usize];
    [
        "Alignment of CUpti_ActivityCdpKernel__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityCdpKernel__bindgen_ty_1__bindgen_ty_1>()
        - 1usize];
};
impl CUpti_ActivityCdpKernel__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn requested(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_requested(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn requested_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 1usize],
                >>::raw_get(::std::ptr::addr_of!((*this)._bitfield_1), 0usize, 4u8) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_requested_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 1usize],
            >>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn executed(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_executed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn executed_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 1usize],
                >>::raw_get(::std::ptr::addr_of!((*this)._bitfield_1), 4usize, 4u8) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_executed_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 1usize],
            >>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        requested: u8,
        executed: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit
            .set(
                0usize,
                4u8,
                {
                    let requested: u8 = unsafe { ::std::mem::transmute(requested) };
                    requested as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                4usize,
                4u8,
                {
                    let executed: u8 = unsafe { ::std::mem::transmute(executed) };
                    executed as u64
                },
            );
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityCdpKernel__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityCdpKernel__bindgen_ty_1>() - 1usize];
    [
        "Alignment of CUpti_ActivityCdpKernel__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityCdpKernel__bindgen_ty_1>() - 1usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel__bindgen_ty_1::both",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel__bindgen_ty_1, both) - 0usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel__bindgen_ty_1::config",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel__bindgen_ty_1, config) - 0usize];
};
impl Default for CUpti_ActivityCdpKernel__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityCdpKernel__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityCdpKernel__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityCdpKernel",
    ][::std::mem::size_of::<CUpti_ActivityCdpKernel>() - 144usize];
    [
        "Alignment of CUpti_ActivityCdpKernel",
    ][::std::mem::align_of::<CUpti_ActivityCdpKernel>() - 8usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::kind",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::cacheConfig",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, cacheConfig) - 4usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::sharedMemoryConfig",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, sharedMemoryConfig) - 5usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::registersPerThread",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, registersPerThread) - 6usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::start",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, start) - 8usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::end",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, end) - 16usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, deviceId) - 24usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, contextId) - 28usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, streamId) - 32usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::gridX",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, gridX) - 36usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::gridY",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, gridY) - 40usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::gridZ",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, gridZ) - 44usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::blockX",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, blockX) - 48usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::blockY",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, blockY) - 52usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::blockZ",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, blockZ) - 56usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::staticSharedMemory",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, staticSharedMemory) - 60usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::dynamicSharedMemory",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, dynamicSharedMemory) - 64usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::localMemoryPerThread",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, localMemoryPerThread) - 68usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::localMemoryTotal",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, localMemoryTotal) - 72usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, correlationId) - 76usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::gridId",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, gridId) - 80usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::parentGridId",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, parentGridId) - 88usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::queued",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, queued) - 96usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::submitted",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, submitted) - 104usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::completed",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, completed) - 112usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::parentBlockX",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, parentBlockX) - 120usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::parentBlockY",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, parentBlockY) - 124usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::parentBlockZ",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, parentBlockZ) - 128usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::pad",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, pad) - 132usize];
    [
        "Offset of field: CUpti_ActivityCdpKernel::name",
    ][::std::mem::offset_of!(CUpti_ActivityCdpKernel, name) - 136usize];
};
impl Default for CUpti_ActivityCdpKernel {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityCdpKernel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityCdpKernel {{ kind: {:?}, cacheConfig: {:?}, name: {:?} }}",
            self.kind,
            self.cacheConfig,
            self.name,
        )
    }
}
/** \brief The activity record for a preemption of a CDP kernel.

 This activity record represents a preemption of a CDP kernel.*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityPreemption {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_PREEMPTION
    pub kind: CUpti_ActivityKind,
    /// kind of the preemption
    pub preemptionKind: CUpti_ActivityPreemptionKind,
    /** The timestamp of the preemption, in ns. A value of 0 indicates
 that timestamp information could not be collected for the
 preemption.*/
    pub timestamp: u64,
    /// The grid-id of the block that is preempted
    pub gridId: i64,
    /// The X-dimension of the block that is preempted
    pub blockX: u32,
    /// The Y-dimension of the block that is preempted
    pub blockY: u32,
    /// The Z-dimension of the block that is preempted
    pub blockZ: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityPreemption",
    ][::std::mem::size_of::<CUpti_ActivityPreemption>() - 40usize];
    [
        "Alignment of CUpti_ActivityPreemption",
    ][::std::mem::align_of::<CUpti_ActivityPreemption>() - 8usize];
    [
        "Offset of field: CUpti_ActivityPreemption::kind",
    ][::std::mem::offset_of!(CUpti_ActivityPreemption, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityPreemption::preemptionKind",
    ][::std::mem::offset_of!(CUpti_ActivityPreemption, preemptionKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityPreemption::timestamp",
    ][::std::mem::offset_of!(CUpti_ActivityPreemption, timestamp) - 8usize];
    [
        "Offset of field: CUpti_ActivityPreemption::gridId",
    ][::std::mem::offset_of!(CUpti_ActivityPreemption, gridId) - 16usize];
    [
        "Offset of field: CUpti_ActivityPreemption::blockX",
    ][::std::mem::offset_of!(CUpti_ActivityPreemption, blockX) - 24usize];
    [
        "Offset of field: CUpti_ActivityPreemption::blockY",
    ][::std::mem::offset_of!(CUpti_ActivityPreemption, blockY) - 28usize];
    [
        "Offset of field: CUpti_ActivityPreemption::blockZ",
    ][::std::mem::offset_of!(CUpti_ActivityPreemption, blockZ) - 32usize];
    [
        "Offset of field: CUpti_ActivityPreemption::pad",
    ][::std::mem::offset_of!(CUpti_ActivityPreemption, pad) - 36usize];
};
impl Default for CUpti_ActivityPreemption {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for a driver or runtime API invocation.

 This activity record represents an invocation of a driver or
 runtime API (CUPTI_ACTIVITY_KIND_DRIVER and
 CUPTI_ACTIVITY_KIND_RUNTIME).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityAPI {
    /** The activity record kind, must be CUPTI_ACTIVITY_KIND_DRIVER,
 CUPTI_ACTIVITY_KIND_RUNTIME, or CUPTI_ACTIVITY_KIND_INTERNAL_LAUNCH_API.*/
    pub kind: CUpti_ActivityKind,
    /// The ID of the driver or runtime function.
    pub cbid: CUpti_CallbackId,
    /** The start timestamp for the function, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the function.*/
    pub start: u64,
    /** The end timestamp for the function, in ns. A value of 0 for both
 the start and end timestamps indicates that timestamp information
 could not be collected for the function.*/
    pub end: u64,
    /** The ID of the process where the driver or runtime CUDA function
 is executing.*/
    pub processId: u32,
    /** The ID of the thread where the driver or runtime CUDA function is
 executing.*/
    pub threadId: u32,
    /** The correlation ID of the driver or runtime CUDA function. Each
 function invocation is assigned a unique correlation ID that is
 identical to the correlation ID in the memcpy, memset, or kernel
 activity record that is associated with this function.*/
    pub correlationId: u32,
    /** The return value for the function. For a CUDA driver function
 with will be a CUresult value, and for a CUDA runtime function
 this will be a cudaError_t value.*/
    pub returnValue: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityAPI"][::std::mem::size_of::<CUpti_ActivityAPI>() - 40usize];
    [
        "Alignment of CUpti_ActivityAPI",
    ][::std::mem::align_of::<CUpti_ActivityAPI>() - 8usize];
    [
        "Offset of field: CUpti_ActivityAPI::kind",
    ][::std::mem::offset_of!(CUpti_ActivityAPI, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityAPI::cbid",
    ][::std::mem::offset_of!(CUpti_ActivityAPI, cbid) - 4usize];
    [
        "Offset of field: CUpti_ActivityAPI::start",
    ][::std::mem::offset_of!(CUpti_ActivityAPI, start) - 8usize];
    [
        "Offset of field: CUpti_ActivityAPI::end",
    ][::std::mem::offset_of!(CUpti_ActivityAPI, end) - 16usize];
    [
        "Offset of field: CUpti_ActivityAPI::processId",
    ][::std::mem::offset_of!(CUpti_ActivityAPI, processId) - 24usize];
    [
        "Offset of field: CUpti_ActivityAPI::threadId",
    ][::std::mem::offset_of!(CUpti_ActivityAPI, threadId) - 28usize];
    [
        "Offset of field: CUpti_ActivityAPI::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityAPI, correlationId) - 32usize];
    [
        "Offset of field: CUpti_ActivityAPI::returnValue",
    ][::std::mem::offset_of!(CUpti_ActivityAPI, returnValue) - 36usize];
};
impl Default for CUpti_ActivityAPI {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for a CUPTI event.

 This activity record represents a CUPTI event value
 (CUPTI_ACTIVITY_KIND_EVENT). This activity record kind is not
 produced by the activity API but is included for completeness and
 ease-of-use. Profile frameworks built on top of CUPTI that collect
 event data may choose to use this type to store the collected event
 data.*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityEvent {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_EVENT.
    pub kind: CUpti_ActivityKind,
    /// The event ID.
    pub id: CUpti_EventID,
    /// The event value.
    pub value: u64,
    /// The event domain ID.
    pub domain: CUpti_EventDomainID,
    /** The correlation ID of the event. Use of this ID is user-defined,
 but typically this ID value will equal the correlation ID of the
 kernel for which the event was gathered.*/
    pub correlationId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityEvent",
    ][::std::mem::size_of::<CUpti_ActivityEvent>() - 24usize];
    [
        "Alignment of CUpti_ActivityEvent",
    ][::std::mem::align_of::<CUpti_ActivityEvent>() - 8usize];
    [
        "Offset of field: CUpti_ActivityEvent::kind",
    ][::std::mem::offset_of!(CUpti_ActivityEvent, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityEvent::id",
    ][::std::mem::offset_of!(CUpti_ActivityEvent, id) - 4usize];
    [
        "Offset of field: CUpti_ActivityEvent::value",
    ][::std::mem::offset_of!(CUpti_ActivityEvent, value) - 8usize];
    [
        "Offset of field: CUpti_ActivityEvent::domain",
    ][::std::mem::offset_of!(CUpti_ActivityEvent, domain) - 16usize];
    [
        "Offset of field: CUpti_ActivityEvent::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityEvent, correlationId) - 20usize];
};
impl Default for CUpti_ActivityEvent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for a CUPTI event with instance
 information.

 This activity record represents the a CUPTI event value for a
 specific event domain instance
 (CUPTI_ACTIVITY_KIND_EVENT_INSTANCE). This activity record kind is
 not produced by the activity API but is included for completeness
 and ease-of-use. Profile frameworks built on top of CUPTI that
 collect event data may choose to use this type to store the
 collected event data. This activity record should be used when
 event domain instance information needs to be associated with the
 event.*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityEventInstance {
    /** The activity record kind, must be
 CUPTI_ACTIVITY_KIND_EVENT_INSTANCE.*/
    pub kind: CUpti_ActivityKind,
    /// The event ID.
    pub id: CUpti_EventID,
    /// The event domain ID.
    pub domain: CUpti_EventDomainID,
    /// The event domain instance.
    pub instance: u32,
    /// The event value.
    pub value: u64,
    /** The correlation ID of the event. Use of this ID is user-defined,
 but typically this ID value will equal the correlation ID of the
 kernel for which the event was gathered.*/
    pub correlationId: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityEventInstance",
    ][::std::mem::size_of::<CUpti_ActivityEventInstance>() - 32usize];
    [
        "Alignment of CUpti_ActivityEventInstance",
    ][::std::mem::align_of::<CUpti_ActivityEventInstance>() - 8usize];
    [
        "Offset of field: CUpti_ActivityEventInstance::kind",
    ][::std::mem::offset_of!(CUpti_ActivityEventInstance, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityEventInstance::id",
    ][::std::mem::offset_of!(CUpti_ActivityEventInstance, id) - 4usize];
    [
        "Offset of field: CUpti_ActivityEventInstance::domain",
    ][::std::mem::offset_of!(CUpti_ActivityEventInstance, domain) - 8usize];
    [
        "Offset of field: CUpti_ActivityEventInstance::instance",
    ][::std::mem::offset_of!(CUpti_ActivityEventInstance, instance) - 12usize];
    [
        "Offset of field: CUpti_ActivityEventInstance::value",
    ][::std::mem::offset_of!(CUpti_ActivityEventInstance, value) - 16usize];
    [
        "Offset of field: CUpti_ActivityEventInstance::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityEventInstance, correlationId) - 24usize];
    [
        "Offset of field: CUpti_ActivityEventInstance::pad",
    ][::std::mem::offset_of!(CUpti_ActivityEventInstance, pad) - 28usize];
};
impl Default for CUpti_ActivityEventInstance {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for a CUPTI metric.

 This activity record represents the collection of a CUPTI metric
 value (CUPTI_ACTIVITY_KIND_METRIC). This activity record kind is not
 produced by the activity API but is included for completeness and
 ease-of-use. Profile frameworks built on top of CUPTI that collect
 metric data may choose to use this type to store the collected metric
 data.*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMetric {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_METRIC.
    pub kind: CUpti_ActivityKind,
    /// The metric ID.
    pub id: CUpti_MetricID,
    /// The metric value.
    pub value: CUpti_MetricValue,
    /** The correlation ID of the metric. Use of this ID is user-defined,
 but typically this ID value will equal the correlation ID of the
 kernel for which the metric was gathered.*/
    pub correlationId: u32,
    /// The properties of this metric. \see CUpti_ActivityFlag
    pub flags: u8,
    /// Undefined. Reserved for internal use.
    pub pad: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMetric",
    ][::std::mem::size_of::<CUpti_ActivityMetric>() - 24usize];
    [
        "Alignment of CUpti_ActivityMetric",
    ][::std::mem::align_of::<CUpti_ActivityMetric>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMetric::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMetric, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMetric::id",
    ][::std::mem::offset_of!(CUpti_ActivityMetric, id) - 4usize];
    [
        "Offset of field: CUpti_ActivityMetric::value",
    ][::std::mem::offset_of!(CUpti_ActivityMetric, value) - 8usize];
    [
        "Offset of field: CUpti_ActivityMetric::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityMetric, correlationId) - 16usize];
    [
        "Offset of field: CUpti_ActivityMetric::flags",
    ][::std::mem::offset_of!(CUpti_ActivityMetric, flags) - 20usize];
    [
        "Offset of field: CUpti_ActivityMetric::pad",
    ][::std::mem::offset_of!(CUpti_ActivityMetric, pad) - 21usize];
};
impl Default for CUpti_ActivityMetric {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMetric {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMetric {{ kind: {:?}, value: {:?}, pad: {:?} }}",
            self.kind,
            self.value,
            self.pad,
        )
    }
}
/** \brief The activity record for a CUPTI metric with instance
 information.

 This activity record represents a CUPTI metric value
 for a specific metric domain instance
 (CUPTI_ACTIVITY_KIND_METRIC_INSTANCE).  This activity record kind
 is not produced by the activity API but is included for
 completeness and ease-of-use. Profile frameworks built on top of
 CUPTI that collect metric data may choose to use this type to store
 the collected metric data. This activity record should be used when
 metric domain instance information needs to be associated with the
 metric.*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMetricInstance {
    /** The activity record kind, must be
 CUPTI_ACTIVITY_KIND_METRIC_INSTANCE.*/
    pub kind: CUpti_ActivityKind,
    /// The metric ID.
    pub id: CUpti_MetricID,
    /// The metric value.
    pub value: CUpti_MetricValue,
    /// The metric domain instance.
    pub instance: u32,
    /** The correlation ID of the metric. Use of this ID is user-defined,
 but typically this ID value will equal the correlation ID of the
 kernel for which the metric was gathered.*/
    pub correlationId: u32,
    /// The properties of this metric. \see CUpti_ActivityFlag
    pub flags: u8,
    /// Undefined. Reserved for internal use.
    pub pad: [u8; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMetricInstance",
    ][::std::mem::size_of::<CUpti_ActivityMetricInstance>() - 32usize];
    [
        "Alignment of CUpti_ActivityMetricInstance",
    ][::std::mem::align_of::<CUpti_ActivityMetricInstance>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMetricInstance::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMetricInstance, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMetricInstance::id",
    ][::std::mem::offset_of!(CUpti_ActivityMetricInstance, id) - 4usize];
    [
        "Offset of field: CUpti_ActivityMetricInstance::value",
    ][::std::mem::offset_of!(CUpti_ActivityMetricInstance, value) - 8usize];
    [
        "Offset of field: CUpti_ActivityMetricInstance::instance",
    ][::std::mem::offset_of!(CUpti_ActivityMetricInstance, instance) - 16usize];
    [
        "Offset of field: CUpti_ActivityMetricInstance::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityMetricInstance, correlationId) - 20usize];
    [
        "Offset of field: CUpti_ActivityMetricInstance::flags",
    ][::std::mem::offset_of!(CUpti_ActivityMetricInstance, flags) - 24usize];
    [
        "Offset of field: CUpti_ActivityMetricInstance::pad",
    ][::std::mem::offset_of!(CUpti_ActivityMetricInstance, pad) - 25usize];
};
impl Default for CUpti_ActivityMetricInstance {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMetricInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMetricInstance {{ kind: {:?}, value: {:?}, pad: {:?} }}",
            self.kind,
            self.value,
            self.pad,
        )
    }
}
/** \brief The activity record for source locator.

 This activity record represents a source locator
 (CUPTI_ACTIVITY_KIND_SOURCE_LOCATOR).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivitySourceLocator {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_SOURCE_LOCATOR.
    pub kind: CUpti_ActivityKind,
    /** The ID for the source path, will be used in all the source level
 results.*/
    pub id: u32,
    /// The line number in the source .
    pub lineNumber: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
    /// The path for the file.
    pub fileName: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivitySourceLocator",
    ][::std::mem::size_of::<CUpti_ActivitySourceLocator>() - 24usize];
    [
        "Alignment of CUpti_ActivitySourceLocator",
    ][::std::mem::align_of::<CUpti_ActivitySourceLocator>() - 8usize];
    [
        "Offset of field: CUpti_ActivitySourceLocator::kind",
    ][::std::mem::offset_of!(CUpti_ActivitySourceLocator, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivitySourceLocator::id",
    ][::std::mem::offset_of!(CUpti_ActivitySourceLocator, id) - 4usize];
    [
        "Offset of field: CUpti_ActivitySourceLocator::lineNumber",
    ][::std::mem::offset_of!(CUpti_ActivitySourceLocator, lineNumber) - 8usize];
    [
        "Offset of field: CUpti_ActivitySourceLocator::pad",
    ][::std::mem::offset_of!(CUpti_ActivitySourceLocator, pad) - 12usize];
    [
        "Offset of field: CUpti_ActivitySourceLocator::fileName",
    ][::std::mem::offset_of!(CUpti_ActivitySourceLocator, fileName) - 16usize];
};
impl Default for CUpti_ActivitySourceLocator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for source-level global
 access.

 This activity records the locations of the global
 accesses in the source (CUPTI_ACTIVITY_KIND_GLOBAL_ACCESS).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityGlobalAccess3 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_GLOBAL_ACCESS.
    pub kind: CUpti_ActivityKind,
    /// The properties of this global access.
    pub flags: CUpti_ActivityFlag,
    /// The ID for source locator.
    pub sourceLocatorId: u32,
    /// The correlation ID of the kernel to which this result is associated.
    pub correlationId: u32,
    /// Correlation ID with global/device function name
    pub functionId: u32,
    /** The number of times this instruction was executed per warp. It will be incremented
 when at least one of thread among warp is active with predicate and condition code
 evaluating to true.*/
    pub executed: u32,
    /// The pc offset for the access.
    pub pcOffset: u64,
    /** This increments each time when this instruction is executed by number of
 threads that executed this instruction with predicate and condition code
 evaluating to true.*/
    pub threadsExecuted: u64,
    /** The total number of 32 bytes transactions to L2 cache generated by this
access*/
    pub l2_transactions: u64,
    /// The minimum number of L2 transactions possible based on the access pattern.
    pub theoreticalL2Transactions: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityGlobalAccess3",
    ][::std::mem::size_of::<CUpti_ActivityGlobalAccess3>() - 56usize];
    [
        "Alignment of CUpti_ActivityGlobalAccess3",
    ][::std::mem::align_of::<CUpti_ActivityGlobalAccess3>() - 8usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess3::kind",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess3, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess3::flags",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess3, flags) - 4usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess3::sourceLocatorId",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess3, sourceLocatorId) - 8usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess3::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess3, correlationId) - 12usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess3::functionId",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess3, functionId) - 16usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess3::executed",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess3, executed) - 20usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess3::pcOffset",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess3, pcOffset) - 24usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess3::threadsExecuted",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess3, threadsExecuted) - 32usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess3::l2_transactions",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess3, l2_transactions) - 40usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess3::theoreticalL2Transactions",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess3, theoreticalL2Transactions)
        - 48usize];
};
impl Default for CUpti_ActivityGlobalAccess3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for source level result
 branch.

 This activity record the locations of the branches in the
 source (CUPTI_ACTIVITY_KIND_BRANCH).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityBranch2 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_BRANCH.
    pub kind: CUpti_ActivityKind,
    /// The ID for source locator.
    pub sourceLocatorId: u32,
    /// The correlation ID of the kernel to which this result is associated.
    pub correlationId: u32,
    /// Correlation ID with global/device function name
    pub functionId: u32,
    /// The pc offset for the branch.
    pub pcOffset: u32,
    /// Number of times this branch diverged
    pub diverged: u32,
    /** This increments each time when this instruction is executed by number
 of threads that executed this instruction*/
    pub threadsExecuted: u64,
    /** The number of times this instruction was executed per warp. It will be incremented
 regardless of predicate or condition code.*/
    pub executed: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityBranch2",
    ][::std::mem::size_of::<CUpti_ActivityBranch2>() - 40usize];
    [
        "Alignment of CUpti_ActivityBranch2",
    ][::std::mem::align_of::<CUpti_ActivityBranch2>() - 8usize];
    [
        "Offset of field: CUpti_ActivityBranch2::kind",
    ][::std::mem::offset_of!(CUpti_ActivityBranch2, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityBranch2::sourceLocatorId",
    ][::std::mem::offset_of!(CUpti_ActivityBranch2, sourceLocatorId) - 4usize];
    [
        "Offset of field: CUpti_ActivityBranch2::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityBranch2, correlationId) - 8usize];
    [
        "Offset of field: CUpti_ActivityBranch2::functionId",
    ][::std::mem::offset_of!(CUpti_ActivityBranch2, functionId) - 12usize];
    [
        "Offset of field: CUpti_ActivityBranch2::pcOffset",
    ][::std::mem::offset_of!(CUpti_ActivityBranch2, pcOffset) - 16usize];
    [
        "Offset of field: CUpti_ActivityBranch2::diverged",
    ][::std::mem::offset_of!(CUpti_ActivityBranch2, diverged) - 20usize];
    [
        "Offset of field: CUpti_ActivityBranch2::threadsExecuted",
    ][::std::mem::offset_of!(CUpti_ActivityBranch2, threadsExecuted) - 24usize];
    [
        "Offset of field: CUpti_ActivityBranch2::executed",
    ][::std::mem::offset_of!(CUpti_ActivityBranch2, executed) - 32usize];
    [
        "Offset of field: CUpti_ActivityBranch2::pad",
    ][::std::mem::offset_of!(CUpti_ActivityBranch2, pad) - 36usize];
};
impl Default for CUpti_ActivityBranch2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for a device. (CUDA 11.6 onwards)

 This activity record represents information about a GPU device
 (CUPTI_ACTIVITY_KIND_DEVICE).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityDevice5 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_DEVICE.
    pub kind: CUpti_ActivityKind,
    /// The flags associated with the device. \see CUpti_ActivityFlag
    pub flags: CUpti_ActivityFlag,
    /** The global memory bandwidth available on the device, in
 kBytes/sec.*/
    pub globalMemoryBandwidth: u64,
    /// The amount of global memory on the device, in bytes.
    pub globalMemorySize: u64,
    /// The amount of constant memory on the device, in bytes.
    pub constantMemorySize: u32,
    /// The size of the L2 cache on the device, in bytes.
    pub l2CacheSize: u32,
    /// The number of threads per warp on the device.
    pub numThreadsPerWarp: u32,
    /// The core clock rate of the device, in kHz.
    pub coreClockRate: u32,
    /// Number of memory copy engines on the device.
    pub numMemcpyEngines: u32,
    /// Number of multiprocessors on the device.
    pub numMultiprocessors: u32,
    /** The maximum "instructions per cycle" possible on each device
 multiprocessor.*/
    pub maxIPC: u32,
    /** Maximum number of warps that can be present on a multiprocessor
 at any given time.*/
    pub maxWarpsPerMultiprocessor: u32,
    /** Maximum number of blocks that can be present on a multiprocessor
 at any given time.*/
    pub maxBlocksPerMultiprocessor: u32,
    /// Maximum amount of shared memory available per multiprocessor, in bytes.
    pub maxSharedMemoryPerMultiprocessor: u32,
    /// Maximum number of 32-bit registers available per multiprocessor.
    pub maxRegistersPerMultiprocessor: u32,
    /// Maximum number of registers that can be allocated to a block.
    pub maxRegistersPerBlock: u32,
    /** Maximum amount of shared memory that can be assigned to a block,
 in bytes.*/
    pub maxSharedMemoryPerBlock: u32,
    /// Maximum number of threads allowed in a block.
    pub maxThreadsPerBlock: u32,
    /// Maximum allowed X dimension for a block.
    pub maxBlockDimX: u32,
    /// Maximum allowed Y dimension for a block.
    pub maxBlockDimY: u32,
    /// Maximum allowed Z dimension for a block.
    pub maxBlockDimZ: u32,
    /// Maximum allowed X dimension for a grid.
    pub maxGridDimX: u32,
    /// Maximum allowed Y dimension for a grid.
    pub maxGridDimY: u32,
    /// Maximum allowed Z dimension for a grid.
    pub maxGridDimZ: u32,
    /// Compute capability for the device, major number.
    pub computeCapabilityMajor: u32,
    /// Compute capability for the device, minor number.
    pub computeCapabilityMinor: u32,
    /// The device ID.
    pub id: u32,
    /// ECC enabled flag for device
    pub eccEnabled: u32,
    /** The device UUID. This value is the globally unique immutable
 alphanumeric identifier of the device.*/
    pub uuid: CUuuid,
    /// The device name. Client is responsible for freeing this memory using the free function when done.
    pub name: *const ::std::os::raw::c_char,
    /** Flag to indicate whether the device is visible to CUDA. Users can
 set the device visibility using CUDA_VISIBLE_DEVICES environment*/
    pub isCudaVisible: u8,
    /// MIG enabled flag for device
    pub isMigEnabled: u8,
    pub reserved: [u8; 6usize],
    /** GPU Instance id for MIG enabled devices.
 If mig mode is disabled value is set to UINT32_MAX*/
    pub gpuInstanceId: u32,
    /** Compute Instance id for MIG enabled devices.
 If mig mode is disabled value is set to UINT32_MAX*/
    pub computeInstanceId: u32,
    /** The MIG UUID. This value is the globally unique immutable
 alphanumeric identifier of the device.*/
    pub migUuid: CUuuid,
    /** Numa (Non-uniform memory access) information for device
 GPU is a NUMA node or not*/
    pub isNumaNode: u32,
    /** Numa (Non-uniform memory access) information for device
 NUMA node ID of the GPU memory
 if GPU is not a NUMA node, it returns invalidNumaId*/
    pub numaId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityDevice5",
    ][::std::mem::size_of::<CUpti_ActivityDevice5>() - 184usize];
    [
        "Alignment of CUpti_ActivityDevice5",
    ][::std::mem::align_of::<CUpti_ActivityDevice5>() - 8usize];
    [
        "Offset of field: CUpti_ActivityDevice5::kind",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityDevice5::flags",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, flags) - 4usize];
    [
        "Offset of field: CUpti_ActivityDevice5::globalMemoryBandwidth",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, globalMemoryBandwidth) - 8usize];
    [
        "Offset of field: CUpti_ActivityDevice5::globalMemorySize",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, globalMemorySize) - 16usize];
    [
        "Offset of field: CUpti_ActivityDevice5::constantMemorySize",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, constantMemorySize) - 24usize];
    [
        "Offset of field: CUpti_ActivityDevice5::l2CacheSize",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, l2CacheSize) - 28usize];
    [
        "Offset of field: CUpti_ActivityDevice5::numThreadsPerWarp",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, numThreadsPerWarp) - 32usize];
    [
        "Offset of field: CUpti_ActivityDevice5::coreClockRate",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, coreClockRate) - 36usize];
    [
        "Offset of field: CUpti_ActivityDevice5::numMemcpyEngines",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, numMemcpyEngines) - 40usize];
    [
        "Offset of field: CUpti_ActivityDevice5::numMultiprocessors",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, numMultiprocessors) - 44usize];
    [
        "Offset of field: CUpti_ActivityDevice5::maxIPC",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, maxIPC) - 48usize];
    [
        "Offset of field: CUpti_ActivityDevice5::maxWarpsPerMultiprocessor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, maxWarpsPerMultiprocessor)
        - 52usize];
    [
        "Offset of field: CUpti_ActivityDevice5::maxBlocksPerMultiprocessor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, maxBlocksPerMultiprocessor)
        - 56usize];
    [
        "Offset of field: CUpti_ActivityDevice5::maxSharedMemoryPerMultiprocessor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, maxSharedMemoryPerMultiprocessor)
        - 60usize];
    [
        "Offset of field: CUpti_ActivityDevice5::maxRegistersPerMultiprocessor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, maxRegistersPerMultiprocessor)
        - 64usize];
    [
        "Offset of field: CUpti_ActivityDevice5::maxRegistersPerBlock",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, maxRegistersPerBlock) - 68usize];
    [
        "Offset of field: CUpti_ActivityDevice5::maxSharedMemoryPerBlock",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, maxSharedMemoryPerBlock) - 72usize];
    [
        "Offset of field: CUpti_ActivityDevice5::maxThreadsPerBlock",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, maxThreadsPerBlock) - 76usize];
    [
        "Offset of field: CUpti_ActivityDevice5::maxBlockDimX",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, maxBlockDimX) - 80usize];
    [
        "Offset of field: CUpti_ActivityDevice5::maxBlockDimY",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, maxBlockDimY) - 84usize];
    [
        "Offset of field: CUpti_ActivityDevice5::maxBlockDimZ",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, maxBlockDimZ) - 88usize];
    [
        "Offset of field: CUpti_ActivityDevice5::maxGridDimX",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, maxGridDimX) - 92usize];
    [
        "Offset of field: CUpti_ActivityDevice5::maxGridDimY",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, maxGridDimY) - 96usize];
    [
        "Offset of field: CUpti_ActivityDevice5::maxGridDimZ",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, maxGridDimZ) - 100usize];
    [
        "Offset of field: CUpti_ActivityDevice5::computeCapabilityMajor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, computeCapabilityMajor) - 104usize];
    [
        "Offset of field: CUpti_ActivityDevice5::computeCapabilityMinor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, computeCapabilityMinor) - 108usize];
    [
        "Offset of field: CUpti_ActivityDevice5::id",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, id) - 112usize];
    [
        "Offset of field: CUpti_ActivityDevice5::eccEnabled",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, eccEnabled) - 116usize];
    [
        "Offset of field: CUpti_ActivityDevice5::uuid",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, uuid) - 120usize];
    [
        "Offset of field: CUpti_ActivityDevice5::name",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, name) - 136usize];
    [
        "Offset of field: CUpti_ActivityDevice5::isCudaVisible",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, isCudaVisible) - 144usize];
    [
        "Offset of field: CUpti_ActivityDevice5::isMigEnabled",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, isMigEnabled) - 145usize];
    [
        "Offset of field: CUpti_ActivityDevice5::reserved",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, reserved) - 146usize];
    [
        "Offset of field: CUpti_ActivityDevice5::gpuInstanceId",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, gpuInstanceId) - 152usize];
    [
        "Offset of field: CUpti_ActivityDevice5::computeInstanceId",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, computeInstanceId) - 156usize];
    [
        "Offset of field: CUpti_ActivityDevice5::migUuid",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, migUuid) - 160usize];
    [
        "Offset of field: CUpti_ActivityDevice5::isNumaNode",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, isNumaNode) - 176usize];
    [
        "Offset of field: CUpti_ActivityDevice5::numaId",
    ][::std::mem::offset_of!(CUpti_ActivityDevice5, numaId) - 180usize];
};
impl Default for CUpti_ActivityDevice5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for a device attribute.

 This activity record represents information about a GPU device:
 either a CUpti_DeviceAttribute or CUdevice_attribute value
 (CUPTI_ACTIVITY_KIND_DEVICE_ATTRIBUTE).*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityDeviceAttribute {
    /** The activity record kind, must be
 CUPTI_ACTIVITY_KIND_DEVICE_ATTRIBUTE.*/
    pub kind: CUpti_ActivityKind,
    /// The flags associated with the device. \see CUpti_ActivityFlag
    pub flags: CUpti_ActivityFlag,
    /// The ID of the device that this attribute applies to.
    pub deviceId: u32,
    pub attribute: CUpti_ActivityDeviceAttribute__bindgen_ty_1,
    pub value: CUpti_ActivityDeviceAttribute__bindgen_ty_2,
}
/** The attribute, either a CUpti_DeviceAttribute or
 CUdevice_attribute. Flag
 CUPTI_ACTIVITY_FLAG_DEVICE_ATTRIBUTE_CUDEVICE is used to indicate
 what kind of attribute this is. If
 CUPTI_ACTIVITY_FLAG_DEVICE_ATTRIBUTE_CUDEVICE is 1 then
 CUdevice_attribute field is value, otherwise
 CUpti_DeviceAttribute field is valid.*/
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityDeviceAttribute__bindgen_ty_1 {
    pub cu: CUdevice_attribute,
    pub cupti: CUpti_DeviceAttribute,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityDeviceAttribute__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityDeviceAttribute__bindgen_ty_1>() - 4usize];
    [
        "Alignment of CUpti_ActivityDeviceAttribute__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityDeviceAttribute__bindgen_ty_1>() - 4usize];
    [
        "Offset of field: CUpti_ActivityDeviceAttribute__bindgen_ty_1::cu",
    ][::std::mem::offset_of!(CUpti_ActivityDeviceAttribute__bindgen_ty_1, cu) - 0usize];
    [
        "Offset of field: CUpti_ActivityDeviceAttribute__bindgen_ty_1::cupti",
    ][::std::mem::offset_of!(CUpti_ActivityDeviceAttribute__bindgen_ty_1, cupti)
        - 0usize];
};
impl Default for CUpti_ActivityDeviceAttribute__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityDeviceAttribute__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityDeviceAttribute__bindgen_ty_1 {{ union }}")
    }
}
/** The value for the attribute. See CUpti_DeviceAttribute and
 CUdevice_attribute for the type of the value for a given
 attribute.*/
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityDeviceAttribute__bindgen_ty_2 {
    pub vDouble: f64,
    pub vUint32: u32,
    pub vUint64: u64,
    pub vInt32: i32,
    pub vInt64: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityDeviceAttribute__bindgen_ty_2",
    ][::std::mem::size_of::<CUpti_ActivityDeviceAttribute__bindgen_ty_2>() - 8usize];
    [
        "Alignment of CUpti_ActivityDeviceAttribute__bindgen_ty_2",
    ][::std::mem::align_of::<CUpti_ActivityDeviceAttribute__bindgen_ty_2>() - 8usize];
    [
        "Offset of field: CUpti_ActivityDeviceAttribute__bindgen_ty_2::vDouble",
    ][::std::mem::offset_of!(CUpti_ActivityDeviceAttribute__bindgen_ty_2, vDouble)
        - 0usize];
    [
        "Offset of field: CUpti_ActivityDeviceAttribute__bindgen_ty_2::vUint32",
    ][::std::mem::offset_of!(CUpti_ActivityDeviceAttribute__bindgen_ty_2, vUint32)
        - 0usize];
    [
        "Offset of field: CUpti_ActivityDeviceAttribute__bindgen_ty_2::vUint64",
    ][::std::mem::offset_of!(CUpti_ActivityDeviceAttribute__bindgen_ty_2, vUint64)
        - 0usize];
    [
        "Offset of field: CUpti_ActivityDeviceAttribute__bindgen_ty_2::vInt32",
    ][::std::mem::offset_of!(CUpti_ActivityDeviceAttribute__bindgen_ty_2, vInt32)
        - 0usize];
    [
        "Offset of field: CUpti_ActivityDeviceAttribute__bindgen_ty_2::vInt64",
    ][::std::mem::offset_of!(CUpti_ActivityDeviceAttribute__bindgen_ty_2, vInt64)
        - 0usize];
};
impl Default for CUpti_ActivityDeviceAttribute__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityDeviceAttribute__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityDeviceAttribute__bindgen_ty_2 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityDeviceAttribute",
    ][::std::mem::size_of::<CUpti_ActivityDeviceAttribute>() - 24usize];
    [
        "Alignment of CUpti_ActivityDeviceAttribute",
    ][::std::mem::align_of::<CUpti_ActivityDeviceAttribute>() - 8usize];
    [
        "Offset of field: CUpti_ActivityDeviceAttribute::kind",
    ][::std::mem::offset_of!(CUpti_ActivityDeviceAttribute, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityDeviceAttribute::flags",
    ][::std::mem::offset_of!(CUpti_ActivityDeviceAttribute, flags) - 4usize];
    [
        "Offset of field: CUpti_ActivityDeviceAttribute::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityDeviceAttribute, deviceId) - 8usize];
    [
        "Offset of field: CUpti_ActivityDeviceAttribute::attribute",
    ][::std::mem::offset_of!(CUpti_ActivityDeviceAttribute, attribute) - 12usize];
    [
        "Offset of field: CUpti_ActivityDeviceAttribute::value",
    ][::std::mem::offset_of!(CUpti_ActivityDeviceAttribute, value) - 16usize];
};
impl Default for CUpti_ActivityDeviceAttribute {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityDeviceAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityDeviceAttribute {{ kind: {:?}, flags: {:?}, attribute: {:?}, value: {:?} }}",
            self.kind,
            self.flags,
            self.attribute,
            self.value,
        )
    }
}
/** \brief The activity record for a context.

 This activity record represents information about a context
 (CUPTI_ACTIVITY_KIND_CONTEXT).*/
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityContext3 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_CONTEXT.
    pub kind: CUpti_ActivityKind,
    /// The context ID.
    pub contextId: u32,
    /// The device ID.
    pub deviceId: u32,
    /// The compute API kind. \see CUpti_ActivityComputeApiKind
    pub computeApiKind: u16,
    /// The ID for the NULL stream in this context
    pub nullStreamId: u16,
    /** The ID of the parent context. It would be 0 if
 context does not have parent*/
    pub parentContextId: u32,
    /// This field indicates whether the context is a green context
    pub isGreenContext: u8,
    pub padding: u8,
    /** Number of multiprocessors assigned to the green context
 Invalid if the field 'isGreenContext' is 0*/
    pub numMultiprocessors: u16,
    /// This field indicates the CIG mode
    pub cigMode: CUpti_ContextCigMode,
    pub padding2: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityContext3",
    ][::std::mem::size_of::<CUpti_ActivityContext3>() - 32usize];
    [
        "Alignment of CUpti_ActivityContext3",
    ][::std::mem::align_of::<CUpti_ActivityContext3>() - 8usize];
    [
        "Offset of field: CUpti_ActivityContext3::kind",
    ][::std::mem::offset_of!(CUpti_ActivityContext3, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityContext3::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityContext3, contextId) - 4usize];
    [
        "Offset of field: CUpti_ActivityContext3::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityContext3, deviceId) - 8usize];
    [
        "Offset of field: CUpti_ActivityContext3::computeApiKind",
    ][::std::mem::offset_of!(CUpti_ActivityContext3, computeApiKind) - 12usize];
    [
        "Offset of field: CUpti_ActivityContext3::nullStreamId",
    ][::std::mem::offset_of!(CUpti_ActivityContext3, nullStreamId) - 14usize];
    [
        "Offset of field: CUpti_ActivityContext3::parentContextId",
    ][::std::mem::offset_of!(CUpti_ActivityContext3, parentContextId) - 16usize];
    [
        "Offset of field: CUpti_ActivityContext3::isGreenContext",
    ][::std::mem::offset_of!(CUpti_ActivityContext3, isGreenContext) - 20usize];
    [
        "Offset of field: CUpti_ActivityContext3::padding",
    ][::std::mem::offset_of!(CUpti_ActivityContext3, padding) - 21usize];
    [
        "Offset of field: CUpti_ActivityContext3::numMultiprocessors",
    ][::std::mem::offset_of!(CUpti_ActivityContext3, numMultiprocessors) - 22usize];
    [
        "Offset of field: CUpti_ActivityContext3::cigMode",
    ][::std::mem::offset_of!(CUpti_ActivityContext3, cigMode) - 24usize];
    [
        "Offset of field: CUpti_ActivityContext3::padding2",
    ][::std::mem::offset_of!(CUpti_ActivityContext3, padding2) - 28usize];
};
impl Default for CUpti_ActivityContext3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record providing a name.

 This activity record provides a name for a device, context, thread,
 etc. and other resource naming done via NVTX APIs
 (CUPTI_ACTIVITY_KIND_NAME).*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityName {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_NAME.
    pub kind: CUpti_ActivityKind,
    /// The kind of activity object being named.
    pub objectKind: CUpti_ActivityObjectKind,
    /** The identifier for the activity object. 'objectKind' indicates
 which ID is valid for this record.*/
    pub objectId: CUpti_ActivityObjectKindId,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
    /// The name.
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityName",
    ][::std::mem::size_of::<CUpti_ActivityName>() - 32usize];
    [
        "Alignment of CUpti_ActivityName",
    ][::std::mem::align_of::<CUpti_ActivityName>() - 8usize];
    [
        "Offset of field: CUpti_ActivityName::kind",
    ][::std::mem::offset_of!(CUpti_ActivityName, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityName::objectKind",
    ][::std::mem::offset_of!(CUpti_ActivityName, objectKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityName::objectId",
    ][::std::mem::offset_of!(CUpti_ActivityName, objectId) - 8usize];
    [
        "Offset of field: CUpti_ActivityName::pad",
    ][::std::mem::offset_of!(CUpti_ActivityName, pad) - 20usize];
    [
        "Offset of field: CUpti_ActivityName::name",
    ][::std::mem::offset_of!(CUpti_ActivityName, name) - 24usize];
};
impl Default for CUpti_ActivityName {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityName {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityName {{ kind: {:?}, objectKind: {:?}, objectId: {:?}, name: {:?} }}",
            self.kind,
            self.objectKind,
            self.objectId,
            self.name,
        )
    }
}
/** \brief The activity record providing a marker which is an
 instantaneous point in time.

 The marker is specified with a descriptive name and unique id
 (CUPTI_ACTIVITY_KIND_MARKER).*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMarker2 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MARKER.
    pub kind: CUpti_ActivityKind,
    /// The flags associated with the marker. \see CUpti_ActivityFlag
    pub flags: CUpti_ActivityFlag,
    /** The timestamp for the marker, in ns. A value of 0 indicates that
 timestamp information could not be collected for the marker.*/
    pub timestamp: u64,
    /// The marker ID.
    pub id: u32,
    /// The kind of activity object associated with this marker.
    pub objectKind: CUpti_ActivityObjectKind,
    /** The identifier for the activity object associated with this
 marker. 'objectKind' indicates which ID is valid for this record.*/
    pub objectId: CUpti_ActivityObjectKindId,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
    /** The marker name for an instantaneous or start marker. This will
 be NULL for an end marker.*/
    pub name: *const ::std::os::raw::c_char,
    /** The name of the domain to which this marker belongs to.
 This will be NULL for default domain.*/
    pub domain: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMarker2",
    ][::std::mem::size_of::<CUpti_ActivityMarker2>() - 56usize];
    [
        "Alignment of CUpti_ActivityMarker2",
    ][::std::mem::align_of::<CUpti_ActivityMarker2>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMarker2::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMarker2, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMarker2::flags",
    ][::std::mem::offset_of!(CUpti_ActivityMarker2, flags) - 4usize];
    [
        "Offset of field: CUpti_ActivityMarker2::timestamp",
    ][::std::mem::offset_of!(CUpti_ActivityMarker2, timestamp) - 8usize];
    [
        "Offset of field: CUpti_ActivityMarker2::id",
    ][::std::mem::offset_of!(CUpti_ActivityMarker2, id) - 16usize];
    [
        "Offset of field: CUpti_ActivityMarker2::objectKind",
    ][::std::mem::offset_of!(CUpti_ActivityMarker2, objectKind) - 20usize];
    [
        "Offset of field: CUpti_ActivityMarker2::objectId",
    ][::std::mem::offset_of!(CUpti_ActivityMarker2, objectId) - 24usize];
    [
        "Offset of field: CUpti_ActivityMarker2::pad",
    ][::std::mem::offset_of!(CUpti_ActivityMarker2, pad) - 36usize];
    [
        "Offset of field: CUpti_ActivityMarker2::name",
    ][::std::mem::offset_of!(CUpti_ActivityMarker2, name) - 40usize];
    [
        "Offset of field: CUpti_ActivityMarker2::domain",
    ][::std::mem::offset_of!(CUpti_ActivityMarker2, domain) - 48usize];
};
impl Default for CUpti_ActivityMarker2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMarker2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMarker2 {{ kind: {:?}, flags: {:?}, objectKind: {:?}, objectId: {:?}, name: {:?}, domain: {:?} }}",
            self.kind,
            self.flags,
            self.objectKind,
            self.objectId,
            self.name,
            self.domain,
        )
    }
}
/** \brief The activity record providing detailed information for a marker.

 User must enable CUPTI_ACTIVITY_KIND_MARKER as well
 to get records for marker data.
 The marker data contains color, payload, and category.
 (CUPTI_ACTIVITY_KIND_MARKER_DATA).*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMarkerData2 {
    /** The activity record kind, must be
 CUPTI_ACTIVITY_KIND_MARKER_DATA.*/
    pub kind: CUpti_ActivityKind,
    /// The flags associated with the marker. \see CUpti_ActivityFlag
    pub flags: CUpti_ActivityFlag,
    /// The marker ID.
    pub id: u32,
    /// Defines the payload format for the value associated with the marker.
    pub payloadKind: CUpti_MetricValueKind,
    /// The payload value.
    pub payload: CUpti_MetricValue,
    /// The color for the marker.
    pub color: u32,
    /// The category for the marker.
    pub category: u32,
    /** CUPTI maintained domain id required for NVTX extended payloads.
 To parse the payload correctly, the domain id must be used to
 identify the payload attributes as they are domain specific.*/
    pub cuptiDomainId: u32,
    /// Reserved for internal use.
    pub padding: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMarkerData2",
    ][::std::mem::size_of::<CUpti_ActivityMarkerData2>() - 40usize];
    [
        "Alignment of CUpti_ActivityMarkerData2",
    ][::std::mem::align_of::<CUpti_ActivityMarkerData2>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMarkerData2::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMarkerData2, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMarkerData2::flags",
    ][::std::mem::offset_of!(CUpti_ActivityMarkerData2, flags) - 4usize];
    [
        "Offset of field: CUpti_ActivityMarkerData2::id",
    ][::std::mem::offset_of!(CUpti_ActivityMarkerData2, id) - 8usize];
    [
        "Offset of field: CUpti_ActivityMarkerData2::payloadKind",
    ][::std::mem::offset_of!(CUpti_ActivityMarkerData2, payloadKind) - 12usize];
    [
        "Offset of field: CUpti_ActivityMarkerData2::payload",
    ][::std::mem::offset_of!(CUpti_ActivityMarkerData2, payload) - 16usize];
    [
        "Offset of field: CUpti_ActivityMarkerData2::color",
    ][::std::mem::offset_of!(CUpti_ActivityMarkerData2, color) - 24usize];
    [
        "Offset of field: CUpti_ActivityMarkerData2::category",
    ][::std::mem::offset_of!(CUpti_ActivityMarkerData2, category) - 28usize];
    [
        "Offset of field: CUpti_ActivityMarkerData2::cuptiDomainId",
    ][::std::mem::offset_of!(CUpti_ActivityMarkerData2, cuptiDomainId) - 32usize];
    [
        "Offset of field: CUpti_ActivityMarkerData2::padding",
    ][::std::mem::offset_of!(CUpti_ActivityMarkerData2, padding) - 36usize];
};
impl Default for CUpti_ActivityMarkerData2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMarkerData2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMarkerData2 {{ kind: {:?}, flags: {:?}, payloadKind: {:?}, payload: {:?} }}",
            self.kind,
            self.flags,
            self.payloadKind,
            self.payload,
        )
    }
}
/** \brief The activity record for CUPTI and driver overheads.

 This activity record provides CUPTI and driver overhead information
 (CUPTI_ACTIVITY_KIND_OVERHEAD).*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityOverhead3 {
    /// The activity record kind, must be CUPTI_ACTIVITY_OVERHEAD.
    pub kind: CUpti_ActivityKind,
    /// The kind of overhead, CUPTI, DRIVER, COMPILER etc.
    pub overheadKind: CUpti_ActivityOverheadKind,
    /// The kind of activity object that the overhead is associated with.
    pub objectKind: CUpti_ActivityObjectKind,
    /** The identifier for the activity object. 'objectKind' indicates
 which ID is valid for this record.*/
    pub objectId: CUpti_ActivityObjectKindId,
    /** The start timestamp for the overhead, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the overhead.*/
    pub start: u64,
    /** The end timestamp for the overhead, in ns. A value of 0 for both
 the start and end timestamps indicates that timestamp information
 could not be collected for the overhead.*/
    pub end: u64,
    /** The correlation ID of the overhead operation to which
 records belong to. This ID is identical to the
 correlation ID in the driver or runtime API activity record that
 launched the overhead operation.
 In some cases, it can be zero, such as for CUPTI_ACTIVITY_OVERHEAD_CUPTI_BUFFER_FLUSH records.*/
    pub correlationId: u32,
    /// Reserved for internal use.
    pub reserved0: u32,
    /** Pointer to the struct with additional details about the overhead.
 Refer CUpti_ActivityOverheadKind enum and the corresponding structure to typecast and access additional overhead data.
 Client is responsible for freeing this memory using the free function when done.*/
    pub overheadData: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityOverhead3",
    ][::std::mem::size_of::<CUpti_ActivityOverhead3>() - 56usize];
    [
        "Alignment of CUpti_ActivityOverhead3",
    ][::std::mem::align_of::<CUpti_ActivityOverhead3>() - 8usize];
    [
        "Offset of field: CUpti_ActivityOverhead3::kind",
    ][::std::mem::offset_of!(CUpti_ActivityOverhead3, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityOverhead3::overheadKind",
    ][::std::mem::offset_of!(CUpti_ActivityOverhead3, overheadKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityOverhead3::objectKind",
    ][::std::mem::offset_of!(CUpti_ActivityOverhead3, objectKind) - 8usize];
    [
        "Offset of field: CUpti_ActivityOverhead3::objectId",
    ][::std::mem::offset_of!(CUpti_ActivityOverhead3, objectId) - 12usize];
    [
        "Offset of field: CUpti_ActivityOverhead3::start",
    ][::std::mem::offset_of!(CUpti_ActivityOverhead3, start) - 24usize];
    [
        "Offset of field: CUpti_ActivityOverhead3::end",
    ][::std::mem::offset_of!(CUpti_ActivityOverhead3, end) - 32usize];
    [
        "Offset of field: CUpti_ActivityOverhead3::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityOverhead3, correlationId) - 40usize];
    [
        "Offset of field: CUpti_ActivityOverhead3::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityOverhead3, reserved0) - 44usize];
    [
        "Offset of field: CUpti_ActivityOverhead3::overheadData",
    ][::std::mem::offset_of!(CUpti_ActivityOverhead3, overheadData) - 48usize];
};
impl Default for CUpti_ActivityOverhead3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityOverhead3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityOverhead3 {{ kind: {:?}, overheadKind: {:?}, objectKind: {:?}, objectId: {:?}, overheadData: {:?} }}",
            self.kind,
            self.overheadKind,
            self.objectKind,
            self.objectId,
            self.overheadData,
        )
    }
}
/** \brief The activity record for CUPTI environmental data.

 This activity record provides CUPTI environmental data, include
 power, clocks, and thermals.  This information is sampled at
 various rates and returned in this activity record.  The consumer
 of the record needs to check the environmentKind field to figure
 out what kind of environmental record this is.*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityEnvironment {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_ENVIRONMENT.
    pub kind: CUpti_ActivityKind,
    /// The ID of the device
    pub deviceId: u32,
    /** The timestamp when this sample was retrieved, in ns. A value of 0
 indicates that timestamp information could not be collected for
 the marker.*/
    pub timestamp: u64,
    /// The kind of data reported in this record.
    pub environmentKind: CUpti_ActivityEnvironmentKind,
    pub data: CUpti_ActivityEnvironment__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityEnvironment__bindgen_ty_1 {
    pub speed: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1,
    pub temperature: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_2,
    pub power: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_3,
    pub cooling: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_4,
}
/** Data returned for CUPTI_ACTIVITY_ENVIRONMENT_SPEED environment
 kind.*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1 {
    /// The SM frequency in MHz
    pub smClock: u32,
    /// The memory frequency in MHz
    pub memoryClock: u32,
    /// The PCIe link generation.
    pub pcieLinkGen: u32,
    /// The PCIe link width.
    pub pcieLinkWidth: u32,
    /// The clocks throttle reasons.
    pub clocksThrottleReasons: CUpti_EnvironmentClocksThrottleReason,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1>()
        - 20usize];
    [
        "Alignment of CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1>()
        - 4usize];
    [
        "Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1::smClock",
    ][::std::mem::offset_of!(
        CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1, smClock
    ) - 0usize];
    [
        "Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1::memoryClock",
    ][::std::mem::offset_of!(
        CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1, memoryClock
    ) - 4usize];
    [
        "Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1::pcieLinkGen",
    ][::std::mem::offset_of!(
        CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1, pcieLinkGen
    ) - 8usize];
    [
        "Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1::pcieLinkWidth",
    ][::std::mem::offset_of!(
        CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1, pcieLinkWidth
    ) - 12usize];
    [
        "Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1::clocksThrottleReasons",
    ][::std::mem::offset_of!(
        CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1, clocksThrottleReasons
    ) - 16usize];
};
impl Default for CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** Data returned for CUPTI_ACTIVITY_ENVIRONMENT_TEMPERATURE
 environment kind.*/
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_2 {
    /// The GPU temperature in degrees C.
    pub gpuTemperature: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_2",
    ][::std::mem::size_of::<CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_2>()
        - 4usize];
    [
        "Alignment of CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_2",
    ][::std::mem::align_of::<CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_2>()
        - 4usize];
    [
        "Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_2::gpuTemperature",
    ][::std::mem::offset_of!(
        CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_2, gpuTemperature
    ) - 0usize];
};
/** Data returned for CUPTI_ACTIVITY_ENVIRONMENT_POWER environment kind.
 The power in milliwatts consumed by GPU and associated circuitry.
 The power in milliwatts that will trigger power management algorithm.*/
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_3 {
    pub power: u32,
    pub powerLimit: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_3",
    ][::std::mem::size_of::<CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_3>()
        - 8usize];
    [
        "Alignment of CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_3",
    ][::std::mem::align_of::<CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_3>()
        - 4usize];
    [
        "Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_3::power",
    ][::std::mem::offset_of!(
        CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_3, power
    ) - 0usize];
    [
        "Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_3::powerLimit",
    ][::std::mem::offset_of!(
        CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_3, powerLimit
    ) - 4usize];
};
/** Data returned for CUPTI_ACTIVITY_ENVIRONMENT_COOLING
 environment kind.*/
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_4 {
    /// The fan speed as percentage of maximum.
    pub fanSpeed: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_4",
    ][::std::mem::size_of::<CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_4>()
        - 4usize];
    [
        "Alignment of CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_4",
    ][::std::mem::align_of::<CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_4>()
        - 4usize];
    [
        "Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_4::fanSpeed",
    ][::std::mem::offset_of!(
        CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_4, fanSpeed
    ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityEnvironment__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityEnvironment__bindgen_ty_1>() - 20usize];
    [
        "Alignment of CUpti_ActivityEnvironment__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityEnvironment__bindgen_ty_1>() - 4usize];
    [
        "Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1::speed",
    ][::std::mem::offset_of!(CUpti_ActivityEnvironment__bindgen_ty_1, speed) - 0usize];
    [
        "Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1::temperature",
    ][::std::mem::offset_of!(CUpti_ActivityEnvironment__bindgen_ty_1, temperature)
        - 0usize];
    [
        "Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1::power",
    ][::std::mem::offset_of!(CUpti_ActivityEnvironment__bindgen_ty_1, power) - 0usize];
    [
        "Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1::cooling",
    ][::std::mem::offset_of!(CUpti_ActivityEnvironment__bindgen_ty_1, cooling) - 0usize];
};
impl Default for CUpti_ActivityEnvironment__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityEnvironment__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityEnvironment__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityEnvironment",
    ][::std::mem::size_of::<CUpti_ActivityEnvironment>() - 40usize];
    [
        "Alignment of CUpti_ActivityEnvironment",
    ][::std::mem::align_of::<CUpti_ActivityEnvironment>() - 8usize];
    [
        "Offset of field: CUpti_ActivityEnvironment::kind",
    ][::std::mem::offset_of!(CUpti_ActivityEnvironment, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityEnvironment::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityEnvironment, deviceId) - 4usize];
    [
        "Offset of field: CUpti_ActivityEnvironment::timestamp",
    ][::std::mem::offset_of!(CUpti_ActivityEnvironment, timestamp) - 8usize];
    [
        "Offset of field: CUpti_ActivityEnvironment::environmentKind",
    ][::std::mem::offset_of!(CUpti_ActivityEnvironment, environmentKind) - 16usize];
    [
        "Offset of field: CUpti_ActivityEnvironment::data",
    ][::std::mem::offset_of!(CUpti_ActivityEnvironment, data) - 20usize];
};
impl Default for CUpti_ActivityEnvironment {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityEnvironment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityEnvironment {{ kind: {:?}, environmentKind: {:?}, data: {:?} }}",
            self.kind,
            self.environmentKind,
            self.data,
        )
    }
}
/** \brief The activity record for source-level instruction execution.

 This activity records result for source level instruction execution.
 (CUPTI_ACTIVITY_KIND_INSTRUCTION_EXECUTION).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityInstructionExecution {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_INSTRUCTION_EXECUTION.
    pub kind: CUpti_ActivityKind,
    /// The properties of this instruction execution.
    pub flags: CUpti_ActivityFlag,
    /// The ID for source locator.
    pub sourceLocatorId: u32,
    /// The correlation ID of the kernel to which this result is associated.
    pub correlationId: u32,
    /// Correlation ID with global/device function name
    pub functionId: u32,
    /// The pc offset for the instruction.
    pub pcOffset: u32,
    /** This increments each time when this instruction is executed by number
 of threads that executed this instruction, regardless of predicate or condition code.*/
    pub threadsExecuted: u64,
    /** This increments each time when this instruction is executed by number
 of threads that executed this instruction with predicate and condition code evaluating to true.*/
    pub notPredOffThreadsExecuted: u64,
    /** The number of times this instruction was executed per warp. It will be incremented
 regardless of predicate or condition code.*/
    pub executed: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityInstructionExecution",
    ][::std::mem::size_of::<CUpti_ActivityInstructionExecution>() - 48usize];
    [
        "Alignment of CUpti_ActivityInstructionExecution",
    ][::std::mem::align_of::<CUpti_ActivityInstructionExecution>() - 8usize];
    [
        "Offset of field: CUpti_ActivityInstructionExecution::kind",
    ][::std::mem::offset_of!(CUpti_ActivityInstructionExecution, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityInstructionExecution::flags",
    ][::std::mem::offset_of!(CUpti_ActivityInstructionExecution, flags) - 4usize];
    [
        "Offset of field: CUpti_ActivityInstructionExecution::sourceLocatorId",
    ][::std::mem::offset_of!(CUpti_ActivityInstructionExecution, sourceLocatorId)
        - 8usize];
    [
        "Offset of field: CUpti_ActivityInstructionExecution::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityInstructionExecution, correlationId)
        - 12usize];
    [
        "Offset of field: CUpti_ActivityInstructionExecution::functionId",
    ][::std::mem::offset_of!(CUpti_ActivityInstructionExecution, functionId) - 16usize];
    [
        "Offset of field: CUpti_ActivityInstructionExecution::pcOffset",
    ][::std::mem::offset_of!(CUpti_ActivityInstructionExecution, pcOffset) - 20usize];
    [
        "Offset of field: CUpti_ActivityInstructionExecution::threadsExecuted",
    ][::std::mem::offset_of!(CUpti_ActivityInstructionExecution, threadsExecuted)
        - 24usize];
    [
        "Offset of field: CUpti_ActivityInstructionExecution::notPredOffThreadsExecuted",
    ][::std::mem::offset_of!(
        CUpti_ActivityInstructionExecution, notPredOffThreadsExecuted
    ) - 32usize];
    [
        "Offset of field: CUpti_ActivityInstructionExecution::executed",
    ][::std::mem::offset_of!(CUpti_ActivityInstructionExecution, executed) - 40usize];
    [
        "Offset of field: CUpti_ActivityInstructionExecution::pad",
    ][::std::mem::offset_of!(CUpti_ActivityInstructionExecution, pad) - 44usize];
};
impl Default for CUpti_ActivityInstructionExecution {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for PC sampling.

 This activity records information obtained by sampling PC
 (CUPTI_ACTIVITY_KIND_PC_SAMPLING).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityPCSampling3 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_PC_SAMPLING.
    pub kind: CUpti_ActivityKind,
    /// The properties of this instruction.
    pub flags: CUpti_ActivityFlag,
    /// The ID for source locator.
    pub sourceLocatorId: u32,
    /// The correlation ID of the kernel to which this result is associated.
    pub correlationId: u32,
    /// Correlation ID with global/device function name
    pub functionId: u32,
    /** Number of times the PC was sampled with the stallReason in the record.
 These samples indicate that no instruction was issued in that cycle from
 the warp scheduler from where the warp was sampled.
 Field is valid for devices with compute capability 6.0 and higher*/
    pub latencySamples: u32,
    /** Number of times the PC was sampled with the stallReason in the record.
 The same PC can be sampled with different stall reasons. The count includes
 latencySamples.*/
    pub samples: u32,
    /** Current stall reason. Includes one of the reasons from
 \ref CUpti_ActivityPCSamplingStallReason*/
    pub stallReason: CUpti_ActivityPCSamplingStallReason,
    /// The pc offset for the instruction.
    pub pcOffset: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityPCSampling3",
    ][::std::mem::size_of::<CUpti_ActivityPCSampling3>() - 40usize];
    [
        "Alignment of CUpti_ActivityPCSampling3",
    ][::std::mem::align_of::<CUpti_ActivityPCSampling3>() - 8usize];
    [
        "Offset of field: CUpti_ActivityPCSampling3::kind",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling3, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityPCSampling3::flags",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling3, flags) - 4usize];
    [
        "Offset of field: CUpti_ActivityPCSampling3::sourceLocatorId",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling3, sourceLocatorId) - 8usize];
    [
        "Offset of field: CUpti_ActivityPCSampling3::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling3, correlationId) - 12usize];
    [
        "Offset of field: CUpti_ActivityPCSampling3::functionId",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling3, functionId) - 16usize];
    [
        "Offset of field: CUpti_ActivityPCSampling3::latencySamples",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling3, latencySamples) - 20usize];
    [
        "Offset of field: CUpti_ActivityPCSampling3::samples",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling3, samples) - 24usize];
    [
        "Offset of field: CUpti_ActivityPCSampling3::stallReason",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling3, stallReason) - 28usize];
    [
        "Offset of field: CUpti_ActivityPCSampling3::pcOffset",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling3, pcOffset) - 32usize];
};
impl Default for CUpti_ActivityPCSampling3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for record status for PC sampling.

 This activity records information obtained by sampling PC
 (CUPTI_ACTIVITY_KIND_PC_SAMPLING_RECORD_INFO).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityPCSamplingRecordInfo {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_PC_SAMPLING_RECORD_INFO.
    pub kind: CUpti_ActivityKind,
    /// The correlation ID of the kernel to which this result is associated.
    pub correlationId: u32,
    /** Number of times the PC was sampled for this kernel instance including all
 dropped samples.*/
    pub totalSamples: u64,
    /// Number of samples that were dropped by hardware due to backpressure/overflow.
    pub droppedSamples: u64,
    /// Sampling period in terms of number of cycles .
    pub samplingPeriodInCycles: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityPCSamplingRecordInfo",
    ][::std::mem::size_of::<CUpti_ActivityPCSamplingRecordInfo>() - 32usize];
    [
        "Alignment of CUpti_ActivityPCSamplingRecordInfo",
    ][::std::mem::align_of::<CUpti_ActivityPCSamplingRecordInfo>() - 8usize];
    [
        "Offset of field: CUpti_ActivityPCSamplingRecordInfo::kind",
    ][::std::mem::offset_of!(CUpti_ActivityPCSamplingRecordInfo, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityPCSamplingRecordInfo::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityPCSamplingRecordInfo, correlationId)
        - 4usize];
    [
        "Offset of field: CUpti_ActivityPCSamplingRecordInfo::totalSamples",
    ][::std::mem::offset_of!(CUpti_ActivityPCSamplingRecordInfo, totalSamples) - 8usize];
    [
        "Offset of field: CUpti_ActivityPCSamplingRecordInfo::droppedSamples",
    ][::std::mem::offset_of!(CUpti_ActivityPCSamplingRecordInfo, droppedSamples)
        - 16usize];
    [
        "Offset of field: CUpti_ActivityPCSamplingRecordInfo::samplingPeriodInCycles",
    ][::std::mem::offset_of!(CUpti_ActivityPCSamplingRecordInfo, samplingPeriodInCycles)
        - 24usize];
};
impl Default for CUpti_ActivityPCSamplingRecordInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for Unified Memory counters (CUDA 7.0 and beyond)

 This activity record represents a Unified Memory counter
 (CUPTI_ACTIVITY_KIND_UNIFIED_MEMORY_COUNTER).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityUnifiedMemoryCounter3 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_UNIFIED_MEMORY_COUNTER
    pub kind: CUpti_ActivityKind,
    /// The Unified Memory counter kind
    pub counterKind: CUpti_ActivityUnifiedMemoryCounterKind,
    /** Value of the counter
 For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD,
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_DTOH,
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THREASHING and
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_REMOTE_MAP, it is the size of the
 memory region in bytes.
 For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT, it
 is the number of page fault groups for the same page.
 For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT,
 it is the program counter for the instruction that caused fault.*/
    pub value: u64,
    /** The start timestamp of the counter, in ns.
 For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD and
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_DTOH, timestamp is
 captured when activity starts on GPU.
 For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT and
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT, timestamp is
 captured when CUDA driver started processing the fault.
 For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING, timestamp
 is captured when CUDA driver detected thrashing of memory region.
 For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING,
 timestamp is captured when throttling operation was started by CUDA driver.
 For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_REMOTE_MAP,
 timestamp is captured when CUDA driver has pushed all required operations
 to the processor specified by dstId.*/
    pub start: u64,
    /** The end timestamp of the counter, in ns.
 Ignore this field if counterKind is
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT or
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING or
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_REMOTE_MAP.
 For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD and
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_DTOH, timestamp is
 captured when activity finishes on GPU.
 For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT, timestamp is
 captured when CUDA driver queues the replay of faulting memory accesses on the GPU
 For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING, timestamp
 is captured when throttling operation was finished by CUDA driver*/
    pub end: u64,
    /** This is the virtual base address of the page/s being transferred. For cpu and
 gpu faults, the virtual address for the page that faulted.*/
    pub address: u64,
    /** The ID of the source CPU/device involved in the memory transfer, page fault, thrashing,
 throttling or remote map operation. For counterKind
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING, it is a bitwise ORing of the
 device IDs fighting for the memory region, ONLY if there are less than 32 devices. Ignore this field if counterKind is
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT*/
    pub srcId: u32,
    /** The ID of the destination CPU/device involved in the memory transfer or remote map
 operation. Ignore this field if counterKind is
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT or
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT or
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING or
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING*/
    pub dstId: u32,
    /** The ID of the stream causing the transfer.
 This value of this field is invalid.*/
    pub streamId: u32,
    /// The ID of the process to which this record belongs to.
    pub processId: u32,
    /** The flags associated with this record. See enums \ref CUpti_ActivityUnifiedMemoryAccessType
 if counterKind is CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT
 and \ref CUpti_ActivityUnifiedMemoryMigrationCause if counterKind is
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD or
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD
 and \ref CUpti_ActivityUnifiedMemoryRemoteMapCause if counterKind is
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_REMOTE_MAP and \ref CUpti_ActivityFlag
 if counterKind is CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING or
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING*/
    pub flags: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
    /** \brief The bitmask of devices involved in the operation.

 For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING, it is a bitwise ORing of the
 device IDs fighting for the memory region. processors[0] represents the device ID of the device 0 to device 63,
 processors[1] represents device ID of device 64 to device 127 and so on.
 Ignore this field if counterKind is
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT or
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT or
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING or
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_REMOTE_MAP or
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD or
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_DTOH or
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_DTOD or
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_FAULT_REPLAY*/
    pub processors: [u64; 5usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityUnifiedMemoryCounter3",
    ][::std::mem::size_of::<CUpti_ActivityUnifiedMemoryCounter3>() - 104usize];
    [
        "Alignment of CUpti_ActivityUnifiedMemoryCounter3",
    ][::std::mem::align_of::<CUpti_ActivityUnifiedMemoryCounter3>() - 8usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter3::kind",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter3::counterKind",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, counterKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter3::value",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, value) - 8usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter3::start",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter3::end",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter3::address",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, address) - 32usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter3::srcId",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, srcId) - 40usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter3::dstId",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, dstId) - 44usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter3::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, streamId) - 48usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter3::processId",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, processId) - 52usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter3::flags",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, flags) - 56usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter3::pad",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, pad) - 60usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter3::processors",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, processors) - 64usize];
};
impl Default for CUpti_ActivityUnifiedMemoryCounter3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for global/device functions.

 This activity records function name and corresponding module
 information.
 (CUPTI_ACTIVITY_KIND_FUNCTION).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityFunction {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_FUNCTION.
    pub kind: CUpti_ActivityKind,
    /// ID to uniquely identify the record
    pub id: u32,
    /// The ID of the context where the function is launched.
    pub contextId: u32,
    /// The module ID in which this global/device function is present.
    pub moduleId: u32,
    /// The function's unique symbol index in the module.
    pub functionIndex: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
    /** The name of the function. This name is shared across all activity
 records representing the same kernel, and so should not be
 modified.*/
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityFunction",
    ][::std::mem::size_of::<CUpti_ActivityFunction>() - 32usize];
    [
        "Alignment of CUpti_ActivityFunction",
    ][::std::mem::align_of::<CUpti_ActivityFunction>() - 8usize];
    [
        "Offset of field: CUpti_ActivityFunction::kind",
    ][::std::mem::offset_of!(CUpti_ActivityFunction, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityFunction::id",
    ][::std::mem::offset_of!(CUpti_ActivityFunction, id) - 4usize];
    [
        "Offset of field: CUpti_ActivityFunction::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityFunction, contextId) - 8usize];
    [
        "Offset of field: CUpti_ActivityFunction::moduleId",
    ][::std::mem::offset_of!(CUpti_ActivityFunction, moduleId) - 12usize];
    [
        "Offset of field: CUpti_ActivityFunction::functionIndex",
    ][::std::mem::offset_of!(CUpti_ActivityFunction, functionIndex) - 16usize];
    [
        "Offset of field: CUpti_ActivityFunction::pad",
    ][::std::mem::offset_of!(CUpti_ActivityFunction, pad) - 20usize];
    [
        "Offset of field: CUpti_ActivityFunction::name",
    ][::std::mem::offset_of!(CUpti_ActivityFunction, name) - 24usize];
};
impl Default for CUpti_ActivityFunction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for a CUDA module.

 This activity record represents a CUDA module
 (CUPTI_ACTIVITY_KIND_MODULE). This activity record kind is not
 produced by the activity API but is included for completeness and
 ease-of-use. Profile frameworks built on top of CUPTI that collect
 module data from the module callback may choose to use this type to
 store the collected module data.*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityModule {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MODULE.
    pub kind: CUpti_ActivityKind,
    /// The ID of the context where the module is loaded.
    pub contextId: u32,
    /// The module ID.
    pub id: u32,
    /// The cubin size.
    pub cubinSize: u32,
    /// The pointer to cubin.
    pub cubin: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityModule",
    ][::std::mem::size_of::<CUpti_ActivityModule>() - 24usize];
    [
        "Alignment of CUpti_ActivityModule",
    ][::std::mem::align_of::<CUpti_ActivityModule>() - 8usize];
    [
        "Offset of field: CUpti_ActivityModule::kind",
    ][::std::mem::offset_of!(CUpti_ActivityModule, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityModule::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityModule, contextId) - 4usize];
    [
        "Offset of field: CUpti_ActivityModule::id",
    ][::std::mem::offset_of!(CUpti_ActivityModule, id) - 8usize];
    [
        "Offset of field: CUpti_ActivityModule::cubinSize",
    ][::std::mem::offset_of!(CUpti_ActivityModule, cubinSize) - 12usize];
    [
        "Offset of field: CUpti_ActivityModule::cubin",
    ][::std::mem::offset_of!(CUpti_ActivityModule, cubin) - 16usize];
};
impl Default for CUpti_ActivityModule {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for source-level shared
 access.

 This activity records the locations of the shared
 accesses in the source
 (CUPTI_ACTIVITY_KIND_SHARED_ACCESS).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivitySharedAccess {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_SHARED_ACCESS.
    pub kind: CUpti_ActivityKind,
    /// The properties of this shared access.
    pub flags: CUpti_ActivityFlag,
    /// The ID for source locator.
    pub sourceLocatorId: u32,
    /// The correlation ID of the kernel to which this result is associated.
    pub correlationId: u32,
    /// Correlation ID with global/device function name
    pub functionId: u32,
    /// The pc offset for the access.
    pub pcOffset: u32,
    /** This increments each time when this instruction is executed by number
 of threads that executed this instruction with predicate and condition code evaluating to true.*/
    pub threadsExecuted: u64,
    /// The total number of shared memory transactions generated by this access
    pub sharedTransactions: u64,
    /// The minimum number of shared memory transactions possible based on the access pattern.
    pub theoreticalSharedTransactions: u64,
    /** The number of times this instruction was executed per warp. It will be incremented
 when at least one of thread among warp is active with predicate and condition code
 evaluating to true.*/
    pub executed: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivitySharedAccess",
    ][::std::mem::size_of::<CUpti_ActivitySharedAccess>() - 56usize];
    [
        "Alignment of CUpti_ActivitySharedAccess",
    ][::std::mem::align_of::<CUpti_ActivitySharedAccess>() - 8usize];
    [
        "Offset of field: CUpti_ActivitySharedAccess::kind",
    ][::std::mem::offset_of!(CUpti_ActivitySharedAccess, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivitySharedAccess::flags",
    ][::std::mem::offset_of!(CUpti_ActivitySharedAccess, flags) - 4usize];
    [
        "Offset of field: CUpti_ActivitySharedAccess::sourceLocatorId",
    ][::std::mem::offset_of!(CUpti_ActivitySharedAccess, sourceLocatorId) - 8usize];
    [
        "Offset of field: CUpti_ActivitySharedAccess::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivitySharedAccess, correlationId) - 12usize];
    [
        "Offset of field: CUpti_ActivitySharedAccess::functionId",
    ][::std::mem::offset_of!(CUpti_ActivitySharedAccess, functionId) - 16usize];
    [
        "Offset of field: CUpti_ActivitySharedAccess::pcOffset",
    ][::std::mem::offset_of!(CUpti_ActivitySharedAccess, pcOffset) - 20usize];
    [
        "Offset of field: CUpti_ActivitySharedAccess::threadsExecuted",
    ][::std::mem::offset_of!(CUpti_ActivitySharedAccess, threadsExecuted) - 24usize];
    [
        "Offset of field: CUpti_ActivitySharedAccess::sharedTransactions",
    ][::std::mem::offset_of!(CUpti_ActivitySharedAccess, sharedTransactions) - 32usize];
    [
        "Offset of field: CUpti_ActivitySharedAccess::theoreticalSharedTransactions",
    ][::std::mem::offset_of!(CUpti_ActivitySharedAccess, theoreticalSharedTransactions)
        - 40usize];
    [
        "Offset of field: CUpti_ActivitySharedAccess::executed",
    ][::std::mem::offset_of!(CUpti_ActivitySharedAccess, executed) - 48usize];
    [
        "Offset of field: CUpti_ActivitySharedAccess::pad",
    ][::std::mem::offset_of!(CUpti_ActivitySharedAccess, pad) - 52usize];
};
impl Default for CUpti_ActivitySharedAccess {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for CUDA event.

 This activity is used to track recorded events.
 (CUPTI_ACTIVITY_KIND_CUDA_EVENT).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityCudaEvent2 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_CUDA_EVENT.
    pub kind: CUpti_ActivityKind,
    /// The correlation ID of the API to which this result is associated.
    pub correlationId: u32,
    /// The ID of the context where the event was recorded.
    pub contextId: u32,
    /// The compute stream where the event was recorded.
    pub streamId: u32,
    /// A unique event ID to identify the event record.
    pub eventId: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
    /// The ID of the device where the event was recorded.
    pub deviceId: u32,
    /// Undefined. Reserved for internal use.
    pub pad2: u32,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
    /** The device-side timestamp on CUDA event record.
 Timestamp is in nanoseconds. Collection of this field is disabled by default.
 It can be enabled by calling CUPTI API \ref cuptiActivityEnableCudaEventDeviceTimestamps*/
    pub deviceTimestamp: u64,
    /** A unique ID to associate event synchronization records
 with the latest CUDA Event record. Similar field is added
 in CUpti_ActivitySynchronization2 to associate CUDA Event
 record to the synchronization record.

 The same CUDA event can be used multiple times, so the
 event id will not be unique to correlate the synchronization
 record with the latest CUDA Event record.
 This field will be unique and can be used to do the required
 correlation.*/
    pub cudaEventSyncId: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityCudaEvent2",
    ][::std::mem::size_of::<CUpti_ActivityCudaEvent2>() - 56usize];
    [
        "Alignment of CUpti_ActivityCudaEvent2",
    ][::std::mem::align_of::<CUpti_ActivityCudaEvent2>() - 8usize];
    [
        "Offset of field: CUpti_ActivityCudaEvent2::kind",
    ][::std::mem::offset_of!(CUpti_ActivityCudaEvent2, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityCudaEvent2::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityCudaEvent2, correlationId) - 4usize];
    [
        "Offset of field: CUpti_ActivityCudaEvent2::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityCudaEvent2, contextId) - 8usize];
    [
        "Offset of field: CUpti_ActivityCudaEvent2::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityCudaEvent2, streamId) - 12usize];
    [
        "Offset of field: CUpti_ActivityCudaEvent2::eventId",
    ][::std::mem::offset_of!(CUpti_ActivityCudaEvent2, eventId) - 16usize];
    [
        "Offset of field: CUpti_ActivityCudaEvent2::pad",
    ][::std::mem::offset_of!(CUpti_ActivityCudaEvent2, pad) - 20usize];
    [
        "Offset of field: CUpti_ActivityCudaEvent2::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityCudaEvent2, deviceId) - 24usize];
    [
        "Offset of field: CUpti_ActivityCudaEvent2::pad2",
    ][::std::mem::offset_of!(CUpti_ActivityCudaEvent2, pad2) - 28usize];
    [
        "Offset of field: CUpti_ActivityCudaEvent2::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityCudaEvent2, reserved0) - 32usize];
    [
        "Offset of field: CUpti_ActivityCudaEvent2::deviceTimestamp",
    ][::std::mem::offset_of!(CUpti_ActivityCudaEvent2, deviceTimestamp) - 40usize];
    [
        "Offset of field: CUpti_ActivityCudaEvent2::cudaEventSyncId",
    ][::std::mem::offset_of!(CUpti_ActivityCudaEvent2, cudaEventSyncId) - 48usize];
};
impl Default for CUpti_ActivityCudaEvent2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for CUDA stream.

 This activity is used to track created streams.
 (CUPTI_ACTIVITY_KIND_STREAM).*/
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityStream {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_STREAM.
    pub kind: CUpti_ActivityKind,
    /// The ID of the context where the stream was created.
    pub contextId: u32,
    /// A unique stream ID to identify the stream.
    pub streamId: u32,
    /// The clamped priority for the stream.
    pub priority: u32,
    /// Flags associated with the stream.
    pub flag: CUpti_ActivityStreamFlag,
    /// The correlation ID of the API to which this result is associated.
    pub correlationId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityStream",
    ][::std::mem::size_of::<CUpti_ActivityStream>() - 24usize];
    [
        "Alignment of CUpti_ActivityStream",
    ][::std::mem::align_of::<CUpti_ActivityStream>() - 8usize];
    [
        "Offset of field: CUpti_ActivityStream::kind",
    ][::std::mem::offset_of!(CUpti_ActivityStream, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityStream::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityStream, contextId) - 4usize];
    [
        "Offset of field: CUpti_ActivityStream::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityStream, streamId) - 8usize];
    [
        "Offset of field: CUpti_ActivityStream::priority",
    ][::std::mem::offset_of!(CUpti_ActivityStream, priority) - 12usize];
    [
        "Offset of field: CUpti_ActivityStream::flag",
    ][::std::mem::offset_of!(CUpti_ActivityStream, flag) - 16usize];
    [
        "Offset of field: CUpti_ActivityStream::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityStream, correlationId) - 20usize];
};
impl Default for CUpti_ActivityStream {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for synchronization management.

 This activity is used to track various CUDA synchronization APIs.
 (CUPTI_ACTIVITY_KIND_SYNCHRONIZATION).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivitySynchronization2 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_SYNCHRONIZATION.
    pub kind: CUpti_ActivityKind,
    /// The type of record.
    pub type_: CUpti_ActivitySynchronizationType,
    /** The start timestamp for the function, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the function.*/
    pub start: u64,
    /** The end timestamp for the function, in ns. A value of 0 for both
 the start and end timestamps indicates that timestamp information
 could not be collected for the function.*/
    pub end: u64,
    /// The correlation ID of the API to which this result is associated.
    pub correlationId: u32,
    /** The ID of the context for which the synchronization API is called.
 In case of context synchronization API it is the context id for which the API is called.
 In case of stream/event synchronization it is the ID of the context where the stream/event was created.*/
    pub contextId: u32,
    /** The compute stream for which the synchronization API is called.
 A CUPTI_SYNCHRONIZATION_INVALID_VALUE value indicate the field is not applicable for this record.
 Not valid for cuCtxSynchronize, cuEventSynchronize.*/
    pub streamId: u32,
    /** The event ID for which the synchronization API is called.
 A CUPTI_SYNCHRONIZATION_INVALID_VALUE value indicate the field is not applicable for this record.
 Not valid for cuCtxSynchronize, cuStreamSynchronize.*/
    pub cudaEventId: u32,
    /** A unique ID to associate event synchronization records
 with the latest CUDA Event record. Similar field is added
 in CUpti_ActivityCudaEvent2 to associate synchronization
 record to the CUDA Event record.

 The same CUDA event can be used multiple times, so the
 event id will not be unique to correlate the synchronization
 record with the latest CUDA Event record.
 This field will be unique and can be used to do the required
 correlation.

 A CUPTI_SYNCHRONIZATION_INVALID_VALUE value indicates that
 the field is not applicable for this record.
 Valid only for synchronization records related to CUDA Events.*/
    pub cudaEventSyncId: u64,
    /** The return value for the synchronization record.
 Use cuptiActivityEnableAllSyncRecords API to enable/disable
 collection of synchronization records with return value being
 non-zero. This will be a CUresult value.*/
    pub returnValue: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivitySynchronization2",
    ][::std::mem::size_of::<CUpti_ActivitySynchronization2>() - 56usize];
    [
        "Alignment of CUpti_ActivitySynchronization2",
    ][::std::mem::align_of::<CUpti_ActivitySynchronization2>() - 8usize];
    [
        "Offset of field: CUpti_ActivitySynchronization2::kind",
    ][::std::mem::offset_of!(CUpti_ActivitySynchronization2, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivitySynchronization2::type_",
    ][::std::mem::offset_of!(CUpti_ActivitySynchronization2, type_) - 4usize];
    [
        "Offset of field: CUpti_ActivitySynchronization2::start",
    ][::std::mem::offset_of!(CUpti_ActivitySynchronization2, start) - 8usize];
    [
        "Offset of field: CUpti_ActivitySynchronization2::end",
    ][::std::mem::offset_of!(CUpti_ActivitySynchronization2, end) - 16usize];
    [
        "Offset of field: CUpti_ActivitySynchronization2::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivitySynchronization2, correlationId) - 24usize];
    [
        "Offset of field: CUpti_ActivitySynchronization2::contextId",
    ][::std::mem::offset_of!(CUpti_ActivitySynchronization2, contextId) - 28usize];
    [
        "Offset of field: CUpti_ActivitySynchronization2::streamId",
    ][::std::mem::offset_of!(CUpti_ActivitySynchronization2, streamId) - 32usize];
    [
        "Offset of field: CUpti_ActivitySynchronization2::cudaEventId",
    ][::std::mem::offset_of!(CUpti_ActivitySynchronization2, cudaEventId) - 36usize];
    [
        "Offset of field: CUpti_ActivitySynchronization2::cudaEventSyncId",
    ][::std::mem::offset_of!(CUpti_ActivitySynchronization2, cudaEventSyncId) - 40usize];
    [
        "Offset of field: CUpti_ActivitySynchronization2::returnValue",
    ][::std::mem::offset_of!(CUpti_ActivitySynchronization2, returnValue) - 48usize];
    [
        "Offset of field: CUpti_ActivitySynchronization2::pad",
    ][::std::mem::offset_of!(CUpti_ActivitySynchronization2, pad) - 52usize];
};
impl Default for CUpti_ActivitySynchronization2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for source-level sass/source
 line-by-line correlation.

 This activity records source level sass/source correlation
 information.
 (CUPTI_ACTIVITY_KIND_INSTRUCTION_CORRELATION).*/
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityInstructionCorrelation {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_INSTRUCTION_CORRELATION.
    pub kind: CUpti_ActivityKind,
    /// The properties of this instruction.
    pub flags: CUpti_ActivityFlag,
    /// The ID for source locator.
    pub sourceLocatorId: u32,
    /// Correlation ID with global/device function name
    pub functionId: u32,
    /// The pc offset for the instruction.
    pub pcOffset: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityInstructionCorrelation",
    ][::std::mem::size_of::<CUpti_ActivityInstructionCorrelation>() - 24usize];
    [
        "Alignment of CUpti_ActivityInstructionCorrelation",
    ][::std::mem::align_of::<CUpti_ActivityInstructionCorrelation>() - 8usize];
    [
        "Offset of field: CUpti_ActivityInstructionCorrelation::kind",
    ][::std::mem::offset_of!(CUpti_ActivityInstructionCorrelation, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityInstructionCorrelation::flags",
    ][::std::mem::offset_of!(CUpti_ActivityInstructionCorrelation, flags) - 4usize];
    [
        "Offset of field: CUpti_ActivityInstructionCorrelation::sourceLocatorId",
    ][::std::mem::offset_of!(CUpti_ActivityInstructionCorrelation, sourceLocatorId)
        - 8usize];
    [
        "Offset of field: CUpti_ActivityInstructionCorrelation::functionId",
    ][::std::mem::offset_of!(CUpti_ActivityInstructionCorrelation, functionId)
        - 12usize];
    [
        "Offset of field: CUpti_ActivityInstructionCorrelation::pcOffset",
    ][::std::mem::offset_of!(CUpti_ActivityInstructionCorrelation, pcOffset) - 16usize];
    [
        "Offset of field: CUpti_ActivityInstructionCorrelation::pad",
    ][::std::mem::offset_of!(CUpti_ActivityInstructionCorrelation, pad) - 20usize];
};
impl Default for CUpti_ActivityInstructionCorrelation {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CUPTI_OPENACC_EVENT_KIND_INVALID: CUpti_OpenAccEventKind = 0;
pub const CUPTI_OPENACC_EVENT_KIND_DEVICE_INIT: CUpti_OpenAccEventKind = 1;
pub const CUPTI_OPENACC_EVENT_KIND_DEVICE_SHUTDOWN: CUpti_OpenAccEventKind = 2;
pub const CUPTI_OPENACC_EVENT_KIND_RUNTIME_SHUTDOWN: CUpti_OpenAccEventKind = 3;
pub const CUPTI_OPENACC_EVENT_KIND_ENQUEUE_LAUNCH: CUpti_OpenAccEventKind = 4;
pub const CUPTI_OPENACC_EVENT_KIND_ENQUEUE_UPLOAD: CUpti_OpenAccEventKind = 5;
pub const CUPTI_OPENACC_EVENT_KIND_ENQUEUE_DOWNLOAD: CUpti_OpenAccEventKind = 6;
pub const CUPTI_OPENACC_EVENT_KIND_WAIT: CUpti_OpenAccEventKind = 7;
pub const CUPTI_OPENACC_EVENT_KIND_IMPLICIT_WAIT: CUpti_OpenAccEventKind = 8;
pub const CUPTI_OPENACC_EVENT_KIND_COMPUTE_CONSTRUCT: CUpti_OpenAccEventKind = 9;
pub const CUPTI_OPENACC_EVENT_KIND_UPDATE: CUpti_OpenAccEventKind = 10;
pub const CUPTI_OPENACC_EVENT_KIND_ENTER_DATA: CUpti_OpenAccEventKind = 11;
pub const CUPTI_OPENACC_EVENT_KIND_EXIT_DATA: CUpti_OpenAccEventKind = 12;
pub const CUPTI_OPENACC_EVENT_KIND_CREATE: CUpti_OpenAccEventKind = 13;
pub const CUPTI_OPENACC_EVENT_KIND_DELETE: CUpti_OpenAccEventKind = 14;
pub const CUPTI_OPENACC_EVENT_KIND_ALLOC: CUpti_OpenAccEventKind = 15;
pub const CUPTI_OPENACC_EVENT_KIND_FREE: CUpti_OpenAccEventKind = 16;
pub const CUPTI_OPENACC_EVENT_KIND_FORCE_INT: CUpti_OpenAccEventKind = 2147483647;
/** \brief The OpenAcc event kind for OpenAcc activity records.

 \see CUpti_ActivityKindOpenAcc*/
pub type CUpti_OpenAccEventKind = ::std::os::raw::c_uint;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_UNKNOWN: CUpti_OpenAccConstructKind = 0;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_PARALLEL: CUpti_OpenAccConstructKind = 1;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_KERNELS: CUpti_OpenAccConstructKind = 2;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_LOOP: CUpti_OpenAccConstructKind = 3;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_DATA: CUpti_OpenAccConstructKind = 4;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_ENTER_DATA: CUpti_OpenAccConstructKind = 5;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_EXIT_DATA: CUpti_OpenAccConstructKind = 6;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_HOST_DATA: CUpti_OpenAccConstructKind = 7;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_ATOMIC: CUpti_OpenAccConstructKind = 8;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_DECLARE: CUpti_OpenAccConstructKind = 9;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_INIT: CUpti_OpenAccConstructKind = 10;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_SHUTDOWN: CUpti_OpenAccConstructKind = 11;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_SET: CUpti_OpenAccConstructKind = 12;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_UPDATE: CUpti_OpenAccConstructKind = 13;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_ROUTINE: CUpti_OpenAccConstructKind = 14;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_WAIT: CUpti_OpenAccConstructKind = 15;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_RUNTIME_API: CUpti_OpenAccConstructKind = 16;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_FORCE_INT: CUpti_OpenAccConstructKind = 2147483647;
/// \brief The OpenAcc parent construct kind for OpenAcc activity records.
pub type CUpti_OpenAccConstructKind = ::std::os::raw::c_uint;
pub const CUPTI_OPENMP_EVENT_KIND_INVALID: CUpti_OpenMpEventKind = 0;
pub const CUPTI_OPENMP_EVENT_KIND_PARALLEL: CUpti_OpenMpEventKind = 1;
pub const CUPTI_OPENMP_EVENT_KIND_TASK: CUpti_OpenMpEventKind = 2;
pub const CUPTI_OPENMP_EVENT_KIND_THREAD: CUpti_OpenMpEventKind = 3;
pub const CUPTI_OPENMP_EVENT_KIND_IDLE: CUpti_OpenMpEventKind = 4;
pub const CUPTI_OPENMP_EVENT_KIND_WAIT_BARRIER: CUpti_OpenMpEventKind = 5;
pub const CUPTI_OPENMP_EVENT_KIND_WAIT_TASKWAIT: CUpti_OpenMpEventKind = 6;
pub const CUPTI_OPENMP_EVENT_KIND_FORCE_INT: CUpti_OpenMpEventKind = 2147483647;
pub type CUpti_OpenMpEventKind = ::std::os::raw::c_uint;
/** \brief The base activity record for OpenAcc records.

 The OpenACC activity API part uses a CUpti_ActivityOpenAcc as a generic
 representation for any OpenACC activity. The 'kind' field is used to determine the
 specific activity kind, and from that the CUpti_ActivityOpenAcc object can
 be cast to the specific OpenACC activity record type appropriate for that kind.

 Note that all OpenACC activity record types are padded and aligned to
 ensure that each member of the record is naturally aligned.

 \see CUpti_ActivityKind*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityOpenAcc {
    /// The kind of this activity.
    pub kind: CUpti_ActivityKind,
    /// CUPTI OpenACC event kind (\see CUpti_OpenAccEventKind)
    pub eventKind: CUpti_OpenAccEventKind,
    /** CUPTI OpenACC parent construct kind (\see CUpti_OpenAccConstructKind)

 Note that for applications using PGI OpenACC runtime < 16.1, this
 will always be CUPTI_OPENACC_CONSTRUCT_KIND_UNKNOWN.*/
    pub parentConstruct: CUpti_OpenAccConstructKind,
    /// Version number
    pub version: u32,
    /** 1 for any implicit event, such as an implicit wait at a synchronous data construct
 0 otherwise*/
    pub implicit: u32,
    /// Device type
    pub deviceType: u32,
    /// Device number
    pub deviceNumber: u32,
    /// ThreadId
    pub threadId: u32,
    /// Value of async() clause of the corresponding directive
    pub async_: u64,
    /// Internal asynchronous queue number used
    pub asyncMap: u64,
    /** The line number of the directive or program construct or the starting line
 number of the OpenACC construct corresponding to the event.
 A zero value means the line number is not known.*/
    pub lineNo: u32,
    /** For an OpenACC construct, this contains the line number of the end
 of the construct. A zero value means the line number is not known.*/
    pub endLineNo: u32,
    /** The line number of the first line of the function named in funcName.
 A zero value means the line number is not known.*/
    pub funcLineNo: u32,
    /** The last line number of the function named in funcName.
 A zero value means the line number is not known.*/
    pub funcEndLineNo: u32,
    /// CUPTI start timestamp
    pub start: u64,
    /// CUPTI end timestamp
    pub end: u64,
    /** CUDA device id
 Valid only if deviceType is acc_device_nvidia.*/
    pub cuDeviceId: u32,
    /** CUDA context id
 Valid only if deviceType is acc_device_nvidia.*/
    pub cuContextId: u32,
    /** CUDA stream id
 Valid only if deviceType is acc_device_nvidia.*/
    pub cuStreamId: u32,
    /// The ID of the process where the OpenACC activity is executing.
    pub cuProcessId: u32,
    /// The ID of the thread where the OpenACC activity is executing.
    pub cuThreadId: u32,
    /** The OpenACC correlation ID.
 Valid only if deviceType is acc_device_nvidia.
 If not 0, it uniquely identifies this record. It is identical to the
 externalId in the preceding external correlation record of type
 CUPTI_EXTERNAL_CORRELATION_KIND_OPENACC.*/
    pub externalId: u32,
    pub srcFile: *const ::std::os::raw::c_char,
    pub funcName: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityOpenAcc",
    ][::std::mem::size_of::<CUpti_ActivityOpenAcc>() - 120usize];
    [
        "Alignment of CUpti_ActivityOpenAcc",
    ][::std::mem::align_of::<CUpti_ActivityOpenAcc>() - 8usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::kind",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::eventKind",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, eventKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::parentConstruct",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, parentConstruct) - 8usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::version",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, version) - 12usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::implicit",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, implicit) - 16usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::deviceType",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, deviceType) - 20usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::deviceNumber",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, deviceNumber) - 24usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::threadId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, threadId) - 28usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::async_",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, async_) - 32usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::asyncMap",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, asyncMap) - 40usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::lineNo",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, lineNo) - 48usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::endLineNo",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, endLineNo) - 52usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::funcLineNo",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, funcLineNo) - 56usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::funcEndLineNo",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, funcEndLineNo) - 60usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::start",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, start) - 64usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::end",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, end) - 72usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::cuDeviceId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, cuDeviceId) - 80usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::cuContextId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, cuContextId) - 84usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::cuStreamId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, cuStreamId) - 88usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::cuProcessId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, cuProcessId) - 92usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::cuThreadId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, cuThreadId) - 96usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::externalId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, externalId) - 100usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::srcFile",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, srcFile) - 104usize];
    [
        "Offset of field: CUpti_ActivityOpenAcc::funcName",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAcc, funcName) - 112usize];
};
impl Default for CUpti_ActivityOpenAcc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for OpenACC data.

 (CUPTI_ACTIVITY_KIND_OPENACC_DATA).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityOpenAccData {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_OPENACC_DATA.
    pub kind: CUpti_ActivityKind,
    /// CUPTI OpenACC event kind (\see CUpti_OpenAccEventKind)
    pub eventKind: CUpti_OpenAccEventKind,
    pub parentConstruct: CUpti_OpenAccConstructKind,
    pub version: u32,
    pub implicit: u32,
    pub deviceType: u32,
    pub deviceNumber: u32,
    /// ThreadId
    pub threadId: u32,
    pub async_: u64,
    pub asyncMap: u64,
    pub lineNo: u32,
    pub endLineNo: u32,
    pub funcLineNo: u32,
    pub funcEndLineNo: u32,
    /// CUPTI start timestamp
    pub start: u64,
    /// CUPTI end timestamp
    pub end: u64,
    /** CUDA device id
 Valid only if deviceType is acc_device_nvidia.*/
    pub cuDeviceId: u32,
    /** CUDA context id
 Valid only if deviceType is acc_device_nvidia.*/
    pub cuContextId: u32,
    /** CUDA stream id
 Valid only if deviceType is acc_device_nvidia.*/
    pub cuStreamId: u32,
    /// The ID of the process where the OpenACC activity is executing.
    pub cuProcessId: u32,
    /// The ID of the thread where the OpenACC activity is executing.
    pub cuThreadId: u32,
    /** The OpenACC correlation ID.
 Valid only if deviceType is acc_device_nvidia.
 If not 0, it uniquely identifies this record. It is identical to the
 externalId in the preceding external correlation record of type
 CUPTI_EXTERNAL_CORRELATION_KIND_OPENACC.*/
    pub externalId: u32,
    pub srcFile: *const ::std::os::raw::c_char,
    pub funcName: *const ::std::os::raw::c_char,
    /// Number of bytes
    pub bytes: u64,
    /// Host pointer if available
    pub hostPtr: u64,
    /// Device pointer if available
    pub devicePtr: u64,
    pub varName: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityOpenAccData",
    ][::std::mem::size_of::<CUpti_ActivityOpenAccData>() - 152usize];
    [
        "Alignment of CUpti_ActivityOpenAccData",
    ][::std::mem::align_of::<CUpti_ActivityOpenAccData>() - 8usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::kind",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::eventKind",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, eventKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::parentConstruct",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, parentConstruct) - 8usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::version",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, version) - 12usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::implicit",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, implicit) - 16usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::deviceType",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, deviceType) - 20usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::deviceNumber",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, deviceNumber) - 24usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::threadId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, threadId) - 28usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::async_",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, async_) - 32usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::asyncMap",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, asyncMap) - 40usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::lineNo",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, lineNo) - 48usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::endLineNo",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, endLineNo) - 52usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::funcLineNo",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, funcLineNo) - 56usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::funcEndLineNo",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, funcEndLineNo) - 60usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::start",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, start) - 64usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::end",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, end) - 72usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::cuDeviceId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, cuDeviceId) - 80usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::cuContextId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, cuContextId) - 84usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::cuStreamId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, cuStreamId) - 88usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::cuProcessId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, cuProcessId) - 92usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::cuThreadId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, cuThreadId) - 96usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::externalId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, externalId) - 100usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::srcFile",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, srcFile) - 104usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::funcName",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, funcName) - 112usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::bytes",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, bytes) - 120usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::hostPtr",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, hostPtr) - 128usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::devicePtr",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, devicePtr) - 136usize];
    [
        "Offset of field: CUpti_ActivityOpenAccData::varName",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccData, varName) - 144usize];
};
impl Default for CUpti_ActivityOpenAccData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for OpenACC launch.

 (CUPTI_ACTIVITY_KIND_OPENACC_LAUNCH).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityOpenAccLaunch {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_OPENACC_LAUNCH.
    pub kind: CUpti_ActivityKind,
    /// CUPTI OpenACC event kind (\see CUpti_OpenAccEventKind)
    pub eventKind: CUpti_OpenAccEventKind,
    /** CUPTI OpenACC parent construct kind (\see CUpti_OpenAccConstructKind)

 Note that for applications using PGI OpenACC runtime < 16.1, this
 will always be CUPTI_OPENACC_CONSTRUCT_KIND_UNKNOWN.*/
    pub parentConstruct: CUpti_OpenAccConstructKind,
    /// Version number
    pub version: u32,
    /** 1 for any implicit event, such as an implicit wait at a synchronous data construct
 0 otherwise*/
    pub implicit: u32,
    /// Device type
    pub deviceType: u32,
    /// Device number
    pub deviceNumber: u32,
    /// ThreadId
    pub threadId: u32,
    /// Value of async() clause of the corresponding directive
    pub async_: u64,
    /// Internal asynchronous queue number used
    pub asyncMap: u64,
    /** The line number of the directive or program construct or the starting line
 number of the OpenACC construct corresponding to the event.
 A negative or zero value means the line number is not known.*/
    pub lineNo: u32,
    /** For an OpenACC construct, this contains the line number of the end
 of the construct. A negative or zero value means the line number is not known.*/
    pub endLineNo: u32,
    /** The line number of the first line of the function named in func_name.
 A negative or zero value means the line number is not known.*/
    pub funcLineNo: u32,
    /** The last line number of the function named in func_name.
 A negative or zero value means the line number is not known.*/
    pub funcEndLineNo: u32,
    /// CUPTI start timestamp
    pub start: u64,
    /// CUPTI end timestamp
    pub end: u64,
    /** CUDA device id
 Valid only if deviceType is acc_device_nvidia.*/
    pub cuDeviceId: u32,
    /** CUDA context id
 Valid only if deviceType is acc_device_nvidia.*/
    pub cuContextId: u32,
    /** CUDA stream id
 Valid only if deviceType is acc_device_nvidia.*/
    pub cuStreamId: u32,
    /// The ID of the process where the OpenACC activity is executing.
    pub cuProcessId: u32,
    /// The ID of the thread where the OpenACC activity is executing.
    pub cuThreadId: u32,
    /** The OpenACC correlation ID.
 Valid only if deviceType is acc_device_nvidia.
 If not 0, it uniquely identifies this record. It is identical to the
 externalId in the preceding external correlation record of type
 CUPTI_EXTERNAL_CORRELATION_KIND_OPENACC.*/
    pub externalId: u32,
    /** A pointer to null-terminated string containing the name of or path to
 the source file, if known, or a null pointer if not.*/
    pub srcFile: *const ::std::os::raw::c_char,
    /** A pointer to a null-terminated string containing the name of the
 function in which the event occurred.*/
    pub funcName: *const ::std::os::raw::c_char,
    /// The number of gangs created for this kernel launch
    pub numGangs: u64,
    /// The number of workers created for this kernel launch
    pub numWorkers: u64,
    /// The number of vector lanes created for this kernel launch
    pub vectorLength: u64,
    /** A pointer to null-terminated string containing the name of the
 kernel being launched, if known, or a null pointer if not.*/
    pub kernelName: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityOpenAccLaunch",
    ][::std::mem::size_of::<CUpti_ActivityOpenAccLaunch>() - 152usize];
    [
        "Alignment of CUpti_ActivityOpenAccLaunch",
    ][::std::mem::align_of::<CUpti_ActivityOpenAccLaunch>() - 8usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::kind",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::eventKind",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, eventKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::parentConstruct",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, parentConstruct) - 8usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::version",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, version) - 12usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::implicit",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, implicit) - 16usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::deviceType",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, deviceType) - 20usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::deviceNumber",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, deviceNumber) - 24usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::threadId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, threadId) - 28usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::async_",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, async_) - 32usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::asyncMap",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, asyncMap) - 40usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::lineNo",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, lineNo) - 48usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::endLineNo",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, endLineNo) - 52usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::funcLineNo",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, funcLineNo) - 56usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::funcEndLineNo",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, funcEndLineNo) - 60usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::start",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, start) - 64usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::end",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, end) - 72usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::cuDeviceId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, cuDeviceId) - 80usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::cuContextId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, cuContextId) - 84usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::cuStreamId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, cuStreamId) - 88usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::cuProcessId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, cuProcessId) - 92usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::cuThreadId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, cuThreadId) - 96usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::externalId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, externalId) - 100usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::srcFile",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, srcFile) - 104usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::funcName",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, funcName) - 112usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::numGangs",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, numGangs) - 120usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::numWorkers",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, numWorkers) - 128usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::vectorLength",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, vectorLength) - 136usize];
    [
        "Offset of field: CUpti_ActivityOpenAccLaunch::kernelName",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, kernelName) - 144usize];
};
impl Default for CUpti_ActivityOpenAccLaunch {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for OpenACC other.

 (CUPTI_ACTIVITY_KIND_OPENACC_OTHER).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityOpenAccOther {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_OPENACC_OTHER.
    pub kind: CUpti_ActivityKind,
    /// CUPTI OpenACC event kind (\see CUpti_OpenAccEventKind)
    pub eventKind: CUpti_OpenAccEventKind,
    /** CUPTI OpenACC parent construct kind (\see CUpti_OpenAccConstructKind)

 Note that for applications using PGI OpenACC runtime < 16.1, this
 will always be CUPTI_OPENACC_CONSTRUCT_KIND_UNKNOWN.*/
    pub parentConstruct: CUpti_OpenAccConstructKind,
    /// Version number
    pub version: u32,
    /** 1 for any implicit event, such as an implicit wait at a synchronous data construct
 0 otherwise*/
    pub implicit: u32,
    /// Device type
    pub deviceType: u32,
    /// Device number
    pub deviceNumber: u32,
    /// ThreadId
    pub threadId: u32,
    /// Value of async() clause of the corresponding directive
    pub async_: u64,
    /// Internal asynchronous queue number used
    pub asyncMap: u64,
    /** The line number of the directive or program construct or the starting line
 number of the OpenACC construct corresponding to the event.
 A negative or zero value means the line number is not known.*/
    pub lineNo: u32,
    /** For an OpenACC construct, this contains the line number of the end
 of the construct. A negative or zero value means the line number is not known.*/
    pub endLineNo: u32,
    /** The line number of the first line of the function named in func_name.
 A negative or zero value means the line number is not known.*/
    pub funcLineNo: u32,
    /** The last line number of the function named in func_name.
 A negative or zero value means the line number is not known.*/
    pub funcEndLineNo: u32,
    /// CUPTI start timestamp
    pub start: u64,
    /// CUPTI end timestamp
    pub end: u64,
    /** CUDA device id
 Valid only if deviceType is acc_device_nvidia.*/
    pub cuDeviceId: u32,
    /** CUDA context id
 Valid only if deviceType is acc_device_nvidia.*/
    pub cuContextId: u32,
    /** CUDA stream id
 Valid only if deviceType is acc_device_nvidia.*/
    pub cuStreamId: u32,
    /// The ID of the process where the OpenACC activity is executing.
    pub cuProcessId: u32,
    /// The ID of the thread where the OpenACC activity is executing.
    pub cuThreadId: u32,
    /** The OpenACC correlation ID.
 Valid only if deviceType is acc_device_nvidia.
 If not 0, it uniquely identifies this record. It is identical to the
 externalId in the preceding external correlation record of type
 CUPTI_EXTERNAL_CORRELATION_KIND_OPENACC.*/
    pub externalId: u32,
    /** A pointer to null-terminated string containing the name of or path to
 the source file, if known, or a null pointer if not.*/
    pub srcFile: *const ::std::os::raw::c_char,
    /** A pointer to a null-terminated string containing the name of the
 function in which the event occurred.*/
    pub funcName: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityOpenAccOther",
    ][::std::mem::size_of::<CUpti_ActivityOpenAccOther>() - 120usize];
    [
        "Alignment of CUpti_ActivityOpenAccOther",
    ][::std::mem::align_of::<CUpti_ActivityOpenAccOther>() - 8usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::kind",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::eventKind",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, eventKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::parentConstruct",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, parentConstruct) - 8usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::version",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, version) - 12usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::implicit",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, implicit) - 16usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::deviceType",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, deviceType) - 20usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::deviceNumber",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, deviceNumber) - 24usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::threadId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, threadId) - 28usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::async_",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, async_) - 32usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::asyncMap",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, asyncMap) - 40usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::lineNo",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, lineNo) - 48usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::endLineNo",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, endLineNo) - 52usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::funcLineNo",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, funcLineNo) - 56usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::funcEndLineNo",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, funcEndLineNo) - 60usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::start",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, start) - 64usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::end",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, end) - 72usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::cuDeviceId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, cuDeviceId) - 80usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::cuContextId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, cuContextId) - 84usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::cuStreamId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, cuStreamId) - 88usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::cuProcessId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, cuProcessId) - 92usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::cuThreadId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, cuThreadId) - 96usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::externalId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, externalId) - 100usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::srcFile",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, srcFile) - 104usize];
    [
        "Offset of field: CUpti_ActivityOpenAccOther::funcName",
    ][::std::mem::offset_of!(CUpti_ActivityOpenAccOther, funcName) - 112usize];
};
impl Default for CUpti_ActivityOpenAccOther {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The base activity record for OpenMp records.

 \see CUpti_ActivityKind*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityOpenMp {
    /// The kind of this activity.
    pub kind: CUpti_ActivityKind,
    /// CUPTI OpenMP event kind (\see CUpti_OpenMpEventKind)
    pub eventKind: CUpti_OpenMpEventKind,
    /// Version number
    pub version: u32,
    /// ThreadId
    pub threadId: u32,
    /// CUPTI start timestamp
    pub start: u64,
    /// CUPTI end timestamp
    pub end: u64,
    /// The ID of the process where the OpenMP activity is executing.
    pub cuProcessId: u32,
    /// The ID of the thread where the OpenMP activity is executing.
    pub cuThreadId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityOpenMp",
    ][::std::mem::size_of::<CUpti_ActivityOpenMp>() - 40usize];
    [
        "Alignment of CUpti_ActivityOpenMp",
    ][::std::mem::align_of::<CUpti_ActivityOpenMp>() - 8usize];
    [
        "Offset of field: CUpti_ActivityOpenMp::kind",
    ][::std::mem::offset_of!(CUpti_ActivityOpenMp, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityOpenMp::eventKind",
    ][::std::mem::offset_of!(CUpti_ActivityOpenMp, eventKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityOpenMp::version",
    ][::std::mem::offset_of!(CUpti_ActivityOpenMp, version) - 8usize];
    [
        "Offset of field: CUpti_ActivityOpenMp::threadId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenMp, threadId) - 12usize];
    [
        "Offset of field: CUpti_ActivityOpenMp::start",
    ][::std::mem::offset_of!(CUpti_ActivityOpenMp, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityOpenMp::end",
    ][::std::mem::offset_of!(CUpti_ActivityOpenMp, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityOpenMp::cuProcessId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenMp, cuProcessId) - 32usize];
    [
        "Offset of field: CUpti_ActivityOpenMp::cuThreadId",
    ][::std::mem::offset_of!(CUpti_ActivityOpenMp, cuThreadId) - 36usize];
};
impl Default for CUpti_ActivityOpenMp {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CUPTI_EXTERNAL_CORRELATION_KIND_INVALID: CUpti_ExternalCorrelationKind = 0;
/// The external API is unknown to CUPTI
pub const CUPTI_EXTERNAL_CORRELATION_KIND_UNKNOWN: CUpti_ExternalCorrelationKind = 1;
/// The external API is OpenACC
pub const CUPTI_EXTERNAL_CORRELATION_KIND_OPENACC: CUpti_ExternalCorrelationKind = 2;
/// The external API is custom0
pub const CUPTI_EXTERNAL_CORRELATION_KIND_CUSTOM0: CUpti_ExternalCorrelationKind = 3;
/// The external API is custom1
pub const CUPTI_EXTERNAL_CORRELATION_KIND_CUSTOM1: CUpti_ExternalCorrelationKind = 4;
/// The external API is custom2
pub const CUPTI_EXTERNAL_CORRELATION_KIND_CUSTOM2: CUpti_ExternalCorrelationKind = 5;
/// Add new kinds before this line
pub const CUPTI_EXTERNAL_CORRELATION_KIND_SIZE: CUpti_ExternalCorrelationKind = 6;
/// Add new kinds before this line
pub const CUPTI_EXTERNAL_CORRELATION_KIND_FORCE_INT: CUpti_ExternalCorrelationKind = 2147483647;
/** \brief The kind of external APIs supported for correlation.

 Custom correlation kinds are reserved for usage in external tools.

 \see CUpti_ActivityExternalCorrelation*/
pub type CUpti_ExternalCorrelationKind = ::std::os::raw::c_uint;
/** \brief The activity record for correlation with external records

 This activity record correlates native CUDA records (e.g. CUDA Driver API,
 kernels, memcpys, ...) with records from external APIs such as OpenACC.
 (CUPTI_ACTIVITY_KIND_EXTERNAL_CORRELATION).

 \see CUpti_ActivityKind*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityExternalCorrelation {
    /// The kind of this activity.
    pub kind: CUpti_ActivityKind,
    /// The kind of external API this record correlated to.
    pub externalKind: CUpti_ExternalCorrelationKind,
    /** The correlation ID of the associated non-CUDA API record.
 The exact field in the associated external record depends
 on that record's activity kind (\see externalKind).*/
    pub externalId: u64,
    /// The correlation ID of the associated CUDA driver or runtime API record.
    pub correlationId: u32,
    /// Undefined. Reserved for internal use.
    pub reserved: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityExternalCorrelation",
    ][::std::mem::size_of::<CUpti_ActivityExternalCorrelation>() - 24usize];
    [
        "Alignment of CUpti_ActivityExternalCorrelation",
    ][::std::mem::align_of::<CUpti_ActivityExternalCorrelation>() - 8usize];
    [
        "Offset of field: CUpti_ActivityExternalCorrelation::kind",
    ][::std::mem::offset_of!(CUpti_ActivityExternalCorrelation, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityExternalCorrelation::externalKind",
    ][::std::mem::offset_of!(CUpti_ActivityExternalCorrelation, externalKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityExternalCorrelation::externalId",
    ][::std::mem::offset_of!(CUpti_ActivityExternalCorrelation, externalId) - 8usize];
    [
        "Offset of field: CUpti_ActivityExternalCorrelation::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityExternalCorrelation, correlationId)
        - 16usize];
    [
        "Offset of field: CUpti_ActivityExternalCorrelation::reserved",
    ][::std::mem::offset_of!(CUpti_ActivityExternalCorrelation, reserved) - 20usize];
};
impl Default for CUpti_ActivityExternalCorrelation {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CUPTI_DEV_TYPE_INVALID: CUpti_DevType = 0;
/// The device type is GPU.
pub const CUPTI_DEV_TYPE_GPU: CUpti_DevType = 1;
/// The device type is NVLink processing unit in CPU.
pub const CUPTI_DEV_TYPE_NPU: CUpti_DevType = 2;
/// The device type is NVLink processing unit in CPU.
pub const CUPTI_DEV_TYPE_FORCE_INT: CUpti_DevType = 2147483647;
/// \brief The device type for device connected to NVLink.
pub type CUpti_DevType = ::std::os::raw::c_uint;
/** \brief NVLink information.

 This structure gives capabilities of each logical NVLink connection between two devices,
 gpu<->gpu or gpu<->CPU which can be used to understand the topology.*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityNvLink4 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_NVLINK.
    pub kind: CUpti_ActivityKind,
    /// NvLink version.
    pub nvlinkVersion: u32,
    /// Type of device 0 \ref CUpti_DevType
    pub typeDev0: CUpti_DevType,
    /// Type of device 1 \ref CUpti_DevType
    pub typeDev1: CUpti_DevType,
    pub idDev0: CUpti_ActivityNvLink4__bindgen_ty_1,
    pub idDev1: CUpti_ActivityNvLink4__bindgen_ty_2,
    /// Flag gives capabilities of the link \see CUpti_LinkFlag
    pub flag: u32,
    /// Number of physical NVLinks present between two devices.
    pub physicalNvLinkCount: u32,
    /** Port numbers for maximum 32 NVLinks connected to device 0.
 If typeDev0 is CUPTI_DEV_TYPE_NPU, ignore this field.
 In case of invalid/unknown port number, this field will be set
 to value CUPTI_NVLINK_INVALID_PORT.
 This will be used to correlate the metric values to individual
 physical link and attribute traffic to the logical NVLink in
 the topology.*/
    pub portDev0: [i8; 32usize],
    /** Port numbers for maximum 32 NVLinks connected to device 1.
 If typeDev1 is CUPTI_DEV_TYPE_NPU, ignore this field.
 In case of invalid/unknown port number, this field will be set
 to value CUPTI_NVLINK_INVALID_PORT.
 This will be used to correlate the metric values to individual
 physical link and attribute traffic to the logical NVLink in
 the topology.*/
    pub portDev1: [i8; 32usize],
    /// Bandwidth of NVLink in kbytes/sec
    pub bandwidth: u64,
    /// NVSwitch is connected as an intermediate node.
    pub nvswitchConnected: u8,
    /// Undefined. reserved for internal use
    pub pad: [u8; 7usize],
}
/** If typeDev0 is CUPTI_DEV_TYPE_GPU, UUID for device 0. \ref CUpti_ActivityDevice5.
 If typeDev0 is CUPTI_DEV_TYPE_NPU, struct npu for NPU.*/
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityNvLink4__bindgen_ty_1 {
    pub uuidDev: CUuuid,
    pub npu: CUpti_ActivityNvLink4__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityNvLink4__bindgen_ty_1__bindgen_ty_1 {
    /// Index of the NPU. First index will always be zero.
    pub index: u32,
    /// Domain ID of NPU. On Linux, this can be queried using lspci.
    pub domainId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityNvLink4__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityNvLink4__bindgen_ty_1__bindgen_ty_1>()
        - 8usize];
    [
        "Alignment of CUpti_ActivityNvLink4__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityNvLink4__bindgen_ty_1__bindgen_ty_1>()
        - 4usize];
    [
        "Offset of field: CUpti_ActivityNvLink4__bindgen_ty_1__bindgen_ty_1::index",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink4__bindgen_ty_1__bindgen_ty_1, index)
        - 0usize];
    [
        "Offset of field: CUpti_ActivityNvLink4__bindgen_ty_1__bindgen_ty_1::domainId",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink4__bindgen_ty_1__bindgen_ty_1, domainId)
        - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityNvLink4__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityNvLink4__bindgen_ty_1>() - 16usize];
    [
        "Alignment of CUpti_ActivityNvLink4__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityNvLink4__bindgen_ty_1>() - 4usize];
    [
        "Offset of field: CUpti_ActivityNvLink4__bindgen_ty_1::uuidDev",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink4__bindgen_ty_1, uuidDev) - 0usize];
    [
        "Offset of field: CUpti_ActivityNvLink4__bindgen_ty_1::npu",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink4__bindgen_ty_1, npu) - 0usize];
};
impl Default for CUpti_ActivityNvLink4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink4__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityNvLink4__bindgen_ty_1 {{ union }}")
    }
}
/** If typeDev1 is CUPTI_DEV_TYPE_GPU, UUID for device 1. \ref CUpti_ActivityDevice5.
 If typeDev1 is CUPTI_DEV_TYPE_NPU, struct npu for NPU.*/
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityNvLink4__bindgen_ty_2 {
    pub uuidDev: CUuuid,
    pub npu: CUpti_ActivityNvLink4__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityNvLink4__bindgen_ty_2__bindgen_ty_1 {
    /// Index of the NPU. First index will always be zero.
    pub index: u32,
    /// Domain ID of NPU. On Linux, this can be queried using lspci.
    pub domainId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityNvLink4__bindgen_ty_2__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityNvLink4__bindgen_ty_2__bindgen_ty_1>()
        - 8usize];
    [
        "Alignment of CUpti_ActivityNvLink4__bindgen_ty_2__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityNvLink4__bindgen_ty_2__bindgen_ty_1>()
        - 4usize];
    [
        "Offset of field: CUpti_ActivityNvLink4__bindgen_ty_2__bindgen_ty_1::index",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink4__bindgen_ty_2__bindgen_ty_1, index)
        - 0usize];
    [
        "Offset of field: CUpti_ActivityNvLink4__bindgen_ty_2__bindgen_ty_1::domainId",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink4__bindgen_ty_2__bindgen_ty_1, domainId)
        - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityNvLink4__bindgen_ty_2",
    ][::std::mem::size_of::<CUpti_ActivityNvLink4__bindgen_ty_2>() - 16usize];
    [
        "Alignment of CUpti_ActivityNvLink4__bindgen_ty_2",
    ][::std::mem::align_of::<CUpti_ActivityNvLink4__bindgen_ty_2>() - 4usize];
    [
        "Offset of field: CUpti_ActivityNvLink4__bindgen_ty_2::uuidDev",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink4__bindgen_ty_2, uuidDev) - 0usize];
    [
        "Offset of field: CUpti_ActivityNvLink4__bindgen_ty_2::npu",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink4__bindgen_ty_2, npu) - 0usize];
};
impl Default for CUpti_ActivityNvLink4__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink4__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityNvLink4__bindgen_ty_2 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityNvLink4",
    ][::std::mem::size_of::<CUpti_ActivityNvLink4>() - 136usize];
    [
        "Alignment of CUpti_ActivityNvLink4",
    ][::std::mem::align_of::<CUpti_ActivityNvLink4>() - 8usize];
    [
        "Offset of field: CUpti_ActivityNvLink4::kind",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink4, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityNvLink4::nvlinkVersion",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink4, nvlinkVersion) - 4usize];
    [
        "Offset of field: CUpti_ActivityNvLink4::typeDev0",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink4, typeDev0) - 8usize];
    [
        "Offset of field: CUpti_ActivityNvLink4::typeDev1",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink4, typeDev1) - 12usize];
    [
        "Offset of field: CUpti_ActivityNvLink4::idDev0",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink4, idDev0) - 16usize];
    [
        "Offset of field: CUpti_ActivityNvLink4::idDev1",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink4, idDev1) - 32usize];
    [
        "Offset of field: CUpti_ActivityNvLink4::flag",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink4, flag) - 48usize];
    [
        "Offset of field: CUpti_ActivityNvLink4::physicalNvLinkCount",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink4, physicalNvLinkCount) - 52usize];
    [
        "Offset of field: CUpti_ActivityNvLink4::portDev0",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink4, portDev0) - 56usize];
    [
        "Offset of field: CUpti_ActivityNvLink4::portDev1",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink4, portDev1) - 88usize];
    [
        "Offset of field: CUpti_ActivityNvLink4::bandwidth",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink4, bandwidth) - 120usize];
    [
        "Offset of field: CUpti_ActivityNvLink4::nvswitchConnected",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink4, nvswitchConnected) - 128usize];
    [
        "Offset of field: CUpti_ActivityNvLink4::pad",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink4, pad) - 129usize];
};
impl Default for CUpti_ActivityNvLink4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink4 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityNvLink4 {{ kind: {:?}, typeDev0: {:?}, typeDev1: {:?}, idDev0: {:?}, idDev1: {:?}, portDev0: {:?}, portDev1: {:?}, pad: {:?} }}",
            self.kind,
            self.typeDev0,
            self.typeDev1,
            self.idDev0,
            self.idDev1,
            self.portDev0,
            self.portDev1,
            self.pad,
        )
    }
}
/// PCIE GPU record
pub const CUPTI_PCIE_DEVICE_TYPE_GPU: CUpti_PcieDeviceType = 0;
/// PCIE Bridge record
pub const CUPTI_PCIE_DEVICE_TYPE_BRIDGE: CUpti_PcieDeviceType = 1;
/// PCIE Bridge record
pub const CUPTI_PCIE_DEVICE_TYPE_FORCE_INT: CUpti_PcieDeviceType = 2147483647;
/** Field to differentiate whether PCIE Activity record
 is of a GPU or a PCI Bridge*/
pub type CUpti_PcieDeviceType = ::std::os::raw::c_uint;
/** \brief PCI devices information required to construct topology

 This structure gives capabilities of GPU and PCI bridge connected to the PCIE bus
 which can be used to understand the topology.*/
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityPcie {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_PCIE.
    pub kind: CUpti_ActivityKind,
    /** Type of device in topology, \ref CUpti_PcieDeviceType. If type is
 CUPTI_PCIE_DEVICE_TYPE_GPU use devId for id and gpuAttr and if type is
 CUPTI_PCIE_DEVICE_TYPE_BRIDGE use bridgeId for id and bridgeAttr.*/
    pub type_: CUpti_PcieDeviceType,
    pub id: CUpti_ActivityPcie__bindgen_ty_1,
    /** Domain for the GPU or Bridge, required to identify which PCIE bus it belongs to in
 multiple NUMA systems.*/
    pub domain: u32,
    /// PCIE Generation of GPU or Bridge.
    pub pcieGeneration: u16,
    /// Link rate of the GPU or bridge in gigatransfers per second (GT/s)
    pub linkRate: u16,
    /// Link width of the GPU or bridge
    pub linkWidth: u16,
    /** Upstream bus ID for the GPU or PCI bridge. Required to identify which bus it is
 connected to in the topology.*/
    pub upstreamBus: u16,
    pub attr: CUpti_ActivityPcie__bindgen_ty_2,
}
/// A unique identifier for GPU or Bridge in Topology
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityPcie__bindgen_ty_1 {
    /// GPU device ID
    pub devId: CUdevice,
    /// A unique identifier for Bridge in the Topology
    pub bridgeId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityPcie__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityPcie__bindgen_ty_1>() - 4usize];
    [
        "Alignment of CUpti_ActivityPcie__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityPcie__bindgen_ty_1>() - 4usize];
    [
        "Offset of field: CUpti_ActivityPcie__bindgen_ty_1::devId",
    ][::std::mem::offset_of!(CUpti_ActivityPcie__bindgen_ty_1, devId) - 0usize];
    [
        "Offset of field: CUpti_ActivityPcie__bindgen_ty_1::bridgeId",
    ][::std::mem::offset_of!(CUpti_ActivityPcie__bindgen_ty_1, bridgeId) - 0usize];
};
impl Default for CUpti_ActivityPcie__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityPcie__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityPcie__bindgen_ty_1 {{ union }}")
    }
}
/// Attributes for more information about GPU (gpuAttr) or PCI Bridge (bridgeAttr)
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityPcie__bindgen_ty_2 {
    pub gpuAttr: CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_1,
    pub bridgeAttr: CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_1 {
    /// UUID for the device. \ref CUpti_ActivityDevice5.
    pub uuidDev: CUuuid,
    /** CUdevice with which this device has P2P capability.
 This can also be obtained by querying cuDeviceCanAccessPeer or
 cudaDeviceCanAccessPeer APIs*/
    pub peerDev: [CUdevice; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_1>()
        - 144usize];
    [
        "Alignment of CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_1>() - 4usize];
    [
        "Offset of field: CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_1::uuidDev",
    ][::std::mem::offset_of!(CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_1, uuidDev)
        - 0usize];
    [
        "Offset of field: CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_1::peerDev",
    ][::std::mem::offset_of!(CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_1, peerDev)
        - 16usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2 {
    /** The downstream bus number, used to search downstream devices/bridges connected
 to this bridge.*/
    pub secondaryBus: u16,
    /// Device ID of the bridge
    pub deviceId: u16,
    /// Vendor ID of the bridge
    pub vendorId: u16,
    /// Padding for alignment
    pub pad0: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2",
    ][::std::mem::size_of::<CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2>() - 8usize];
    [
        "Alignment of CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2",
    ][::std::mem::align_of::<CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2>() - 2usize];
    [
        "Offset of field: CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2::secondaryBus",
    ][::std::mem::offset_of!(
        CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2, secondaryBus
    ) - 0usize];
    [
        "Offset of field: CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2, deviceId)
        - 2usize];
    [
        "Offset of field: CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2::vendorId",
    ][::std::mem::offset_of!(CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2, vendorId)
        - 4usize];
    [
        "Offset of field: CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2::pad0",
    ][::std::mem::offset_of!(CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2, pad0)
        - 6usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityPcie__bindgen_ty_2",
    ][::std::mem::size_of::<CUpti_ActivityPcie__bindgen_ty_2>() - 144usize];
    [
        "Alignment of CUpti_ActivityPcie__bindgen_ty_2",
    ][::std::mem::align_of::<CUpti_ActivityPcie__bindgen_ty_2>() - 4usize];
    [
        "Offset of field: CUpti_ActivityPcie__bindgen_ty_2::gpuAttr",
    ][::std::mem::offset_of!(CUpti_ActivityPcie__bindgen_ty_2, gpuAttr) - 0usize];
    [
        "Offset of field: CUpti_ActivityPcie__bindgen_ty_2::bridgeAttr",
    ][::std::mem::offset_of!(CUpti_ActivityPcie__bindgen_ty_2, bridgeAttr) - 0usize];
};
impl Default for CUpti_ActivityPcie__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityPcie__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityPcie__bindgen_ty_2 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityPcie",
    ][::std::mem::size_of::<CUpti_ActivityPcie>() - 168usize];
    [
        "Alignment of CUpti_ActivityPcie",
    ][::std::mem::align_of::<CUpti_ActivityPcie>() - 8usize];
    [
        "Offset of field: CUpti_ActivityPcie::kind",
    ][::std::mem::offset_of!(CUpti_ActivityPcie, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityPcie::type_",
    ][::std::mem::offset_of!(CUpti_ActivityPcie, type_) - 4usize];
    [
        "Offset of field: CUpti_ActivityPcie::id",
    ][::std::mem::offset_of!(CUpti_ActivityPcie, id) - 8usize];
    [
        "Offset of field: CUpti_ActivityPcie::domain",
    ][::std::mem::offset_of!(CUpti_ActivityPcie, domain) - 12usize];
    [
        "Offset of field: CUpti_ActivityPcie::pcieGeneration",
    ][::std::mem::offset_of!(CUpti_ActivityPcie, pcieGeneration) - 16usize];
    [
        "Offset of field: CUpti_ActivityPcie::linkRate",
    ][::std::mem::offset_of!(CUpti_ActivityPcie, linkRate) - 18usize];
    [
        "Offset of field: CUpti_ActivityPcie::linkWidth",
    ][::std::mem::offset_of!(CUpti_ActivityPcie, linkWidth) - 20usize];
    [
        "Offset of field: CUpti_ActivityPcie::upstreamBus",
    ][::std::mem::offset_of!(CUpti_ActivityPcie, upstreamBus) - 22usize];
    [
        "Offset of field: CUpti_ActivityPcie::attr",
    ][::std::mem::offset_of!(CUpti_ActivityPcie, attr) - 24usize];
};
impl Default for CUpti_ActivityPcie {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityPcie {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityPcie {{ kind: {:?}, type: {:?}, id: {:?}, attr: {:?} }}",
            self.kind,
            self.type_,
            self.id,
            self.attr,
        )
    }
}
/// PCIE Generation 1
pub const CUPTI_PCIE_GEN_GEN1: CUpti_PcieGen = 1;
/// PCIE Generation 2
pub const CUPTI_PCIE_GEN_GEN2: CUpti_PcieGen = 2;
/// PCIE Generation 3
pub const CUPTI_PCIE_GEN_GEN3: CUpti_PcieGen = 3;
/// PCIE Generation 4
pub const CUPTI_PCIE_GEN_GEN4: CUpti_PcieGen = 4;
/// PCIE Generation 5
pub const CUPTI_PCIE_GEN_GEN5: CUpti_PcieGen = 5;
/// PCIE Generation 6
pub const CUPTI_PCIE_GEN_GEN6: CUpti_PcieGen = 6;
/// PCIE Generation 6
pub const CUPTI_PCIE_GEN_FORCE_INT: CUpti_PcieGen = 2147483647;
/** \brief PCIE Generation.

 Enumeration of PCIE Generation for
 pcie activity attribute pcieGeneration*/
pub type CUpti_PcieGen = ::std::os::raw::c_uint;
pub const CUPTI_CONFIDENTIAL_COMPUTE_INVALID_ROTATION_EVENT: CUpti_ConfidentialComputeRotationEventType = 0;
/// This channel has been blocked from accepting new CUDA work so a key rotation can be done.
pub const CUPTI_CONFIDENTIAL_COMPUTE_KEY_ROTATION_CHANNEL_BLOCKED: CUpti_ConfidentialComputeRotationEventType = 1;
/** This channel remains blocked and all queued CUDA work has completed.
 Other clients or channels may cause delays in starting the key rotation.*/
pub const CUPTI_CONFIDENTIAL_COMPUTE_KEY_ROTATION_CHANNEL_DRAINED: CUpti_ConfidentialComputeRotationEventType = 2;
/// Key rotations have completed and this channel is unblocked.
pub const CUPTI_CONFIDENTIAL_COMPUTE_KEY_ROTATION_CHANNEL_UNBLOCKED: CUpti_ConfidentialComputeRotationEventType = 3;
/// Key rotations have completed and this channel is unblocked.
pub const CUPTI_CONFIDENTIAL_COMPUTE_EVENT_TYPE_FORCE_INT: CUpti_ConfidentialComputeRotationEventType = 2147483647;
pub type CUpti_ConfidentialComputeRotationEventType = ::std::os::raw::c_uint;
/** \brief Event related to confidential compute encryption rotation

 This structure gives timestamps for stages of encryption rotation*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityConfidentialComputeRotation {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_CONFIDENTIAL_COMPUTE_ROTATION.
    pub kind: CUpti_ActivityKind,
    /// Type of event \ref CUpti_ConfidentialComputeRotationEventType
    pub eventType: CUpti_ConfidentialComputeRotationEventType,
    /// Device ID
    pub deviceId: u32,
    /// Context ID
    pub contextId: u32,
    /// Channel ID
    pub channelId: u32,
    /// Channel Type \ref CUpti_ChannelType
    pub channelType: CUpti_ChannelType,
    /// Timestamp in ns
    pub timestamp: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityConfidentialComputeRotation",
    ][::std::mem::size_of::<CUpti_ActivityConfidentialComputeRotation>() - 32usize];
    [
        "Alignment of CUpti_ActivityConfidentialComputeRotation",
    ][::std::mem::align_of::<CUpti_ActivityConfidentialComputeRotation>() - 8usize];
    [
        "Offset of field: CUpti_ActivityConfidentialComputeRotation::kind",
    ][::std::mem::offset_of!(CUpti_ActivityConfidentialComputeRotation, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityConfidentialComputeRotation::eventType",
    ][::std::mem::offset_of!(CUpti_ActivityConfidentialComputeRotation, eventType)
        - 4usize];
    [
        "Offset of field: CUpti_ActivityConfidentialComputeRotation::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityConfidentialComputeRotation, deviceId)
        - 8usize];
    [
        "Offset of field: CUpti_ActivityConfidentialComputeRotation::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityConfidentialComputeRotation, contextId)
        - 12usize];
    [
        "Offset of field: CUpti_ActivityConfidentialComputeRotation::channelId",
    ][::std::mem::offset_of!(CUpti_ActivityConfidentialComputeRotation, channelId)
        - 16usize];
    [
        "Offset of field: CUpti_ActivityConfidentialComputeRotation::channelType",
    ][::std::mem::offset_of!(CUpti_ActivityConfidentialComputeRotation, channelType)
        - 20usize];
    [
        "Offset of field: CUpti_ActivityConfidentialComputeRotation::timestamp",
    ][::std::mem::offset_of!(CUpti_ActivityConfidentialComputeRotation, timestamp)
        - 24usize];
};
impl Default for CUpti_ActivityConfidentialComputeRotation {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for an instantaneous CUPTI event.

 This activity record represents a CUPTI event value
 (CUPTI_ACTIVITY_KIND_EVENT) sampled at a particular instant.
 This activity record kind is not produced by the activity API but is
 included for completeness and ease-of-use. Profiler frameworks built on
 top of CUPTI that collect event data at a particular time may choose to
 use this type to store the collected event data.*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityInstantaneousEvent {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_INSTANTANEOUS_EVENT.
    pub kind: CUpti_ActivityKind,
    /// The event ID.
    pub id: CUpti_EventID,
    /// The event value.
    pub value: u64,
    /// The timestamp at which event is sampled
    pub timestamp: u64,
    /// The device id
    pub deviceId: u32,
    /// Undefined. reserved for internal use
    pub reserved: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityInstantaneousEvent",
    ][::std::mem::size_of::<CUpti_ActivityInstantaneousEvent>() - 32usize];
    [
        "Alignment of CUpti_ActivityInstantaneousEvent",
    ][::std::mem::align_of::<CUpti_ActivityInstantaneousEvent>() - 8usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousEvent::kind",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousEvent, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousEvent::id",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousEvent, id) - 4usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousEvent::value",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousEvent, value) - 8usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousEvent::timestamp",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousEvent, timestamp) - 16usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousEvent::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousEvent, deviceId) - 24usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousEvent::reserved",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousEvent, reserved) - 28usize];
};
impl Default for CUpti_ActivityInstantaneousEvent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for an instantaneous CUPTI event
 with event domain instance information.

 This activity record represents the a CUPTI event value for a
 specific event domain instance
 (CUPTI_ACTIVITY_KIND_EVENT_INSTANCE) sampled at a particular instant.
 This activity record kind is not produced by the activity API but is
 included for completeness and ease-of-use. Profiler frameworks built on
 top of CUPTI that collect event data may choose to use this type to store the
 collected event data. This activity record should be used when
 event domain instance information needs to be associated with the
 event.*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityInstantaneousEventInstance {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_INSTANTANEOUS_EVENT_INSTANCE.
    pub kind: CUpti_ActivityKind,
    /// The event ID.
    pub id: CUpti_EventID,
    /// The event value.
    pub value: u64,
    /// The timestamp at which event is sampled
    pub timestamp: u64,
    /// The device id
    pub deviceId: u32,
    /// The event domain instance
    pub instance: u8,
    /// Undefined. reserved for internal use
    pub pad: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityInstantaneousEventInstance",
    ][::std::mem::size_of::<CUpti_ActivityInstantaneousEventInstance>() - 32usize];
    [
        "Alignment of CUpti_ActivityInstantaneousEventInstance",
    ][::std::mem::align_of::<CUpti_ActivityInstantaneousEventInstance>() - 8usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousEventInstance::kind",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousEventInstance, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousEventInstance::id",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousEventInstance, id) - 4usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousEventInstance::value",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousEventInstance, value) - 8usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousEventInstance::timestamp",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousEventInstance, timestamp)
        - 16usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousEventInstance::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousEventInstance, deviceId)
        - 24usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousEventInstance::instance",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousEventInstance, instance)
        - 28usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousEventInstance::pad",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousEventInstance, pad) - 29usize];
};
impl Default for CUpti_ActivityInstantaneousEventInstance {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for an instantaneous CUPTI metric.

 This activity record represents the collection of a CUPTI metric
 value (CUPTI_ACTIVITY_KIND_METRIC) at a particular instance.
 This activity record kind is not produced by the activity API but
 is included for completeness and ease-of-use. Profiler frameworks built
 on top of CUPTI that collect metric data may choose to use this type to
 store the collected metric data.*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityInstantaneousMetric {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_INSTANTANEOUS_METRIC.
    pub kind: CUpti_ActivityKind,
    /// The metric ID.
    pub id: CUpti_MetricID,
    /// The metric value.
    pub value: CUpti_MetricValue,
    /// The timestamp at which metric is sampled
    pub timestamp: u64,
    /// The device id
    pub deviceId: u32,
    /// The properties of this metric. \see CUpti_ActivityFlag
    pub flags: u8,
    /// Undefined. reserved for internal use
    pub pad: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityInstantaneousMetric",
    ][::std::mem::size_of::<CUpti_ActivityInstantaneousMetric>() - 32usize];
    [
        "Alignment of CUpti_ActivityInstantaneousMetric",
    ][::std::mem::align_of::<CUpti_ActivityInstantaneousMetric>() - 8usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousMetric::kind",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousMetric, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousMetric::id",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousMetric, id) - 4usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousMetric::value",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousMetric, value) - 8usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousMetric::timestamp",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousMetric, timestamp) - 16usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousMetric::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousMetric, deviceId) - 24usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousMetric::flags",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousMetric, flags) - 28usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousMetric::pad",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousMetric, pad) - 29usize];
};
impl Default for CUpti_ActivityInstantaneousMetric {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityInstantaneousMetric {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityInstantaneousMetric {{ kind: {:?}, value: {:?}, pad: {:?} }}",
            self.kind,
            self.value,
            self.pad,
        )
    }
}
/** \brief The instantaneous activity record for a CUPTI metric with instance
 information.

 This activity record represents a CUPTI metric value
 for a specific metric domain instance
 (CUPTI_ACTIVITY_KIND_METRIC_INSTANCE) sampled at a particular time. This
 activity record kind is not produced by the activity API but is included for
 completeness and ease-of-use. Profiler frameworks built on top of
 CUPTI that collect metric data may choose to use this type to store
 the collected metric data. This activity record should be used when
 metric domain instance information needs to be associated with the
 metric.*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityInstantaneousMetricInstance {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_INSTANTANEOUS_METRIC_INSTANCE.
    pub kind: CUpti_ActivityKind,
    /// The metric ID.
    pub id: CUpti_MetricID,
    /// The metric value.
    pub value: CUpti_MetricValue,
    /// The timestamp at which metric is sampled
    pub timestamp: u64,
    /// The device id
    pub deviceId: u32,
    /// The properties of this metric. \see CUpti_ActivityFlag
    pub flags: u8,
    /// The metric domain instance
    pub instance: u8,
    /// Undefined. reserved for internal use
    pub pad: [u8; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityInstantaneousMetricInstance",
    ][::std::mem::size_of::<CUpti_ActivityInstantaneousMetricInstance>() - 32usize];
    [
        "Alignment of CUpti_ActivityInstantaneousMetricInstance",
    ][::std::mem::align_of::<CUpti_ActivityInstantaneousMetricInstance>() - 8usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousMetricInstance::kind",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousMetricInstance, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousMetricInstance::id",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousMetricInstance, id) - 4usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousMetricInstance::value",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousMetricInstance, value) - 8usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousMetricInstance::timestamp",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousMetricInstance, timestamp)
        - 16usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousMetricInstance::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousMetricInstance, deviceId)
        - 24usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousMetricInstance::flags",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousMetricInstance, flags)
        - 28usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousMetricInstance::instance",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousMetricInstance, instance)
        - 29usize];
    [
        "Offset of field: CUpti_ActivityInstantaneousMetricInstance::pad",
    ][::std::mem::offset_of!(CUpti_ActivityInstantaneousMetricInstance, pad) - 30usize];
};
impl Default for CUpti_ActivityInstantaneousMetricInstance {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityInstantaneousMetricInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityInstantaneousMetricInstance {{ kind: {:?}, value: {:?}, pad: {:?} }}",
            self.kind,
            self.value,
            self.pad,
        )
    }
}
pub const CUPTI_ACTIVITY_JIT_ENTRY_INVALID: CUpti_ActivityJitEntryType = 0;
/// PTX to CUBIN.
pub const CUPTI_ACTIVITY_JIT_ENTRY_PTX_TO_CUBIN: CUpti_ActivityJitEntryType = 1;
/// NVVM-IR to PTX
pub const CUPTI_ACTIVITY_JIT_ENTRY_NVVM_IR_TO_PTX: CUpti_ActivityJitEntryType = 2;
/// NVVM-IR to PTX
pub const CUPTI_ACTIVITY_JIT_ENTRY_TYPE_FORCE_INT: CUpti_ActivityJitEntryType = 2147483647;
/** \brief The types of JIT entry.

 To be used in CUpti_ActivityJit.*/
pub type CUpti_ActivityJitEntryType = ::std::os::raw::c_uint;
pub const CUPTI_ACTIVITY_JIT_OPERATION_INVALID: CUpti_ActivityJitOperationType = 0;
/// Loaded from the compute cache.
pub const CUPTI_ACTIVITY_JIT_OPERATION_CACHE_LOAD: CUpti_ActivityJitOperationType = 1;
/// Stored in the compute cache.
pub const CUPTI_ACTIVITY_JIT_OPERATION_CACHE_STORE: CUpti_ActivityJitOperationType = 2;
/// JIT compilation.
pub const CUPTI_ACTIVITY_JIT_OPERATION_COMPILE: CUpti_ActivityJitOperationType = 3;
/// JIT compilation.
pub const CUPTI_ACTIVITY_JIT_OPERATION_TYPE_FORCE_INT: CUpti_ActivityJitOperationType = 2147483647;
/** \brief The types of JIT compilation operations.

 To be used in CUpti_ActivityJit.*/
pub type CUpti_ActivityJitOperationType = ::std::os::raw::c_uint;
/** \brief The activity record for JIT operations.
 This activity represents the JIT operations (compile, load, store) of a CUmodule
 from the Compute Cache.
 Gives the exact hashed path of where the cached module is loaded from,
 or where the module will be stored after Just-In-Time (JIT) compilation.*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityJit2 {
    /// The activity record kind must be CUPTI_ACTIVITY_KIND_JIT.
    pub kind: CUpti_ActivityKind,
    /// The JIT entry type.
    pub jitEntryType: CUpti_ActivityJitEntryType,
    /// The JIT operation type.
    pub jitOperationType: CUpti_ActivityJitOperationType,
    /// The device ID.
    pub deviceId: u32,
    /** The start timestamp for the JIT operation, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the JIT operation.*/
    pub start: u64,
    /** The end timestamp for the JIT operation, in ns. A value of 0 for both
 the start and end timestamps indicates that timestamp information
 could not be collected for the JIT operation.*/
    pub end: u64,
    /** The correlation ID of the JIT operation to which
 records belong to. Each JIT operation is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver or runtime API activity record that
 launched the JIT operation.*/
    pub correlationId: u32,
    /// Internal use.
    pub padding: u32,
    /** The correlation ID to correlate JIT compilation, load and store operations.
 Each JIT compilation unit is assigned a unique correlation ID
 at the time of the JIT compilation. This correlation id can be used
 to find the matching JIT cache load/store records.*/
    pub jitOperationCorrelationId: u64,
    /// The size of compute cache.
    pub cacheSize: u64,
    /// The path where the fat binary is cached.
    pub cachePath: *const ::std::os::raw::c_char,
    /// The ID of the process where the JIT operation is executing.
    pub processId: u32,
    /// The ID of the thread where the JIT operation is executing.
    pub threadId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityJit2",
    ][::std::mem::size_of::<CUpti_ActivityJit2>() - 72usize];
    [
        "Alignment of CUpti_ActivityJit2",
    ][::std::mem::align_of::<CUpti_ActivityJit2>() - 8usize];
    [
        "Offset of field: CUpti_ActivityJit2::kind",
    ][::std::mem::offset_of!(CUpti_ActivityJit2, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityJit2::jitEntryType",
    ][::std::mem::offset_of!(CUpti_ActivityJit2, jitEntryType) - 4usize];
    [
        "Offset of field: CUpti_ActivityJit2::jitOperationType",
    ][::std::mem::offset_of!(CUpti_ActivityJit2, jitOperationType) - 8usize];
    [
        "Offset of field: CUpti_ActivityJit2::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityJit2, deviceId) - 12usize];
    [
        "Offset of field: CUpti_ActivityJit2::start",
    ][::std::mem::offset_of!(CUpti_ActivityJit2, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityJit2::end",
    ][::std::mem::offset_of!(CUpti_ActivityJit2, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityJit2::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityJit2, correlationId) - 32usize];
    [
        "Offset of field: CUpti_ActivityJit2::padding",
    ][::std::mem::offset_of!(CUpti_ActivityJit2, padding) - 36usize];
    [
        "Offset of field: CUpti_ActivityJit2::jitOperationCorrelationId",
    ][::std::mem::offset_of!(CUpti_ActivityJit2, jitOperationCorrelationId) - 40usize];
    [
        "Offset of field: CUpti_ActivityJit2::cacheSize",
    ][::std::mem::offset_of!(CUpti_ActivityJit2, cacheSize) - 48usize];
    [
        "Offset of field: CUpti_ActivityJit2::cachePath",
    ][::std::mem::offset_of!(CUpti_ActivityJit2, cachePath) - 56usize];
    [
        "Offset of field: CUpti_ActivityJit2::processId",
    ][::std::mem::offset_of!(CUpti_ActivityJit2, processId) - 64usize];
    [
        "Offset of field: CUpti_ActivityJit2::threadId",
    ][::std::mem::offset_of!(CUpti_ActivityJit2, threadId) - 68usize];
};
impl Default for CUpti_ActivityJit2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for trace of graph execution.

 This activity record represents execution for a graph without giving visibility
 about the execution of its nodes. This is intended to reduce overheads in tracing
 each node. The activity kind is CUPTI_ACTIVITY_KIND_GRAPH_TRACE*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityGraphTrace2 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_GRAPH_TRACE
    pub kind: CUpti_ActivityKind,
    /** The correlation ID of the graph launch. Each graph launch is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver API activity record that launched
 the graph.*/
    pub correlationId: u32,
    /** The start timestamp for the graph execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the graph.*/
    pub start: u64,
    /** The end timestamp for the graph execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the graph.*/
    pub end: u64,
    /** The ID of the device where the first node of the graph is executed.
 If this is INT_MAX, then the start is on the host.*/
    pub deviceId: u32,
    /// The unique ID of the graph that is launched.
    pub graphId: u32,
    /** The ID of the context where the first node of the graph is executed.
 If this is INT_MAX, then the start is on the host.*/
    pub contextId: u32,
    /// The ID of the stream where the graph is being launched.
    pub streamId: u32,
    /// This field is reserved for internal use
    pub reserved: *mut ::std::os::raw::c_void,
    /// The ID of the device where last node of the graph is executed
    pub endDeviceId: u32,
    /// The ID of the context where the last node of the graph is executed.
    pub endContextId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityGraphTrace2",
    ][::std::mem::size_of::<CUpti_ActivityGraphTrace2>() - 56usize];
    [
        "Alignment of CUpti_ActivityGraphTrace2",
    ][::std::mem::align_of::<CUpti_ActivityGraphTrace2>() - 8usize];
    [
        "Offset of field: CUpti_ActivityGraphTrace2::kind",
    ][::std::mem::offset_of!(CUpti_ActivityGraphTrace2, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityGraphTrace2::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityGraphTrace2, correlationId) - 4usize];
    [
        "Offset of field: CUpti_ActivityGraphTrace2::start",
    ][::std::mem::offset_of!(CUpti_ActivityGraphTrace2, start) - 8usize];
    [
        "Offset of field: CUpti_ActivityGraphTrace2::end",
    ][::std::mem::offset_of!(CUpti_ActivityGraphTrace2, end) - 16usize];
    [
        "Offset of field: CUpti_ActivityGraphTrace2::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityGraphTrace2, deviceId) - 24usize];
    [
        "Offset of field: CUpti_ActivityGraphTrace2::graphId",
    ][::std::mem::offset_of!(CUpti_ActivityGraphTrace2, graphId) - 28usize];
    [
        "Offset of field: CUpti_ActivityGraphTrace2::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityGraphTrace2, contextId) - 32usize];
    [
        "Offset of field: CUpti_ActivityGraphTrace2::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityGraphTrace2, streamId) - 36usize];
    [
        "Offset of field: CUpti_ActivityGraphTrace2::reserved",
    ][::std::mem::offset_of!(CUpti_ActivityGraphTrace2, reserved) - 40usize];
    [
        "Offset of field: CUpti_ActivityGraphTrace2::endDeviceId",
    ][::std::mem::offset_of!(CUpti_ActivityGraphTrace2, endDeviceId) - 48usize];
    [
        "Offset of field: CUpti_ActivityGraphTrace2::endContextId",
    ][::std::mem::offset_of!(CUpti_ActivityGraphTrace2, endContextId) - 52usize];
};
impl Default for CUpti_ActivityGraphTrace2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CUPTI_DEVICE_GRAPH_LAUNCH_MODE_INVALID: CUpti_DeviceGraphLaunchMode = 0;
pub const CUPTI_DEVICE_GRAPH_LAUNCH_MODE_FIRE_AND_FORGET: CUpti_DeviceGraphLaunchMode = 1;
pub const CUPTI_DEVICE_GRAPH_LAUNCH_MODE_TAIL: CUpti_DeviceGraphLaunchMode = 2;
pub const CUPTI_DEVICE_GRAPH_LAUNCH_MODE_FIRE_AND_FORGET_AS_SIBLING: CUpti_DeviceGraphLaunchMode = 3;
/// \brief The launch mode for device graph execution.
pub type CUpti_DeviceGraphLaunchMode = ::std::os::raw::c_uint;
/** \brief The activity record for trace of device graph execution.

 This activity record represents execution for a device launched graph without giving visibility
 about the execution of its nodes. This is intended to reduce overheads in tracing
 each node. The activity kind is CUPTI_ACTIVITY_KIND_DEVICE_GRAPH_TRACE*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityDeviceGraphTrace {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_DEVICE_GRAPH_TRACE
    pub kind: CUpti_ActivityKind,
    /// The ID of the device where the first node of the graph is executed.
    pub deviceId: u32,
    /** The start timestamp for the graph execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the graph.*/
    pub start: u64,
    /** The end timestamp for the graph execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the graph.*/
    pub end: u64,
    /// The unique ID of the graph that is launched.
    pub graphId: u32,
    /// The unique ID of the graph that has launched this graph.
    pub launcherGraphId: u32,
    /// The type of launch. See \ref CUpti_DeviceGraphLaunchMode
    pub deviceLaunchMode: u32,
    /// The ID of the context where the first node of the graph is executed.
    pub contextId: u32,
    /// The ID of the stream where the graph is being launched.
    pub streamId: u64,
    /// This field is reserved for internal use
    pub reserved: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityDeviceGraphTrace",
    ][::std::mem::size_of::<CUpti_ActivityDeviceGraphTrace>() - 56usize];
    [
        "Alignment of CUpti_ActivityDeviceGraphTrace",
    ][::std::mem::align_of::<CUpti_ActivityDeviceGraphTrace>() - 8usize];
    [
        "Offset of field: CUpti_ActivityDeviceGraphTrace::kind",
    ][::std::mem::offset_of!(CUpti_ActivityDeviceGraphTrace, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityDeviceGraphTrace::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityDeviceGraphTrace, deviceId) - 4usize];
    [
        "Offset of field: CUpti_ActivityDeviceGraphTrace::start",
    ][::std::mem::offset_of!(CUpti_ActivityDeviceGraphTrace, start) - 8usize];
    [
        "Offset of field: CUpti_ActivityDeviceGraphTrace::end",
    ][::std::mem::offset_of!(CUpti_ActivityDeviceGraphTrace, end) - 16usize];
    [
        "Offset of field: CUpti_ActivityDeviceGraphTrace::graphId",
    ][::std::mem::offset_of!(CUpti_ActivityDeviceGraphTrace, graphId) - 24usize];
    [
        "Offset of field: CUpti_ActivityDeviceGraphTrace::launcherGraphId",
    ][::std::mem::offset_of!(CUpti_ActivityDeviceGraphTrace, launcherGraphId) - 28usize];
    [
        "Offset of field: CUpti_ActivityDeviceGraphTrace::deviceLaunchMode",
    ][::std::mem::offset_of!(CUpti_ActivityDeviceGraphTrace, deviceLaunchMode)
        - 32usize];
    [
        "Offset of field: CUpti_ActivityDeviceGraphTrace::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityDeviceGraphTrace, contextId) - 36usize];
    [
        "Offset of field: CUpti_ActivityDeviceGraphTrace::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityDeviceGraphTrace, streamId) - 40usize];
    [
        "Offset of field: CUpti_ActivityDeviceGraphTrace::reserved",
    ][::std::mem::offset_of!(CUpti_ActivityDeviceGraphTrace, reserved) - 48usize];
};
impl Default for CUpti_ActivityDeviceGraphTrace {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for trace of decompression operations.

 This activity record represents execution for a batch of decompression operatios.
 The activity kind is CUPTI_ACTIVITY_KIND_MEM_DECOMPRESS*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemDecompress {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MEM_DECOMPRESS
    pub kind: CUpti_ActivityKind,
    /// The ID of the device.
    pub deviceId: u32,
    /// The ID of the context.
    pub contextId: u32,
    /// The ID of the stream.
    pub streamId: u32,
    /// The ID of the HW channel on which the memory copy is occurring.
    pub channelID: u32,
    /// The type of the channel
    pub channelType: CUpti_ChannelType,
    /** The correlation ID of the decompression operations. Each operation is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver API activity record that launched
 the operation.*/
    pub correlationId: u32,
    /// The number of operations in the batch.
    pub numberOfOperations: u32,
    /** The number of bytes to be read and decompressed in the
 batch operation.*/
    pub sourceBytes: u64,
    /// This field is reserved for internal use
    pub reserved0: *mut ::std::os::raw::c_void,
    /** The start timestamp.
 A value of CUPTI_TIMESTAMP_UNKNOWN indicates that
 the start time is unknown.*/
    pub start: u64,
    /** The end timestamp.
 A value of CUPTI_TIMESTAMP_UNKNOWN indicates that
 the start time is unknown.*/
    pub end: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemDecompress",
    ][::std::mem::size_of::<CUpti_ActivityMemDecompress>() - 64usize];
    [
        "Alignment of CUpti_ActivityMemDecompress",
    ][::std::mem::align_of::<CUpti_ActivityMemDecompress>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemDecompress::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMemDecompress, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMemDecompress::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemDecompress, deviceId) - 4usize];
    [
        "Offset of field: CUpti_ActivityMemDecompress::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemDecompress, contextId) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemDecompress::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityMemDecompress, streamId) - 12usize];
    [
        "Offset of field: CUpti_ActivityMemDecompress::channelID",
    ][::std::mem::offset_of!(CUpti_ActivityMemDecompress, channelID) - 16usize];
    [
        "Offset of field: CUpti_ActivityMemDecompress::channelType",
    ][::std::mem::offset_of!(CUpti_ActivityMemDecompress, channelType) - 20usize];
    [
        "Offset of field: CUpti_ActivityMemDecompress::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemDecompress, correlationId) - 24usize];
    [
        "Offset of field: CUpti_ActivityMemDecompress::numberOfOperations",
    ][::std::mem::offset_of!(CUpti_ActivityMemDecompress, numberOfOperations) - 28usize];
    [
        "Offset of field: CUpti_ActivityMemDecompress::sourceBytes",
    ][::std::mem::offset_of!(CUpti_ActivityMemDecompress, sourceBytes) - 32usize];
    [
        "Offset of field: CUpti_ActivityMemDecompress::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityMemDecompress, reserved0) - 40usize];
    [
        "Offset of field: CUpti_ActivityMemDecompress::start",
    ][::std::mem::offset_of!(CUpti_ActivityMemDecompress, start) - 48usize];
    [
        "Offset of field: CUpti_ActivityMemDecompress::end",
    ][::std::mem::offset_of!(CUpti_ActivityMemDecompress, end) - 56usize];
};
impl Default for CUpti_ActivityMemDecompress {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** The device memory size (in bytes) reserved for storing profiling data for concurrent
 kernels (activity kind \ref CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL), memcopies and memsets
 for each buffer on a context. The value is a size_t.

 There is a limit on how many device buffers can be allocated per context. User
 can query and set this limit using the attribute
 \ref CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_POOL_LIMIT.
 CUPTI doesn't pre-allocate all the buffers, it pre-allocates only those many
 buffers as set by the attribute \ref CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_PRE_ALLOCATE_VALUE.
 When all of the data in a buffer is consumed, it is added in the reuse pool, and
 CUPTI picks a buffer from this pool when a new buffer is needed. Thus memory
 footprint does not scale with the kernel count. Applications with the high density
 of kernels, memcopies and memsets might result in having CUPTI to allocate more device buffers.
 CUPTI allocates another buffer only when it runs out of the buffers in the
 reuse pool.

 Since buffer allocation happens in the main application thread, this might result
 in stalls in the critical path. CUPTI pre-allocates 3 buffers of the same size to
 mitigate this issue. User can query and set the pre-allocation limit using the
 attribute \ref CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_PRE_ALLOCATE_VALUE.

 Having larger buffer size leaves less device memory for the application.
 Having smaller buffer size increases the risk of dropping timestamps for
 records if too many kernels or memcopies or memsets are launched at one time.

 This value only applies to new buffer allocations. Set this value before initializing
 CUDA or before creating a context to ensure it is considered for the following allocations.

 The default value is 3200000 (~3MB) which can accommodate profiling data
 up to 100,000 kernels, memcopies and memsets combined.

 Note: Starting with the CUDA 12.0 Update 1 release, CUPTI allocates the profiling buffer
 in the device memory by default, which may improve the performance of the tracing run.
 To change the preferred location to page-locked host memory, refer to the attribute
 \ref CUPTI_ACTIVITY_ATTR_MEM_ALLOCATION_TYPE_HOST_PINNED.
 The size of the memory and maximum number of pools are still controlled by the attributes
 \ref CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_SIZE and \ref CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_POOL_LIMIT.

 Note: The actual amount of device memory per buffer reserved by CUPTI might be larger.*/
pub const CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_SIZE: CUpti_ActivityAttribute = 0;
/** The device memory size (in bytes) reserved for storing profiling
 data for CDP operations for each buffer on a context. The
 value is a size_t.

 Having larger buffer size means less flush operations but
 consumes more device memory. This value only applies to new
 allocations.

 Set this value before initializing CUDA or before creating a
 context to ensure it is considered for the following allocations.

 The default value is 8388608 (8MB).

 Note: The actual amount of device memory per context reserved by
 CUPTI might be larger.*/
pub const CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_SIZE_CDP: CUpti_ActivityAttribute = 1;
/** The maximum number of device memory buffers per context. The value is a size_t.

 For an application with high rate of kernel launches, memcopies and memsets having a bigger pool
 limit helps in timestamp collection for all these activities at the expense of a larger memory footprint.
 Refer to the description of the attribute \ref CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_SIZE
 for more details.

 Setting this value will not modify the number of memory buffers
 currently stored.

 Set this value before initializing CUDA to ensure the limit is
 not exceeded.

 The default value is 250.*/
pub const CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_POOL_LIMIT: CUpti_ActivityAttribute = 2;
/** This attribute is not supported starting with CUDA 12.3
 CUPTI no longer uses profiling semaphore pool to store profiling data.

 There is a limit on how many semaphore pools can be allocated per context. User
 can query and set this limit using the attribute
 \ref CUPTI_ACTIVITY_ATTR_PROFILING_SEMAPHORE_POOL_LIMIT.
 CUPTI doesn't pre-allocate all the semaphore pools, it pre-allocates only those many
 semaphore pools as set by the attribute \ref CUPTI_ACTIVITY_ATTR_PROFILING_SEMAPHORE_PRE_ALLOCATE_VALUE.
 When all of the data in a semaphore pool is consumed, it is added in the reuse pool, and
 CUPTI picks a semaphore pool from the reuse pool when a new semaphore pool is needed. Thus memory
 footprint does not scale with the kernel count. Applications with the high density
 of kernels might result in having CUPTI to allocate more semaphore pools.
 CUPTI allocates another semaphore pool only when it runs out of the semaphore pools in the
 reuse pool.

 Since semaphore pool allocation happens in the main application thread, this might result
 in stalls in the critical path. CUPTI pre-allocates 3 semaphore pools of the same size to
 mitigate this issue. User can query and set the pre-allocation limit using the
 attribute \ref CUPTI_ACTIVITY_ATTR_PROFILING_SEMAPHORE_PRE_ALLOCATE_VALUE.

 Having larger semaphore pool size leaves less device memory for the application.
 Having smaller semaphore pool size increases the risk of dropping timestamps for
 kernel records if too many kernels are issued/launched at one time.

 This value only applies to new semaphore pool allocations. Set this value before initializing
 CUDA or before creating a context to ensure it is considered for the following allocations.

 The default value is 25000 which can accommodate profiling data for upto 25,000 kernels.
*/
pub const CUPTI_ACTIVITY_ATTR_PROFILING_SEMAPHORE_POOL_SIZE: CUpti_ActivityAttribute = 3;
/** This attribute is not supported starting with CUDA 12.3
 CUPTI no longer uses profiling semaphore pool to store profiling data.

 The maximum number of profiling semaphore pools per context. The value is a size_t.

 Refer to the description of the attribute \ref CUPTI_ACTIVITY_ATTR_PROFILING_SEMAPHORE_POOL_SIZE
 for more details.

 Set this value before initializing CUDA to ensure the limit is not exceeded.

 The default value is 250.*/
pub const CUPTI_ACTIVITY_ATTR_PROFILING_SEMAPHORE_POOL_LIMIT: CUpti_ActivityAttribute = 4;
/** The flag to indicate whether user should provide activity buffer of zero value.
 The value is a uint8_t.

 If the value of this attribute is non-zero, user should provide
 a zero value buffer in the \ref CUpti_BuffersCallbackRequestFunc.
 If the user does not provide a zero value buffer after setting this to non-zero,
 the activity buffer may contain some uninitialized values when CUPTI returns it in
 \ref CUpti_BuffersCallbackCompleteFunc

 If the value of this attribute is zero, CUPTI will initialize the user buffer
 received in the \ref CUpti_BuffersCallbackRequestFunc to zero before filling it.
 If the user sets this to zero, a few stalls may appear in critical path because CUPTI
 will zero out the buffer in the main thread.
 Set this value before returning from \ref CUpti_BuffersCallbackRequestFunc to
 ensure it is considered for all the subsequent user buffers.

 The default value is 0.*/
pub const CUPTI_ACTIVITY_ATTR_ZEROED_OUT_ACTIVITY_BUFFER: CUpti_ActivityAttribute = 5;
/** Number of device buffers to pre-allocate for a context during the initialization phase.
 The value is a size_t.

 Refer to the description of the attribute \ref CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_SIZE
 for details.

 This value must be less than the maximum number of device buffers set using
 the attribute \ref CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_POOL_LIMIT

 Set this value before initializing CUDA or before creating a context to ensure it
 is considered by the CUPTI.

 The default value is set to 3 to ping pong between these buffers (if possible).*/
pub const CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_PRE_ALLOCATE_VALUE: CUpti_ActivityAttribute = 6;
/** This attribute is not supported starting with CUDA 12.3
 CUPTI no longer uses profiling semaphore pool to store profiling data.

 Number of profiling semaphore pools to pre-allocate for a context during the
 initialization phase. The value is a size_t.

 Refer to the description of the attribute \ref CUPTI_ACTIVITY_ATTR_PROFILING_SEMAPHORE_POOL_SIZE
 for details.

 This value must be less than the maximum number of profiling semaphore pools set
 using the attribute \ref CUPTI_ACTIVITY_ATTR_PROFILING_SEMAPHORE_POOL_LIMIT

 Set this value before initializing CUDA or before creating a context to ensure it
 is considered by the CUPTI.

 The default value is set to 3 to ping pong between these pools (if possible).*/
pub const CUPTI_ACTIVITY_ATTR_PROFILING_SEMAPHORE_PRE_ALLOCATE_VALUE: CUpti_ActivityAttribute = 7;
/** Allocate page-locked (pinned) host memory for storing profiling data for concurrent
 kernels, memcopies and memsets for each buffer on a context. The value is a uint8_t.

 From CUDA 11.2 through CUDA 12.0 GA releases, CUPTI allocated the profiling buffer
 in pinned host memory by default.
 Allocating excessive amounts of pinned memory may degrade system performance, as it
 reduces the amount of memory available to the system for paging. For this reason user
 might want to change the location from pinned host memory to device memory by setting
 value of this attribute to 0.

 Using page-locked (pinned) host memory buffers is not supported on confidential computing
 devices. If this attribute is set to 1, CUPTI will return error CUPTI_ERROR_NOT_SUPPORTED.

 The default value is 0.*/
pub const CUPTI_ACTIVITY_ATTR_MEM_ALLOCATION_TYPE_HOST_PINNED: CUpti_ActivityAttribute = 8;
/** Request activity buffers per-thread to store CUPTI activity records
 in the activity buffer on per-thread basis. The value is a uint8_t.

 The attribute should be set before registering the buffer callbacks using
 cuptiActivityRegisterCallbacks API and before any of the CUPTI activity kinds are enabled.
 This makes sure that all the records are stored in activity buffers allocated per-thread.
 Changing this attribute in the middle of the profiling session will result in undefined behavior.

 The default value is 1.*/
pub const CUPTI_ACTIVITY_ATTR_PER_THREAD_ACTIVITY_BUFFER: CUpti_ActivityAttribute = 9;
/** The device memory size (in bytes) reserved for storing profiling
 data for device graph operations for each buffer on a context. The
 value is a size_t.

 Having larger buffer size means less flush operations but
 consumes more device memory. This value only applies to new
 allocations.

 Set this value before initializing CUDA or before creating a
 context to ensure it is considered for the following allocations.

 The default value is 16777216 (16MB).

 Note: The actual amount of device memory per context reserved by
 CUPTI might be larger.*/
pub const CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_SIZE_DEVICE_GRAPHS: CUpti_ActivityAttribute = 10;
/** The device memory size (in bytes) reserved for storing profiling
 data for device graph operations for each buffer on a context. The
 value is a size_t.

 Having larger buffer size means less flush operations but
 consumes more device memory. This value only applies to new
 allocations.

 Set this value before initializing CUDA or before creating a
 context to ensure it is considered for the following allocations.

 The default value is 16777216 (16MB).

 Note: The actual amount of device memory per context reserved by
 CUPTI might be larger.*/
pub const CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_FORCE_INT: CUpti_ActivityAttribute = 2147483647;
/** \brief Activity attributes.

 These attributes are used to control the behavior of the activity
 API.*/
pub type CUpti_ActivityAttribute = ::std::os::raw::c_uint;
/** Default type
 Windows uses API GetCurrentThreadId()
 Linux/Mac/Android/QNX use POSIX pthread API pthread_self()*/
pub const CUPTI_ACTIVITY_THREAD_ID_TYPE_DEFAULT: CUpti_ActivityThreadIdType = 0;
/** This type is based on the system API available on the underlying platform
 and thread-id obtained is supposed to be unique for the process lifetime.
 Windows uses API GetCurrentThreadId()
 Linux uses syscall SYS_gettid
 Mac uses syscall SYS_thread_selfid
 Android/QNX use gettid()*/
pub const CUPTI_ACTIVITY_THREAD_ID_TYPE_SYSTEM: CUpti_ActivityThreadIdType = 1;
/// Add new enums before this field.
pub const CUPTI_ACTIVITY_THREAD_ID_TYPE_SIZE: CUpti_ActivityThreadIdType = 2;
/// Add new enums before this field.
pub const CUPTI_ACTIVITY_THREAD_ID_TYPE_FORCE_INT: CUpti_ActivityThreadIdType = 2147483647;
/** \brief Thread-Id types.

 CUPTI uses different methods to obtain the thread-id depending on the
 support and the underlying platform. This enum documents these methods
 for each type. APIs \ref cuptiSetThreadIdType and \ref cuptiGetThreadIdType
 can be used to set and get the thread-id type.*/
pub type CUpti_ActivityThreadIdType = ::std::os::raw::c_uint;
unsafe extern "C" {
    /** \brief Get the CUPTI timestamp.

 Returns a timestamp normalized to correspond with the start and end
 timestamps reported in the CUPTI activity records. The timestamp is
 reported in nanoseconds.

 \param timestamp Returns the CUPTI timestamp

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p timestamp is NULL*/
    pub fn cuptiGetTimestamp(timestamp: *mut u64) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get the ID of a context.

 Get the ID of a context.

 \param context The context
 \param contextId Returns a process-unique ID for the context

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_CONTEXT The context is NULL or not valid.
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p contextId is NULL*/
    pub fn cuptiGetContextId(context: CUcontext, contextId: *mut u32) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get the ID of a stream.

 Get the ID of a stream. The stream ID is unique within a context
 (i.e. all streams within a context will have unique stream
 IDs).

 \param context If non-NULL then the stream is checked to ensure
 that it belongs to this context. Typically this parameter should be
 null.
 \param stream The stream
 \param streamId Returns a context-unique ID for the stream

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_STREAM if unable to get stream ID, or
 if \p context is non-NULL and \p stream does not belong to the
 context
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p streamId is NULL

 **DEPRECATED** This method is deprecated as of CUDA 8.0.
 Use method cuptiGetStreamIdEx instead.*/
    pub fn cuptiGetStreamId(
        context: CUcontext,
        stream: CUstream,
        streamId: *mut u32,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get the ID of a stream.

 Get the ID of a stream. The stream ID is unique within a context
 (i.e. all streams within a context will have unique stream
 IDs).

 \param context If non-NULL then the stream is checked to ensure
 that it belongs to this context. Typically this parameter should be
 null.
 \param stream The stream
 \param perThreadStream Flag to indicate if program is compiled for per-thread streams
 \param streamId Returns a context-unique ID for the stream

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_STREAM if unable to get stream ID, or
 if \p context is non-NULL and \p stream does not belong to the
 context
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p streamId is NULL*/
    pub fn cuptiGetStreamIdEx(
        context: CUcontext,
        stream: CUstream,
        perThreadStream: u8,
        streamId: *mut u32,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get the ID of a device

 If \p context is NULL, returns the ID of the device that contains
 the currently active context. If \p context is non-NULL, returns
 the ID of the device which contains that context. Operates in a
 similar manner to cudaGetDevice() or cuCtxGetDevice() but may be
 called from within callback functions.

 \param context The context, or NULL to indicate the current context.
 \param deviceId Returns the ID of the device that is current for
 the calling thread.

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_DEVICE if unable to get device ID
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p deviceId is NULL*/
    pub fn cuptiGetDeviceId(context: CUcontext, deviceId: *mut u32) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get the unique ID of a graph node

 Returns the unique ID of the CUDA graph node.

 \param node The graph node.
 \param nodeId Returns the unique ID of the node

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p node is NULL*/
    pub fn cuptiGetGraphNodeId(node: CUgraphNode, nodeId: *mut u64) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get the unique ID of graph

 Returns the unique ID of CUDA graph.

 \param graph The graph.
 \param pId Returns the unique ID of the graph

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p graph is NULL*/
    pub fn cuptiGetGraphId(graph: CUgraph, pId: *mut u32) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get the unique ID of executable graph

 Returns the unique ID of executable CUDA graph.

 \param graphExec The executable graph.
 \param pId Returns the unique ID of the executable graph

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p graph is NULL*/
    pub fn cuptiGetGraphExecId(graphExec: CUgraphExec, pId: *mut u32) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Enable collection of a specific kind of activity record.

 Enable collection of a specific kind of activity record. Multiple
 kinds can be enabled by calling this function multiple times. By
 default all activity kinds are disabled for collection.

 \param kind The kind of activity record to collect

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_NOT_COMPATIBLE if the activity kind cannot be enabled
 \retval CUPTI_ERROR_INVALID_KIND if the activity kind is not supported*/
    pub fn cuptiActivityEnable(kind: CUpti_ActivityKind) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Enable collection of a specific kind of activity record. For certain activity kinds
 it dumps existing records.

 In general, the behavior of this API is similar to the API \ref cuptiActivityEnable i.e. it
 enables the collection of a specific kind of activity record.
 Additionally, this API can help in dumping the records for activities which happened in
 the past before enabling the corresponding activity kind.
 The API allows to get records for the current resource allocations done in CUDA
 For CUPTI_ACTIVITY_KIND_DEVICE, existing device records are dumped
 For CUPTI_ACTIVITY_KIND_CONTEXT, existing context records are dumped
 For CUPTI_ACTIVITY_KIND_STREAM, existing stream records are dumped
 For CUPTI_ACTIVITY_KIND_ NVLINK, existing NVLINK records are dumped
 For CUPTI_ACTIVITY_KIND_PCIE, existing PCIE records are dumped
 For other activities, the behavior is similar to the API \ref cuptiActivityEnable

 Device records are emitted in CUPTI on CUDA driver initialization. Those records
 can only be retrieved by the user if CUPTI is attached before CUDA initialization.
 Context and stream records are emitted on context and stream creation.
 The use case of the API is to provide the records for CUDA resources
 (contexts/streams/devices) that are currently active if user late attaches CUPTI.

 Before calling this function, the user must register buffer callbacks
 to get the activity records by calling \ref cuptiActivityRegisterCallbacks.
 If the user does not register the buffers and calls API \ref cuptiActivityEnableAndDump,
 then CUPTI will enable the activity kind but not provide any records for that
 activity kind.

 \param kind The kind of activity record to collect

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_UNKNOWN if buffer is not initialized.
 \retval CUPTI_ERROR_NOT_COMPATIBLE if the activity kind cannot be enabled
 \retval CUPTI_ERROR_INVALID_KIND if the activity kind is not supported*/
    pub fn cuptiActivityEnableAndDump(kind: CUpti_ActivityKind) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Disable collection of a specific kind of activity record.

 Disable collection of a specific kind of activity record. Multiple
 kinds can be disabled by calling this function multiple times. By
 default all activity kinds are disabled for collection.

 \param kind The kind of activity record to stop collecting

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_KIND if the activity kind is not supported*/
    pub fn cuptiActivityDisable(kind: CUpti_ActivityKind) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Enable collection of a specific kind of activity record for
 a context.

 Enable collection of a specific kind of activity record for a
 context.  This setting done by this API will supersede the global
 settings for activity records enabled by \ref cuptiActivityEnable.
 Multiple kinds can be enabled by calling this function multiple
 times.

 \param context The context for which activity is to be enabled
 \param kind The kind of activity record to collect

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_NOT_COMPATIBLE if the activity kind cannot be enabled
 \retval CUPTI_ERROR_INVALID_KIND if the activity kind is not supported*/
    pub fn cuptiActivityEnableContext(
        context: CUcontext,
        kind: CUpti_ActivityKind,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Disable collection of a specific kind of activity record for
 a context.

 Disable collection of a specific kind of activity record for a context.
 This setting done by this API will supersede the global settings
 for activity records.
 Multiple kinds can be enabled by calling this function multiple times.

 \param context The context for which activity is to be disabled
 \param kind The kind of activity record to stop collecting

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_KIND if the activity kind is not supported*/
    pub fn cuptiActivityDisableContext(
        context: CUcontext,
        kind: CUpti_ActivityKind,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get the number of activity records that were dropped of
 insufficient buffer space.

 Get the number of records that were dropped because of insufficient
 buffer space.  The dropped count includes records that could not be
 recorded because CUPTI did not have activity buffer space available
 for the record (because the CUpti_BuffersCallbackRequestFunc
 callback did not return an empty buffer of sufficient size) and
 also CDP records that could not be record because the device-size
 buffer was full (size is controlled by the
 CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_SIZE_CDP attribute). The dropped
 count maintained for the queue is reset to zero when this function
 is called.

 \param context The context, or NULL to get dropped count from global queue
 \param streamId The stream ID
 \param dropped The number of records that were dropped since the last call
 to this function.

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p dropped is NULL*/
    pub fn cuptiActivityGetNumDroppedRecords(
        context: CUcontext,
        streamId: u32,
        dropped: *mut usize,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Iterate over the activity records in a buffer.

 This is a helper function to iterate over the activity records in a
 buffer. A buffer of activity records is typically obtained by
 receiving a CUpti_BuffersCallbackCompleteFunc callback. Stop iterating
 the buffer when an error occurs.

 An example of typical usage:
 \code
 CUpti_Activity *record = NULL;
 CUptiResult status = CUPTI_SUCCESS;
   do {
      status = cuptiActivityGetNextRecord(buffer, validSize, &record);
      if(status == CUPTI_SUCCESS) {
           // Use record here...
      }
      else if (status == CUPTI_ERROR_MAX_LIMIT_REACHED)
          break;
      else if (status == CUPTI_ERROR_INVALID_KIND)
          break;
      else {
          goto Error;
      }
    } while (1);
 \endcode

 \param buffer The buffer containing activity records
 \param record Inputs the previous record returned by
 cuptiActivityGetNextRecord and returns the next activity record
 from the buffer. If input value is NULL, returns the first activity
 record in the buffer. Records of certain kinds like CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL
 may contain invalid (0) timestamps, indicating that no timing information could
 be collected for lack of device memory.
 \param validBufferSizeBytes The number of valid bytes in the buffer.

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_MAX_LIMIT_REACHED if no more records in the buffer
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p buffer is NULL.
 \retval CUPTI_ERROR_INVALID_KIND if activity record is either incomplete or invalid*/
    pub fn cuptiActivityGetNextRecord(
        buffer: *mut u8,
        validBufferSizeBytes: usize,
        record: *mut *mut CUpti_Activity,
    ) -> CUptiResult;
}
/** \brief Function type for callback used by CUPTI to request an empty
 buffer for storing activity records.

 This callback function signals the CUPTI client that an activity
 buffer is needed by CUPTI. The activity buffer is used by CUPTI to
 store activity records. The callback function can decline the
 request by setting \p *buffer to NULL. In this case CUPTI may drop
 activity records.

 \param buffer Returns the new buffer. If set to NULL then no buffer
 is returned.
 \param size Returns the size of the returned buffer.
 \param maxNumRecords Returns the maximum number of records that
 should be placed in the buffer. If 0 then the buffer is filled with
 as many records as possible. If > 0 the buffer is filled with at
 most that many records before it is returned.*/
pub type CUpti_BuffersCallbackRequestFunc = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *mut *mut u8,
        size: *mut usize,
        maxNumRecords: *mut usize,
    ),
>;
/** \brief Function type for callback used by CUPTI to return a buffer
 of activity records.

 This callback function returns to the CUPTI client a buffer
 containing activity records.  The buffer contains \p validSize
 bytes of activity records which should be read using
 cuptiActivityGetNextRecord. The number of dropped records can be
 read using cuptiActivityGetNumDroppedRecords. After this call CUPTI
 relinquished ownership of the buffer and will not use it
 anymore. The client may return the buffer to CUPTI using the
 CUpti_BuffersCallbackRequestFunc callback.
 Note: CUDA 6.0 onwards, all buffers returned by this callback are
 global buffers i.e. there is no context/stream specific buffer.
 User needs to parse the global buffer to extract the context/stream
 specific activity records.

 \param context The context this buffer is associated with. If NULL, the
 buffer is associated with the global activities. This field is deprecated
 as of CUDA 6.0 and will always be NULL.
 \param streamId The stream id this buffer is associated with.
 This field is deprecated as of CUDA 6.0 and will always be NULL.
 \param buffer The activity record buffer.
 \param size The total size of the buffer in bytes as set in
 CUpti_BuffersCallbackRequestFunc.
 \param validSize The number of valid bytes in the buffer.*/
pub type CUpti_BuffersCallbackCompleteFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: CUcontext,
        streamId: u32,
        buffer: *mut u8,
        size: usize,
        validSize: usize,
    ),
>;
unsafe extern "C" {
    /** \brief Registers callback functions with CUPTI for activity buffer
 handling.

 This function registers two callback functions to be used in asynchronous
 buffer handling. If registered, activity record buffers are handled using
 asynchronous requested/completed callbacks from CUPTI.

 Registering these callbacks prevents the client from using CUPTI's
 blocking enqueue/dequeue functions.

 \param funcBufferRequested callback which is invoked when an empty
 buffer is requested by CUPTI
 \param funcBufferCompleted callback which is invoked when a buffer
 containing activity records is available from CUPTI

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if either \p
 funcBufferRequested or \p funcBufferCompleted is NULL*/
    pub fn cuptiActivityRegisterCallbacks(
        funcBufferRequested: CUpti_BuffersCallbackRequestFunc,
        funcBufferCompleted: CUpti_BuffersCallbackCompleteFunc,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Wait for all activity records to be delivered via the
 completion callback.

 This function does not return until all activity records associated
 with the specified context/stream are returned to the CUPTI client
 using the callback registered in cuptiActivityRegisterCallbacks. To
 ensure that all activity records are complete, the requested
 stream(s), if any, are synchronized.

 If \p context is NULL, the global activity records (i.e. those not
 associated with a particular stream) are flushed (in this case no
 streams are synchronized).  If \p context is a valid CUcontext and
 \p streamId is 0, the buffers of all streams of this context are
 flushed.  Otherwise, the buffers of the specified stream in this
 context is flushed.

 Before calling this function, the buffer handling callback api
 must be activated by calling cuptiActivityRegisterCallbacks.

 \param context A valid CUcontext or NULL.
 \param streamId The stream ID.
 \param flag The flag can be set to indicate a forced flush. See CUpti_ActivityFlag

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_CUPTI_ERROR_INVALID_OPERATION if not preceded
 by a successful call to cuptiActivityRegisterCallbacks
 \retval CUPTI_ERROR_UNKNOWN an internal error occurred

 **DEPRECATED** This method is deprecated
 CONTEXT and STREAMID will be ignored. Use cuptiActivityFlushAll
 to flush all data.*/
    pub fn cuptiActivityFlush(
        context: CUcontext,
        streamId: u32,
        flag: u32,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Request to deliver activity records via the buffer completion callback.

 This function returns the activity records associated with all contexts/streams
 (and the global buffers not associated with any stream) to the CUPTI client
 using the callback registered in cuptiActivityRegisterCallbacks.

 This is a blocking call but it doesn't issue any CUDA synchronization calls
 implicitly thus it's not guaranteed that all activities are completed on the
 underlying devices. Activity record is considered as completed if it has all
 the information filled up including the timestamps if any. It is the client's
 responsibility to issue necessary CUDA synchronization calls before calling
 this function if all activity records with complete information are expected
 to be delivered.

 Behavior of the function based on the input flag:
 (-) ::For default flush i.e. when flag is set as 0, it returns all the
 activity buffers which have all the activity records completed, buffers need not
 to be full though. It doesn't return buffers which have one or more incomplete
 records. Default flush can be done at a regular interval in a separate thread.
 (-) ::For forced flush i.e. when flag CUPTI_ACTIVITY_FLAG_FLUSH_FORCED is passed
 to the function, it returns all the activity buffers including the ones which have
 one or more incomplete activity records. It's suggested for clients to do the
 force flush before the termination of the profiling session to allow remaining
 buffers to be delivered. In general, it can be done in the at-exit handler.

 Before calling this function, the buffer handling callback api must be activated
 by calling cuptiActivityRegisterCallbacks.

 \param flag The flag can be set to indicate a forced flush. See CUpti_ActivityFlag

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_OPERATION if not preceded by a
 successful call to cuptiActivityRegisterCallbacks
 \retval CUPTI_ERROR_UNKNOWN an internal error occurred

 \see cuptiActivityFlushPeriod*/
    pub fn cuptiActivityFlushAll(flag: u32) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Read an activity API attribute.

 Read an activity API attribute and return it in \p *value.

 \param attr The attribute to read
 \param valueSize Size of buffer pointed by the value, and
 returns the number of bytes written to \p value
 \param value Returns the value of the attribute

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p valueSize or \p value is NULL, or
 if \p attr is not an activity attribute
 \retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT Indicates that
 the \p value buffer is too small to hold the attribute value.*/
    pub fn cuptiActivityGetAttribute(
        attr: CUpti_ActivityAttribute,
        valueSize: *mut usize,
        value: *mut ::std::os::raw::c_void,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Write an activity API attribute.

 Write an activity API attribute.

 \param attr The attribute to write
 \param valueSize The size, in bytes, of the value
 \param value The attribute value to write

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p valueSize or \p value is NULL, or
 if \p attr is not an activity attribute
 \retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT Indicates that
 the \p value buffer is too small to hold the attribute value.*/
    pub fn cuptiActivitySetAttribute(
        attr: CUpti_ActivityAttribute,
        valueSize: *mut usize,
        value: *mut ::std::os::raw::c_void,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Set Unified Memory Counter configuration.

 Set the configuration before enabling the corresponding activity kind
 CUPTI_ACTIVITY_KIND_UNIFIED_MEMORY_COUNTER.
 The API should be called after CUDA driver initialization.

 \param config A pointer to \ref CUpti_ActivityUnifiedMemoryCounterConfig structures
 containing Unified Memory counter configuration.
 \param count Number of Unified Memory counter configuration structures

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p config is NULL or
 any parameter in the \p config structures is not a valid value
 \retval CUPTI_ERROR_UM_PROFILING_NOT_SUPPORTED One potential reason is that
 platform (OS/arch) does not support the unified memory counters
 \retval CUPTI_ERROR_UM_PROFILING_NOT_SUPPORTED_ON_DEVICE Indicates that the device
 does not support the unified memory counters
 \retval CUPTI_ERROR_UM_PROFILING_NOT_SUPPORTED_ON_NON_P2P_DEVICES Indicates that
 multi-GPU configuration without P2P support between any pair of devices
 does not support the unified memory counters*/
    pub fn cuptiActivityConfigureUnifiedMemoryCounter(
        config: *mut CUpti_ActivityUnifiedMemoryCounterConfig,
        count: u32,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get auto boost state

 The profiling results can be inconsistent in case auto boost is enabled.
 CUPTI tries to disable auto boost while profiling. It can fail to disable in
 cases where user does not have the permissions or CUDA_AUTO_BOOST env
 variable is set. The function can be used to query whether auto boost is
 enabled.

 \param context A valid CUcontext.
 \param state A pointer to \ref CUpti_ActivityAutoBoostState structure which
 contains the current state and the id of the process that has requested the
 current state

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p CUcontext or \p state is NULL
 \retval CUPTI_ERROR_NOT_SUPPORTED Indicates that the device does not support auto boost
 \retval CUPTI_ERROR_UNKNOWN an internal error occurred*/
    pub fn cuptiGetAutoBoostState(
        context: CUcontext,
        state: *mut CUpti_ActivityAutoBoostState,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Set PC sampling configuration.

 For Pascal and older GPU architectures this API must be called before enabling
 activity kind CUPTI_ACTIVITY_KIND_PC_SAMPLING. There is no such requirement
 for Volta and newer GPU architectures.

 For Volta and newer GPU architectures if this API is called in the middle of
 execution, PC sampling configuration will be updated for subsequent kernel launches.

 Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.

 \param ctx The context
 \param config A pointer to \ref CUpti_ActivityPCSamplingConfig structure
 containing PC sampling configuration.

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_OPERATION if this api is called while
 some valid event collection method is set.
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p config is NULL or
 any parameter in the \p config structures is not a valid value
 \retval CUPTI_ERROR_NOT_SUPPORTED Indicates that the system/device
 does not support the unified memory counters*/
    pub fn cuptiActivityConfigurePCSampling(
        ctx: CUcontext,
        config: *mut CUpti_ActivityPCSamplingConfig,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Returns the last error from a cupti call or callback

 Returns the last error that has been produced by any of the cupti api calls
 or the callback in the same host thread and resets it to CUPTI_SUCCESS.*/
    pub fn cuptiGetLastError() -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Set the thread-id type

 CUPTI uses the method corresponding to set type to generate the thread-id.
 See enum \ref CUpti_ActivityThreadIdType for the list of methods.
 Activity records having thread-id field contain the same value.
 Thread id type must not be changed during the profiling session to
 avoid thread-id value mismatch across activity records.

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_SUPPORTED if \p type is not supported on the platform*/
    pub fn cuptiSetThreadIdType(type_: CUpti_ActivityThreadIdType) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Get the thread-id type

 Returns the thread-id type used in CUPTI

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p type is NULL*/
    pub fn cuptiGetThreadIdType(type_: *mut CUpti_ActivityThreadIdType) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Check support for a compute capability

 This function is used to check the support for a device based on
 it's compute capability. It sets the \p support when the compute
 capability is supported by the current version of CUPTI, and clears
 it otherwise. This version of CUPTI might not support all GPUs sharing
 the same compute capability. It is suggested to use API \ref
 cuptiDeviceSupported which provides correct information.

 \param major The major revision number of the compute capability
 \param minor The minor revision number of the compute capability
 \param support Pointer to an integer to return the support status

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p support is NULL

 \sa ::cuptiDeviceSupported*/
    pub fn cuptiComputeCapabilitySupported(
        major: ::std::os::raw::c_int,
        minor: ::std::os::raw::c_int,
        support: *mut ::std::os::raw::c_int,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Check support for a compute device

 This function is used to check the support for a compute device.
 It sets the \p support when the device is supported by the current
 version of CUPTI, and clears it otherwise.

 \param dev The device handle returned by CUDA Driver API cuDeviceGet
 \param support Pointer to an integer to return the support status

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p support is NULL
 \retval CUPTI_ERROR_INVALID_DEVICE if \p dev is not a valid device

 \sa ::cuptiComputeCapabilitySupported*/
    pub fn cuptiDeviceSupported(
        dev: CUdevice,
        support: *mut ::std::os::raw::c_int,
    ) -> CUptiResult;
}
/** No virtualization mode is associated with the device
 i.e. it's a baremetal GPU*/
pub const CUPTI_DEVICE_VIRTUALIZATION_MODE_NONE: CUpti_DeviceVirtualizationMode = 0;
/** The device is associated with the pass-through GPU.
 In this mode, an entire physical GPU is directly assigned
 to one virtual machine (VM).*/
pub const CUPTI_DEVICE_VIRTUALIZATION_MODE_PASS_THROUGH: CUpti_DeviceVirtualizationMode = 1;
/** The device is associated with the virtual GPU (vGPU).
 In this mode multiple virtual machines (VMs) have simultaneous,
 direct access to a single physical GPU.*/
pub const CUPTI_DEVICE_VIRTUALIZATION_MODE_VIRTUAL_GPU: CUpti_DeviceVirtualizationMode = 2;
/** The device is associated with the virtual GPU (vGPU).
 In this mode multiple virtual machines (VMs) have simultaneous,
 direct access to a single physical GPU.*/
pub const CUPTI_DEVICE_VIRTUALIZATION_MODE_FORCE_INT: CUpti_DeviceVirtualizationMode = 2147483647;
/// This indicates the virtualization mode in which CUDA device is running
pub type CUpti_DeviceVirtualizationMode = ::std::os::raw::c_uint;
unsafe extern "C" {
    /** \brief Query the virtualization mode of the device

 This function is used to query the virtualization mode of the CUDA device.

 \param dev The device handle returned by CUDA Driver API cuDeviceGet
 \param mode Pointer to an CUpti_DeviceVirtualizationMode to return the virtualization mode

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_DEVICE if \p dev is not a valid device
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p mode is NULL
*/
    pub fn cuptiDeviceVirtualizationMode(
        dev: CUdevice,
        mode: *mut CUpti_DeviceVirtualizationMode,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Detach CUPTI from the running process

 This API detaches the CUPTI from the running process. It destroys and cleans up all the
 resources associated with CUPTI in the current process. After CUPTI detaches from the process,
 the process will keep on running with no CUPTI attached to it.
 For safe operation of the API, it is recommended this API is invoked from the exit callsite
 of any of the CUDA Driver or Runtime API. Otherwise CUPTI client needs to make sure that
 required CUDA synchronization and CUPTI activity buffer flush is done before calling the API.
 Sample code showing the usage of the API in the cupti callback handler code:
 \code
void CUPTIAPI
cuptiCallbackHandler(void *userdata, CUpti_CallbackDomain domain,
CUpti_CallbackId cbid, void *cbdata)
{
const CUpti_CallbackData *cbInfo = (CUpti_CallbackData *)cbdata;

// Take this code path when CUPTI detach is requested
if (detachCupti) {
switch(domain)
{
case CUPTI_CB_DOMAIN_RUNTIME_API:
case CUPTI_CB_DOMAIN_DRIVER_API:
if (cbInfo->callbackSite == CUPTI_API_EXIT) {
// call the CUPTI detach API
cuptiFinalize();
}
break;
default:
break;
}
}
}
\endcode*/
    pub fn cuptiFinalize() -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Push an external correlation id for the calling thread

 This function notifies CUPTI that the calling thread is entering an external API region.
 When a CUPTI activity API record is created while within an external API region and
 CUPTI_ACTIVITY_KIND_EXTERNAL_CORRELATION is enabled, the activity API record will
 be preceded by a CUpti_ActivityExternalCorrelation record for each \ref CUpti_ExternalCorrelationKind.

 \param kind The kind of external API activities should be correlated with.
 \param id External correlation id.

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER The external API kind is invalid*/
    pub fn cuptiActivityPushExternalCorrelationId(
        kind: CUpti_ExternalCorrelationKind,
        id: u64,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Pop an external correlation id for the calling thread

 This function notifies CUPTI that the calling thread is leaving an external API region.

 \param kind The kind of external API activities should be correlated with.
 \param lastId If the function returns successful, contains the last external correlation id for this \p kind, can be NULL.

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER The external API kind is invalid.
 \retval CUPTI_ERROR_QUEUE_EMPTY No external id is currently associated with \p kind.*/
    pub fn cuptiActivityPopExternalCorrelationId(
        kind: CUpti_ExternalCorrelationKind,
        lastId: *mut u64,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Controls the collection of queued and submitted timestamps for kernels.

 This API is used to control the collection of queued and submitted timestamps
 for kernels whose records are provided through the struct \ref CUpti_ActivityKernel10.
 Default value is 0, i.e. these timestamps are not collected. This API needs
 to be called before initialization of CUDA and this setting should not be
 changed during the profiling session.

 This API is not supported if the HW trace is enabled through the API \ref cuptiActivityEnableHWTrace.
 \param enable is a boolean, denoting whether these timestamps should be
 collected

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED*/
    pub fn cuptiActivityEnableLatencyTimestamps(enable: u8) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Sets the flush period for the worker thread

 CUPTI creates a worker thread to minimize the perturbance for the application created
 threads. CUPTI offloads certain operations from the application threads to the worker
 thread, this includes synchronization of profiling resources between host and device,
 delivery of the activity buffers to the client using the callback registered in
 cuptiActivityRegisterCallbacks. For performance reasons, CUPTI wakes up the worker
 thread based on certain heuristics.

 This API is used to control the flush period of the worker thread. This setting will
 override the CUPTI heuristics. Setting time to zero disables the periodic flush and
 restores the default behavior.

 Periodic flush can return only those activity buffers which are full and have all the
 activity records completed.

 It's allowed to use the API \ref cuptiActivityFlushAll to flush the data on-demand, even
 when client sets the periodic flush.

 \param time flush period in milliseconds (ms)

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED

 \see cuptiActivityFlushAll*/
    pub fn cuptiActivityFlushPeriod(time: u32) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Controls the collection of launch attributes for kernels.

 This API is used to control the collection of launch attributes for kernels whose
 records are provided through the struct \ref CUpti_ActivityKernel10.
 Default value is 0, i.e. these attributes are not collected.

 \param enable is a boolean denoting whether these launch attributes should be collected*/
    pub fn cuptiActivityEnableLaunchAttributes(enable: u8) -> CUptiResult;
}
/** \brief Function type for callback used by CUPTI to request a timestamp
 to be used in activity records.

 This callback function signals the CUPTI client that a timestamp needs
 to be returned. This timestamp would be treated as normalized timestamp
 to be used for various purposes in CUPTI. For example to store start and
 end timestamps reported in the CUPTI activity records.
 The returned timestamp must be in nanoseconds.

 \sa ::cuptiActivityRegisterTimestampCallback*/
pub type CUpti_TimestampCallbackFunc = ::std::option::Option<
    unsafe extern "C" fn() -> u64,
>;
unsafe extern "C" {
    /** \brief Registers callback function with CUPTI for providing timestamp.

 This function registers a callback function to obtain timestamp of user's
 choice instead of using CUPTI provided timestamp.
 By default CUPTI uses different methods, based on the underlying platform,
 to retrieve the timestamp
 Linux (x86_64, aarch64 sbsa, aarch64) uses clock_gettime(CLOCK_REALTIME)
 Windows uses QueryPerformanceCounter()
 WSL (Windows Subsystem for Linux) uses clock_gettime(CLOCK_MONOTONIC_RAW) as CLOCK_REALTIME can cause backward jumps.
 QNX uses ClockCycles()
 Timestamps retrieved using these methods are converted to nanosecond if needed
 before usage.

 Timestamps for GPU activities such as kernels, memory copies and memset operations are
 recorded directly on the GPU. To provide a unified and normalized view of these timestamps
 in relation to CPU time, CUPTI performs a linear interpolation to convert GPU timestamps
 into CPU timestamps during post-processing.
 For activities where timestamps are captured on the GPU, the timestamp callback is invoked
 during the post-processing phase, while converting GPU timestamps into CPU timestamps.
 For activities for which timestamps are captured directly on the CPU, the timestamp callback
 is invoked immediately at the time of the activity.

 The registration of timestamp callback should be done before any of the CUPTI
 activity kinds are enabled to make sure that all the records report the timestamp using
 the callback function registered through cuptiActivityRegisterTimestampCallback API.

 Changing the timestamp callback function in CUPTI through
 cuptiActivityRegisterTimestampCallback API in the middle of the profiling
 session can cause records generated prior to the change to report
 timestamps through previous timestamp method.

 \param funcTimestamp callback which is invoked when a timestamp is
 needed by CUPTI

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p funcTimestamp is NULL
 \retval CUPTI_ERROR_NOT_INITIALIZED*/
    pub fn cuptiActivityRegisterTimestampCallback(
        funcTimestamp: CUpti_TimestampCallbackFunc,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Controls the collection of records for device launched graphs.

 This API is used to control the collection of records for device launched graphs.
 Default value is 0, i.e. these records are not collected.
 Default value is 1 if HW trace is enabled using API cuptiActivityEnableHWTrace.
 This API needs to be called before initialization of CUDA and this setting should not be
 changed during the profiling session.

 \param enable is a boolean, denoting whether these records should be
 collected

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED*/
    pub fn cuptiActivityEnableDeviceGraph(enable: u8) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Controls the collection of activity records for specific CUDA Driver APIs.

 Activity kind CUPTI_ACTIVITY_KIND_DRIVER controls the collection of either all
 CUDA Driver APIs or none. API cuptiActivityEnableDriverApi can be used for fine-grained
 control, it allows enabling/disabling tracing of a specific set of CUDA Driver APIs.
 To disable collection of a small set of CUDA Driver APIs, user can
 first enable the collection of all Driver APIs using the activity kind
 CUPTI_ACTIVITY_KIND_DRIVER and call this API to disable specific Driver APIs.
 And to enable the collection of a small set of CUDA Driver APIs, user can
 call this API without using the activity kind CUPTI_ACTIVITY_KIND_DRIVER.

 Note: Activity kind CUPTI_ACTIVITY_KIND_DRIVER overrides the settings done by this API
 if it is called after the API.

 \param cbid callback id of the CUDA Driver API. This can be found in the header cupti_driver_cbid.h.
 \param enable is a boolean, denoting whether to enable or disable the collection

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED*/
    pub fn cuptiActivityEnableDriverApi(
        cbid: CUpti_CallbackId,
        enable: u8,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Controls the collection of activity records for specific CUDA Runtime APIs.

 Activity kind CUPTI_ACTIVITY_KIND_RUNTIME controls the collection of either all
 CUDA Runtime APIs or none. API cuptiActivityEnableRuntimeApi can be used for fine-grained
 control, it allows enabling/disabling tracing of a specific set of CUDA Runtime APIs.
 To disable collection of a small set of CUDA Runtime APIs, user can
 first enable the collection of all Runtime APIs using the activity kind
 CUPTI_ACTIVITY_KIND_RUNTIME and call this API to disable specific Runtime APIs.
 And to enable the collection of a small set of CUDA Runtime APIs, user can
 call this API without using the activity kind CUPTI_ACTIVITY_KIND_RUNTIME.

 Note: Activity kind CUPTI_ACTIVITY_KIND_RUNTIME overrides the settings done by this API
 if it is called after the API.

 \param cbid callback id of the CUDA Runtime API. This can be found in the header cupti_runtime_cbid.h.
 \param enable is a boolean, denoting whether to enable or disable the collection

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED*/
    pub fn cuptiActivityEnableRuntimeApi(
        cbid: CUpti_CallbackId,
        enable: u8,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Enables the collection of CUDA kernel timestamps through Hardware Event System(HES).

 This API enables the collection of CUDA kernel timestamps through HW events instead
 of the traditional SW instrumentation and semaphore based approach.
 This option is only available on Blackwell architecture.
 This API should be called after driver is initialized.

 \param enable is a boolean, denoting whether to enable or disable the collection through HW events

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED if CUPTI is not initialized or the CUDA driver is not initialized
 \retval CUPTI_ERROR_NOT_SUPPORTED if HW trace cannot be enabled on the current platform
 \retval CUPTI_ERROR_VIRTUALIZED_DEVICE_NOT_SUPPORTED
 \retval CUPTI_ERROR_CONFIDENTIAL_COMPUTING_NOT_SUPPORTED
 \retval CUPTI_ERROR_CMP_DEVICE_NOT_SUPPORTED
 \retval CUPTI_ERROR_MIG_DEVICE_NOT_SUPPORTED
 \retval CUPTI_ERROR_SLI_DEVICE_NOT_SUPPORTED
 \retval CUPTI_ERROR_WSL_DEVICE_NOT_SUPPORTED*/
    pub fn cuptiActivityEnableHWTrace(enable: u8) -> CUptiResult;
}
unsafe extern "C" {
    /**  \brief Enables tracking the source library for memory allocation requests.

 This API is used to control whether or not we track the source library of
 memory allocation requests. Default value is 0, i.e. it is not tracked. The
 activity kind CUPTI_ACTIVITY_KIND_MEMORY2 needs to be enabled, and if this flag is
 set, we get the full path of the shared object responsible for the GPU memory allocation
 request in the member source in the CUpti_ActivityMemory4 records. Also note that this feature
 adds runtime overhead.

 \param enable is a boolean, denoting whether the source library of the memory allocation
 request needs to be tracked

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED*/
    pub fn cuptiActivityEnableAllocationSource(enable: u8) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Enables collecting records for all synchronization operations.

 CUPTI provides CUDA event query and stream query records via CUPTI_ACTIVITY_KIND_SYNCHRONIZATION.
 Using this API, CUPTI client can disable to record CUDA event query and stream query records
 for queries for which the operations have not yet been completed on the CUDA event/stream.

 By default, the record is generated for all CUDA events and stream irrespective of whether the
 operations have been completed on the CUDA event/stream.

 \param enable is a boolean, denoting whether to enable or disable the collection of all CUDA event query
 and stream query records

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED*/
    pub fn cuptiActivityEnableAllSyncRecords(enable: u8) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Enable/Disable collecting device timestamp for CUPTI_ACTIVITY_KIND_CUDA_EVENT record.

 CUPTI provides device timestamps via 'deviceTimestamp' field in CUPTI_ACTIVITY_KIND_CUDA_EVENT records.
 Using this API, CUPTI client can enable or disable the collection of CUDA event device timestamps.
 By default, the collection of CUDA event device timestamps is disabled.

 \param enable is a boolean, denoting whether to enable or disable the collection of CUDA event device timestamps

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_NOT_INITIALIZED*/
    pub fn cuptiActivityEnableCudaEventDeviceTimestamps(enable: u8) -> CUptiResult;
}
/** \brief The activity record for CUPTI and driver overheads.
 (Deprecated in CUDA 12.2)

 This activity record provides CUPTI and driver overhead information
 (CUPTI_ACTIVITY_OVERHEAD). These records are now reported using
 CUpti_ActivityOverhead3*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityOverhead {
    /// The activity record kind, must be CUPTI_ACTIVITY_OVERHEAD.
    pub kind: CUpti_ActivityKind,
    /// The kind of overhead, CUPTI, DRIVER, COMPILER etc.
    pub overheadKind: CUpti_ActivityOverheadKind,
    /// The kind of activity object that the overhead is associated with.
    pub objectKind: CUpti_ActivityObjectKind,
    /** The identifier for the activity object. 'objectKind' indicates
 which ID is valid for this record.*/
    pub objectId: CUpti_ActivityObjectKindId,
    /** The start timestamp for the overhead, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the overhead.*/
    pub start: u64,
    /** The end timestamp for the overhead, in ns. A value of 0 for both
 the start and end timestamps indicates that timestamp information
 could not be collected for the overhead.*/
    pub end: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityOverhead",
    ][::std::mem::size_of::<CUpti_ActivityOverhead>() - 40usize];
    [
        "Alignment of CUpti_ActivityOverhead",
    ][::std::mem::align_of::<CUpti_ActivityOverhead>() - 8usize];
    [
        "Offset of field: CUpti_ActivityOverhead::kind",
    ][::std::mem::offset_of!(CUpti_ActivityOverhead, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityOverhead::overheadKind",
    ][::std::mem::offset_of!(CUpti_ActivityOverhead, overheadKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityOverhead::objectKind",
    ][::std::mem::offset_of!(CUpti_ActivityOverhead, objectKind) - 8usize];
    [
        "Offset of field: CUpti_ActivityOverhead::objectId",
    ][::std::mem::offset_of!(CUpti_ActivityOverhead, objectId) - 12usize];
    [
        "Offset of field: CUpti_ActivityOverhead::start",
    ][::std::mem::offset_of!(CUpti_ActivityOverhead, start) - 24usize];
    [
        "Offset of field: CUpti_ActivityOverhead::end",
    ][::std::mem::offset_of!(CUpti_ActivityOverhead, end) - 32usize];
};
impl Default for CUpti_ActivityOverhead {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityOverhead {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityOverhead {{ kind: {:?}, overheadKind: {:?}, objectKind: {:?}, objectId: {:?} }}",
            self.kind,
            self.overheadKind,
            self.objectKind,
            self.objectId,
        )
    }
}
/** \brief The activity record for CUPTI and driver overheads.

 This activity record provides CUPTI and driver overhead information
 (CUPTI_ACTIVITY_OVERHEAD).*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityOverhead2 {
    /// The activity record kind, must be CUPTI_ACTIVITY_OVERHEAD.
    pub kind: CUpti_ActivityKind,
    /// The kind of overhead, CUPTI, DRIVER, COMPILER etc.
    pub overheadKind: CUpti_ActivityOverheadKind,
    /// The kind of activity object that the overhead is associated with.
    pub objectKind: CUpti_ActivityObjectKind,
    /** The identifier for the activity object. 'objectKind' indicates
 which ID is valid for this record.*/
    pub objectId: CUpti_ActivityObjectKindId,
    /** The start timestamp for the overhead, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the overhead.*/
    pub start: u64,
    /** The end timestamp for the overhead, in ns. A value of 0 for both
 the start and end timestamps indicates that timestamp information
 could not be collected for the overhead.*/
    pub end: u64,
    /** The correlation ID of the overhead operation to which
 records belong to. This ID is identical to the
 correlation ID in the driver or runtime API activity record that
 launched the overhead operation.
 In some cases, it can be zero, such as for CUPTI_ACTIVITY_OVERHEAD_CUPTI_BUFFER_FLUSH records.*/
    pub correlationId: u32,
    /// Reserved for internal use.
    pub reserved0: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityOverhead2",
    ][::std::mem::size_of::<CUpti_ActivityOverhead2>() - 48usize];
    [
        "Alignment of CUpti_ActivityOverhead2",
    ][::std::mem::align_of::<CUpti_ActivityOverhead2>() - 8usize];
    [
        "Offset of field: CUpti_ActivityOverhead2::kind",
    ][::std::mem::offset_of!(CUpti_ActivityOverhead2, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityOverhead2::overheadKind",
    ][::std::mem::offset_of!(CUpti_ActivityOverhead2, overheadKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityOverhead2::objectKind",
    ][::std::mem::offset_of!(CUpti_ActivityOverhead2, objectKind) - 8usize];
    [
        "Offset of field: CUpti_ActivityOverhead2::objectId",
    ][::std::mem::offset_of!(CUpti_ActivityOverhead2, objectId) - 12usize];
    [
        "Offset of field: CUpti_ActivityOverhead2::start",
    ][::std::mem::offset_of!(CUpti_ActivityOverhead2, start) - 24usize];
    [
        "Offset of field: CUpti_ActivityOverhead2::end",
    ][::std::mem::offset_of!(CUpti_ActivityOverhead2, end) - 32usize];
    [
        "Offset of field: CUpti_ActivityOverhead2::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityOverhead2, correlationId) - 40usize];
    [
        "Offset of field: CUpti_ActivityOverhead2::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityOverhead2, reserved0) - 44usize];
};
impl Default for CUpti_ActivityOverhead2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityOverhead2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityOverhead2 {{ kind: {:?}, overheadKind: {:?}, objectKind: {:?}, objectId: {:?} }}",
            self.kind,
            self.overheadKind,
            self.objectKind,
            self.objectId,
        )
    }
}
/** \brief The activity record for a device. (deprecated)

 This activity record represents information about a GPU device
 (CUPTI_ACTIVITY_KIND_DEVICE).
 Device activity is now reported using the
 CUpti_ActivityDevice5 activity record.*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityDevice {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_DEVICE.
    pub kind: CUpti_ActivityKind,
    /// The flags associated with the device. \see CUpti_ActivityFlag
    pub flags: CUpti_ActivityFlag,
    /** The global memory bandwidth available on the device, in
 kBytes/sec.*/
    pub globalMemoryBandwidth: u64,
    /// The amount of global memory on the device, in bytes.
    pub globalMemorySize: u64,
    /// The amount of constant memory on the device, in bytes.
    pub constantMemorySize: u32,
    /// The size of the L2 cache on the device, in bytes.
    pub l2CacheSize: u32,
    /// The number of threads per warp on the device.
    pub numThreadsPerWarp: u32,
    /// The core clock rate of the device, in kHz.
    pub coreClockRate: u32,
    /// Number of memory copy engines on the device.
    pub numMemcpyEngines: u32,
    /// Number of multiprocessors on the device.
    pub numMultiprocessors: u32,
    /** The maximum "instructions per cycle" possible on each device
 multiprocessor.*/
    pub maxIPC: u32,
    /** Maximum number of warps that can be present on a multiprocessor
 at any given time.*/
    pub maxWarpsPerMultiprocessor: u32,
    /** Maximum number of blocks that can be present on a multiprocessor
 at any given time.*/
    pub maxBlocksPerMultiprocessor: u32,
    /// Maximum number of registers that can be allocated to a block.
    pub maxRegistersPerBlock: u32,
    /** Maximum amount of shared memory that can be assigned to a block,
 in bytes.*/
    pub maxSharedMemoryPerBlock: u32,
    /// Maximum number of threads allowed in a block.
    pub maxThreadsPerBlock: u32,
    /// Maximum allowed X dimension for a block.
    pub maxBlockDimX: u32,
    /// Maximum allowed Y dimension for a block.
    pub maxBlockDimY: u32,
    /// Maximum allowed Z dimension for a block.
    pub maxBlockDimZ: u32,
    /// Maximum allowed X dimension for a grid.
    pub maxGridDimX: u32,
    /// Maximum allowed Y dimension for a grid.
    pub maxGridDimY: u32,
    /// Maximum allowed Z dimension for a grid.
    pub maxGridDimZ: u32,
    /// Compute capability for the device, major number.
    pub computeCapabilityMajor: u32,
    /// Compute capability for the device, minor number.
    pub computeCapabilityMinor: u32,
    /// The device ID.
    pub id: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
    /** The device name. This name is shared across all activity records
 representing instances of the device, and so should not be
 modified.*/
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityDevice",
    ][::std::mem::size_of::<CUpti_ActivityDevice>() - 120usize];
    [
        "Alignment of CUpti_ActivityDevice",
    ][::std::mem::align_of::<CUpti_ActivityDevice>() - 8usize];
    [
        "Offset of field: CUpti_ActivityDevice::kind",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityDevice::flags",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, flags) - 4usize];
    [
        "Offset of field: CUpti_ActivityDevice::globalMemoryBandwidth",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, globalMemoryBandwidth) - 8usize];
    [
        "Offset of field: CUpti_ActivityDevice::globalMemorySize",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, globalMemorySize) - 16usize];
    [
        "Offset of field: CUpti_ActivityDevice::constantMemorySize",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, constantMemorySize) - 24usize];
    [
        "Offset of field: CUpti_ActivityDevice::l2CacheSize",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, l2CacheSize) - 28usize];
    [
        "Offset of field: CUpti_ActivityDevice::numThreadsPerWarp",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, numThreadsPerWarp) - 32usize];
    [
        "Offset of field: CUpti_ActivityDevice::coreClockRate",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, coreClockRate) - 36usize];
    [
        "Offset of field: CUpti_ActivityDevice::numMemcpyEngines",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, numMemcpyEngines) - 40usize];
    [
        "Offset of field: CUpti_ActivityDevice::numMultiprocessors",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, numMultiprocessors) - 44usize];
    [
        "Offset of field: CUpti_ActivityDevice::maxIPC",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, maxIPC) - 48usize];
    [
        "Offset of field: CUpti_ActivityDevice::maxWarpsPerMultiprocessor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, maxWarpsPerMultiprocessor) - 52usize];
    [
        "Offset of field: CUpti_ActivityDevice::maxBlocksPerMultiprocessor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, maxBlocksPerMultiprocessor)
        - 56usize];
    [
        "Offset of field: CUpti_ActivityDevice::maxRegistersPerBlock",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, maxRegistersPerBlock) - 60usize];
    [
        "Offset of field: CUpti_ActivityDevice::maxSharedMemoryPerBlock",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, maxSharedMemoryPerBlock) - 64usize];
    [
        "Offset of field: CUpti_ActivityDevice::maxThreadsPerBlock",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, maxThreadsPerBlock) - 68usize];
    [
        "Offset of field: CUpti_ActivityDevice::maxBlockDimX",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, maxBlockDimX) - 72usize];
    [
        "Offset of field: CUpti_ActivityDevice::maxBlockDimY",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, maxBlockDimY) - 76usize];
    [
        "Offset of field: CUpti_ActivityDevice::maxBlockDimZ",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, maxBlockDimZ) - 80usize];
    [
        "Offset of field: CUpti_ActivityDevice::maxGridDimX",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, maxGridDimX) - 84usize];
    [
        "Offset of field: CUpti_ActivityDevice::maxGridDimY",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, maxGridDimY) - 88usize];
    [
        "Offset of field: CUpti_ActivityDevice::maxGridDimZ",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, maxGridDimZ) - 92usize];
    [
        "Offset of field: CUpti_ActivityDevice::computeCapabilityMajor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, computeCapabilityMajor) - 96usize];
    [
        "Offset of field: CUpti_ActivityDevice::computeCapabilityMinor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, computeCapabilityMinor) - 100usize];
    [
        "Offset of field: CUpti_ActivityDevice::id",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, id) - 104usize];
    [
        "Offset of field: CUpti_ActivityDevice::pad",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, pad) - 108usize];
    [
        "Offset of field: CUpti_ActivityDevice::name",
    ][::std::mem::offset_of!(CUpti_ActivityDevice, name) - 112usize];
};
impl Default for CUpti_ActivityDevice {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for a device. (deprecated)

 This activity record represents information about a GPU device
 (CUPTI_ACTIVITY_KIND_DEVICE).
 Device activity is now reported using the
 CUpti_ActivityDevice5 activity record.*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityDevice2 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_DEVICE.
    pub kind: CUpti_ActivityKind,
    /// The flags associated with the device. \see CUpti_ActivityFlag
    pub flags: CUpti_ActivityFlag,
    /** The global memory bandwidth available on the device, in
 kBytes/sec.*/
    pub globalMemoryBandwidth: u64,
    /// The amount of global memory on the device, in bytes.
    pub globalMemorySize: u64,
    /// The amount of constant memory on the device, in bytes.
    pub constantMemorySize: u32,
    /// The size of the L2 cache on the device, in bytes.
    pub l2CacheSize: u32,
    /// The number of threads per warp on the device.
    pub numThreadsPerWarp: u32,
    /// The core clock rate of the device, in kHz.
    pub coreClockRate: u32,
    /// Number of memory copy engines on the device.
    pub numMemcpyEngines: u32,
    /// Number of multiprocessors on the device.
    pub numMultiprocessors: u32,
    /** The maximum "instructions per cycle" possible on each device
 multiprocessor.*/
    pub maxIPC: u32,
    /** Maximum number of warps that can be present on a multiprocessor
 at any given time.*/
    pub maxWarpsPerMultiprocessor: u32,
    /** Maximum number of blocks that can be present on a multiprocessor
 at any given time.*/
    pub maxBlocksPerMultiprocessor: u32,
    /// Maximum amount of shared memory available per multiprocessor, in bytes.
    pub maxSharedMemoryPerMultiprocessor: u32,
    /// Maximum number of 32-bit registers available per multiprocessor.
    pub maxRegistersPerMultiprocessor: u32,
    /// Maximum number of registers that can be allocated to a block.
    pub maxRegistersPerBlock: u32,
    /** Maximum amount of shared memory that can be assigned to a block,
 in bytes.*/
    pub maxSharedMemoryPerBlock: u32,
    /// Maximum number of threads allowed in a block.
    pub maxThreadsPerBlock: u32,
    /// Maximum allowed X dimension for a block.
    pub maxBlockDimX: u32,
    /// Maximum allowed Y dimension for a block.
    pub maxBlockDimY: u32,
    /// Maximum allowed Z dimension for a block.
    pub maxBlockDimZ: u32,
    /// Maximum allowed X dimension for a grid.
    pub maxGridDimX: u32,
    /// Maximum allowed Y dimension for a grid.
    pub maxGridDimY: u32,
    /// Maximum allowed Z dimension for a grid.
    pub maxGridDimZ: u32,
    /// Compute capability for the device, major number.
    pub computeCapabilityMajor: u32,
    /// Compute capability for the device, minor number.
    pub computeCapabilityMinor: u32,
    /// The device ID.
    pub id: u32,
    /// ECC enabled flag for device
    pub eccEnabled: u32,
    /** The device UUID. This value is the globally unique immutable
 alphanumeric identifier of the device.*/
    pub uuid: CUuuid,
    /** The device name. This name is shared across all activity records
 representing instances of the device, and so should not be
 modified.*/
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityDevice2",
    ][::std::mem::size_of::<CUpti_ActivityDevice2>() - 144usize];
    [
        "Alignment of CUpti_ActivityDevice2",
    ][::std::mem::align_of::<CUpti_ActivityDevice2>() - 8usize];
    [
        "Offset of field: CUpti_ActivityDevice2::kind",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityDevice2::flags",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, flags) - 4usize];
    [
        "Offset of field: CUpti_ActivityDevice2::globalMemoryBandwidth",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, globalMemoryBandwidth) - 8usize];
    [
        "Offset of field: CUpti_ActivityDevice2::globalMemorySize",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, globalMemorySize) - 16usize];
    [
        "Offset of field: CUpti_ActivityDevice2::constantMemorySize",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, constantMemorySize) - 24usize];
    [
        "Offset of field: CUpti_ActivityDevice2::l2CacheSize",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, l2CacheSize) - 28usize];
    [
        "Offset of field: CUpti_ActivityDevice2::numThreadsPerWarp",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, numThreadsPerWarp) - 32usize];
    [
        "Offset of field: CUpti_ActivityDevice2::coreClockRate",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, coreClockRate) - 36usize];
    [
        "Offset of field: CUpti_ActivityDevice2::numMemcpyEngines",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, numMemcpyEngines) - 40usize];
    [
        "Offset of field: CUpti_ActivityDevice2::numMultiprocessors",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, numMultiprocessors) - 44usize];
    [
        "Offset of field: CUpti_ActivityDevice2::maxIPC",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, maxIPC) - 48usize];
    [
        "Offset of field: CUpti_ActivityDevice2::maxWarpsPerMultiprocessor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, maxWarpsPerMultiprocessor)
        - 52usize];
    [
        "Offset of field: CUpti_ActivityDevice2::maxBlocksPerMultiprocessor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, maxBlocksPerMultiprocessor)
        - 56usize];
    [
        "Offset of field: CUpti_ActivityDevice2::maxSharedMemoryPerMultiprocessor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, maxSharedMemoryPerMultiprocessor)
        - 60usize];
    [
        "Offset of field: CUpti_ActivityDevice2::maxRegistersPerMultiprocessor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, maxRegistersPerMultiprocessor)
        - 64usize];
    [
        "Offset of field: CUpti_ActivityDevice2::maxRegistersPerBlock",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, maxRegistersPerBlock) - 68usize];
    [
        "Offset of field: CUpti_ActivityDevice2::maxSharedMemoryPerBlock",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, maxSharedMemoryPerBlock) - 72usize];
    [
        "Offset of field: CUpti_ActivityDevice2::maxThreadsPerBlock",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, maxThreadsPerBlock) - 76usize];
    [
        "Offset of field: CUpti_ActivityDevice2::maxBlockDimX",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, maxBlockDimX) - 80usize];
    [
        "Offset of field: CUpti_ActivityDevice2::maxBlockDimY",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, maxBlockDimY) - 84usize];
    [
        "Offset of field: CUpti_ActivityDevice2::maxBlockDimZ",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, maxBlockDimZ) - 88usize];
    [
        "Offset of field: CUpti_ActivityDevice2::maxGridDimX",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, maxGridDimX) - 92usize];
    [
        "Offset of field: CUpti_ActivityDevice2::maxGridDimY",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, maxGridDimY) - 96usize];
    [
        "Offset of field: CUpti_ActivityDevice2::maxGridDimZ",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, maxGridDimZ) - 100usize];
    [
        "Offset of field: CUpti_ActivityDevice2::computeCapabilityMajor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, computeCapabilityMajor) - 104usize];
    [
        "Offset of field: CUpti_ActivityDevice2::computeCapabilityMinor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, computeCapabilityMinor) - 108usize];
    [
        "Offset of field: CUpti_ActivityDevice2::id",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, id) - 112usize];
    [
        "Offset of field: CUpti_ActivityDevice2::eccEnabled",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, eccEnabled) - 116usize];
    [
        "Offset of field: CUpti_ActivityDevice2::uuid",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, uuid) - 120usize];
    [
        "Offset of field: CUpti_ActivityDevice2::name",
    ][::std::mem::offset_of!(CUpti_ActivityDevice2, name) - 136usize];
};
impl Default for CUpti_ActivityDevice2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for a device. (CUDA 7.0 onwards)

 This activity record represents information about a GPU device
 (CUPTI_ACTIVITY_KIND_DEVICE).
 Device activity is now reported using the
 CUpti_ActivityDevice5 activity record.*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityDevice3 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_DEVICE.
    pub kind: CUpti_ActivityKind,
    /// The flags associated with the device. \see CUpti_ActivityFlag
    pub flags: CUpti_ActivityFlag,
    /** The global memory bandwidth available on the device, in
 kBytes/sec.*/
    pub globalMemoryBandwidth: u64,
    /// The amount of global memory on the device, in bytes.
    pub globalMemorySize: u64,
    /// The amount of constant memory on the device, in bytes.
    pub constantMemorySize: u32,
    /// The size of the L2 cache on the device, in bytes.
    pub l2CacheSize: u32,
    /// The number of threads per warp on the device.
    pub numThreadsPerWarp: u32,
    /// The core clock rate of the device, in kHz.
    pub coreClockRate: u32,
    /// Number of memory copy engines on the device.
    pub numMemcpyEngines: u32,
    /// Number of multiprocessors on the device.
    pub numMultiprocessors: u32,
    /** The maximum "instructions per cycle" possible on each device
 multiprocessor.*/
    pub maxIPC: u32,
    /** Maximum number of warps that can be present on a multiprocessor
 at any given time.*/
    pub maxWarpsPerMultiprocessor: u32,
    /** Maximum number of blocks that can be present on a multiprocessor
 at any given time.*/
    pub maxBlocksPerMultiprocessor: u32,
    /// Maximum amount of shared memory available per multiprocessor, in bytes.
    pub maxSharedMemoryPerMultiprocessor: u32,
    /// Maximum number of 32-bit registers available per multiprocessor.
    pub maxRegistersPerMultiprocessor: u32,
    /// Maximum number of registers that can be allocated to a block.
    pub maxRegistersPerBlock: u32,
    /** Maximum amount of shared memory that can be assigned to a block,
 in bytes.*/
    pub maxSharedMemoryPerBlock: u32,
    /// Maximum number of threads allowed in a block.
    pub maxThreadsPerBlock: u32,
    /// Maximum allowed X dimension for a block.
    pub maxBlockDimX: u32,
    /// Maximum allowed Y dimension for a block.
    pub maxBlockDimY: u32,
    /// Maximum allowed Z dimension for a block.
    pub maxBlockDimZ: u32,
    /// Maximum allowed X dimension for a grid.
    pub maxGridDimX: u32,
    /// Maximum allowed Y dimension for a grid.
    pub maxGridDimY: u32,
    /// Maximum allowed Z dimension for a grid.
    pub maxGridDimZ: u32,
    /// Compute capability for the device, major number.
    pub computeCapabilityMajor: u32,
    /// Compute capability for the device, minor number.
    pub computeCapabilityMinor: u32,
    /// The device ID.
    pub id: u32,
    /// ECC enabled flag for device
    pub eccEnabled: u32,
    /** The device UUID. This value is the globally unique immutable
 alphanumeric identifier of the device.*/
    pub uuid: CUuuid,
    /** The device name. This name is shared across all activity records
 representing instances of the device, and so should not be
 modified.*/
    pub name: *const ::std::os::raw::c_char,
    /** Flag to indicate whether the device is visible to CUDA. Users can
 set the device visibility using CUDA_VISIBLE_DEVICES environment*/
    pub isCudaVisible: u8,
    pub reserved: [u8; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityDevice3",
    ][::std::mem::size_of::<CUpti_ActivityDevice3>() - 152usize];
    [
        "Alignment of CUpti_ActivityDevice3",
    ][::std::mem::align_of::<CUpti_ActivityDevice3>() - 8usize];
    [
        "Offset of field: CUpti_ActivityDevice3::kind",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityDevice3::flags",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, flags) - 4usize];
    [
        "Offset of field: CUpti_ActivityDevice3::globalMemoryBandwidth",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, globalMemoryBandwidth) - 8usize];
    [
        "Offset of field: CUpti_ActivityDevice3::globalMemorySize",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, globalMemorySize) - 16usize];
    [
        "Offset of field: CUpti_ActivityDevice3::constantMemorySize",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, constantMemorySize) - 24usize];
    [
        "Offset of field: CUpti_ActivityDevice3::l2CacheSize",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, l2CacheSize) - 28usize];
    [
        "Offset of field: CUpti_ActivityDevice3::numThreadsPerWarp",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, numThreadsPerWarp) - 32usize];
    [
        "Offset of field: CUpti_ActivityDevice3::coreClockRate",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, coreClockRate) - 36usize];
    [
        "Offset of field: CUpti_ActivityDevice3::numMemcpyEngines",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, numMemcpyEngines) - 40usize];
    [
        "Offset of field: CUpti_ActivityDevice3::numMultiprocessors",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, numMultiprocessors) - 44usize];
    [
        "Offset of field: CUpti_ActivityDevice3::maxIPC",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, maxIPC) - 48usize];
    [
        "Offset of field: CUpti_ActivityDevice3::maxWarpsPerMultiprocessor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, maxWarpsPerMultiprocessor)
        - 52usize];
    [
        "Offset of field: CUpti_ActivityDevice3::maxBlocksPerMultiprocessor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, maxBlocksPerMultiprocessor)
        - 56usize];
    [
        "Offset of field: CUpti_ActivityDevice3::maxSharedMemoryPerMultiprocessor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, maxSharedMemoryPerMultiprocessor)
        - 60usize];
    [
        "Offset of field: CUpti_ActivityDevice3::maxRegistersPerMultiprocessor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, maxRegistersPerMultiprocessor)
        - 64usize];
    [
        "Offset of field: CUpti_ActivityDevice3::maxRegistersPerBlock",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, maxRegistersPerBlock) - 68usize];
    [
        "Offset of field: CUpti_ActivityDevice3::maxSharedMemoryPerBlock",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, maxSharedMemoryPerBlock) - 72usize];
    [
        "Offset of field: CUpti_ActivityDevice3::maxThreadsPerBlock",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, maxThreadsPerBlock) - 76usize];
    [
        "Offset of field: CUpti_ActivityDevice3::maxBlockDimX",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, maxBlockDimX) - 80usize];
    [
        "Offset of field: CUpti_ActivityDevice3::maxBlockDimY",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, maxBlockDimY) - 84usize];
    [
        "Offset of field: CUpti_ActivityDevice3::maxBlockDimZ",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, maxBlockDimZ) - 88usize];
    [
        "Offset of field: CUpti_ActivityDevice3::maxGridDimX",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, maxGridDimX) - 92usize];
    [
        "Offset of field: CUpti_ActivityDevice3::maxGridDimY",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, maxGridDimY) - 96usize];
    [
        "Offset of field: CUpti_ActivityDevice3::maxGridDimZ",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, maxGridDimZ) - 100usize];
    [
        "Offset of field: CUpti_ActivityDevice3::computeCapabilityMajor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, computeCapabilityMajor) - 104usize];
    [
        "Offset of field: CUpti_ActivityDevice3::computeCapabilityMinor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, computeCapabilityMinor) - 108usize];
    [
        "Offset of field: CUpti_ActivityDevice3::id",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, id) - 112usize];
    [
        "Offset of field: CUpti_ActivityDevice3::eccEnabled",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, eccEnabled) - 116usize];
    [
        "Offset of field: CUpti_ActivityDevice3::uuid",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, uuid) - 120usize];
    [
        "Offset of field: CUpti_ActivityDevice3::name",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, name) - 136usize];
    [
        "Offset of field: CUpti_ActivityDevice3::isCudaVisible",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, isCudaVisible) - 144usize];
    [
        "Offset of field: CUpti_ActivityDevice3::reserved",
    ][::std::mem::offset_of!(CUpti_ActivityDevice3, reserved) - 145usize];
};
impl Default for CUpti_ActivityDevice3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for a device. (CUDA 11.6 onwards)

 This activity record represents information about a GPU device
 (CUPTI_ACTIVITY_KIND_DEVICE).
 Device activity is now reported using the
 CUpti_ActivityDevice5 activity record.*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityDevice4 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_DEVICE.
    pub kind: CUpti_ActivityKind,
    /// The flags associated with the device. \see CUpti_ActivityFlag
    pub flags: CUpti_ActivityFlag,
    /** The global memory bandwidth available on the device, in
 kBytes/sec.*/
    pub globalMemoryBandwidth: u64,
    /// The amount of global memory on the device, in bytes.
    pub globalMemorySize: u64,
    /// The amount of constant memory on the device, in bytes.
    pub constantMemorySize: u32,
    /// The size of the L2 cache on the device, in bytes.
    pub l2CacheSize: u32,
    /// The number of threads per warp on the device.
    pub numThreadsPerWarp: u32,
    /// The core clock rate of the device, in kHz.
    pub coreClockRate: u32,
    /// Number of memory copy engines on the device.
    pub numMemcpyEngines: u32,
    /// Number of multiprocessors on the device.
    pub numMultiprocessors: u32,
    /** The maximum "instructions per cycle" possible on each device
 multiprocessor.*/
    pub maxIPC: u32,
    /** Maximum number of warps that can be present on a multiprocessor
 at any given time.*/
    pub maxWarpsPerMultiprocessor: u32,
    /** Maximum number of blocks that can be present on a multiprocessor
 at any given time.*/
    pub maxBlocksPerMultiprocessor: u32,
    /// Maximum amount of shared memory available per multiprocessor, in bytes.
    pub maxSharedMemoryPerMultiprocessor: u32,
    /// Maximum number of 32-bit registers available per multiprocessor.
    pub maxRegistersPerMultiprocessor: u32,
    /// Maximum number of registers that can be allocated to a block.
    pub maxRegistersPerBlock: u32,
    /** Maximum amount of shared memory that can be assigned to a block,
 in bytes.*/
    pub maxSharedMemoryPerBlock: u32,
    /// Maximum number of threads allowed in a block.
    pub maxThreadsPerBlock: u32,
    /// Maximum allowed X dimension for a block.
    pub maxBlockDimX: u32,
    /// Maximum allowed Y dimension for a block.
    pub maxBlockDimY: u32,
    /// Maximum allowed Z dimension for a block.
    pub maxBlockDimZ: u32,
    /// Maximum allowed X dimension for a grid.
    pub maxGridDimX: u32,
    /// Maximum allowed Y dimension for a grid.
    pub maxGridDimY: u32,
    /// Maximum allowed Z dimension for a grid.
    pub maxGridDimZ: u32,
    /// Compute capability for the device, major number.
    pub computeCapabilityMajor: u32,
    /// Compute capability for the device, minor number.
    pub computeCapabilityMinor: u32,
    /// The device ID.
    pub id: u32,
    /// ECC enabled flag for device
    pub eccEnabled: u32,
    /** The device UUID. This value is the globally unique immutable
 alphanumeric identifier of the device.*/
    pub uuid: CUuuid,
    /** The device name. This name is shared across all activity records
 representing instances of the device, and so should not be
 modified.*/
    pub name: *const ::std::os::raw::c_char,
    /** Flag to indicate whether the device is visible to CUDA. Users can
 set the device visibility using CUDA_VISIBLE_DEVICES environment*/
    pub isCudaVisible: u8,
    /// MIG enabled flag for device
    pub isMigEnabled: u8,
    pub reserved: [u8; 6usize],
    /** GPU Instance id for MIG enabled devices.
 If mig mode is disabled value is set to UINT32_MAX*/
    pub gpuInstanceId: u32,
    /** Compute Instance id for MIG enabled devices.
 If mig mode is disabled value is set to UINT32_MAX*/
    pub computeInstanceId: u32,
    /** The MIG UUID. This value is the globally unique immutable
 alphanumeric identifier of the device.*/
    pub migUuid: CUuuid,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityDevice4",
    ][::std::mem::size_of::<CUpti_ActivityDevice4>() - 176usize];
    [
        "Alignment of CUpti_ActivityDevice4",
    ][::std::mem::align_of::<CUpti_ActivityDevice4>() - 8usize];
    [
        "Offset of field: CUpti_ActivityDevice4::kind",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityDevice4::flags",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, flags) - 4usize];
    [
        "Offset of field: CUpti_ActivityDevice4::globalMemoryBandwidth",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, globalMemoryBandwidth) - 8usize];
    [
        "Offset of field: CUpti_ActivityDevice4::globalMemorySize",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, globalMemorySize) - 16usize];
    [
        "Offset of field: CUpti_ActivityDevice4::constantMemorySize",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, constantMemorySize) - 24usize];
    [
        "Offset of field: CUpti_ActivityDevice4::l2CacheSize",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, l2CacheSize) - 28usize];
    [
        "Offset of field: CUpti_ActivityDevice4::numThreadsPerWarp",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, numThreadsPerWarp) - 32usize];
    [
        "Offset of field: CUpti_ActivityDevice4::coreClockRate",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, coreClockRate) - 36usize];
    [
        "Offset of field: CUpti_ActivityDevice4::numMemcpyEngines",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, numMemcpyEngines) - 40usize];
    [
        "Offset of field: CUpti_ActivityDevice4::numMultiprocessors",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, numMultiprocessors) - 44usize];
    [
        "Offset of field: CUpti_ActivityDevice4::maxIPC",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, maxIPC) - 48usize];
    [
        "Offset of field: CUpti_ActivityDevice4::maxWarpsPerMultiprocessor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, maxWarpsPerMultiprocessor)
        - 52usize];
    [
        "Offset of field: CUpti_ActivityDevice4::maxBlocksPerMultiprocessor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, maxBlocksPerMultiprocessor)
        - 56usize];
    [
        "Offset of field: CUpti_ActivityDevice4::maxSharedMemoryPerMultiprocessor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, maxSharedMemoryPerMultiprocessor)
        - 60usize];
    [
        "Offset of field: CUpti_ActivityDevice4::maxRegistersPerMultiprocessor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, maxRegistersPerMultiprocessor)
        - 64usize];
    [
        "Offset of field: CUpti_ActivityDevice4::maxRegistersPerBlock",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, maxRegistersPerBlock) - 68usize];
    [
        "Offset of field: CUpti_ActivityDevice4::maxSharedMemoryPerBlock",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, maxSharedMemoryPerBlock) - 72usize];
    [
        "Offset of field: CUpti_ActivityDevice4::maxThreadsPerBlock",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, maxThreadsPerBlock) - 76usize];
    [
        "Offset of field: CUpti_ActivityDevice4::maxBlockDimX",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, maxBlockDimX) - 80usize];
    [
        "Offset of field: CUpti_ActivityDevice4::maxBlockDimY",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, maxBlockDimY) - 84usize];
    [
        "Offset of field: CUpti_ActivityDevice4::maxBlockDimZ",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, maxBlockDimZ) - 88usize];
    [
        "Offset of field: CUpti_ActivityDevice4::maxGridDimX",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, maxGridDimX) - 92usize];
    [
        "Offset of field: CUpti_ActivityDevice4::maxGridDimY",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, maxGridDimY) - 96usize];
    [
        "Offset of field: CUpti_ActivityDevice4::maxGridDimZ",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, maxGridDimZ) - 100usize];
    [
        "Offset of field: CUpti_ActivityDevice4::computeCapabilityMajor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, computeCapabilityMajor) - 104usize];
    [
        "Offset of field: CUpti_ActivityDevice4::computeCapabilityMinor",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, computeCapabilityMinor) - 108usize];
    [
        "Offset of field: CUpti_ActivityDevice4::id",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, id) - 112usize];
    [
        "Offset of field: CUpti_ActivityDevice4::eccEnabled",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, eccEnabled) - 116usize];
    [
        "Offset of field: CUpti_ActivityDevice4::uuid",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, uuid) - 120usize];
    [
        "Offset of field: CUpti_ActivityDevice4::name",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, name) - 136usize];
    [
        "Offset of field: CUpti_ActivityDevice4::isCudaVisible",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, isCudaVisible) - 144usize];
    [
        "Offset of field: CUpti_ActivityDevice4::isMigEnabled",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, isMigEnabled) - 145usize];
    [
        "Offset of field: CUpti_ActivityDevice4::reserved",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, reserved) - 146usize];
    [
        "Offset of field: CUpti_ActivityDevice4::gpuInstanceId",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, gpuInstanceId) - 152usize];
    [
        "Offset of field: CUpti_ActivityDevice4::computeInstanceId",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, computeInstanceId) - 156usize];
    [
        "Offset of field: CUpti_ActivityDevice4::migUuid",
    ][::std::mem::offset_of!(CUpti_ActivityDevice4, migUuid) - 160usize];
};
impl Default for CUpti_ActivityDevice4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for kernel. (deprecated)

 This activity record represents a kernel execution
 (CUPTI_ACTIVITY_KIND_KERNEL and
 CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL) but is no longer generated
 by CUPTI. Kernel activities are now reported using the
 CUpti_ActivityKernel9 activity record.*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityKernel {
    /** The activity record kind, must be CUPTI_ACTIVITY_KIND_KERNEL
 or CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL.*/
    pub kind: CUpti_ActivityKind,
    /** The cache configuration requested by the kernel. The value is one
 of the CUfunc_cache enumeration values from cuda.h.*/
    pub cacheConfigRequested: u8,
    /** The cache configuration used for the kernel. The value is one of
 the CUfunc_cache enumeration values from cuda.h.*/
    pub cacheConfigExecuted: u8,
    /** The number of registers required for each thread executing the
 kernel.*/
    pub registersPerThread: u16,
    /** The start timestamp for the kernel execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the kernel.*/
    pub start: u64,
    /** The end timestamp for the kernel execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the kernel.*/
    pub end: u64,
    /// The ID of the device where the kernel is executing.
    pub deviceId: u32,
    /// The ID of the context where the kernel is executing.
    pub contextId: u32,
    /// The ID of the stream where the kernel is executing.
    pub streamId: u32,
    /// The X-dimension grid size for the kernel.
    pub gridX: i32,
    /// The Y-dimension grid size for the kernel.
    pub gridY: i32,
    /// The Z-dimension grid size for the kernel.
    pub gridZ: i32,
    /// The X-dimension block size for the kernel.
    pub blockX: i32,
    /// The Y-dimension block size for the kernel.
    pub blockY: i32,
    /// The Z-dimension grid size for the kernel.
    pub blockZ: i32,
    /// The static shared memory allocated for the kernel, in bytes.
    pub staticSharedMemory: i32,
    /// The dynamic shared memory reserved for the kernel, in bytes.
    pub dynamicSharedMemory: i32,
    /// The amount of local memory reserved for each thread, in bytes.
    pub localMemoryPerThread: u32,
    /** The total amount of local memory reserved for the kernel, in
 bytes.*/
    pub localMemoryTotal: u32,
    /** The correlation ID of the kernel. Each kernel execution is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver API activity record that launched
 the kernel.*/
    pub correlationId: u32,
    /** The runtime correlation ID of the kernel. Each kernel execution
 is assigned a unique runtime correlation ID that is identical to
 the correlation ID in the runtime API activity record that
 launched the kernel.*/
    pub runtimeCorrelationId: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
    /** The name of the kernel. This name is shared across all activity
 records representing the same kernel, and so should not be
 modified.*/
    pub name: *const ::std::os::raw::c_char,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel",
    ][::std::mem::size_of::<CUpti_ActivityKernel>() - 104usize];
    [
        "Alignment of CUpti_ActivityKernel",
    ][::std::mem::align_of::<CUpti_ActivityKernel>() - 8usize];
    [
        "Offset of field: CUpti_ActivityKernel::kind",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityKernel::cacheConfigRequested",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, cacheConfigRequested) - 4usize];
    [
        "Offset of field: CUpti_ActivityKernel::cacheConfigExecuted",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, cacheConfigExecuted) - 5usize];
    [
        "Offset of field: CUpti_ActivityKernel::registersPerThread",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, registersPerThread) - 6usize];
    [
        "Offset of field: CUpti_ActivityKernel::start",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, start) - 8usize];
    [
        "Offset of field: CUpti_ActivityKernel::end",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, end) - 16usize];
    [
        "Offset of field: CUpti_ActivityKernel::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, deviceId) - 24usize];
    [
        "Offset of field: CUpti_ActivityKernel::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, contextId) - 28usize];
    [
        "Offset of field: CUpti_ActivityKernel::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, streamId) - 32usize];
    [
        "Offset of field: CUpti_ActivityKernel::gridX",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, gridX) - 36usize];
    [
        "Offset of field: CUpti_ActivityKernel::gridY",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, gridY) - 40usize];
    [
        "Offset of field: CUpti_ActivityKernel::gridZ",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, gridZ) - 44usize];
    [
        "Offset of field: CUpti_ActivityKernel::blockX",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, blockX) - 48usize];
    [
        "Offset of field: CUpti_ActivityKernel::blockY",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, blockY) - 52usize];
    [
        "Offset of field: CUpti_ActivityKernel::blockZ",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, blockZ) - 56usize];
    [
        "Offset of field: CUpti_ActivityKernel::staticSharedMemory",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, staticSharedMemory) - 60usize];
    [
        "Offset of field: CUpti_ActivityKernel::dynamicSharedMemory",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, dynamicSharedMemory) - 64usize];
    [
        "Offset of field: CUpti_ActivityKernel::localMemoryPerThread",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, localMemoryPerThread) - 68usize];
    [
        "Offset of field: CUpti_ActivityKernel::localMemoryTotal",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, localMemoryTotal) - 72usize];
    [
        "Offset of field: CUpti_ActivityKernel::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, correlationId) - 76usize];
    [
        "Offset of field: CUpti_ActivityKernel::runtimeCorrelationId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, runtimeCorrelationId) - 80usize];
    [
        "Offset of field: CUpti_ActivityKernel::pad",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, pad) - 84usize];
    [
        "Offset of field: CUpti_ActivityKernel::name",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, name) - 88usize];
    [
        "Offset of field: CUpti_ActivityKernel::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityKernel, reserved0) - 96usize];
};
impl Default for CUpti_ActivityKernel {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for kernel. (deprecated)

 This activity record represents a kernel execution
 (CUPTI_ACTIVITY_KIND_KERNEL and
 CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL) but is no longer generated
 by CUPTI. Kernel activities are now reported using the
 CUpti_ActivityKernel9 activity record.*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityKernel2 {
    /** The activity record kind, must be CUPTI_ACTIVITY_KIND_KERNEL or
 CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL.*/
    pub kind: CUpti_ActivityKind,
    pub cacheConfig: CUpti_ActivityKernel2__bindgen_ty_1,
    /** The shared memory configuration used for the kernel. The value is one of
 the CUsharedconfig enumeration values from cuda.h.*/
    pub sharedMemoryConfig: u8,
    /** The number of registers required for each thread executing the
 kernel.*/
    pub registersPerThread: u16,
    /** The start timestamp for the kernel execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the kernel.*/
    pub start: u64,
    /** The end timestamp for the kernel execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the kernel.*/
    pub end: u64,
    /** The completed timestamp for the kernel execution, in ns.  It
 represents the completion of all it's child kernels and the
 kernel itself. A value of CUPTI_TIMESTAMP_UNKNOWN indicates that
 the completion time is unknown.*/
    pub completed: u64,
    /// The ID of the device where the kernel is executing.
    pub deviceId: u32,
    /// The ID of the context where the kernel is executing.
    pub contextId: u32,
    /// The ID of the stream where the kernel is executing.
    pub streamId: u32,
    /// The X-dimension grid size for the kernel.
    pub gridX: i32,
    /// The Y-dimension grid size for the kernel.
    pub gridY: i32,
    /// The Z-dimension grid size for the kernel.
    pub gridZ: i32,
    /// The X-dimension block size for the kernel.
    pub blockX: i32,
    /// The Y-dimension block size for the kernel.
    pub blockY: i32,
    /// The Z-dimension grid size for the kernel.
    pub blockZ: i32,
    /// The static shared memory allocated for the kernel, in bytes.
    pub staticSharedMemory: i32,
    /// The dynamic shared memory reserved for the kernel, in bytes.
    pub dynamicSharedMemory: i32,
    /// The amount of local memory reserved for each thread, in bytes.
    pub localMemoryPerThread: u32,
    /** The total amount of local memory reserved for the kernel, in
 bytes.*/
    pub localMemoryTotal: u32,
    /** The correlation ID of the kernel. Each kernel execution is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver or runtime API activity record that
 launched the kernel.*/
    pub correlationId: u32,
    /** The grid ID of the kernel. Each kernel is assigned a unique
 grid ID at runtime.*/
    pub gridId: i64,
    /** The name of the kernel. This name is shared across all activity
 records representing the same kernel, and so should not be
 modified.*/
    pub name: *const ::std::os::raw::c_char,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityKernel2__bindgen_ty_1 {
    pub both: u8,
    pub config: CUpti_ActivityKernel2__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityKernel2__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel2__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityKernel2__bindgen_ty_1__bindgen_ty_1>()
        - 1usize];
    [
        "Alignment of CUpti_ActivityKernel2__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityKernel2__bindgen_ty_1__bindgen_ty_1>()
        - 1usize];
};
impl CUpti_ActivityKernel2__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn requested(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_requested(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn requested_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 1usize],
                >>::raw_get(::std::ptr::addr_of!((*this)._bitfield_1), 0usize, 4u8) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_requested_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 1usize],
            >>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn executed(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_executed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn executed_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 1usize],
                >>::raw_get(::std::ptr::addr_of!((*this)._bitfield_1), 4usize, 4u8) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_executed_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 1usize],
            >>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        requested: u8,
        executed: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit
            .set(
                0usize,
                4u8,
                {
                    let requested: u8 = unsafe { ::std::mem::transmute(requested) };
                    requested as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                4usize,
                4u8,
                {
                    let executed: u8 = unsafe { ::std::mem::transmute(executed) };
                    executed as u64
                },
            );
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel2__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityKernel2__bindgen_ty_1>() - 1usize];
    [
        "Alignment of CUpti_ActivityKernel2__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityKernel2__bindgen_ty_1>() - 1usize];
    [
        "Offset of field: CUpti_ActivityKernel2__bindgen_ty_1::both",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2__bindgen_ty_1, both) - 0usize];
    [
        "Offset of field: CUpti_ActivityKernel2__bindgen_ty_1::config",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2__bindgen_ty_1, config) - 0usize];
};
impl Default for CUpti_ActivityKernel2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel2__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityKernel2__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel2",
    ][::std::mem::size_of::<CUpti_ActivityKernel2>() - 112usize];
    [
        "Alignment of CUpti_ActivityKernel2",
    ][::std::mem::align_of::<CUpti_ActivityKernel2>() - 8usize];
    [
        "Offset of field: CUpti_ActivityKernel2::kind",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityKernel2::cacheConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, cacheConfig) - 4usize];
    [
        "Offset of field: CUpti_ActivityKernel2::sharedMemoryConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, sharedMemoryConfig) - 5usize];
    [
        "Offset of field: CUpti_ActivityKernel2::registersPerThread",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, registersPerThread) - 6usize];
    [
        "Offset of field: CUpti_ActivityKernel2::start",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, start) - 8usize];
    [
        "Offset of field: CUpti_ActivityKernel2::end",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, end) - 16usize];
    [
        "Offset of field: CUpti_ActivityKernel2::completed",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, completed) - 24usize];
    [
        "Offset of field: CUpti_ActivityKernel2::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, deviceId) - 32usize];
    [
        "Offset of field: CUpti_ActivityKernel2::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, contextId) - 36usize];
    [
        "Offset of field: CUpti_ActivityKernel2::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, streamId) - 40usize];
    [
        "Offset of field: CUpti_ActivityKernel2::gridX",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, gridX) - 44usize];
    [
        "Offset of field: CUpti_ActivityKernel2::gridY",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, gridY) - 48usize];
    [
        "Offset of field: CUpti_ActivityKernel2::gridZ",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, gridZ) - 52usize];
    [
        "Offset of field: CUpti_ActivityKernel2::blockX",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, blockX) - 56usize];
    [
        "Offset of field: CUpti_ActivityKernel2::blockY",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, blockY) - 60usize];
    [
        "Offset of field: CUpti_ActivityKernel2::blockZ",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, blockZ) - 64usize];
    [
        "Offset of field: CUpti_ActivityKernel2::staticSharedMemory",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, staticSharedMemory) - 68usize];
    [
        "Offset of field: CUpti_ActivityKernel2::dynamicSharedMemory",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, dynamicSharedMemory) - 72usize];
    [
        "Offset of field: CUpti_ActivityKernel2::localMemoryPerThread",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, localMemoryPerThread) - 76usize];
    [
        "Offset of field: CUpti_ActivityKernel2::localMemoryTotal",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, localMemoryTotal) - 80usize];
    [
        "Offset of field: CUpti_ActivityKernel2::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, correlationId) - 84usize];
    [
        "Offset of field: CUpti_ActivityKernel2::gridId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, gridId) - 88usize];
    [
        "Offset of field: CUpti_ActivityKernel2::name",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, name) - 96usize];
    [
        "Offset of field: CUpti_ActivityKernel2::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityKernel2, reserved0) - 104usize];
};
impl Default for CUpti_ActivityKernel2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityKernel2 {{ kind: {:?}, cacheConfig: {:?}, name: {:?}, reserved0: {:?} }}",
            self.kind,
            self.cacheConfig,
            self.name,
            self.reserved0,
        )
    }
}
/** \brief The activity record for a kernel (CUDA 6.5(with sm_52 support) onwards).
 (deprecated in CUDA 9.0)

 This activity record represents a kernel execution
 (CUPTI_ACTIVITY_KIND_KERNEL and
 CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL).
 Kernel activities are now reported using the CUpti_ActivityKernel9 activity
 record.*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityKernel3 {
    /** The activity record kind, must be CUPTI_ACTIVITY_KIND_KERNEL or
 CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL.*/
    pub kind: CUpti_ActivityKind,
    pub cacheConfig: CUpti_ActivityKernel3__bindgen_ty_1,
    /** The shared memory configuration used for the kernel. The value is one of
 the CUsharedconfig enumeration values from cuda.h.*/
    pub sharedMemoryConfig: u8,
    /** The number of registers required for each thread executing the
 kernel.*/
    pub registersPerThread: u16,
    /** The partitioned global caching requested for the kernel. Partitioned
 global caching is required to enable caching on certain chips, such as
 devices with compute capability 5.2.*/
    pub partitionedGlobalCacheRequested: CUpti_ActivityPartitionedGlobalCacheConfig,
    /** The partitioned global caching executed for the kernel. Partitioned
 global caching is required to enable caching on certain chips, such as
 devices with compute capability 5.2. Partitioned global caching can be
 automatically disabled if the occupancy requirement of the launch cannot
 support caching.*/
    pub partitionedGlobalCacheExecuted: CUpti_ActivityPartitionedGlobalCacheConfig,
    /** The start timestamp for the kernel execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the kernel.*/
    pub start: u64,
    /** The end timestamp for the kernel execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the kernel.*/
    pub end: u64,
    /** The completed timestamp for the kernel execution, in ns.  It
 represents the completion of all it's child kernels and the
 kernel itself. A value of CUPTI_TIMESTAMP_UNKNOWN indicates that
 the completion time is unknown.*/
    pub completed: u64,
    /// The ID of the device where the kernel is executing.
    pub deviceId: u32,
    /// The ID of the context where the kernel is executing.
    pub contextId: u32,
    /// The ID of the stream where the kernel is executing.
    pub streamId: u32,
    /// The X-dimension grid size for the kernel.
    pub gridX: i32,
    /// The Y-dimension grid size for the kernel.
    pub gridY: i32,
    /// The Z-dimension grid size for the kernel.
    pub gridZ: i32,
    /// The X-dimension block size for the kernel.
    pub blockX: i32,
    /// The Y-dimension block size for the kernel.
    pub blockY: i32,
    /// The Z-dimension grid size for the kernel.
    pub blockZ: i32,
    /// The static shared memory allocated for the kernel, in bytes.
    pub staticSharedMemory: i32,
    /// The dynamic shared memory reserved for the kernel, in bytes.
    pub dynamicSharedMemory: i32,
    /// The amount of local memory reserved for each thread, in bytes.
    pub localMemoryPerThread: u32,
    /** The total amount of local memory reserved for the kernel, in
 bytes.*/
    pub localMemoryTotal: u32,
    /** The correlation ID of the kernel. Each kernel execution is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver or runtime API activity record that
 launched the kernel.*/
    pub correlationId: u32,
    /** The grid ID of the kernel. Each kernel is assigned a unique
 grid ID at runtime.*/
    pub gridId: i64,
    /** The name of the kernel. This name is shared across all activity
 records representing the same kernel, and so should not be
 modified.*/
    pub name: *const ::std::os::raw::c_char,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityKernel3__bindgen_ty_1 {
    pub both: u8,
    pub config: CUpti_ActivityKernel3__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityKernel3__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel3__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityKernel3__bindgen_ty_1__bindgen_ty_1>()
        - 1usize];
    [
        "Alignment of CUpti_ActivityKernel3__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityKernel3__bindgen_ty_1__bindgen_ty_1>()
        - 1usize];
};
impl CUpti_ActivityKernel3__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn requested(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_requested(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn requested_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 1usize],
                >>::raw_get(::std::ptr::addr_of!((*this)._bitfield_1), 0usize, 4u8) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_requested_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 1usize],
            >>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn executed(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_executed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn executed_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 1usize],
                >>::raw_get(::std::ptr::addr_of!((*this)._bitfield_1), 4usize, 4u8) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_executed_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 1usize],
            >>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        requested: u8,
        executed: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit
            .set(
                0usize,
                4u8,
                {
                    let requested: u8 = unsafe { ::std::mem::transmute(requested) };
                    requested as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                4usize,
                4u8,
                {
                    let executed: u8 = unsafe { ::std::mem::transmute(executed) };
                    executed as u64
                },
            );
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel3__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityKernel3__bindgen_ty_1>() - 1usize];
    [
        "Alignment of CUpti_ActivityKernel3__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityKernel3__bindgen_ty_1>() - 1usize];
    [
        "Offset of field: CUpti_ActivityKernel3__bindgen_ty_1::both",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3__bindgen_ty_1, both) - 0usize];
    [
        "Offset of field: CUpti_ActivityKernel3__bindgen_ty_1::config",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3__bindgen_ty_1, config) - 0usize];
};
impl Default for CUpti_ActivityKernel3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel3__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityKernel3__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel3",
    ][::std::mem::size_of::<CUpti_ActivityKernel3>() - 120usize];
    [
        "Alignment of CUpti_ActivityKernel3",
    ][::std::mem::align_of::<CUpti_ActivityKernel3>() - 8usize];
    [
        "Offset of field: CUpti_ActivityKernel3::kind",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityKernel3::cacheConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, cacheConfig) - 4usize];
    [
        "Offset of field: CUpti_ActivityKernel3::sharedMemoryConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, sharedMemoryConfig) - 5usize];
    [
        "Offset of field: CUpti_ActivityKernel3::registersPerThread",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, registersPerThread) - 6usize];
    [
        "Offset of field: CUpti_ActivityKernel3::partitionedGlobalCacheRequested",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, partitionedGlobalCacheRequested)
        - 8usize];
    [
        "Offset of field: CUpti_ActivityKernel3::partitionedGlobalCacheExecuted",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, partitionedGlobalCacheExecuted)
        - 12usize];
    [
        "Offset of field: CUpti_ActivityKernel3::start",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityKernel3::end",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityKernel3::completed",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, completed) - 32usize];
    [
        "Offset of field: CUpti_ActivityKernel3::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, deviceId) - 40usize];
    [
        "Offset of field: CUpti_ActivityKernel3::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, contextId) - 44usize];
    [
        "Offset of field: CUpti_ActivityKernel3::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, streamId) - 48usize];
    [
        "Offset of field: CUpti_ActivityKernel3::gridX",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, gridX) - 52usize];
    [
        "Offset of field: CUpti_ActivityKernel3::gridY",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, gridY) - 56usize];
    [
        "Offset of field: CUpti_ActivityKernel3::gridZ",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, gridZ) - 60usize];
    [
        "Offset of field: CUpti_ActivityKernel3::blockX",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, blockX) - 64usize];
    [
        "Offset of field: CUpti_ActivityKernel3::blockY",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, blockY) - 68usize];
    [
        "Offset of field: CUpti_ActivityKernel3::blockZ",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, blockZ) - 72usize];
    [
        "Offset of field: CUpti_ActivityKernel3::staticSharedMemory",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, staticSharedMemory) - 76usize];
    [
        "Offset of field: CUpti_ActivityKernel3::dynamicSharedMemory",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, dynamicSharedMemory) - 80usize];
    [
        "Offset of field: CUpti_ActivityKernel3::localMemoryPerThread",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, localMemoryPerThread) - 84usize];
    [
        "Offset of field: CUpti_ActivityKernel3::localMemoryTotal",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, localMemoryTotal) - 88usize];
    [
        "Offset of field: CUpti_ActivityKernel3::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, correlationId) - 92usize];
    [
        "Offset of field: CUpti_ActivityKernel3::gridId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, gridId) - 96usize];
    [
        "Offset of field: CUpti_ActivityKernel3::name",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, name) - 104usize];
    [
        "Offset of field: CUpti_ActivityKernel3::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityKernel3, reserved0) - 112usize];
};
impl Default for CUpti_ActivityKernel3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityKernel3 {{ kind: {:?}, cacheConfig: {:?}, partitionedGlobalCacheRequested: {:?}, partitionedGlobalCacheExecuted: {:?}, name: {:?}, reserved0: {:?} }}",
            self.kind,
            self.cacheConfig,
            self.partitionedGlobalCacheRequested,
            self.partitionedGlobalCacheExecuted,
            self.name,
            self.reserved0,
        )
    }
}
/** \brief The activity record for a kernel (CUDA 9.0(with sm_70 support) onwards).
 (deprecated in CUDA 11.0)

 This activity record represents a kernel execution
 (CUPTI_ACTIVITY_KIND_KERNEL and
 CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL).
 Kernel activities are now reported using the CUpti_ActivityKernel9 activity
 record.*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityKernel4 {
    /** The activity record kind, must be CUPTI_ACTIVITY_KIND_KERNEL or
 CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL.*/
    pub kind: CUpti_ActivityKind,
    pub cacheConfig: CUpti_ActivityKernel4__bindgen_ty_1,
    /** The shared memory configuration used for the kernel. The value is one of
 the CUsharedconfig enumeration values from cuda.h.*/
    pub sharedMemoryConfig: u8,
    /** The number of registers required for each thread executing the
 kernel.*/
    pub registersPerThread: u16,
    /** The partitioned global caching requested for the kernel. Partitioned
 global caching is required to enable caching on certain chips, such as
 devices with compute capability 5.2.*/
    pub partitionedGlobalCacheRequested: CUpti_ActivityPartitionedGlobalCacheConfig,
    /** The partitioned global caching executed for the kernel. Partitioned
 global caching is required to enable caching on certain chips, such as
 devices with compute capability 5.2. Partitioned global caching can be
 automatically disabled if the occupancy requirement of the launch cannot
 support caching.*/
    pub partitionedGlobalCacheExecuted: CUpti_ActivityPartitionedGlobalCacheConfig,
    /** The start timestamp for the kernel execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the kernel.*/
    pub start: u64,
    /** The end timestamp for the kernel execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the kernel.*/
    pub end: u64,
    /** The completed timestamp for the kernel execution, in ns.  It
 represents the completion of all it's child kernels and the
 kernel itself. A value of CUPTI_TIMESTAMP_UNKNOWN indicates that
 the completion time is unknown.*/
    pub completed: u64,
    /// The ID of the device where the kernel is executing.
    pub deviceId: u32,
    /// The ID of the context where the kernel is executing.
    pub contextId: u32,
    /// The ID of the stream where the kernel is executing.
    pub streamId: u32,
    /// The X-dimension grid size for the kernel.
    pub gridX: i32,
    /// The Y-dimension grid size for the kernel.
    pub gridY: i32,
    /// The Z-dimension grid size for the kernel.
    pub gridZ: i32,
    /// The X-dimension block size for the kernel.
    pub blockX: i32,
    /// The Y-dimension block size for the kernel.
    pub blockY: i32,
    /// The Z-dimension grid size for the kernel.
    pub blockZ: i32,
    /// The static shared memory allocated for the kernel, in bytes.
    pub staticSharedMemory: i32,
    /// The dynamic shared memory reserved for the kernel, in bytes.
    pub dynamicSharedMemory: i32,
    /// The amount of local memory reserved for each thread, in bytes.
    pub localMemoryPerThread: u32,
    /** The total amount of local memory reserved for the kernel, in
 bytes.*/
    pub localMemoryTotal: u32,
    /** The correlation ID of the kernel. Each kernel execution is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver or runtime API activity record that
 launched the kernel.*/
    pub correlationId: u32,
    /** The grid ID of the kernel. Each kernel is assigned a unique
 grid ID at runtime.*/
    pub gridId: i64,
    /** The name of the kernel. This name is shared across all activity
 records representing the same kernel, and so should not be
 modified.*/
    pub name: *const ::std::os::raw::c_char,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
    /** The timestamp when the kernel is queued up in the command buffer, in ns.
 A value of CUPTI_TIMESTAMP_UNKNOWN indicates that the queued time
 could not be collected for the kernel. This timestamp is not collected
 by default. Use API \ref cuptiActivityEnableLatencyTimestamps() to
 enable collection.

 Command buffer is a buffer written by CUDA driver to send commands
 like kernel launch, memory copy etc to the GPU. All launches of CUDA
 kernels are asynchronous with respect to the host, the host requests
 the launch by writing commands into the command buffer, then returns
 without checking the GPU's progress.*/
    pub queued: u64,
    /** The timestamp when the command buffer containing the kernel launch
 is submitted to the GPU, in ns. A value of CUPTI_TIMESTAMP_UNKNOWN
 indicates that the submitted time could not be collected for the kernel.
 This timestamp is not collected by default. Use API \ref
 cuptiActivityEnableLatencyTimestamps() to enable collection.*/
    pub submitted: u64,
    /** The indicates if the kernel was executed via a regular launch or via a
 single/multi device cooperative launch. \see CUpti_ActivityLaunchType*/
    pub launchType: u8,
    /** This indicates if CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT was
 updated for the kernel launch*/
    pub isSharedMemoryCarveoutRequested: u8,
    /** Shared memory carveout value requested for the function in percentage of
 the total resource. The value will be updated only if field
 isSharedMemoryCarveoutRequested is set.*/
    pub sharedMemoryCarveoutRequested: u8,
    /// Undefined. Reserved for internal use.
    pub padding: u8,
    /// Shared memory size set by the driver.
    pub sharedMemoryExecuted: u32,
}
/** For devices with compute capability 7.5+ cacheConfig values are not updated
 in case field isSharedMemoryCarveoutRequested is set*/
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityKernel4__bindgen_ty_1 {
    pub both: u8,
    pub config: CUpti_ActivityKernel4__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityKernel4__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel4__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityKernel4__bindgen_ty_1__bindgen_ty_1>()
        - 1usize];
    [
        "Alignment of CUpti_ActivityKernel4__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityKernel4__bindgen_ty_1__bindgen_ty_1>()
        - 1usize];
};
impl CUpti_ActivityKernel4__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn requested(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_requested(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn requested_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 1usize],
                >>::raw_get(::std::ptr::addr_of!((*this)._bitfield_1), 0usize, 4u8) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_requested_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 1usize],
            >>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn executed(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_executed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn executed_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 1usize],
                >>::raw_get(::std::ptr::addr_of!((*this)._bitfield_1), 4usize, 4u8) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_executed_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 1usize],
            >>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        requested: u8,
        executed: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit
            .set(
                0usize,
                4u8,
                {
                    let requested: u8 = unsafe { ::std::mem::transmute(requested) };
                    requested as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                4usize,
                4u8,
                {
                    let executed: u8 = unsafe { ::std::mem::transmute(executed) };
                    executed as u64
                },
            );
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel4__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityKernel4__bindgen_ty_1>() - 1usize];
    [
        "Alignment of CUpti_ActivityKernel4__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityKernel4__bindgen_ty_1>() - 1usize];
    [
        "Offset of field: CUpti_ActivityKernel4__bindgen_ty_1::both",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4__bindgen_ty_1, both) - 0usize];
    [
        "Offset of field: CUpti_ActivityKernel4__bindgen_ty_1::config",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4__bindgen_ty_1, config) - 0usize];
};
impl Default for CUpti_ActivityKernel4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel4__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityKernel4__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel4",
    ][::std::mem::size_of::<CUpti_ActivityKernel4>() - 144usize];
    [
        "Alignment of CUpti_ActivityKernel4",
    ][::std::mem::align_of::<CUpti_ActivityKernel4>() - 8usize];
    [
        "Offset of field: CUpti_ActivityKernel4::kind",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityKernel4::cacheConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, cacheConfig) - 4usize];
    [
        "Offset of field: CUpti_ActivityKernel4::sharedMemoryConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, sharedMemoryConfig) - 5usize];
    [
        "Offset of field: CUpti_ActivityKernel4::registersPerThread",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, registersPerThread) - 6usize];
    [
        "Offset of field: CUpti_ActivityKernel4::partitionedGlobalCacheRequested",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, partitionedGlobalCacheRequested)
        - 8usize];
    [
        "Offset of field: CUpti_ActivityKernel4::partitionedGlobalCacheExecuted",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, partitionedGlobalCacheExecuted)
        - 12usize];
    [
        "Offset of field: CUpti_ActivityKernel4::start",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityKernel4::end",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityKernel4::completed",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, completed) - 32usize];
    [
        "Offset of field: CUpti_ActivityKernel4::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, deviceId) - 40usize];
    [
        "Offset of field: CUpti_ActivityKernel4::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, contextId) - 44usize];
    [
        "Offset of field: CUpti_ActivityKernel4::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, streamId) - 48usize];
    [
        "Offset of field: CUpti_ActivityKernel4::gridX",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, gridX) - 52usize];
    [
        "Offset of field: CUpti_ActivityKernel4::gridY",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, gridY) - 56usize];
    [
        "Offset of field: CUpti_ActivityKernel4::gridZ",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, gridZ) - 60usize];
    [
        "Offset of field: CUpti_ActivityKernel4::blockX",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, blockX) - 64usize];
    [
        "Offset of field: CUpti_ActivityKernel4::blockY",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, blockY) - 68usize];
    [
        "Offset of field: CUpti_ActivityKernel4::blockZ",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, blockZ) - 72usize];
    [
        "Offset of field: CUpti_ActivityKernel4::staticSharedMemory",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, staticSharedMemory) - 76usize];
    [
        "Offset of field: CUpti_ActivityKernel4::dynamicSharedMemory",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, dynamicSharedMemory) - 80usize];
    [
        "Offset of field: CUpti_ActivityKernel4::localMemoryPerThread",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, localMemoryPerThread) - 84usize];
    [
        "Offset of field: CUpti_ActivityKernel4::localMemoryTotal",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, localMemoryTotal) - 88usize];
    [
        "Offset of field: CUpti_ActivityKernel4::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, correlationId) - 92usize];
    [
        "Offset of field: CUpti_ActivityKernel4::gridId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, gridId) - 96usize];
    [
        "Offset of field: CUpti_ActivityKernel4::name",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, name) - 104usize];
    [
        "Offset of field: CUpti_ActivityKernel4::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, reserved0) - 112usize];
    [
        "Offset of field: CUpti_ActivityKernel4::queued",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, queued) - 120usize];
    [
        "Offset of field: CUpti_ActivityKernel4::submitted",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, submitted) - 128usize];
    [
        "Offset of field: CUpti_ActivityKernel4::launchType",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, launchType) - 136usize];
    [
        "Offset of field: CUpti_ActivityKernel4::isSharedMemoryCarveoutRequested",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, isSharedMemoryCarveoutRequested)
        - 137usize];
    [
        "Offset of field: CUpti_ActivityKernel4::sharedMemoryCarveoutRequested",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, sharedMemoryCarveoutRequested)
        - 138usize];
    [
        "Offset of field: CUpti_ActivityKernel4::padding",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, padding) - 139usize];
    [
        "Offset of field: CUpti_ActivityKernel4::sharedMemoryExecuted",
    ][::std::mem::offset_of!(CUpti_ActivityKernel4, sharedMemoryExecuted) - 140usize];
};
impl Default for CUpti_ActivityKernel4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel4 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityKernel4 {{ kind: {:?}, cacheConfig: {:?}, partitionedGlobalCacheRequested: {:?}, partitionedGlobalCacheExecuted: {:?}, name: {:?}, reserved0: {:?} }}",
            self.kind,
            self.cacheConfig,
            self.partitionedGlobalCacheRequested,
            self.partitionedGlobalCacheExecuted,
            self.name,
            self.reserved0,
        )
    }
}
/** \brief The activity record for a kernel (CUDA 11.0(with sm_80 support) onwards).
 (deprecated in CUDA 11.2)
 This activity record represents a kernel execution
 (CUPTI_ACTIVITY_KIND_KERNEL and
 CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL) but is no longer generated
 by CUPTI. Kernel activities are now reported using the
 CUpti_ActivityKernel9 activity record.*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityKernel5 {
    /** The activity record kind, must be CUPTI_ACTIVITY_KIND_KERNEL or
 CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL.*/
    pub kind: CUpti_ActivityKind,
    pub cacheConfig: CUpti_ActivityKernel5__bindgen_ty_1,
    /** The shared memory configuration used for the kernel. The value is one of
 the CUsharedconfig enumeration values from cuda.h.*/
    pub sharedMemoryConfig: u8,
    /** The number of registers required for each thread executing the
 kernel.*/
    pub registersPerThread: u16,
    /** The partitioned global caching requested for the kernel. Partitioned
 global caching is required to enable caching on certain chips, such as
 devices with compute capability 5.2.*/
    pub partitionedGlobalCacheRequested: CUpti_ActivityPartitionedGlobalCacheConfig,
    /** The partitioned global caching executed for the kernel. Partitioned
 global caching is required to enable caching on certain chips, such as
 devices with compute capability 5.2. Partitioned global caching can be
 automatically disabled if the occupancy requirement of the launch cannot
 support caching.*/
    pub partitionedGlobalCacheExecuted: CUpti_ActivityPartitionedGlobalCacheConfig,
    /** The start timestamp for the kernel execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the kernel.*/
    pub start: u64,
    /** The end timestamp for the kernel execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the kernel.*/
    pub end: u64,
    /** The completed timestamp for the kernel execution, in ns.  It
 represents the completion of all it's child kernels and the
 kernel itself. A value of CUPTI_TIMESTAMP_UNKNOWN indicates that
 the completion time is unknown.*/
    pub completed: u64,
    /// The ID of the device where the kernel is executing.
    pub deviceId: u32,
    /// The ID of the context where the kernel is executing.
    pub contextId: u32,
    /// The ID of the stream where the kernel is executing.
    pub streamId: u32,
    /// The X-dimension grid size for the kernel.
    pub gridX: i32,
    /// The Y-dimension grid size for the kernel.
    pub gridY: i32,
    /// The Z-dimension grid size for the kernel.
    pub gridZ: i32,
    /// The X-dimension block size for the kernel.
    pub blockX: i32,
    /// The Y-dimension block size for the kernel.
    pub blockY: i32,
    /// The Z-dimension grid size for the kernel.
    pub blockZ: i32,
    /// The static shared memory allocated for the kernel, in bytes.
    pub staticSharedMemory: i32,
    /// The dynamic shared memory reserved for the kernel, in bytes.
    pub dynamicSharedMemory: i32,
    /// The amount of local memory reserved for each thread, in bytes.
    pub localMemoryPerThread: u32,
    /** The total amount of local memory reserved for the kernel, in
 bytes.*/
    pub localMemoryTotal: u32,
    /** The correlation ID of the kernel. Each kernel execution is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver or runtime API activity record that
 launched the kernel.*/
    pub correlationId: u32,
    /** The grid ID of the kernel. Each kernel is assigned a unique
 grid ID at runtime.*/
    pub gridId: i64,
    /** The name of the kernel. This name is shared across all activity
 records representing the same kernel, and so should not be
 modified.*/
    pub name: *const ::std::os::raw::c_char,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
    /** The timestamp when the kernel is queued up in the command buffer, in ns.
 A value of CUPTI_TIMESTAMP_UNKNOWN indicates that the queued time
 could not be collected for the kernel. This timestamp is not collected
 by default. Use API \ref cuptiActivityEnableLatencyTimestamps() to
 enable collection.

 Command buffer is a buffer written by CUDA driver to send commands
 like kernel launch, memory copy etc to the GPU. All launches of CUDA
 kernels are asynchronous with respect to the host, the host requests
 the launch by writing commands into the command buffer, then returns
 without checking the GPU's progress.*/
    pub queued: u64,
    /** The timestamp when the command buffer containing the kernel launch
 is submitted to the GPU, in ns. A value of CUPTI_TIMESTAMP_UNKNOWN
 indicates that the submitted time could not be collected for the kernel.
 This timestamp is not collected by default. Use API \ref
 cuptiActivityEnableLatencyTimestamps() to enable collection.*/
    pub submitted: u64,
    /** The indicates if the kernel was executed via a regular launch or via a
 single/multi device cooperative launch. \see CUpti_ActivityLaunchType*/
    pub launchType: u8,
    /** This indicates if CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT was
 updated for the kernel launch*/
    pub isSharedMemoryCarveoutRequested: u8,
    /** Shared memory carveout value requested for the function in percentage of
 the total resource. The value will be updated only if field
 isSharedMemoryCarveoutRequested is set.*/
    pub sharedMemoryCarveoutRequested: u8,
    /// Undefined. Reserved for internal use.
    pub padding: u8,
    /// Shared memory size set by the driver.
    pub sharedMemoryExecuted: u32,
    /** The unique ID of the graph node that launched this kernel through graph launch APIs.
 This field will be 0 if the kernel is not launched through graph launch APIs.*/
    pub graphNodeId: u64,
    /** The shared memory limit config for the kernel. This field shows whether user has opted for a
 higher per block limit of dynamic shared memory.*/
    pub shmemLimitConfig: CUpti_FuncShmemLimitConfig,
    /** The unique ID of the graph that launched this kernel through graph launch APIs.
 This field will be 0 if the kernel is not launched through graph launch APIs.*/
    pub graphId: u32,
}
/** For devices with compute capability 7.5+ cacheConfig values are not updated
 in case field isSharedMemoryCarveoutRequested is set*/
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityKernel5__bindgen_ty_1 {
    pub both: u8,
    pub config: CUpti_ActivityKernel5__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityKernel5__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel5__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityKernel5__bindgen_ty_1__bindgen_ty_1>()
        - 1usize];
    [
        "Alignment of CUpti_ActivityKernel5__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityKernel5__bindgen_ty_1__bindgen_ty_1>()
        - 1usize];
};
impl CUpti_ActivityKernel5__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn requested(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_requested(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn requested_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 1usize],
                >>::raw_get(::std::ptr::addr_of!((*this)._bitfield_1), 0usize, 4u8) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_requested_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 1usize],
            >>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn executed(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_executed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn executed_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 1usize],
                >>::raw_get(::std::ptr::addr_of!((*this)._bitfield_1), 4usize, 4u8) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_executed_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 1usize],
            >>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        requested: u8,
        executed: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit
            .set(
                0usize,
                4u8,
                {
                    let requested: u8 = unsafe { ::std::mem::transmute(requested) };
                    requested as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                4usize,
                4u8,
                {
                    let executed: u8 = unsafe { ::std::mem::transmute(executed) };
                    executed as u64
                },
            );
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel5__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityKernel5__bindgen_ty_1>() - 1usize];
    [
        "Alignment of CUpti_ActivityKernel5__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityKernel5__bindgen_ty_1>() - 1usize];
    [
        "Offset of field: CUpti_ActivityKernel5__bindgen_ty_1::both",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5__bindgen_ty_1, both) - 0usize];
    [
        "Offset of field: CUpti_ActivityKernel5__bindgen_ty_1::config",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5__bindgen_ty_1, config) - 0usize];
};
impl Default for CUpti_ActivityKernel5__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel5__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityKernel5__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel5",
    ][::std::mem::size_of::<CUpti_ActivityKernel5>() - 160usize];
    [
        "Alignment of CUpti_ActivityKernel5",
    ][::std::mem::align_of::<CUpti_ActivityKernel5>() - 8usize];
    [
        "Offset of field: CUpti_ActivityKernel5::kind",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityKernel5::cacheConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, cacheConfig) - 4usize];
    [
        "Offset of field: CUpti_ActivityKernel5::sharedMemoryConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, sharedMemoryConfig) - 5usize];
    [
        "Offset of field: CUpti_ActivityKernel5::registersPerThread",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, registersPerThread) - 6usize];
    [
        "Offset of field: CUpti_ActivityKernel5::partitionedGlobalCacheRequested",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, partitionedGlobalCacheRequested)
        - 8usize];
    [
        "Offset of field: CUpti_ActivityKernel5::partitionedGlobalCacheExecuted",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, partitionedGlobalCacheExecuted)
        - 12usize];
    [
        "Offset of field: CUpti_ActivityKernel5::start",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityKernel5::end",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityKernel5::completed",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, completed) - 32usize];
    [
        "Offset of field: CUpti_ActivityKernel5::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, deviceId) - 40usize];
    [
        "Offset of field: CUpti_ActivityKernel5::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, contextId) - 44usize];
    [
        "Offset of field: CUpti_ActivityKernel5::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, streamId) - 48usize];
    [
        "Offset of field: CUpti_ActivityKernel5::gridX",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, gridX) - 52usize];
    [
        "Offset of field: CUpti_ActivityKernel5::gridY",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, gridY) - 56usize];
    [
        "Offset of field: CUpti_ActivityKernel5::gridZ",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, gridZ) - 60usize];
    [
        "Offset of field: CUpti_ActivityKernel5::blockX",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, blockX) - 64usize];
    [
        "Offset of field: CUpti_ActivityKernel5::blockY",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, blockY) - 68usize];
    [
        "Offset of field: CUpti_ActivityKernel5::blockZ",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, blockZ) - 72usize];
    [
        "Offset of field: CUpti_ActivityKernel5::staticSharedMemory",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, staticSharedMemory) - 76usize];
    [
        "Offset of field: CUpti_ActivityKernel5::dynamicSharedMemory",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, dynamicSharedMemory) - 80usize];
    [
        "Offset of field: CUpti_ActivityKernel5::localMemoryPerThread",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, localMemoryPerThread) - 84usize];
    [
        "Offset of field: CUpti_ActivityKernel5::localMemoryTotal",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, localMemoryTotal) - 88usize];
    [
        "Offset of field: CUpti_ActivityKernel5::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, correlationId) - 92usize];
    [
        "Offset of field: CUpti_ActivityKernel5::gridId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, gridId) - 96usize];
    [
        "Offset of field: CUpti_ActivityKernel5::name",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, name) - 104usize];
    [
        "Offset of field: CUpti_ActivityKernel5::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, reserved0) - 112usize];
    [
        "Offset of field: CUpti_ActivityKernel5::queued",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, queued) - 120usize];
    [
        "Offset of field: CUpti_ActivityKernel5::submitted",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, submitted) - 128usize];
    [
        "Offset of field: CUpti_ActivityKernel5::launchType",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, launchType) - 136usize];
    [
        "Offset of field: CUpti_ActivityKernel5::isSharedMemoryCarveoutRequested",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, isSharedMemoryCarveoutRequested)
        - 137usize];
    [
        "Offset of field: CUpti_ActivityKernel5::sharedMemoryCarveoutRequested",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, sharedMemoryCarveoutRequested)
        - 138usize];
    [
        "Offset of field: CUpti_ActivityKernel5::padding",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, padding) - 139usize];
    [
        "Offset of field: CUpti_ActivityKernel5::sharedMemoryExecuted",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, sharedMemoryExecuted) - 140usize];
    [
        "Offset of field: CUpti_ActivityKernel5::graphNodeId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, graphNodeId) - 144usize];
    [
        "Offset of field: CUpti_ActivityKernel5::shmemLimitConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, shmemLimitConfig) - 152usize];
    [
        "Offset of field: CUpti_ActivityKernel5::graphId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel5, graphId) - 156usize];
};
impl Default for CUpti_ActivityKernel5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel5 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityKernel5 {{ kind: {:?}, cacheConfig: {:?}, partitionedGlobalCacheRequested: {:?}, partitionedGlobalCacheExecuted: {:?}, name: {:?}, reserved0: {:?}, shmemLimitConfig: {:?} }}",
            self.kind,
            self.cacheConfig,
            self.partitionedGlobalCacheRequested,
            self.partitionedGlobalCacheExecuted,
            self.name,
            self.reserved0,
            self.shmemLimitConfig,
        )
    }
}
/** \brief The activity record for kernel. (deprecated in CUDA 11.6)

 This activity record represents a kernel execution
 (CUPTI_ACTIVITY_KIND_KERNEL and
 CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL) but is no longer generated
 by CUPTI. Kernel activities are now reported using the
 CUpti_ActivityKernel9 activity record.*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityKernel6 {
    /** The activity record kind, must be CUPTI_ACTIVITY_KIND_KERNEL or
 CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL.*/
    pub kind: CUpti_ActivityKind,
    pub cacheConfig: CUpti_ActivityKernel6__bindgen_ty_1,
    /** The shared memory configuration used for the kernel. The value is one of
 the CUsharedconfig enumeration values from cuda.h.*/
    pub sharedMemoryConfig: u8,
    /** The number of registers required for each thread executing the
 kernel.*/
    pub registersPerThread: u16,
    /** The partitioned global caching requested for the kernel. Partitioned
 global caching is required to enable caching on certain chips, such as
 devices with compute capability 5.2.*/
    pub partitionedGlobalCacheRequested: CUpti_ActivityPartitionedGlobalCacheConfig,
    /** The partitioned global caching executed for the kernel. Partitioned
 global caching is required to enable caching on certain chips, such as
 devices with compute capability 5.2. Partitioned global caching can be
 automatically disabled if the occupancy requirement of the launch cannot
 support caching.*/
    pub partitionedGlobalCacheExecuted: CUpti_ActivityPartitionedGlobalCacheConfig,
    /** The start timestamp for the kernel execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the kernel.*/
    pub start: u64,
    /** The end timestamp for the kernel execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the kernel.*/
    pub end: u64,
    /** The completed timestamp for the kernel execution, in ns.  It
 represents the completion of all it's child kernels and the
 kernel itself. A value of CUPTI_TIMESTAMP_UNKNOWN indicates that
 the completion time is unknown.*/
    pub completed: u64,
    /// The ID of the device where the kernel is executing.
    pub deviceId: u32,
    /// The ID of the context where the kernel is executing.
    pub contextId: u32,
    /// The ID of the stream where the kernel is executing.
    pub streamId: u32,
    /// The X-dimension grid size for the kernel.
    pub gridX: i32,
    /// The Y-dimension grid size for the kernel.
    pub gridY: i32,
    /// The Z-dimension grid size for the kernel.
    pub gridZ: i32,
    /// The X-dimension block size for the kernel.
    pub blockX: i32,
    /// The Y-dimension block size for the kernel.
    pub blockY: i32,
    /// The Z-dimension grid size for the kernel.
    pub blockZ: i32,
    /// The static shared memory allocated for the kernel, in bytes.
    pub staticSharedMemory: i32,
    /// The dynamic shared memory reserved for the kernel, in bytes.
    pub dynamicSharedMemory: i32,
    /// The amount of local memory reserved for each thread, in bytes.
    pub localMemoryPerThread: u32,
    /** The total amount of local memory reserved for the kernel, in
 bytes.*/
    pub localMemoryTotal: u32,
    /** The correlation ID of the kernel. Each kernel execution is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver or runtime API activity record that
 launched the kernel.*/
    pub correlationId: u32,
    /** The grid ID of the kernel. Each kernel is assigned a unique
 grid ID at runtime.*/
    pub gridId: i64,
    /** The name of the kernel. This name is shared across all activity
 records representing the same kernel, and so should not be
 modified.*/
    pub name: *const ::std::os::raw::c_char,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
    /** The timestamp when the kernel is queued up in the command buffer, in ns.
 A value of CUPTI_TIMESTAMP_UNKNOWN indicates that the queued time
 could not be collected for the kernel. This timestamp is not collected
 by default. Use API \ref cuptiActivityEnableLatencyTimestamps() to
 enable collection.

 Command buffer is a buffer written by CUDA driver to send commands
 like kernel launch, memory copy etc to the GPU. All launches of CUDA
 kernels are asynchronous with respect to the host, the host requests
 the launch by writing commands into the command buffer, then returns
 without checking the GPU's progress.*/
    pub queued: u64,
    /** The timestamp when the command buffer containing the kernel launch
 is submitted to the GPU, in ns. A value of CUPTI_TIMESTAMP_UNKNOWN
 indicates that the submitted time could not be collected for the kernel.
 This timestamp is not collected by default. Use API \ref
 cuptiActivityEnableLatencyTimestamps() to enable collection.*/
    pub submitted: u64,
    /** The indicates if the kernel was executed via a regular launch or via a
 single/multi device cooperative launch. \see CUpti_ActivityLaunchType*/
    pub launchType: u8,
    /** This indicates if CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT was
 updated for the kernel launch*/
    pub isSharedMemoryCarveoutRequested: u8,
    /** Shared memory carveout value requested for the function in percentage of
 the total resource. The value will be updated only if field
 isSharedMemoryCarveoutRequested is set.*/
    pub sharedMemoryCarveoutRequested: u8,
    /// Undefined. Reserved for internal use.
    pub padding: u8,
    /// Shared memory size set by the driver.
    pub sharedMemoryExecuted: u32,
    /** The unique ID of the graph node that launched this kernel through graph launch APIs.
 This field will be 0 if the kernel is not launched through graph launch APIs.*/
    pub graphNodeId: u64,
    /** The shared memory limit config for the kernel. This field shows whether user has opted for a
 higher per block limit of dynamic shared memory.*/
    pub shmemLimitConfig: CUpti_FuncShmemLimitConfig,
    /** The unique ID of the graph that launched this kernel through graph launch APIs.
 This field will be 0 if the kernel is not launched through graph launch APIs.*/
    pub graphId: u32,
    /** The pointer to the access policy window. The structure CUaccessPolicyWindow is
 defined in cuda.h.*/
    pub pAccessPolicyWindow: *mut CUaccessPolicyWindow,
}
/** For devices with compute capability 7.5+ cacheConfig values are not updated
 in case field isSharedMemoryCarveoutRequested is set*/
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityKernel6__bindgen_ty_1 {
    pub both: u8,
    pub config: CUpti_ActivityKernel6__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityKernel6__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel6__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityKernel6__bindgen_ty_1__bindgen_ty_1>()
        - 1usize];
    [
        "Alignment of CUpti_ActivityKernel6__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityKernel6__bindgen_ty_1__bindgen_ty_1>()
        - 1usize];
};
impl CUpti_ActivityKernel6__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn requested(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_requested(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn requested_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 1usize],
                >>::raw_get(::std::ptr::addr_of!((*this)._bitfield_1), 0usize, 4u8) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_requested_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 1usize],
            >>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn executed(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_executed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn executed_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 1usize],
                >>::raw_get(::std::ptr::addr_of!((*this)._bitfield_1), 4usize, 4u8) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_executed_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 1usize],
            >>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        requested: u8,
        executed: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit
            .set(
                0usize,
                4u8,
                {
                    let requested: u8 = unsafe { ::std::mem::transmute(requested) };
                    requested as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                4usize,
                4u8,
                {
                    let executed: u8 = unsafe { ::std::mem::transmute(executed) };
                    executed as u64
                },
            );
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel6__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityKernel6__bindgen_ty_1>() - 1usize];
    [
        "Alignment of CUpti_ActivityKernel6__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityKernel6__bindgen_ty_1>() - 1usize];
    [
        "Offset of field: CUpti_ActivityKernel6__bindgen_ty_1::both",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6__bindgen_ty_1, both) - 0usize];
    [
        "Offset of field: CUpti_ActivityKernel6__bindgen_ty_1::config",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6__bindgen_ty_1, config) - 0usize];
};
impl Default for CUpti_ActivityKernel6__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel6__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityKernel6__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel6",
    ][::std::mem::size_of::<CUpti_ActivityKernel6>() - 168usize];
    [
        "Alignment of CUpti_ActivityKernel6",
    ][::std::mem::align_of::<CUpti_ActivityKernel6>() - 8usize];
    [
        "Offset of field: CUpti_ActivityKernel6::kind",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityKernel6::cacheConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, cacheConfig) - 4usize];
    [
        "Offset of field: CUpti_ActivityKernel6::sharedMemoryConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, sharedMemoryConfig) - 5usize];
    [
        "Offset of field: CUpti_ActivityKernel6::registersPerThread",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, registersPerThread) - 6usize];
    [
        "Offset of field: CUpti_ActivityKernel6::partitionedGlobalCacheRequested",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, partitionedGlobalCacheRequested)
        - 8usize];
    [
        "Offset of field: CUpti_ActivityKernel6::partitionedGlobalCacheExecuted",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, partitionedGlobalCacheExecuted)
        - 12usize];
    [
        "Offset of field: CUpti_ActivityKernel6::start",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityKernel6::end",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityKernel6::completed",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, completed) - 32usize];
    [
        "Offset of field: CUpti_ActivityKernel6::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, deviceId) - 40usize];
    [
        "Offset of field: CUpti_ActivityKernel6::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, contextId) - 44usize];
    [
        "Offset of field: CUpti_ActivityKernel6::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, streamId) - 48usize];
    [
        "Offset of field: CUpti_ActivityKernel6::gridX",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, gridX) - 52usize];
    [
        "Offset of field: CUpti_ActivityKernel6::gridY",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, gridY) - 56usize];
    [
        "Offset of field: CUpti_ActivityKernel6::gridZ",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, gridZ) - 60usize];
    [
        "Offset of field: CUpti_ActivityKernel6::blockX",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, blockX) - 64usize];
    [
        "Offset of field: CUpti_ActivityKernel6::blockY",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, blockY) - 68usize];
    [
        "Offset of field: CUpti_ActivityKernel6::blockZ",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, blockZ) - 72usize];
    [
        "Offset of field: CUpti_ActivityKernel6::staticSharedMemory",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, staticSharedMemory) - 76usize];
    [
        "Offset of field: CUpti_ActivityKernel6::dynamicSharedMemory",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, dynamicSharedMemory) - 80usize];
    [
        "Offset of field: CUpti_ActivityKernel6::localMemoryPerThread",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, localMemoryPerThread) - 84usize];
    [
        "Offset of field: CUpti_ActivityKernel6::localMemoryTotal",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, localMemoryTotal) - 88usize];
    [
        "Offset of field: CUpti_ActivityKernel6::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, correlationId) - 92usize];
    [
        "Offset of field: CUpti_ActivityKernel6::gridId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, gridId) - 96usize];
    [
        "Offset of field: CUpti_ActivityKernel6::name",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, name) - 104usize];
    [
        "Offset of field: CUpti_ActivityKernel6::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, reserved0) - 112usize];
    [
        "Offset of field: CUpti_ActivityKernel6::queued",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, queued) - 120usize];
    [
        "Offset of field: CUpti_ActivityKernel6::submitted",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, submitted) - 128usize];
    [
        "Offset of field: CUpti_ActivityKernel6::launchType",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, launchType) - 136usize];
    [
        "Offset of field: CUpti_ActivityKernel6::isSharedMemoryCarveoutRequested",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, isSharedMemoryCarveoutRequested)
        - 137usize];
    [
        "Offset of field: CUpti_ActivityKernel6::sharedMemoryCarveoutRequested",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, sharedMemoryCarveoutRequested)
        - 138usize];
    [
        "Offset of field: CUpti_ActivityKernel6::padding",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, padding) - 139usize];
    [
        "Offset of field: CUpti_ActivityKernel6::sharedMemoryExecuted",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, sharedMemoryExecuted) - 140usize];
    [
        "Offset of field: CUpti_ActivityKernel6::graphNodeId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, graphNodeId) - 144usize];
    [
        "Offset of field: CUpti_ActivityKernel6::shmemLimitConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, shmemLimitConfig) - 152usize];
    [
        "Offset of field: CUpti_ActivityKernel6::graphId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, graphId) - 156usize];
    [
        "Offset of field: CUpti_ActivityKernel6::pAccessPolicyWindow",
    ][::std::mem::offset_of!(CUpti_ActivityKernel6, pAccessPolicyWindow) - 160usize];
};
impl Default for CUpti_ActivityKernel6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel6 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityKernel6 {{ kind: {:?}, cacheConfig: {:?}, partitionedGlobalCacheRequested: {:?}, partitionedGlobalCacheExecuted: {:?}, name: {:?}, reserved0: {:?}, shmemLimitConfig: {:?}, pAccessPolicyWindow: {:?} }}",
            self.kind,
            self.cacheConfig,
            self.partitionedGlobalCacheRequested,
            self.partitionedGlobalCacheExecuted,
            self.name,
            self.reserved0,
            self.shmemLimitConfig,
            self.pAccessPolicyWindow,
        )
    }
}
/** \brief The activity record for kernel. (deprecated in CUDA 11.8)

 This activity record represents a kernel execution
 (CUPTI_ACTIVITY_KIND_KERNEL and
 CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL) but is no longer generated
 by CUPTI. Kernel activities are now reported using the
 CUpti_ActivityKernel9 activity record.*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityKernel7 {
    /** The activity record kind, must be CUPTI_ACTIVITY_KIND_KERNEL or
 CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL.*/
    pub kind: CUpti_ActivityKind,
    pub cacheConfig: CUpti_ActivityKernel7__bindgen_ty_1,
    /** The shared memory configuration used for the kernel. The value is one of
 the CUsharedconfig enumeration values from cuda.h.*/
    pub sharedMemoryConfig: u8,
    /** The number of registers required for each thread executing the
 kernel.*/
    pub registersPerThread: u16,
    /** The partitioned global caching requested for the kernel. Partitioned
 global caching is required to enable caching on certain chips, such as
 devices with compute capability 5.2.*/
    pub partitionedGlobalCacheRequested: CUpti_ActivityPartitionedGlobalCacheConfig,
    /** The partitioned global caching executed for the kernel. Partitioned
 global caching is required to enable caching on certain chips, such as
 devices with compute capability 5.2. Partitioned global caching can be
 automatically disabled if the occupancy requirement of the launch cannot
 support caching.*/
    pub partitionedGlobalCacheExecuted: CUpti_ActivityPartitionedGlobalCacheConfig,
    /** The start timestamp for the kernel execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the kernel.*/
    pub start: u64,
    /** The end timestamp for the kernel execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the kernel.*/
    pub end: u64,
    /** The completed timestamp for the kernel execution, in ns.  It
 represents the completion of all it's child kernels and the
 kernel itself. A value of CUPTI_TIMESTAMP_UNKNOWN indicates that
 the completion time is unknown.*/
    pub completed: u64,
    /// The ID of the device where the kernel is executing.
    pub deviceId: u32,
    /// The ID of the context where the kernel is executing.
    pub contextId: u32,
    /// The ID of the stream where the kernel is executing.
    pub streamId: u32,
    /// The X-dimension grid size for the kernel.
    pub gridX: i32,
    /// The Y-dimension grid size for the kernel.
    pub gridY: i32,
    /// The Z-dimension grid size for the kernel.
    pub gridZ: i32,
    /// The X-dimension block size for the kernel.
    pub blockX: i32,
    /// The Y-dimension block size for the kernel.
    pub blockY: i32,
    /// The Z-dimension grid size for the kernel.
    pub blockZ: i32,
    /// The static shared memory allocated for the kernel, in bytes.
    pub staticSharedMemory: i32,
    /// The dynamic shared memory reserved for the kernel, in bytes.
    pub dynamicSharedMemory: i32,
    /// The amount of local memory reserved for each thread, in bytes.
    pub localMemoryPerThread: u32,
    /** The total amount of local memory reserved for the kernel, in
 bytes.*/
    pub localMemoryTotal: u32,
    /** The correlation ID of the kernel. Each kernel execution is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver or runtime API activity record that
 launched the kernel.*/
    pub correlationId: u32,
    /** The grid ID of the kernel. Each kernel is assigned a unique
 grid ID at runtime.*/
    pub gridId: i64,
    /** The name of the kernel. This name is shared across all activity
 records representing the same kernel, and so should not be
 modified.*/
    pub name: *const ::std::os::raw::c_char,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
    /** The timestamp when the kernel is queued up in the command buffer, in ns.
 A value of CUPTI_TIMESTAMP_UNKNOWN indicates that the queued time
 could not be collected for the kernel. This timestamp is not collected
 by default. Use API \ref cuptiActivityEnableLatencyTimestamps() to
 enable collection.

 Command buffer is a buffer written by CUDA driver to send commands
 like kernel launch, memory copy etc to the GPU. All launches of CUDA
 kernels are asynchronous with respect to the host, the host requests
 the launch by writing commands into the command buffer, then returns
 without checking the GPU's progress.*/
    pub queued: u64,
    /** The timestamp when the command buffer containing the kernel launch
 is submitted to the GPU, in ns. A value of CUPTI_TIMESTAMP_UNKNOWN
 indicates that the submitted time could not be collected for the kernel.
 This timestamp is not collected by default. Use API \ref
 cuptiActivityEnableLatencyTimestamps() to enable collection.*/
    pub submitted: u64,
    /** The indicates if the kernel was executed via a regular launch or via a
 single/multi device cooperative launch. \see CUpti_ActivityLaunchType*/
    pub launchType: u8,
    /** This indicates if CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT was
 updated for the kernel launch*/
    pub isSharedMemoryCarveoutRequested: u8,
    /** Shared memory carveout value requested for the function in percentage of
 the total resource. The value will be updated only if field
 isSharedMemoryCarveoutRequested is set.*/
    pub sharedMemoryCarveoutRequested: u8,
    /// Undefined. Reserved for internal use.
    pub padding: u8,
    /// Shared memory size set by the driver.
    pub sharedMemoryExecuted: u32,
    /** The unique ID of the graph node that launched this kernel through graph launch APIs.
 This field will be 0 if the kernel is not launched through graph launch APIs.*/
    pub graphNodeId: u64,
    /** The shared memory limit config for the kernel. This field shows whether user has opted for a
 higher per block limit of dynamic shared memory.*/
    pub shmemLimitConfig: CUpti_FuncShmemLimitConfig,
    /** The unique ID of the graph that launched this kernel through graph launch APIs.
 This field will be 0 if the kernel is not launched through graph launch APIs.*/
    pub graphId: u32,
    /** The pointer to the access policy window. The structure CUaccessPolicyWindow is
 defined in cuda.h.*/
    pub pAccessPolicyWindow: *mut CUaccessPolicyWindow,
    /// The ID of the HW channel on which the kernel is launched.
    pub channelID: u32,
    /// The type of the channel
    pub channelType: CUpti_ChannelType,
}
/** For devices with compute capability 7.5+ cacheConfig values are not updated
 in case field isSharedMemoryCarveoutRequested is set*/
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityKernel7__bindgen_ty_1 {
    pub both: u8,
    pub config: CUpti_ActivityKernel7__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityKernel7__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel7__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityKernel7__bindgen_ty_1__bindgen_ty_1>()
        - 1usize];
    [
        "Alignment of CUpti_ActivityKernel7__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityKernel7__bindgen_ty_1__bindgen_ty_1>()
        - 1usize];
};
impl CUpti_ActivityKernel7__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn requested(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_requested(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn requested_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 1usize],
                >>::raw_get(::std::ptr::addr_of!((*this)._bitfield_1), 0usize, 4u8) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_requested_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 1usize],
            >>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn executed(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_executed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn executed_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 1usize],
                >>::raw_get(::std::ptr::addr_of!((*this)._bitfield_1), 4usize, 4u8) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_executed_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 1usize],
            >>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        requested: u8,
        executed: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit
            .set(
                0usize,
                4u8,
                {
                    let requested: u8 = unsafe { ::std::mem::transmute(requested) };
                    requested as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                4usize,
                4u8,
                {
                    let executed: u8 = unsafe { ::std::mem::transmute(executed) };
                    executed as u64
                },
            );
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel7__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityKernel7__bindgen_ty_1>() - 1usize];
    [
        "Alignment of CUpti_ActivityKernel7__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityKernel7__bindgen_ty_1>() - 1usize];
    [
        "Offset of field: CUpti_ActivityKernel7__bindgen_ty_1::both",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7__bindgen_ty_1, both) - 0usize];
    [
        "Offset of field: CUpti_ActivityKernel7__bindgen_ty_1::config",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7__bindgen_ty_1, config) - 0usize];
};
impl Default for CUpti_ActivityKernel7__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel7__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityKernel7__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel7",
    ][::std::mem::size_of::<CUpti_ActivityKernel7>() - 176usize];
    [
        "Alignment of CUpti_ActivityKernel7",
    ][::std::mem::align_of::<CUpti_ActivityKernel7>() - 8usize];
    [
        "Offset of field: CUpti_ActivityKernel7::kind",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityKernel7::cacheConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, cacheConfig) - 4usize];
    [
        "Offset of field: CUpti_ActivityKernel7::sharedMemoryConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, sharedMemoryConfig) - 5usize];
    [
        "Offset of field: CUpti_ActivityKernel7::registersPerThread",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, registersPerThread) - 6usize];
    [
        "Offset of field: CUpti_ActivityKernel7::partitionedGlobalCacheRequested",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, partitionedGlobalCacheRequested)
        - 8usize];
    [
        "Offset of field: CUpti_ActivityKernel7::partitionedGlobalCacheExecuted",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, partitionedGlobalCacheExecuted)
        - 12usize];
    [
        "Offset of field: CUpti_ActivityKernel7::start",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityKernel7::end",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityKernel7::completed",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, completed) - 32usize];
    [
        "Offset of field: CUpti_ActivityKernel7::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, deviceId) - 40usize];
    [
        "Offset of field: CUpti_ActivityKernel7::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, contextId) - 44usize];
    [
        "Offset of field: CUpti_ActivityKernel7::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, streamId) - 48usize];
    [
        "Offset of field: CUpti_ActivityKernel7::gridX",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, gridX) - 52usize];
    [
        "Offset of field: CUpti_ActivityKernel7::gridY",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, gridY) - 56usize];
    [
        "Offset of field: CUpti_ActivityKernel7::gridZ",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, gridZ) - 60usize];
    [
        "Offset of field: CUpti_ActivityKernel7::blockX",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, blockX) - 64usize];
    [
        "Offset of field: CUpti_ActivityKernel7::blockY",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, blockY) - 68usize];
    [
        "Offset of field: CUpti_ActivityKernel7::blockZ",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, blockZ) - 72usize];
    [
        "Offset of field: CUpti_ActivityKernel7::staticSharedMemory",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, staticSharedMemory) - 76usize];
    [
        "Offset of field: CUpti_ActivityKernel7::dynamicSharedMemory",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, dynamicSharedMemory) - 80usize];
    [
        "Offset of field: CUpti_ActivityKernel7::localMemoryPerThread",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, localMemoryPerThread) - 84usize];
    [
        "Offset of field: CUpti_ActivityKernel7::localMemoryTotal",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, localMemoryTotal) - 88usize];
    [
        "Offset of field: CUpti_ActivityKernel7::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, correlationId) - 92usize];
    [
        "Offset of field: CUpti_ActivityKernel7::gridId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, gridId) - 96usize];
    [
        "Offset of field: CUpti_ActivityKernel7::name",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, name) - 104usize];
    [
        "Offset of field: CUpti_ActivityKernel7::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, reserved0) - 112usize];
    [
        "Offset of field: CUpti_ActivityKernel7::queued",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, queued) - 120usize];
    [
        "Offset of field: CUpti_ActivityKernel7::submitted",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, submitted) - 128usize];
    [
        "Offset of field: CUpti_ActivityKernel7::launchType",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, launchType) - 136usize];
    [
        "Offset of field: CUpti_ActivityKernel7::isSharedMemoryCarveoutRequested",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, isSharedMemoryCarveoutRequested)
        - 137usize];
    [
        "Offset of field: CUpti_ActivityKernel7::sharedMemoryCarveoutRequested",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, sharedMemoryCarveoutRequested)
        - 138usize];
    [
        "Offset of field: CUpti_ActivityKernel7::padding",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, padding) - 139usize];
    [
        "Offset of field: CUpti_ActivityKernel7::sharedMemoryExecuted",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, sharedMemoryExecuted) - 140usize];
    [
        "Offset of field: CUpti_ActivityKernel7::graphNodeId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, graphNodeId) - 144usize];
    [
        "Offset of field: CUpti_ActivityKernel7::shmemLimitConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, shmemLimitConfig) - 152usize];
    [
        "Offset of field: CUpti_ActivityKernel7::graphId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, graphId) - 156usize];
    [
        "Offset of field: CUpti_ActivityKernel7::pAccessPolicyWindow",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, pAccessPolicyWindow) - 160usize];
    [
        "Offset of field: CUpti_ActivityKernel7::channelID",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, channelID) - 168usize];
    [
        "Offset of field: CUpti_ActivityKernel7::channelType",
    ][::std::mem::offset_of!(CUpti_ActivityKernel7, channelType) - 172usize];
};
impl Default for CUpti_ActivityKernel7 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel7 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityKernel7 {{ kind: {:?}, cacheConfig: {:?}, partitionedGlobalCacheRequested: {:?}, partitionedGlobalCacheExecuted: {:?}, name: {:?}, reserved0: {:?}, shmemLimitConfig: {:?}, pAccessPolicyWindow: {:?}, channelType: {:?} }}",
            self.kind,
            self.cacheConfig,
            self.partitionedGlobalCacheRequested,
            self.partitionedGlobalCacheExecuted,
            self.name,
            self.reserved0,
            self.shmemLimitConfig,
            self.pAccessPolicyWindow,
            self.channelType,
        )
    }
}
/** \brief The activity record for kernel.

 This activity record represents a kernel execution
 (CUPTI_ACTIVITY_KIND_KERNEL and
 CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL)*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityKernel8 {
    /** The activity record kind, must be CUPTI_ACTIVITY_KIND_KERNEL or
 CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL.*/
    pub kind: CUpti_ActivityKind,
    pub cacheConfig: CUpti_ActivityKernel8__bindgen_ty_1,
    /** The shared memory configuration used for the kernel. The value is one of
 the CUsharedconfig enumeration values from cuda.h.*/
    pub sharedMemoryConfig: u8,
    /** The number of registers required for each thread executing the
 kernel.*/
    pub registersPerThread: u16,
    /** The partitioned global caching requested for the kernel. Partitioned
 global caching is required to enable caching on certain chips, such as
 devices with compute capability 5.2.*/
    pub partitionedGlobalCacheRequested: CUpti_ActivityPartitionedGlobalCacheConfig,
    /** The partitioned global caching executed for the kernel. Partitioned
 global caching is required to enable caching on certain chips, such as
 devices with compute capability 5.2. Partitioned global caching can be
 automatically disabled if the occupancy requirement of the launch cannot
 support caching.*/
    pub partitionedGlobalCacheExecuted: CUpti_ActivityPartitionedGlobalCacheConfig,
    /** The start timestamp for the kernel execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the kernel.*/
    pub start: u64,
    /** The end timestamp for the kernel execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the kernel.*/
    pub end: u64,
    /** The completed timestamp for the kernel execution, in ns.  It
 represents the completion of all it's child kernels and the
 kernel itself. A value of CUPTI_TIMESTAMP_UNKNOWN indicates that
 the completion time is unknown.*/
    pub completed: u64,
    /// The ID of the device where the kernel is executing.
    pub deviceId: u32,
    /// The ID of the context where the kernel is executing.
    pub contextId: u32,
    /// The ID of the stream where the kernel is executing.
    pub streamId: u32,
    /// The X-dimension grid size for the kernel.
    pub gridX: i32,
    /// The Y-dimension grid size for the kernel.
    pub gridY: i32,
    /// The Z-dimension grid size for the kernel.
    pub gridZ: i32,
    /// The X-dimension block size for the kernel.
    pub blockX: i32,
    /// The Y-dimension block size for the kernel.
    pub blockY: i32,
    /// The Z-dimension grid size for the kernel.
    pub blockZ: i32,
    /// The static shared memory allocated for the kernel, in bytes.
    pub staticSharedMemory: i32,
    /// The dynamic shared memory reserved for the kernel, in bytes.
    pub dynamicSharedMemory: i32,
    /// The amount of local memory reserved for each thread, in bytes.
    pub localMemoryPerThread: u32,
    /** The total amount of local memory reserved for the kernel, in
 bytes (deprecated in CUDA 11.8).
 Refer field localMemoryTotal_v2*/
    pub localMemoryTotal: u32,
    /** The correlation ID of the kernel. Each kernel execution is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver or runtime API activity record that
 launched the kernel.*/
    pub correlationId: u32,
    /** The grid ID of the kernel. Each kernel is assigned a unique
 grid ID at runtime.*/
    pub gridId: i64,
    /** The name of the kernel. This name is shared across all activity
 records representing the same kernel, and so should not be
 modified.*/
    pub name: *const ::std::os::raw::c_char,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
    /** The timestamp when the kernel is queued up in the command buffer, in ns.
 A value of CUPTI_TIMESTAMP_UNKNOWN indicates that the queued time
 could not be collected for the kernel. This timestamp is not collected
 by default. Use API \ref cuptiActivityEnableLatencyTimestamps() to
 enable collection.

 Command buffer is a buffer written by CUDA driver to send commands
 like kernel launch, memory copy etc to the GPU. All launches of CUDA
 kernels are asynchronous with respect to the host, the host requests
 the launch by writing commands into the command buffer, then returns
 without checking the GPU's progress.*/
    pub queued: u64,
    /** The timestamp when the command buffer containing the kernel launch
 is submitted to the GPU, in ns. A value of CUPTI_TIMESTAMP_UNKNOWN
 indicates that the submitted time could not be collected for the kernel.
 This timestamp is not collected by default. Use API \ref
 cuptiActivityEnableLatencyTimestamps() to enable collection.*/
    pub submitted: u64,
    /** The indicates if the kernel was executed via a regular launch or via a
 single/multi device cooperative launch. \see CUpti_ActivityLaunchType*/
    pub launchType: u8,
    /** This indicates if CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT was
 updated for the kernel launch*/
    pub isSharedMemoryCarveoutRequested: u8,
    /** Shared memory carveout value requested for the function in percentage of
 the total resource. The value will be updated only if field
 isSharedMemoryCarveoutRequested is set.*/
    pub sharedMemoryCarveoutRequested: u8,
    /// Undefined. Reserved for internal use.
    pub padding: u8,
    /// Shared memory size set by the driver.
    pub sharedMemoryExecuted: u32,
    /** The unique ID of the graph node that launched this kernel through graph launch APIs.
 This field will be 0 if the kernel is not launched through graph launch APIs.*/
    pub graphNodeId: u64,
    /** The shared memory limit config for the kernel. This field shows whether user has opted for a
 higher per block limit of dynamic shared memory.*/
    pub shmemLimitConfig: CUpti_FuncShmemLimitConfig,
    /** The unique ID of the graph that launched this kernel through graph launch APIs.
 This field will be 0 if the kernel is not launched through graph launch APIs.*/
    pub graphId: u32,
    /** The pointer to the access policy window. The structure CUaccessPolicyWindow is
 defined in cuda.h.*/
    pub pAccessPolicyWindow: *mut CUaccessPolicyWindow,
    /// The ID of the HW channel on which the kernel is launched.
    pub channelID: u32,
    /// The type of the channel
    pub channelType: CUpti_ChannelType,
    /** The X-dimension cluster size for the kernel.
 Field is valid for devices with compute capability 9.0 and higher*/
    pub clusterX: u32,
    /** The Y-dimension cluster size for the kernel.
 Field is valid for devices with compute capability 9.0 and higher*/
    pub clusterY: u32,
    /** The Z-dimension cluster size for the kernel.
 Field is valid for devices with compute capability 9.0 and higher*/
    pub clusterZ: u32,
    /** The cluster scheduling policy for the kernel. Refer CUclusterSchedulingPolicy
 Field is valid for devices with compute capability 9.0 and higher*/
    pub clusterSchedulingPolicy: u32,
    /** The total amount of local memory reserved for the kernel, in
 bytes.*/
    pub localMemoryTotal_v2: u64,
}
/** For devices with compute capability 7.5+ cacheConfig values are not updated
 in case field isSharedMemoryCarveoutRequested is set*/
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityKernel8__bindgen_ty_1 {
    pub both: u8,
    pub config: CUpti_ActivityKernel8__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityKernel8__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel8__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityKernel8__bindgen_ty_1__bindgen_ty_1>()
        - 1usize];
    [
        "Alignment of CUpti_ActivityKernel8__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityKernel8__bindgen_ty_1__bindgen_ty_1>()
        - 1usize];
};
impl CUpti_ActivityKernel8__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn requested(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_requested(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn requested_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 1usize],
                >>::raw_get(::std::ptr::addr_of!((*this)._bitfield_1), 0usize, 4u8) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_requested_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 1usize],
            >>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn executed(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_executed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn executed_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 1usize],
                >>::raw_get(::std::ptr::addr_of!((*this)._bitfield_1), 4usize, 4u8) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_executed_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 1usize],
            >>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        requested: u8,
        executed: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit
            .set(
                0usize,
                4u8,
                {
                    let requested: u8 = unsafe { ::std::mem::transmute(requested) };
                    requested as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                4usize,
                4u8,
                {
                    let executed: u8 = unsafe { ::std::mem::transmute(executed) };
                    executed as u64
                },
            );
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel8__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityKernel8__bindgen_ty_1>() - 1usize];
    [
        "Alignment of CUpti_ActivityKernel8__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityKernel8__bindgen_ty_1>() - 1usize];
    [
        "Offset of field: CUpti_ActivityKernel8__bindgen_ty_1::both",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8__bindgen_ty_1, both) - 0usize];
    [
        "Offset of field: CUpti_ActivityKernel8__bindgen_ty_1::config",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8__bindgen_ty_1, config) - 0usize];
};
impl Default for CUpti_ActivityKernel8__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel8__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityKernel8__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel8",
    ][::std::mem::size_of::<CUpti_ActivityKernel8>() - 200usize];
    [
        "Alignment of CUpti_ActivityKernel8",
    ][::std::mem::align_of::<CUpti_ActivityKernel8>() - 8usize];
    [
        "Offset of field: CUpti_ActivityKernel8::kind",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityKernel8::cacheConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, cacheConfig) - 4usize];
    [
        "Offset of field: CUpti_ActivityKernel8::sharedMemoryConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, sharedMemoryConfig) - 5usize];
    [
        "Offset of field: CUpti_ActivityKernel8::registersPerThread",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, registersPerThread) - 6usize];
    [
        "Offset of field: CUpti_ActivityKernel8::partitionedGlobalCacheRequested",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, partitionedGlobalCacheRequested)
        - 8usize];
    [
        "Offset of field: CUpti_ActivityKernel8::partitionedGlobalCacheExecuted",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, partitionedGlobalCacheExecuted)
        - 12usize];
    [
        "Offset of field: CUpti_ActivityKernel8::start",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityKernel8::end",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityKernel8::completed",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, completed) - 32usize];
    [
        "Offset of field: CUpti_ActivityKernel8::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, deviceId) - 40usize];
    [
        "Offset of field: CUpti_ActivityKernel8::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, contextId) - 44usize];
    [
        "Offset of field: CUpti_ActivityKernel8::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, streamId) - 48usize];
    [
        "Offset of field: CUpti_ActivityKernel8::gridX",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, gridX) - 52usize];
    [
        "Offset of field: CUpti_ActivityKernel8::gridY",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, gridY) - 56usize];
    [
        "Offset of field: CUpti_ActivityKernel8::gridZ",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, gridZ) - 60usize];
    [
        "Offset of field: CUpti_ActivityKernel8::blockX",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, blockX) - 64usize];
    [
        "Offset of field: CUpti_ActivityKernel8::blockY",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, blockY) - 68usize];
    [
        "Offset of field: CUpti_ActivityKernel8::blockZ",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, blockZ) - 72usize];
    [
        "Offset of field: CUpti_ActivityKernel8::staticSharedMemory",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, staticSharedMemory) - 76usize];
    [
        "Offset of field: CUpti_ActivityKernel8::dynamicSharedMemory",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, dynamicSharedMemory) - 80usize];
    [
        "Offset of field: CUpti_ActivityKernel8::localMemoryPerThread",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, localMemoryPerThread) - 84usize];
    [
        "Offset of field: CUpti_ActivityKernel8::localMemoryTotal",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, localMemoryTotal) - 88usize];
    [
        "Offset of field: CUpti_ActivityKernel8::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, correlationId) - 92usize];
    [
        "Offset of field: CUpti_ActivityKernel8::gridId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, gridId) - 96usize];
    [
        "Offset of field: CUpti_ActivityKernel8::name",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, name) - 104usize];
    [
        "Offset of field: CUpti_ActivityKernel8::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, reserved0) - 112usize];
    [
        "Offset of field: CUpti_ActivityKernel8::queued",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, queued) - 120usize];
    [
        "Offset of field: CUpti_ActivityKernel8::submitted",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, submitted) - 128usize];
    [
        "Offset of field: CUpti_ActivityKernel8::launchType",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, launchType) - 136usize];
    [
        "Offset of field: CUpti_ActivityKernel8::isSharedMemoryCarveoutRequested",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, isSharedMemoryCarveoutRequested)
        - 137usize];
    [
        "Offset of field: CUpti_ActivityKernel8::sharedMemoryCarveoutRequested",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, sharedMemoryCarveoutRequested)
        - 138usize];
    [
        "Offset of field: CUpti_ActivityKernel8::padding",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, padding) - 139usize];
    [
        "Offset of field: CUpti_ActivityKernel8::sharedMemoryExecuted",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, sharedMemoryExecuted) - 140usize];
    [
        "Offset of field: CUpti_ActivityKernel8::graphNodeId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, graphNodeId) - 144usize];
    [
        "Offset of field: CUpti_ActivityKernel8::shmemLimitConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, shmemLimitConfig) - 152usize];
    [
        "Offset of field: CUpti_ActivityKernel8::graphId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, graphId) - 156usize];
    [
        "Offset of field: CUpti_ActivityKernel8::pAccessPolicyWindow",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, pAccessPolicyWindow) - 160usize];
    [
        "Offset of field: CUpti_ActivityKernel8::channelID",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, channelID) - 168usize];
    [
        "Offset of field: CUpti_ActivityKernel8::channelType",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, channelType) - 172usize];
    [
        "Offset of field: CUpti_ActivityKernel8::clusterX",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, clusterX) - 176usize];
    [
        "Offset of field: CUpti_ActivityKernel8::clusterY",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, clusterY) - 180usize];
    [
        "Offset of field: CUpti_ActivityKernel8::clusterZ",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, clusterZ) - 184usize];
    [
        "Offset of field: CUpti_ActivityKernel8::clusterSchedulingPolicy",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, clusterSchedulingPolicy) - 188usize];
    [
        "Offset of field: CUpti_ActivityKernel8::localMemoryTotal_v2",
    ][::std::mem::offset_of!(CUpti_ActivityKernel8, localMemoryTotal_v2) - 192usize];
};
impl Default for CUpti_ActivityKernel8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel8 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityKernel8 {{ kind: {:?}, cacheConfig: {:?}, partitionedGlobalCacheRequested: {:?}, partitionedGlobalCacheExecuted: {:?}, name: {:?}, reserved0: {:?}, shmemLimitConfig: {:?}, pAccessPolicyWindow: {:?}, channelType: {:?} }}",
            self.kind,
            self.cacheConfig,
            self.partitionedGlobalCacheRequested,
            self.partitionedGlobalCacheExecuted,
            self.name,
            self.reserved0,
            self.shmemLimitConfig,
            self.pAccessPolicyWindow,
            self.channelType,
        )
    }
}
/** \brief The activity record for kernel.

 This activity record represents a kernel execution
 (CUPTI_ACTIVITY_KIND_KERNEL and
 CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL)*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityKernel9 {
    /** The activity record kind, must be CUPTI_ACTIVITY_KIND_KERNEL or
 CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL.*/
    pub kind: CUpti_ActivityKind,
    pub cacheConfig: CUpti_ActivityKernel9__bindgen_ty_1,
    /** The shared memory configuration used for the kernel. The value is one of
 the CUsharedconfig enumeration values from cuda.h.*/
    pub sharedMemoryConfig: u8,
    /** The number of registers required for each thread executing the
 kernel.*/
    pub registersPerThread: u16,
    /** The partitioned global caching requested for the kernel. Partitioned
 global caching is required to enable caching on certain chips, such as
 devices with compute capability 5.2.*/
    pub partitionedGlobalCacheRequested: CUpti_ActivityPartitionedGlobalCacheConfig,
    /** The partitioned global caching executed for the kernel. Partitioned
 global caching is required to enable caching on certain chips, such as
 devices with compute capability 5.2. Partitioned global caching can be
 automatically disabled if the occupancy requirement of the launch cannot
 support caching.*/
    pub partitionedGlobalCacheExecuted: CUpti_ActivityPartitionedGlobalCacheConfig,
    /** The start timestamp for the kernel execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the kernel.*/
    pub start: u64,
    /** The end timestamp for the kernel execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the kernel.*/
    pub end: u64,
    /** The completed timestamp for the kernel execution, in ns.  It
 represents the completion of all it's child kernels and the
 kernel itself. A value of CUPTI_TIMESTAMP_UNKNOWN indicates that
 the completion time is unknown.*/
    pub completed: u64,
    /// The ID of the device where the kernel is executing.
    pub deviceId: u32,
    /// The ID of the context where the kernel is executing.
    pub contextId: u32,
    /// The ID of the stream where the kernel is executing.
    pub streamId: u32,
    /// The X-dimension grid size for the kernel.
    pub gridX: i32,
    /// The Y-dimension grid size for the kernel.
    pub gridY: i32,
    /// The Z-dimension grid size for the kernel.
    pub gridZ: i32,
    /// The X-dimension block size for the kernel.
    pub blockX: i32,
    /// The Y-dimension block size for the kernel.
    pub blockY: i32,
    /// The Z-dimension grid size for the kernel.
    pub blockZ: i32,
    /// The static shared memory allocated for the kernel, in bytes.
    pub staticSharedMemory: i32,
    /// The dynamic shared memory reserved for the kernel, in bytes.
    pub dynamicSharedMemory: i32,
    /// The amount of local memory reserved for each thread, in bytes.
    pub localMemoryPerThread: u32,
    /** The total amount of local memory reserved for the kernel, in
 bytes (deprecated in CUDA 11.8).
 Refer field localMemoryTotal_v2*/
    pub localMemoryTotal: u32,
    /** The correlation ID of the kernel. Each kernel execution is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver or runtime API activity record that
 launched the kernel.*/
    pub correlationId: u32,
    /** The grid ID of the kernel. Each kernel is assigned a unique
 grid ID at runtime.*/
    pub gridId: i64,
    /** The name of the kernel. This name is shared across all activity
 records representing the same kernel, and so should not be
 modified.*/
    pub name: *const ::std::os::raw::c_char,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
    /** The timestamp when the kernel is queued up in the command buffer, in ns.
 A value of CUPTI_TIMESTAMP_UNKNOWN indicates that the queued time
 could not be collected for the kernel. This timestamp is not collected
 by default. Use API \ref cuptiActivityEnableLatencyTimestamps() to
 enable collection.

 Command buffer is a buffer written by CUDA driver to send commands
 like kernel launch, memory copy etc to the GPU. All launches of CUDA
 kernels are asynchronous with respect to the host, the host requests
 the launch by writing commands into the command buffer, then returns
 without checking the GPU's progress.*/
    pub queued: u64,
    /** The timestamp when the command buffer containing the kernel launch
 is submitted to the GPU, in ns. A value of CUPTI_TIMESTAMP_UNKNOWN
 indicates that the submitted time could not be collected for the kernel.
 This timestamp is not collected by default. Use API \ref
 cuptiActivityEnableLatencyTimestamps() to enable collection.*/
    pub submitted: u64,
    /** The indicates if the kernel was executed via a regular launch or via a
 single/multi device cooperative launch. \see CUpti_ActivityLaunchType*/
    pub launchType: u8,
    /** This indicates if CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT was
 updated for the kernel launch*/
    pub isSharedMemoryCarveoutRequested: u8,
    /** Shared memory carveout value requested for the function in percentage of
 the total resource. The value will be updated only if field
 isSharedMemoryCarveoutRequested is set.*/
    pub sharedMemoryCarveoutRequested: u8,
    /// Undefined. Reserved for internal use.
    pub padding: u8,
    /// Shared memory size set by the driver.
    pub sharedMemoryExecuted: u32,
    /** The unique ID of the graph node that launched this kernel through graph launch APIs.
 This field will be 0 if the kernel is not launched through graph launch APIs.*/
    pub graphNodeId: u64,
    /** The shared memory limit config for the kernel. This field shows whether user has opted for a
 higher per block limit of dynamic shared memory.*/
    pub shmemLimitConfig: CUpti_FuncShmemLimitConfig,
    /** The unique ID of the graph that launched this kernel through graph launch APIs.
 This field will be 0 if the kernel is not launched through graph launch APIs.*/
    pub graphId: u32,
    /** The pointer to the access policy window. The structure CUaccessPolicyWindow is
 defined in cuda.h.*/
    pub pAccessPolicyWindow: *mut CUaccessPolicyWindow,
    /// The ID of the HW channel on which the kernel is launched.
    pub channelID: u32,
    /// The type of the channel
    pub channelType: CUpti_ChannelType,
    /** The X-dimension cluster size for the kernel.
 Field is valid for devices with compute capability 9.0 and higher*/
    pub clusterX: u32,
    /** The Y-dimension cluster size for the kernel.
 Field is valid for devices with compute capability 9.0 and higher*/
    pub clusterY: u32,
    /** The Z-dimension cluster size for the kernel.
 Field is valid for devices with compute capability 9.0 and higher*/
    pub clusterZ: u32,
    /** The cluster scheduling policy for the kernel. Refer CUclusterSchedulingPolicy
 Field is valid for devices with compute capability 9.0 and higher*/
    pub clusterSchedulingPolicy: u32,
    /** The total amount of local memory reserved for the kernel, in
 bytes.*/
    pub localMemoryTotal_v2: u64,
    /// The maximum cluster size for the kernel
    pub maxPotentialClusterSize: u32,
    /// The maximum clusters that could co-exist on the target device for the kernel
    pub maxActiveClusters: u32,
}
/** For devices with compute capability 7.5+ cacheConfig values are not updated
 in case field isSharedMemoryCarveoutRequested is set*/
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityKernel9__bindgen_ty_1 {
    pub both: u8,
    pub config: CUpti_ActivityKernel9__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityKernel9__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel9__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityKernel9__bindgen_ty_1__bindgen_ty_1>()
        - 1usize];
    [
        "Alignment of CUpti_ActivityKernel9__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityKernel9__bindgen_ty_1__bindgen_ty_1>()
        - 1usize];
};
impl CUpti_ActivityKernel9__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn requested(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_requested(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn requested_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 1usize],
                >>::raw_get(::std::ptr::addr_of!((*this)._bitfield_1), 0usize, 4u8) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_requested_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 1usize],
            >>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn executed(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_executed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn executed_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 1usize],
                >>::raw_get(::std::ptr::addr_of!((*this)._bitfield_1), 4usize, 4u8) as u8,
            )
        }
    }
    #[inline]
    pub unsafe fn set_executed_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 1usize],
            >>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        requested: u8,
        executed: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit
            .set(
                0usize,
                4u8,
                {
                    let requested: u8 = unsafe { ::std::mem::transmute(requested) };
                    requested as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                4usize,
                4u8,
                {
                    let executed: u8 = unsafe { ::std::mem::transmute(executed) };
                    executed as u64
                },
            );
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel9__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityKernel9__bindgen_ty_1>() - 1usize];
    [
        "Alignment of CUpti_ActivityKernel9__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityKernel9__bindgen_ty_1>() - 1usize];
    [
        "Offset of field: CUpti_ActivityKernel9__bindgen_ty_1::both",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9__bindgen_ty_1, both) - 0usize];
    [
        "Offset of field: CUpti_ActivityKernel9__bindgen_ty_1::config",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9__bindgen_ty_1, config) - 0usize];
};
impl Default for CUpti_ActivityKernel9__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel9__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityKernel9__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityKernel9",
    ][::std::mem::size_of::<CUpti_ActivityKernel9>() - 208usize];
    [
        "Alignment of CUpti_ActivityKernel9",
    ][::std::mem::align_of::<CUpti_ActivityKernel9>() - 8usize];
    [
        "Offset of field: CUpti_ActivityKernel9::kind",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityKernel9::cacheConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, cacheConfig) - 4usize];
    [
        "Offset of field: CUpti_ActivityKernel9::sharedMemoryConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, sharedMemoryConfig) - 5usize];
    [
        "Offset of field: CUpti_ActivityKernel9::registersPerThread",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, registersPerThread) - 6usize];
    [
        "Offset of field: CUpti_ActivityKernel9::partitionedGlobalCacheRequested",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, partitionedGlobalCacheRequested)
        - 8usize];
    [
        "Offset of field: CUpti_ActivityKernel9::partitionedGlobalCacheExecuted",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, partitionedGlobalCacheExecuted)
        - 12usize];
    [
        "Offset of field: CUpti_ActivityKernel9::start",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityKernel9::end",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityKernel9::completed",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, completed) - 32usize];
    [
        "Offset of field: CUpti_ActivityKernel9::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, deviceId) - 40usize];
    [
        "Offset of field: CUpti_ActivityKernel9::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, contextId) - 44usize];
    [
        "Offset of field: CUpti_ActivityKernel9::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, streamId) - 48usize];
    [
        "Offset of field: CUpti_ActivityKernel9::gridX",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, gridX) - 52usize];
    [
        "Offset of field: CUpti_ActivityKernel9::gridY",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, gridY) - 56usize];
    [
        "Offset of field: CUpti_ActivityKernel9::gridZ",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, gridZ) - 60usize];
    [
        "Offset of field: CUpti_ActivityKernel9::blockX",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, blockX) - 64usize];
    [
        "Offset of field: CUpti_ActivityKernel9::blockY",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, blockY) - 68usize];
    [
        "Offset of field: CUpti_ActivityKernel9::blockZ",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, blockZ) - 72usize];
    [
        "Offset of field: CUpti_ActivityKernel9::staticSharedMemory",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, staticSharedMemory) - 76usize];
    [
        "Offset of field: CUpti_ActivityKernel9::dynamicSharedMemory",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, dynamicSharedMemory) - 80usize];
    [
        "Offset of field: CUpti_ActivityKernel9::localMemoryPerThread",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, localMemoryPerThread) - 84usize];
    [
        "Offset of field: CUpti_ActivityKernel9::localMemoryTotal",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, localMemoryTotal) - 88usize];
    [
        "Offset of field: CUpti_ActivityKernel9::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, correlationId) - 92usize];
    [
        "Offset of field: CUpti_ActivityKernel9::gridId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, gridId) - 96usize];
    [
        "Offset of field: CUpti_ActivityKernel9::name",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, name) - 104usize];
    [
        "Offset of field: CUpti_ActivityKernel9::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, reserved0) - 112usize];
    [
        "Offset of field: CUpti_ActivityKernel9::queued",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, queued) - 120usize];
    [
        "Offset of field: CUpti_ActivityKernel9::submitted",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, submitted) - 128usize];
    [
        "Offset of field: CUpti_ActivityKernel9::launchType",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, launchType) - 136usize];
    [
        "Offset of field: CUpti_ActivityKernel9::isSharedMemoryCarveoutRequested",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, isSharedMemoryCarveoutRequested)
        - 137usize];
    [
        "Offset of field: CUpti_ActivityKernel9::sharedMemoryCarveoutRequested",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, sharedMemoryCarveoutRequested)
        - 138usize];
    [
        "Offset of field: CUpti_ActivityKernel9::padding",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, padding) - 139usize];
    [
        "Offset of field: CUpti_ActivityKernel9::sharedMemoryExecuted",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, sharedMemoryExecuted) - 140usize];
    [
        "Offset of field: CUpti_ActivityKernel9::graphNodeId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, graphNodeId) - 144usize];
    [
        "Offset of field: CUpti_ActivityKernel9::shmemLimitConfig",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, shmemLimitConfig) - 152usize];
    [
        "Offset of field: CUpti_ActivityKernel9::graphId",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, graphId) - 156usize];
    [
        "Offset of field: CUpti_ActivityKernel9::pAccessPolicyWindow",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, pAccessPolicyWindow) - 160usize];
    [
        "Offset of field: CUpti_ActivityKernel9::channelID",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, channelID) - 168usize];
    [
        "Offset of field: CUpti_ActivityKernel9::channelType",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, channelType) - 172usize];
    [
        "Offset of field: CUpti_ActivityKernel9::clusterX",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, clusterX) - 176usize];
    [
        "Offset of field: CUpti_ActivityKernel9::clusterY",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, clusterY) - 180usize];
    [
        "Offset of field: CUpti_ActivityKernel9::clusterZ",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, clusterZ) - 184usize];
    [
        "Offset of field: CUpti_ActivityKernel9::clusterSchedulingPolicy",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, clusterSchedulingPolicy) - 188usize];
    [
        "Offset of field: CUpti_ActivityKernel9::localMemoryTotal_v2",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, localMemoryTotal_v2) - 192usize];
    [
        "Offset of field: CUpti_ActivityKernel9::maxPotentialClusterSize",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, maxPotentialClusterSize) - 200usize];
    [
        "Offset of field: CUpti_ActivityKernel9::maxActiveClusters",
    ][::std::mem::offset_of!(CUpti_ActivityKernel9, maxActiveClusters) - 204usize];
};
impl Default for CUpti_ActivityKernel9 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel9 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityKernel9 {{ kind: {:?}, cacheConfig: {:?}, partitionedGlobalCacheRequested: {:?}, partitionedGlobalCacheExecuted: {:?}, name: {:?}, reserved0: {:?}, shmemLimitConfig: {:?}, pAccessPolicyWindow: {:?}, channelType: {:?} }}",
            self.kind,
            self.cacheConfig,
            self.partitionedGlobalCacheRequested,
            self.partitionedGlobalCacheExecuted,
            self.name,
            self.reserved0,
            self.shmemLimitConfig,
            self.pAccessPolicyWindow,
            self.channelType,
        )
    }
}
/** \brief The activity record for memory copies. (deprecated)

 This activity record represents a memory copy
 (CUPTI_ACTIVITY_KIND_MEMCPY).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemcpy {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMCPY.
    pub kind: CUpti_ActivityKind,
    /** The kind of the memory copy, stored as a byte to reduce record
 size. \see CUpti_ActivityMemcpyKind*/
    pub copyKind: u8,
    /** The source memory kind read by the memory copy, stored as a byte
 to reduce record size. \see CUpti_ActivityMemoryKind*/
    pub srcKind: u8,
    /** The destination memory kind read by the memory copy, stored as a
 byte to reduce record size. \see CUpti_ActivityMemoryKind*/
    pub dstKind: u8,
    /// The flags associated with the memory copy. \see CUpti_ActivityFlag
    pub flags: u8,
    /// The number of bytes transferred by the memory copy.
    pub bytes: u64,
    /** The start timestamp for the memory copy, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory copy.*/
    pub start: u64,
    /** The end timestamp for the memory copy, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory copy.*/
    pub end: u64,
    /// The ID of the device where the memory copy is occurring.
    pub deviceId: u32,
    /// The ID of the context where the memory copy is occurring.
    pub contextId: u32,
    /// The ID of the stream where the memory copy is occurring.
    pub streamId: u32,
    /** The correlation ID of the memory copy. Each memory copy is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver API activity record that launched
 the memory copy.*/
    pub correlationId: u32,
    /** The runtime correlation ID of the memory copy. Each memory copy
 is assigned a unique runtime correlation ID that is identical to
 the correlation ID in the runtime API activity record that
 launched the memory copy.*/
    pub runtimeCorrelationId: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemcpy",
    ][::std::mem::size_of::<CUpti_ActivityMemcpy>() - 64usize];
    [
        "Alignment of CUpti_ActivityMemcpy",
    ][::std::mem::align_of::<CUpti_ActivityMemcpy>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemcpy::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMemcpy::copyKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy, copyKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityMemcpy::srcKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy, srcKind) - 5usize];
    [
        "Offset of field: CUpti_ActivityMemcpy::dstKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy, dstKind) - 6usize];
    [
        "Offset of field: CUpti_ActivityMemcpy::flags",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy, flags) - 7usize];
    [
        "Offset of field: CUpti_ActivityMemcpy::bytes",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy, bytes) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemcpy::start",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityMemcpy::end",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityMemcpy::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy, deviceId) - 32usize];
    [
        "Offset of field: CUpti_ActivityMemcpy::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy, contextId) - 36usize];
    [
        "Offset of field: CUpti_ActivityMemcpy::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy, streamId) - 40usize];
    [
        "Offset of field: CUpti_ActivityMemcpy::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy, correlationId) - 44usize];
    [
        "Offset of field: CUpti_ActivityMemcpy::runtimeCorrelationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy, runtimeCorrelationId) - 48usize];
    [
        "Offset of field: CUpti_ActivityMemcpy::pad",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy, pad) - 52usize];
    [
        "Offset of field: CUpti_ActivityMemcpy::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy, reserved0) - 56usize];
};
impl Default for CUpti_ActivityMemcpy {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for memory copies. (deprecated in CUDA 11.1)

 This activity record represents a memory copy
 (CUPTI_ACTIVITY_KIND_MEMCPY).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemcpy3 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMCPY.
    pub kind: CUpti_ActivityKind,
    /** The kind of the memory copy, stored as a byte to reduce record
 size. \see CUpti_ActivityMemcpyKind*/
    pub copyKind: u8,
    /** The source memory kind read by the memory copy, stored as a byte
 to reduce record size. \see CUpti_ActivityMemoryKind*/
    pub srcKind: u8,
    /** The destination memory kind read by the memory copy, stored as a
 byte to reduce record size. \see CUpti_ActivityMemoryKind*/
    pub dstKind: u8,
    /// The flags associated with the memory copy. \see CUpti_ActivityFlag
    pub flags: u8,
    /// The number of bytes transferred by the memory copy.
    pub bytes: u64,
    /** The start timestamp for the memory copy, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory copy.*/
    pub start: u64,
    /** The end timestamp for the memory copy, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory copy.*/
    pub end: u64,
    /// The ID of the device where the memory copy is occurring.
    pub deviceId: u32,
    /// The ID of the context where the memory copy is occurring.
    pub contextId: u32,
    /// The ID of the stream where the memory copy is occurring.
    pub streamId: u32,
    /** The correlation ID of the memory copy. Each memory copy is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver API activity record that launched
 the memory copy.*/
    pub correlationId: u32,
    /** The runtime correlation ID of the memory copy. Each memory copy
 is assigned a unique runtime correlation ID that is identical to
 the correlation ID in the runtime API activity record that
 launched the memory copy.*/
    pub runtimeCorrelationId: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
    /** The unique ID of the graph node that executed this memcpy through graph launch.
 This field will be 0 if the memcpy is not done through graph launch.*/
    pub graphNodeId: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemcpy3",
    ][::std::mem::size_of::<CUpti_ActivityMemcpy3>() - 72usize];
    [
        "Alignment of CUpti_ActivityMemcpy3",
    ][::std::mem::align_of::<CUpti_ActivityMemcpy3>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemcpy3::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy3, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMemcpy3::copyKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy3, copyKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityMemcpy3::srcKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy3, srcKind) - 5usize];
    [
        "Offset of field: CUpti_ActivityMemcpy3::dstKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy3, dstKind) - 6usize];
    [
        "Offset of field: CUpti_ActivityMemcpy3::flags",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy3, flags) - 7usize];
    [
        "Offset of field: CUpti_ActivityMemcpy3::bytes",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy3, bytes) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemcpy3::start",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy3, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityMemcpy3::end",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy3, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityMemcpy3::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy3, deviceId) - 32usize];
    [
        "Offset of field: CUpti_ActivityMemcpy3::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy3, contextId) - 36usize];
    [
        "Offset of field: CUpti_ActivityMemcpy3::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy3, streamId) - 40usize];
    [
        "Offset of field: CUpti_ActivityMemcpy3::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy3, correlationId) - 44usize];
    [
        "Offset of field: CUpti_ActivityMemcpy3::runtimeCorrelationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy3, runtimeCorrelationId) - 48usize];
    [
        "Offset of field: CUpti_ActivityMemcpy3::pad",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy3, pad) - 52usize];
    [
        "Offset of field: CUpti_ActivityMemcpy3::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy3, reserved0) - 56usize];
    [
        "Offset of field: CUpti_ActivityMemcpy3::graphNodeId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy3, graphNodeId) - 64usize];
};
impl Default for CUpti_ActivityMemcpy3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for memory copies. (deprecated in CUDA 11.6)

 This activity record represents a memory copy
 (CUPTI_ACTIVITY_KIND_MEMCPY).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemcpy4 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMCPY.
    pub kind: CUpti_ActivityKind,
    /** The kind of the memory copy, stored as a byte to reduce record
 size. \see CUpti_ActivityMemcpyKind*/
    pub copyKind: u8,
    /** The source memory kind read by the memory copy, stored as a byte
 to reduce record size. \see CUpti_ActivityMemoryKind*/
    pub srcKind: u8,
    /** The destination memory kind read by the memory copy, stored as a
 byte to reduce record size. \see CUpti_ActivityMemoryKind*/
    pub dstKind: u8,
    /// The flags associated with the memory copy. \see CUpti_ActivityFlag
    pub flags: u8,
    /// The number of bytes transferred by the memory copy.
    pub bytes: u64,
    /** The start timestamp for the memory copy, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory copy.*/
    pub start: u64,
    /** The end timestamp for the memory copy, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory copy.*/
    pub end: u64,
    /// The ID of the device where the memory copy is occurring.
    pub deviceId: u32,
    /// The ID of the context where the memory copy is occurring.
    pub contextId: u32,
    /// The ID of the stream where the memory copy is occurring.
    pub streamId: u32,
    /** The correlation ID of the memory copy. Each memory copy is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver API activity record that launched
 the memory copy.*/
    pub correlationId: u32,
    /** The runtime correlation ID of the memory copy. Each memory copy
 is assigned a unique runtime correlation ID that is identical to
 the correlation ID in the runtime API activity record that
 launched the memory copy.*/
    pub runtimeCorrelationId: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
    /** The unique ID of the graph node that executed this memcpy through graph launch.
 This field will be 0 if the memcpy is not done through graph launch.*/
    pub graphNodeId: u64,
    /** The unique ID of the graph that executed this memcpy through graph launch.
 This field will be 0 if the memcpy is not done through graph launch.*/
    pub graphId: u32,
    /// Undefined. Reserved for internal use.
    pub padding: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemcpy4",
    ][::std::mem::size_of::<CUpti_ActivityMemcpy4>() - 80usize];
    [
        "Alignment of CUpti_ActivityMemcpy4",
    ][::std::mem::align_of::<CUpti_ActivityMemcpy4>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemcpy4::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy4, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMemcpy4::copyKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy4, copyKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityMemcpy4::srcKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy4, srcKind) - 5usize];
    [
        "Offset of field: CUpti_ActivityMemcpy4::dstKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy4, dstKind) - 6usize];
    [
        "Offset of field: CUpti_ActivityMemcpy4::flags",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy4, flags) - 7usize];
    [
        "Offset of field: CUpti_ActivityMemcpy4::bytes",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy4, bytes) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemcpy4::start",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy4, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityMemcpy4::end",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy4, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityMemcpy4::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy4, deviceId) - 32usize];
    [
        "Offset of field: CUpti_ActivityMemcpy4::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy4, contextId) - 36usize];
    [
        "Offset of field: CUpti_ActivityMemcpy4::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy4, streamId) - 40usize];
    [
        "Offset of field: CUpti_ActivityMemcpy4::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy4, correlationId) - 44usize];
    [
        "Offset of field: CUpti_ActivityMemcpy4::runtimeCorrelationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy4, runtimeCorrelationId) - 48usize];
    [
        "Offset of field: CUpti_ActivityMemcpy4::pad",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy4, pad) - 52usize];
    [
        "Offset of field: CUpti_ActivityMemcpy4::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy4, reserved0) - 56usize];
    [
        "Offset of field: CUpti_ActivityMemcpy4::graphNodeId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy4, graphNodeId) - 64usize];
    [
        "Offset of field: CUpti_ActivityMemcpy4::graphId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy4, graphId) - 72usize];
    [
        "Offset of field: CUpti_ActivityMemcpy4::padding",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy4, padding) - 76usize];
};
impl Default for CUpti_ActivityMemcpy4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for peer-to-peer memory copies.

 This activity record represents a peer-to-peer memory copy
 (CUPTI_ACTIVITY_KIND_MEMCPY2) but is no longer generated
 by CUPTI. Peer-to-peer memory copy activities are now reported using the
 CUpti_ActivityMemcpyPtoP2 activity record..*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemcpyPtoP {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMCPY2.
    pub kind: CUpti_ActivityKind,
    /** The kind of the memory copy, stored as a byte to reduce record
 size.  \see CUpti_ActivityMemcpyKind*/
    pub copyKind: u8,
    /** The source memory kind read by the memory copy, stored as a byte
 to reduce record size.  \see CUpti_ActivityMemoryKind*/
    pub srcKind: u8,
    /** The destination memory kind read by the memory copy, stored as a
 byte to reduce record size.  \see CUpti_ActivityMemoryKind*/
    pub dstKind: u8,
    /** The flags associated with the memory copy. \see
 CUpti_ActivityFlag*/
    pub flags: u8,
    /// The number of bytes transferred by the memory copy.
    pub bytes: u64,
    /** The start timestamp for the memory copy, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory copy.*/
    pub start: u64,
    /** The end timestamp for the memory copy, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory copy.*/
    pub end: u64,
    /// The ID of the device where the memory copy is occurring.
    pub deviceId: u32,
    /// The ID of the context where the memory copy is occurring.
    pub contextId: u32,
    /// The ID of the stream where the memory copy is occurring.
    pub streamId: u32,
    /// The ID of the device where memory is being copied from.
    pub srcDeviceId: u32,
    /// The ID of the context owning the memory being copied from.
    pub srcContextId: u32,
    /// The ID of the device where memory is being copied to.
    pub dstDeviceId: u32,
    /// The ID of the context owning the memory being copied to.
    pub dstContextId: u32,
    /** The correlation ID of the memory copy. Each memory copy is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver and runtime API activity record that
 launched the memory copy.*/
    pub correlationId: u32,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemcpyPtoP",
    ][::std::mem::size_of::<CUpti_ActivityMemcpyPtoP>() - 72usize];
    [
        "Alignment of CUpti_ActivityMemcpyPtoP",
    ][::std::mem::align_of::<CUpti_ActivityMemcpyPtoP>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP::copyKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, copyKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP::srcKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, srcKind) - 5usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP::dstKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, dstKind) - 6usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP::flags",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, flags) - 7usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP::bytes",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, bytes) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP::start",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP::end",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, deviceId) - 32usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, contextId) - 36usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, streamId) - 40usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP::srcDeviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, srcDeviceId) - 44usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP::srcContextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, srcContextId) - 48usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP::dstDeviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, dstDeviceId) - 52usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP::dstContextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, dstContextId) - 56usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, correlationId) - 60usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, reserved0) - 64usize];
};
impl Default for CUpti_ActivityMemcpyPtoP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for peer-to-peer memory copies.

 This activity record represents a peer-to-peer memory copy
 (CUPTI_ACTIVITY_KIND_MEMCPY2) but is no longer generated
 by CUPTI. Peer-to-peer memory copy activities are now reported using the
 CUpti_ActivityMemcpyPtoP2 activity record..*/
pub type CUpti_ActivityMemcpy2 = CUpti_ActivityMemcpyPtoP;
/** \brief The activity record for peer-to-peer memory copies.
 (deprecated in CUDA 11.1)

 This activity record represents a peer-to-peer memory copy
 (CUPTI_ACTIVITY_KIND_MEMCPY2).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemcpyPtoP2 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMCPY2.
    pub kind: CUpti_ActivityKind,
    /** The kind of the memory copy, stored as a byte to reduce record
 size.  \see CUpti_ActivityMemcpyKind*/
    pub copyKind: u8,
    /** The source memory kind read by the memory copy, stored as a byte
 to reduce record size.  \see CUpti_ActivityMemoryKind*/
    pub srcKind: u8,
    /** The destination memory kind read by the memory copy, stored as a
 byte to reduce record size.  \see CUpti_ActivityMemoryKind*/
    pub dstKind: u8,
    /** The flags associated with the memory copy. \see
 CUpti_ActivityFlag*/
    pub flags: u8,
    /// The number of bytes transferred by the memory copy.
    pub bytes: u64,
    /** The start timestamp for the memory copy, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory copy.*/
    pub start: u64,
    /** The end timestamp for the memory copy, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory copy.*/
    pub end: u64,
    /// The ID of the device where the memory copy is occurring.
    pub deviceId: u32,
    /// The ID of the context where the memory copy is occurring.
    pub contextId: u32,
    /// The ID of the stream where the memory copy is occurring.
    pub streamId: u32,
    /// The ID of the device where memory is being copied from.
    pub srcDeviceId: u32,
    /// The ID of the context owning the memory being copied from.
    pub srcContextId: u32,
    /// The ID of the device where memory is being copied to.
    pub dstDeviceId: u32,
    /// The ID of the context owning the memory being copied to.
    pub dstContextId: u32,
    /** The correlation ID of the memory copy. Each memory copy is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver and runtime API activity record that
 launched the memory copy.*/
    pub correlationId: u32,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
    /** The unique ID of the graph node that executed the memcpy through graph launch.
 This field will be 0 if memcpy is not done using graph launch.*/
    pub graphNodeId: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemcpyPtoP2",
    ][::std::mem::size_of::<CUpti_ActivityMemcpyPtoP2>() - 80usize];
    [
        "Alignment of CUpti_ActivityMemcpyPtoP2",
    ][::std::mem::align_of::<CUpti_ActivityMemcpyPtoP2>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP2::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP2::copyKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, copyKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP2::srcKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, srcKind) - 5usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP2::dstKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, dstKind) - 6usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP2::flags",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, flags) - 7usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP2::bytes",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, bytes) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP2::start",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP2::end",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP2::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, deviceId) - 32usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP2::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, contextId) - 36usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP2::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, streamId) - 40usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP2::srcDeviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, srcDeviceId) - 44usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP2::srcContextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, srcContextId) - 48usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP2::dstDeviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, dstDeviceId) - 52usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP2::dstContextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, dstContextId) - 56usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP2::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, correlationId) - 60usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP2::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, reserved0) - 64usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP2::graphNodeId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, graphNodeId) - 72usize];
};
impl Default for CUpti_ActivityMemcpyPtoP2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for peer-to-peer memory copies.
 (deprecated in CUDA 11.6)

 This activity record represents a peer-to-peer memory copy
 (CUPTI_ACTIVITY_KIND_MEMCPY2).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemcpyPtoP3 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMCPY2.
    pub kind: CUpti_ActivityKind,
    /** The kind of the memory copy, stored as a byte to reduce record
 size.  \see CUpti_ActivityMemcpyKind*/
    pub copyKind: u8,
    /** The source memory kind read by the memory copy, stored as a byte
 to reduce record size.  \see CUpti_ActivityMemoryKind*/
    pub srcKind: u8,
    /** The destination memory kind read by the memory copy, stored as a
 byte to reduce record size.  \see CUpti_ActivityMemoryKind*/
    pub dstKind: u8,
    /** The flags associated with the memory copy. \see
 CUpti_ActivityFlag*/
    pub flags: u8,
    /// The number of bytes transferred by the memory copy.
    pub bytes: u64,
    /** The start timestamp for the memory copy, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory copy.*/
    pub start: u64,
    /** The end timestamp for the memory copy, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory copy.*/
    pub end: u64,
    /// The ID of the device where the memory copy is occurring.
    pub deviceId: u32,
    /// The ID of the context where the memory copy is occurring.
    pub contextId: u32,
    /// The ID of the stream where the memory copy is occurring.
    pub streamId: u32,
    /// The ID of the device where memory is being copied from.
    pub srcDeviceId: u32,
    /// The ID of the context owning the memory being copied from.
    pub srcContextId: u32,
    /// The ID of the device where memory is being copied to.
    pub dstDeviceId: u32,
    /// The ID of the context owning the memory being copied to.
    pub dstContextId: u32,
    /** The correlation ID of the memory copy. Each memory copy is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver and runtime API activity record that
 launched the memory copy.*/
    pub correlationId: u32,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
    /** The unique ID of the graph node that executed the memcpy through graph launch.
 This field will be 0 if memcpy is not done using graph launch.*/
    pub graphNodeId: u64,
    /** The unique ID of the graph that executed this memcpy through graph launch.
 This field will be 0 if the memcpy is not done through graph launch.*/
    pub graphId: u32,
    /// Undefined. Reserved for internal use.
    pub padding: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemcpyPtoP3",
    ][::std::mem::size_of::<CUpti_ActivityMemcpyPtoP3>() - 88usize];
    [
        "Alignment of CUpti_ActivityMemcpyPtoP3",
    ][::std::mem::align_of::<CUpti_ActivityMemcpyPtoP3>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP3::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP3::copyKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, copyKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP3::srcKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, srcKind) - 5usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP3::dstKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, dstKind) - 6usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP3::flags",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, flags) - 7usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP3::bytes",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, bytes) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP3::start",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP3::end",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP3::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, deviceId) - 32usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP3::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, contextId) - 36usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP3::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, streamId) - 40usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP3::srcDeviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, srcDeviceId) - 44usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP3::srcContextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, srcContextId) - 48usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP3::dstDeviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, dstDeviceId) - 52usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP3::dstContextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, dstContextId) - 56usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP3::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, correlationId) - 60usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP3::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, reserved0) - 64usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP3::graphNodeId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, graphNodeId) - 72usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP3::graphId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, graphId) - 80usize];
    [
        "Offset of field: CUpti_ActivityMemcpyPtoP3::padding",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, padding) - 84usize];
};
impl Default for CUpti_ActivityMemcpyPtoP3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for memset. (deprecated)

 This activity record represents a memory set operation
 (CUPTI_ACTIVITY_KIND_MEMSET).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemset {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMSET.
    pub kind: CUpti_ActivityKind,
    /// The value being assigned to memory by the memory set.
    pub value: u32,
    /// The number of bytes being set by the memory set.
    pub bytes: u64,
    /** The start timestamp for the memory set, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory set.*/
    pub start: u64,
    /** The end timestamp for the memory set, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory set.*/
    pub end: u64,
    /// The ID of the device where the memory set is occurring.
    pub deviceId: u32,
    /// The ID of the context where the memory set is occurring.
    pub contextId: u32,
    /// The ID of the stream where the memory set is occurring.
    pub streamId: u32,
    /** The correlation ID of the memory set. Each memory set is assigned
 a unique correlation ID that is identical to the correlation ID
 in the driver API activity record that launched the memory set.*/
    pub correlationId: u32,
    /// The flags associated with the memset. \see CUpti_ActivityFlag
    pub flags: u16,
    /// The memory kind of the memory set \see CUpti_ActivityMemoryKind
    pub memoryKind: u16,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemset",
    ][::std::mem::size_of::<CUpti_ActivityMemset>() - 64usize];
    [
        "Alignment of CUpti_ActivityMemset",
    ][::std::mem::align_of::<CUpti_ActivityMemset>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemset::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMemset, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMemset::value",
    ][::std::mem::offset_of!(CUpti_ActivityMemset, value) - 4usize];
    [
        "Offset of field: CUpti_ActivityMemset::bytes",
    ][::std::mem::offset_of!(CUpti_ActivityMemset, bytes) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemset::start",
    ][::std::mem::offset_of!(CUpti_ActivityMemset, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityMemset::end",
    ][::std::mem::offset_of!(CUpti_ActivityMemset, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityMemset::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemset, deviceId) - 32usize];
    [
        "Offset of field: CUpti_ActivityMemset::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemset, contextId) - 36usize];
    [
        "Offset of field: CUpti_ActivityMemset::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityMemset, streamId) - 40usize];
    [
        "Offset of field: CUpti_ActivityMemset::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemset, correlationId) - 44usize];
    [
        "Offset of field: CUpti_ActivityMemset::flags",
    ][::std::mem::offset_of!(CUpti_ActivityMemset, flags) - 48usize];
    [
        "Offset of field: CUpti_ActivityMemset::memoryKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemset, memoryKind) - 50usize];
    [
        "Offset of field: CUpti_ActivityMemset::pad",
    ][::std::mem::offset_of!(CUpti_ActivityMemset, pad) - 52usize];
    [
        "Offset of field: CUpti_ActivityMemset::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityMemset, reserved0) - 56usize];
};
impl Default for CUpti_ActivityMemset {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for memset. (deprecated in CUDA 11.1)

 This activity record represents a memory set operation
 (CUPTI_ACTIVITY_KIND_MEMSET).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemset2 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMSET.
    pub kind: CUpti_ActivityKind,
    /// The value being assigned to memory by the memory set.
    pub value: u32,
    /// The number of bytes being set by the memory set.
    pub bytes: u64,
    /** The start timestamp for the memory set, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory set.*/
    pub start: u64,
    /** The end timestamp for the memory set, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory set.*/
    pub end: u64,
    /// The ID of the device where the memory set is occurring.
    pub deviceId: u32,
    /// The ID of the context where the memory set is occurring.
    pub contextId: u32,
    /// The ID of the stream where the memory set is occurring.
    pub streamId: u32,
    /** The correlation ID of the memory set. Each memory set is assigned
 a unique correlation ID that is identical to the correlation ID
 in the driver API activity record that launched the memory set.*/
    pub correlationId: u32,
    /// The flags associated with the memset. \see CUpti_ActivityFlag
    pub flags: u16,
    /// The memory kind of the memory set \see CUpti_ActivityMemoryKind
    pub memoryKind: u16,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
    /** The unique ID of the graph node that executed this memset through graph launch.
 This field will be 0 if the memset is not executed through graph launch.*/
    pub graphNodeId: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemset2",
    ][::std::mem::size_of::<CUpti_ActivityMemset2>() - 72usize];
    [
        "Alignment of CUpti_ActivityMemset2",
    ][::std::mem::align_of::<CUpti_ActivityMemset2>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemset2::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMemset2, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMemset2::value",
    ][::std::mem::offset_of!(CUpti_ActivityMemset2, value) - 4usize];
    [
        "Offset of field: CUpti_ActivityMemset2::bytes",
    ][::std::mem::offset_of!(CUpti_ActivityMemset2, bytes) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemset2::start",
    ][::std::mem::offset_of!(CUpti_ActivityMemset2, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityMemset2::end",
    ][::std::mem::offset_of!(CUpti_ActivityMemset2, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityMemset2::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemset2, deviceId) - 32usize];
    [
        "Offset of field: CUpti_ActivityMemset2::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemset2, contextId) - 36usize];
    [
        "Offset of field: CUpti_ActivityMemset2::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityMemset2, streamId) - 40usize];
    [
        "Offset of field: CUpti_ActivityMemset2::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemset2, correlationId) - 44usize];
    [
        "Offset of field: CUpti_ActivityMemset2::flags",
    ][::std::mem::offset_of!(CUpti_ActivityMemset2, flags) - 48usize];
    [
        "Offset of field: CUpti_ActivityMemset2::memoryKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemset2, memoryKind) - 50usize];
    [
        "Offset of field: CUpti_ActivityMemset2::pad",
    ][::std::mem::offset_of!(CUpti_ActivityMemset2, pad) - 52usize];
    [
        "Offset of field: CUpti_ActivityMemset2::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityMemset2, reserved0) - 56usize];
    [
        "Offset of field: CUpti_ActivityMemset2::graphNodeId",
    ][::std::mem::offset_of!(CUpti_ActivityMemset2, graphNodeId) - 64usize];
};
impl Default for CUpti_ActivityMemset2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for memset. (deprecated in CUDA 11.6)

 This activity record represents a memory set operation
 (CUPTI_ACTIVITY_KIND_MEMSET).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemset3 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMSET.
    pub kind: CUpti_ActivityKind,
    /// The value being assigned to memory by the memory set.
    pub value: u32,
    /// The number of bytes being set by the memory set.
    pub bytes: u64,
    /** The start timestamp for the memory set, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory set.*/
    pub start: u64,
    /** The end timestamp for the memory set, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory set.*/
    pub end: u64,
    /// The ID of the device where the memory set is occurring.
    pub deviceId: u32,
    /// The ID of the context where the memory set is occurring.
    pub contextId: u32,
    /// The ID of the stream where the memory set is occurring.
    pub streamId: u32,
    /** The correlation ID of the memory set. Each memory set is assigned
 a unique correlation ID that is identical to the correlation ID
 in the driver API activity record that launched the memory set.*/
    pub correlationId: u32,
    /// The flags associated with the memset. \see CUpti_ActivityFlag
    pub flags: u16,
    /// The memory kind of the memory set \see CUpti_ActivityMemoryKind
    pub memoryKind: u16,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
    /** The unique ID of the graph node that executed this memset through graph launch.
 This field will be 0 if the memset is not executed through graph launch.*/
    pub graphNodeId: u64,
    /** The unique ID of the graph that executed this memset through graph launch.
 This field will be 0 if the memset is not executed through graph launch.*/
    pub graphId: u32,
    /// Undefined. Reserved for internal use.
    pub padding: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemset3",
    ][::std::mem::size_of::<CUpti_ActivityMemset3>() - 80usize];
    [
        "Alignment of CUpti_ActivityMemset3",
    ][::std::mem::align_of::<CUpti_ActivityMemset3>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemset3::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMemset3, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMemset3::value",
    ][::std::mem::offset_of!(CUpti_ActivityMemset3, value) - 4usize];
    [
        "Offset of field: CUpti_ActivityMemset3::bytes",
    ][::std::mem::offset_of!(CUpti_ActivityMemset3, bytes) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemset3::start",
    ][::std::mem::offset_of!(CUpti_ActivityMemset3, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityMemset3::end",
    ][::std::mem::offset_of!(CUpti_ActivityMemset3, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityMemset3::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemset3, deviceId) - 32usize];
    [
        "Offset of field: CUpti_ActivityMemset3::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemset3, contextId) - 36usize];
    [
        "Offset of field: CUpti_ActivityMemset3::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityMemset3, streamId) - 40usize];
    [
        "Offset of field: CUpti_ActivityMemset3::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemset3, correlationId) - 44usize];
    [
        "Offset of field: CUpti_ActivityMemset3::flags",
    ][::std::mem::offset_of!(CUpti_ActivityMemset3, flags) - 48usize];
    [
        "Offset of field: CUpti_ActivityMemset3::memoryKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemset3, memoryKind) - 50usize];
    [
        "Offset of field: CUpti_ActivityMemset3::pad",
    ][::std::mem::offset_of!(CUpti_ActivityMemset3, pad) - 52usize];
    [
        "Offset of field: CUpti_ActivityMemset3::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityMemset3, reserved0) - 56usize];
    [
        "Offset of field: CUpti_ActivityMemset3::graphNodeId",
    ][::std::mem::offset_of!(CUpti_ActivityMemset3, graphNodeId) - 64usize];
    [
        "Offset of field: CUpti_ActivityMemset3::graphId",
    ][::std::mem::offset_of!(CUpti_ActivityMemset3, graphId) - 72usize];
    [
        "Offset of field: CUpti_ActivityMemset3::padding",
    ][::std::mem::offset_of!(CUpti_ActivityMemset3, padding) - 76usize];
};
impl Default for CUpti_ActivityMemset3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for memory.

 This activity record represents a memory allocation and free operation
 (CUPTI_ACTIVITY_KIND_MEMORY2).
 This activity record provides separate records for memory allocation and
 memory release operations.
 This allows to correlate the corresponding driver and runtime API
 activity record with the memory operation.

 Note: This activity record is an upgrade over \ref CUpti_ActivityMemory
 enabled using the kind \ref CUPTI_ACTIVITY_KIND_MEMORY.
 \ref CUpti_ActivityMemory provides a single record for the memory
 allocation and memory release operations.*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMemory2 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMORY2
    pub kind: CUpti_ActivityKind,
    /// The memory operation requested by the user, \ref CUpti_ActivityMemoryOperationType.
    pub memoryOperationType: CUpti_ActivityMemoryOperationType,
    /// The memory kind requested by the user, \ref CUpti_ActivityMemoryKind.
    pub memoryKind: CUpti_ActivityMemoryKind,
    /** The correlation ID of the memory operation. Each memory operation is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver and runtime API activity record that
 launched the memory operation.*/
    pub correlationId: u32,
    /// The virtual address of the allocation.
    pub address: u64,
    /// The number of bytes of memory allocated.
    pub bytes: u64,
    /// The start timestamp for the memory operation, in ns.
    pub timestamp: u64,
    /// The program counter of the memory operation.
    pub PC: u64,
    /// The ID of the process to which this record belongs to.
    pub processId: u32,
    /// The ID of the device where the memory operation is taking place.
    pub deviceId: u32,
    /// The ID of the context. If context is NULL, \p contextId is set to CUPTI_INVALID_CONTEXT_ID.
    pub contextId: u32,
    /// The ID of the stream. If memory operation is not async, \p streamId is set to CUPTI_INVALID_STREAM_ID.
    pub streamId: u32,
    /** Variable name. This name is shared across all activity
 records representing the same symbol, and so should not be
 modified.*/
    pub name: *const ::std::os::raw::c_char,
    /// \p isAsync is set if memory operation happens through async memory APIs.
    pub isAsync: u32,
    /// Undefined. Reserved for internal use.
    pub pad1: u32,
    pub memoryPoolConfig: CUpti_ActivityMemory2__bindgen_ty_1,
}
/// The memory pool configuration used for the memory operations.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMemory2__bindgen_ty_1 {
    /// The type of the memory pool, \ref CUpti_ActivityMemoryPoolType
    pub memoryPoolType: CUpti_ActivityMemoryPoolType,
    /// Undefined. Reserved for internal use.
    pub pad2: u32,
    /// The base address of the memory pool.
    pub address: u64,
    /** The release threshold of the memory pool in bytes. \p releaseThreshold is
 valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \ref CUpti_ActivityMemoryPoolType.*/
    pub releaseThreshold: u64,
    pub pool: CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1,
}
/** The size of the memory pool in bytes and the processID of the memory pool.
 \p size is valid if \p memoryPoolType is
 CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \ref CUpti_ActivityMemoryPoolType.
 \p processId is valid if \p memoryPoolType is
 CUPTI_ACTIVITY_MEMORY_POOL_TYPE_IMPORTED, \ref CUpti_ActivityMemoryPoolType.*/
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1 {
    pub size: u64,
    pub processId: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1>()
        - 8usize];
    [
        "Alignment of CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1>()
        - 8usize];
    [
        "Offset of field: CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1::size",
    ][::std::mem::offset_of!(CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1, size)
        - 0usize];
    [
        "Offset of field: CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1::processId",
    ][::std::mem::offset_of!(
        CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1, processId
    ) - 0usize];
};
impl Default for CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemory2__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityMemory2__bindgen_ty_1>() - 32usize];
    [
        "Alignment of CUpti_ActivityMemory2__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityMemory2__bindgen_ty_1>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemory2__bindgen_ty_1::memoryPoolType",
    ][::std::mem::offset_of!(CUpti_ActivityMemory2__bindgen_ty_1, memoryPoolType)
        - 0usize];
    [
        "Offset of field: CUpti_ActivityMemory2__bindgen_ty_1::pad2",
    ][::std::mem::offset_of!(CUpti_ActivityMemory2__bindgen_ty_1, pad2) - 4usize];
    [
        "Offset of field: CUpti_ActivityMemory2__bindgen_ty_1::address",
    ][::std::mem::offset_of!(CUpti_ActivityMemory2__bindgen_ty_1, address) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemory2__bindgen_ty_1::releaseThreshold",
    ][::std::mem::offset_of!(CUpti_ActivityMemory2__bindgen_ty_1, releaseThreshold)
        - 16usize];
    [
        "Offset of field: CUpti_ActivityMemory2__bindgen_ty_1::pool",
    ][::std::mem::offset_of!(CUpti_ActivityMemory2__bindgen_ty_1, pool) - 24usize];
};
impl Default for CUpti_ActivityMemory2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMemory2__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMemory2__bindgen_ty_1 {{ memoryPoolType: {:?}, pool: {:?} }}",
            self.memoryPoolType,
            self.pool,
        )
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemory2",
    ][::std::mem::size_of::<CUpti_ActivityMemory2>() - 112usize];
    [
        "Alignment of CUpti_ActivityMemory2",
    ][::std::mem::align_of::<CUpti_ActivityMemory2>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemory2::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMemory2, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMemory2::memoryOperationType",
    ][::std::mem::offset_of!(CUpti_ActivityMemory2, memoryOperationType) - 4usize];
    [
        "Offset of field: CUpti_ActivityMemory2::memoryKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemory2, memoryKind) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemory2::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemory2, correlationId) - 12usize];
    [
        "Offset of field: CUpti_ActivityMemory2::address",
    ][::std::mem::offset_of!(CUpti_ActivityMemory2, address) - 16usize];
    [
        "Offset of field: CUpti_ActivityMemory2::bytes",
    ][::std::mem::offset_of!(CUpti_ActivityMemory2, bytes) - 24usize];
    [
        "Offset of field: CUpti_ActivityMemory2::timestamp",
    ][::std::mem::offset_of!(CUpti_ActivityMemory2, timestamp) - 32usize];
    [
        "Offset of field: CUpti_ActivityMemory2::PC",
    ][::std::mem::offset_of!(CUpti_ActivityMemory2, PC) - 40usize];
    [
        "Offset of field: CUpti_ActivityMemory2::processId",
    ][::std::mem::offset_of!(CUpti_ActivityMemory2, processId) - 48usize];
    [
        "Offset of field: CUpti_ActivityMemory2::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemory2, deviceId) - 52usize];
    [
        "Offset of field: CUpti_ActivityMemory2::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemory2, contextId) - 56usize];
    [
        "Offset of field: CUpti_ActivityMemory2::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityMemory2, streamId) - 60usize];
    [
        "Offset of field: CUpti_ActivityMemory2::name",
    ][::std::mem::offset_of!(CUpti_ActivityMemory2, name) - 64usize];
    [
        "Offset of field: CUpti_ActivityMemory2::isAsync",
    ][::std::mem::offset_of!(CUpti_ActivityMemory2, isAsync) - 72usize];
    [
        "Offset of field: CUpti_ActivityMemory2::pad1",
    ][::std::mem::offset_of!(CUpti_ActivityMemory2, pad1) - 76usize];
    [
        "Offset of field: CUpti_ActivityMemory2::memoryPoolConfig",
    ][::std::mem::offset_of!(CUpti_ActivityMemory2, memoryPoolConfig) - 80usize];
};
impl Default for CUpti_ActivityMemory2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMemory2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMemory2 {{ kind: {:?}, memoryOperationType: {:?}, memoryKind: {:?}, name: {:?}, memoryPoolConfig: {:?} }}",
            self.kind,
            self.memoryOperationType,
            self.memoryKind,
            self.name,
            self.memoryPoolConfig,
        )
    }
}
/** \brief The activity record for memory.

 This activity record represents a memory allocation and free operation
 (CUPTI_ACTIVITY_KIND_MEMORY2).
 This activity record provides separate records for memory allocation and
 memory release operations.
 This allows to correlate the corresponding driver and runtime API
 activity record with the memory operation.

 Note: This activity record is an upgrade over \ref CUpti_ActivityMemory2
 enabled using the kind \ref CUPTI_ACTIVITY_KIND_MEMORY.
 \ref CUpti_ActivityMemory provides a single record for the memory
 allocation and memory release operations.*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMemory3 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMORY2
    pub kind: CUpti_ActivityKind,
    /// The memory operation requested by the user, \ref CUpti_ActivityMemoryOperationType.
    pub memoryOperationType: CUpti_ActivityMemoryOperationType,
    /// The memory kind requested by the user, \ref CUpti_ActivityMemoryKind.
    pub memoryKind: CUpti_ActivityMemoryKind,
    /** The correlation ID of the memory operation. Each memory operation is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver and runtime API activity record that
 launched the memory operation.*/
    pub correlationId: u32,
    /// The virtual address of the allocation.
    pub address: u64,
    /// The number of bytes of memory allocated.
    pub bytes: u64,
    /// The start timestamp for the memory operation, in ns.
    pub timestamp: u64,
    /// The program counter of the memory operation.
    pub PC: u64,
    /// The ID of the process to which this record belongs to.
    pub processId: u32,
    /// The ID of the device where the memory operation is taking place.
    pub deviceId: u32,
    /// The ID of the context. If context is NULL, \p contextId is set to CUPTI_INVALID_CONTEXT_ID.
    pub contextId: u32,
    /// The ID of the stream. If memory operation is not async, \p streamId is set to CUPTI_INVALID_STREAM_ID.
    pub streamId: u32,
    /** Variable name. This name is shared across all activity
 records representing the same symbol, and so should not be
 modified.*/
    pub name: *const ::std::os::raw::c_char,
    /// \p isAsync is set if memory operation happens through async memory APIs.
    pub isAsync: u32,
    /// Undefined. Reserved for internal use.
    pub pad1: u32,
    pub memoryPoolConfig: CUpti_ActivityMemory3__bindgen_ty_1,
}
/// The memory pool configuration used for the memory operations.
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMemory3__bindgen_ty_1 {
    /// The type of the memory pool, \ref CUpti_ActivityMemoryPoolType
    pub memoryPoolType: CUpti_ActivityMemoryPoolType,
    /// Undefined. Reserved for internal use.
    pub pad2: u32,
    /// The base address of the memory pool.
    pub address: u64,
    /** The release threshold of the memory pool in bytes. \p releaseThreshold is
 valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \ref CUpti_ActivityMemoryPoolType.*/
    pub releaseThreshold: u64,
    pub pool: CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1,
    /** The utilized size of the memory pool. \p utilizedSize is
 valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \ref CUpti_ActivityMemoryPoolType.*/
    pub utilizedSize: u64,
}
/** The size of memory pool in bytes and the processId of the memory pools
 \p size is valid if \p memoryPoolType is
 CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \ref CUpti_ActivityMemoryPoolType.
 \p processId is valid if \p memoryPoolType is
 CUPTI_ACTIVITY_MEMORY_POOL_TYPE_IMPORTED, \ref CUpti_ActivityMemoryPoolType*/
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1 {
    pub size: u64,
    pub processId: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1>()
        - 8usize];
    [
        "Alignment of CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1>()
        - 8usize];
    [
        "Offset of field: CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1::size",
    ][::std::mem::offset_of!(CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1, size)
        - 0usize];
    [
        "Offset of field: CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1::processId",
    ][::std::mem::offset_of!(
        CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1, processId
    ) - 0usize];
};
impl Default for CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemory3__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityMemory3__bindgen_ty_1>() - 40usize];
    [
        "Alignment of CUpti_ActivityMemory3__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityMemory3__bindgen_ty_1>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemory3__bindgen_ty_1::memoryPoolType",
    ][::std::mem::offset_of!(CUpti_ActivityMemory3__bindgen_ty_1, memoryPoolType)
        - 0usize];
    [
        "Offset of field: CUpti_ActivityMemory3__bindgen_ty_1::pad2",
    ][::std::mem::offset_of!(CUpti_ActivityMemory3__bindgen_ty_1, pad2) - 4usize];
    [
        "Offset of field: CUpti_ActivityMemory3__bindgen_ty_1::address",
    ][::std::mem::offset_of!(CUpti_ActivityMemory3__bindgen_ty_1, address) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemory3__bindgen_ty_1::releaseThreshold",
    ][::std::mem::offset_of!(CUpti_ActivityMemory3__bindgen_ty_1, releaseThreshold)
        - 16usize];
    [
        "Offset of field: CUpti_ActivityMemory3__bindgen_ty_1::pool",
    ][::std::mem::offset_of!(CUpti_ActivityMemory3__bindgen_ty_1, pool) - 24usize];
    [
        "Offset of field: CUpti_ActivityMemory3__bindgen_ty_1::utilizedSize",
    ][::std::mem::offset_of!(CUpti_ActivityMemory3__bindgen_ty_1, utilizedSize)
        - 32usize];
};
impl Default for CUpti_ActivityMemory3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMemory3__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMemory3__bindgen_ty_1 {{ memoryPoolType: {:?}, pool: {:?} }}",
            self.memoryPoolType,
            self.pool,
        )
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemory3",
    ][::std::mem::size_of::<CUpti_ActivityMemory3>() - 120usize];
    [
        "Alignment of CUpti_ActivityMemory3",
    ][::std::mem::align_of::<CUpti_ActivityMemory3>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemory3::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMemory3, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMemory3::memoryOperationType",
    ][::std::mem::offset_of!(CUpti_ActivityMemory3, memoryOperationType) - 4usize];
    [
        "Offset of field: CUpti_ActivityMemory3::memoryKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemory3, memoryKind) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemory3::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemory3, correlationId) - 12usize];
    [
        "Offset of field: CUpti_ActivityMemory3::address",
    ][::std::mem::offset_of!(CUpti_ActivityMemory3, address) - 16usize];
    [
        "Offset of field: CUpti_ActivityMemory3::bytes",
    ][::std::mem::offset_of!(CUpti_ActivityMemory3, bytes) - 24usize];
    [
        "Offset of field: CUpti_ActivityMemory3::timestamp",
    ][::std::mem::offset_of!(CUpti_ActivityMemory3, timestamp) - 32usize];
    [
        "Offset of field: CUpti_ActivityMemory3::PC",
    ][::std::mem::offset_of!(CUpti_ActivityMemory3, PC) - 40usize];
    [
        "Offset of field: CUpti_ActivityMemory3::processId",
    ][::std::mem::offset_of!(CUpti_ActivityMemory3, processId) - 48usize];
    [
        "Offset of field: CUpti_ActivityMemory3::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemory3, deviceId) - 52usize];
    [
        "Offset of field: CUpti_ActivityMemory3::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemory3, contextId) - 56usize];
    [
        "Offset of field: CUpti_ActivityMemory3::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityMemory3, streamId) - 60usize];
    [
        "Offset of field: CUpti_ActivityMemory3::name",
    ][::std::mem::offset_of!(CUpti_ActivityMemory3, name) - 64usize];
    [
        "Offset of field: CUpti_ActivityMemory3::isAsync",
    ][::std::mem::offset_of!(CUpti_ActivityMemory3, isAsync) - 72usize];
    [
        "Offset of field: CUpti_ActivityMemory3::pad1",
    ][::std::mem::offset_of!(CUpti_ActivityMemory3, pad1) - 76usize];
    [
        "Offset of field: CUpti_ActivityMemory3::memoryPoolConfig",
    ][::std::mem::offset_of!(CUpti_ActivityMemory3, memoryPoolConfig) - 80usize];
};
impl Default for CUpti_ActivityMemory3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMemory3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMemory3 {{ kind: {:?}, memoryOperationType: {:?}, memoryKind: {:?}, name: {:?}, memoryPoolConfig: {:?} }}",
            self.kind,
            self.memoryOperationType,
            self.memoryKind,
            self.name,
            self.memoryPoolConfig,
        )
    }
}
/** \brief The activity record for memory pool.

 This activity record represents a memory pool creation, destruction and
 trimming (CUPTI_ACTIVITY_KIND_MEMORY_POOL).
 This activity record provides separate records for memory pool creation,
 destruction and trimming operations.
 This allows to correlate the corresponding driver and runtime API
 activity record with the memory pool operation.
*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemoryPool {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMORY_POOL
    pub kind: CUpti_ActivityKind,
    /// The memory operation requested by the user, \ref CUpti_ActivityMemoryPoolOperationType.
    pub memoryPoolOperationType: CUpti_ActivityMemoryPoolOperationType,
    /// The type of the memory pool, \ref CUpti_ActivityMemoryPoolType
    pub memoryPoolType: CUpti_ActivityMemoryPoolType,
    /** The correlation ID of the memory pool operation. Each memory pool
 operation is assigned a unique correlation ID that is identical to the
 correlation ID in the driver and runtime API activity record that
 launched the memory operation.*/
    pub correlationId: u32,
    /// The ID of the process to which this record belongs to.
    pub processId: u32,
    /// The ID of the device where the memory pool is created.
    pub deviceId: u32,
    /** The minimum bytes to keep of the memory pool. \p minBytesToKeep is
 valid for CUPTI_ACTIVITY_MEMORY_POOL_OPERATION_TYPE_TRIMMED,
 \ref CUpti_ActivityMemoryPoolOperationType*/
    pub minBytesToKeep: usize,
    /// The virtual address of the allocation.
    pub address: u64,
    /** The size of the memory pool operation in bytes. \p size is
 valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \ref CUpti_ActivityMemoryPoolType.*/
    pub size: u64,
    /** The release threshold of the memory pool. \p releaseThreshold is
 valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \ref CUpti_ActivityMemoryPoolType.*/
    pub releaseThreshold: u64,
    /// The start timestamp for the memory operation, in ns.
    pub timestamp: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemoryPool",
    ][::std::mem::size_of::<CUpti_ActivityMemoryPool>() - 64usize];
    [
        "Alignment of CUpti_ActivityMemoryPool",
    ][::std::mem::align_of::<CUpti_ActivityMemoryPool>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool::memoryPoolOperationType",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool, memoryPoolOperationType)
        - 4usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool::memoryPoolType",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool, memoryPoolType) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool, correlationId) - 12usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool::processId",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool, processId) - 16usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool, deviceId) - 20usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool::minBytesToKeep",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool, minBytesToKeep) - 24usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool::address",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool, address) - 32usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool::size",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool, size) - 40usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool::releaseThreshold",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool, releaseThreshold) - 48usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool::timestamp",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool, timestamp) - 56usize];
};
impl Default for CUpti_ActivityMemoryPool {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for memory pool.

 This activity record represents a memory pool creation, destruction and
 trimming (CUPTI_ACTIVITY_KIND_MEMORY_POOL).
 This activity record provides separate records for memory pool creation,
 destruction and trimming operations.
 This allows to correlate the corresponding driver and runtime API
 activity record with the memory pool operation.
*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemoryPool2 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMORY_POOL
    pub kind: CUpti_ActivityKind,
    /// The memory operation requested by the user, \ref CUpti_ActivityMemoryPoolOperationType.
    pub memoryPoolOperationType: CUpti_ActivityMemoryPoolOperationType,
    /// The type of the memory pool, \ref CUpti_ActivityMemoryPoolType
    pub memoryPoolType: CUpti_ActivityMemoryPoolType,
    /** The correlation ID of the memory pool operation. Each memory pool
 operation is assigned a unique correlation ID that is identical to the
 correlation ID in the driver and runtime API activity record that
 launched the memory operation.*/
    pub correlationId: u32,
    /// The ID of the process to which this record belongs to.
    pub processId: u32,
    /// The ID of the device where the memory pool is created.
    pub deviceId: u32,
    /** The minimum bytes to keep of the memory pool. \p minBytesToKeep is
 valid for CUPTI_ACTIVITY_MEMORY_POOL_OPERATION_TYPE_TRIMMED,
 \ref CUpti_ActivityMemoryPoolOperationType*/
    pub minBytesToKeep: usize,
    /// The virtual address of the allocation.
    pub address: u64,
    /** The size of the memory pool operation in bytes. \p size is
 valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \ref CUpti_ActivityMemoryPoolType.*/
    pub size: u64,
    /** The release threshold of the memory pool. \p releaseThreshold is
 valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \ref CUpti_ActivityMemoryPoolType.*/
    pub releaseThreshold: u64,
    /// The start timestamp for the memory operation, in ns.
    pub timestamp: u64,
    /** The utilized size of the memory pool. \p utilizedSize is
 valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \ref CUpti_ActivityMemoryPoolType.*/
    pub utilizedSize: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemoryPool2",
    ][::std::mem::size_of::<CUpti_ActivityMemoryPool2>() - 72usize];
    [
        "Alignment of CUpti_ActivityMemoryPool2",
    ][::std::mem::align_of::<CUpti_ActivityMemoryPool2>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool2::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool2, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool2::memoryPoolOperationType",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool2, memoryPoolOperationType)
        - 4usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool2::memoryPoolType",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool2, memoryPoolType) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool2::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool2, correlationId) - 12usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool2::processId",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool2, processId) - 16usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool2::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool2, deviceId) - 20usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool2::minBytesToKeep",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool2, minBytesToKeep) - 24usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool2::address",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool2, address) - 32usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool2::size",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool2, size) - 40usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool2::releaseThreshold",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool2, releaseThreshold) - 48usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool2::timestamp",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool2, timestamp) - 56usize];
    [
        "Offset of field: CUpti_ActivityMemoryPool2::utilizedSize",
    ][::std::mem::offset_of!(CUpti_ActivityMemoryPool2, utilizedSize) - 64usize];
};
impl Default for CUpti_ActivityMemoryPool2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record providing a marker which is an
 instantaneous point in time. (deprecated in CUDA 8.0)

 The marker is specified with a descriptive name and unique id
 (CUPTI_ACTIVITY_KIND_MARKER).
 Marker activity is now reported using the
 CUpti_ActivityMarker2 activity record.*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMarker {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MARKER.
    pub kind: CUpti_ActivityKind,
    /// The flags associated with the marker. \see CUpti_ActivityFlag
    pub flags: CUpti_ActivityFlag,
    /** The timestamp for the marker, in ns. A value of 0 indicates that
 timestamp information could not be collected for the marker.*/
    pub timestamp: u64,
    /// The marker ID.
    pub id: u32,
    /// The kind of activity object associated with this marker.
    pub objectKind: CUpti_ActivityObjectKind,
    /** The identifier for the activity object associated with this
 marker. 'objectKind' indicates which ID is valid for this record.*/
    pub objectId: CUpti_ActivityObjectKindId,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
    /** The marker name for an instantaneous or start marker. This will
 be NULL for an end marker.*/
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMarker",
    ][::std::mem::size_of::<CUpti_ActivityMarker>() - 48usize];
    [
        "Alignment of CUpti_ActivityMarker",
    ][::std::mem::align_of::<CUpti_ActivityMarker>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMarker::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMarker, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMarker::flags",
    ][::std::mem::offset_of!(CUpti_ActivityMarker, flags) - 4usize];
    [
        "Offset of field: CUpti_ActivityMarker::timestamp",
    ][::std::mem::offset_of!(CUpti_ActivityMarker, timestamp) - 8usize];
    [
        "Offset of field: CUpti_ActivityMarker::id",
    ][::std::mem::offset_of!(CUpti_ActivityMarker, id) - 16usize];
    [
        "Offset of field: CUpti_ActivityMarker::objectKind",
    ][::std::mem::offset_of!(CUpti_ActivityMarker, objectKind) - 20usize];
    [
        "Offset of field: CUpti_ActivityMarker::objectId",
    ][::std::mem::offset_of!(CUpti_ActivityMarker, objectId) - 24usize];
    [
        "Offset of field: CUpti_ActivityMarker::pad",
    ][::std::mem::offset_of!(CUpti_ActivityMarker, pad) - 36usize];
    [
        "Offset of field: CUpti_ActivityMarker::name",
    ][::std::mem::offset_of!(CUpti_ActivityMarker, name) - 40usize];
};
impl Default for CUpti_ActivityMarker {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMarker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMarker {{ kind: {:?}, flags: {:?}, objectKind: {:?}, objectId: {:?}, name: {:?} }}",
            self.kind,
            self.flags,
            self.objectKind,
            self.objectId,
            self.name,
        )
    }
}
/** \brief The activity record for source-level global
 access. (deprecated)

 This activity records the locations of the global
 accesses in the source (CUPTI_ACTIVITY_KIND_GLOBAL_ACCESS).
 Global access activities are now reported using the
 CUpti_ActivityGlobalAccess3 activity record.*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityGlobalAccess {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_GLOBAL_ACCESS.
    pub kind: CUpti_ActivityKind,
    /// The properties of this global access.
    pub flags: CUpti_ActivityFlag,
    /// The ID for source locator.
    pub sourceLocatorId: u32,
    /// The correlation ID of the kernel to which this result is associated.
    pub correlationId: u32,
    /// The pc offset for the access.
    pub pcOffset: u32,
    /** The number of times this instruction was executed per warp. It will be incremented
 when at least one of thread among warp is active with predicate and condition code
 evaluating to true.*/
    pub executed: u32,
    /** This increments each time when this instruction is executed by number
 of threads that executed this instruction with predicate and condition code evaluating to true.*/
    pub threadsExecuted: u64,
    /// The total number of 32 bytes transactions to L2 cache generated by this access
    pub l2_transactions: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityGlobalAccess",
    ][::std::mem::size_of::<CUpti_ActivityGlobalAccess>() - 40usize];
    [
        "Alignment of CUpti_ActivityGlobalAccess",
    ][::std::mem::align_of::<CUpti_ActivityGlobalAccess>() - 8usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess::kind",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess::flags",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess, flags) - 4usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess::sourceLocatorId",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess, sourceLocatorId) - 8usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess, correlationId) - 12usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess::pcOffset",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess, pcOffset) - 16usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess::executed",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess, executed) - 20usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess::threadsExecuted",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess, threadsExecuted) - 24usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess::l2_transactions",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess, l2_transactions) - 32usize];
};
impl Default for CUpti_ActivityGlobalAccess {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for source-level global
 access. (deprecated in CUDA 9.0)

 This activity records the locations of the global
 accesses in the source (CUPTI_ACTIVITY_KIND_GLOBAL_ACCESS).
 Global access activities are now reported using the
 CUpti_ActivityGlobalAccess3 activity record.*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityGlobalAccess2 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_GLOBAL_ACCESS.
    pub kind: CUpti_ActivityKind,
    /// The properties of this global access.
    pub flags: CUpti_ActivityFlag,
    /// The ID for source locator.
    pub sourceLocatorId: u32,
    /// The correlation ID of the kernel to which this result is associated.
    pub correlationId: u32,
    /// Correlation ID with global/device function name
    pub functionId: u32,
    /// The pc offset for the access.
    pub pcOffset: u32,
    /** This increments each time when this instruction is executed by number
 of threads that executed this instruction with predicate and condition code evaluating to true.*/
    pub threadsExecuted: u64,
    /// The total number of 32 bytes transactions to L2 cache generated by this access
    pub l2_transactions: u64,
    /// The minimum number of L2 transactions possible based on the access pattern.
    pub theoreticalL2Transactions: u64,
    /** The number of times this instruction was executed per warp. It will be incremented
 when at least one of thread among warp is active with predicate and condition code
 evaluating to true.*/
    pub executed: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityGlobalAccess2",
    ][::std::mem::size_of::<CUpti_ActivityGlobalAccess2>() - 56usize];
    [
        "Alignment of CUpti_ActivityGlobalAccess2",
    ][::std::mem::align_of::<CUpti_ActivityGlobalAccess2>() - 8usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess2::kind",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess2, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess2::flags",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess2, flags) - 4usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess2::sourceLocatorId",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess2, sourceLocatorId) - 8usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess2::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess2, correlationId) - 12usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess2::functionId",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess2, functionId) - 16usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess2::pcOffset",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess2, pcOffset) - 20usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess2::threadsExecuted",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess2, threadsExecuted) - 24usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess2::l2_transactions",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess2, l2_transactions) - 32usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess2::theoreticalL2Transactions",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess2, theoreticalL2Transactions)
        - 40usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess2::executed",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess2, executed) - 48usize];
    [
        "Offset of field: CUpti_ActivityGlobalAccess2::pad",
    ][::std::mem::offset_of!(CUpti_ActivityGlobalAccess2, pad) - 52usize];
};
impl Default for CUpti_ActivityGlobalAccess2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for source level result
 branch. (deprecated)

 This activity record the locations of the branches in the
 source (CUPTI_ACTIVITY_KIND_BRANCH).
 Branch activities are now reported using the
 CUpti_ActivityBranch2 activity record.*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityBranch {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_BRANCH.
    pub kind: CUpti_ActivityKind,
    /// The ID for source locator.
    pub sourceLocatorId: u32,
    /// The correlation ID of the kernel to which this result is associated.
    pub correlationId: u32,
    /// The pc offset for the branch.
    pub pcOffset: u32,
    /** The number of times this instruction was executed per warp. It will be incremented
 regardless of predicate or condition code.*/
    pub executed: u32,
    /// Number of times this branch diverged
    pub diverged: u32,
    /** This increments each time when this instruction is executed by number
 of threads that executed this instruction*/
    pub threadsExecuted: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityBranch",
    ][::std::mem::size_of::<CUpti_ActivityBranch>() - 32usize];
    [
        "Alignment of CUpti_ActivityBranch",
    ][::std::mem::align_of::<CUpti_ActivityBranch>() - 8usize];
    [
        "Offset of field: CUpti_ActivityBranch::kind",
    ][::std::mem::offset_of!(CUpti_ActivityBranch, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityBranch::sourceLocatorId",
    ][::std::mem::offset_of!(CUpti_ActivityBranch, sourceLocatorId) - 4usize];
    [
        "Offset of field: CUpti_ActivityBranch::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityBranch, correlationId) - 8usize];
    [
        "Offset of field: CUpti_ActivityBranch::pcOffset",
    ][::std::mem::offset_of!(CUpti_ActivityBranch, pcOffset) - 12usize];
    [
        "Offset of field: CUpti_ActivityBranch::executed",
    ][::std::mem::offset_of!(CUpti_ActivityBranch, executed) - 16usize];
    [
        "Offset of field: CUpti_ActivityBranch::diverged",
    ][::std::mem::offset_of!(CUpti_ActivityBranch, diverged) - 20usize];
    [
        "Offset of field: CUpti_ActivityBranch::threadsExecuted",
    ][::std::mem::offset_of!(CUpti_ActivityBranch, threadsExecuted) - 24usize];
};
impl Default for CUpti_ActivityBranch {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for PC sampling. (deprecated in CUDA 8.0)

 This activity records information obtained by sampling PC
 (CUPTI_ACTIVITY_KIND_PC_SAMPLING).
 PC sampling activities are now reported using the
 CUpti_ActivityPCSampling2 activity record.*/
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityPCSampling {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_PC_SAMPLING.
    pub kind: CUpti_ActivityKind,
    /// The properties of this instruction.
    pub flags: CUpti_ActivityFlag,
    /// The ID for source locator.
    pub sourceLocatorId: u32,
    /// The correlation ID of the kernel to which this result is associated.
    pub correlationId: u32,
    /// Correlation ID with global/device function name
    pub functionId: u32,
    /// The pc offset for the instruction.
    pub pcOffset: u32,
    /** Number of times the PC was sampled with the stallReason in the record.
 The same PC can be sampled with different stall reasons.*/
    pub samples: u32,
    /** Current stall reason. Includes one of the reasons from
 \ref CUpti_ActivityPCSamplingStallReason*/
    pub stallReason: CUpti_ActivityPCSamplingStallReason,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityPCSampling",
    ][::std::mem::size_of::<CUpti_ActivityPCSampling>() - 32usize];
    [
        "Alignment of CUpti_ActivityPCSampling",
    ][::std::mem::align_of::<CUpti_ActivityPCSampling>() - 8usize];
    [
        "Offset of field: CUpti_ActivityPCSampling::kind",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityPCSampling::flags",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling, flags) - 4usize];
    [
        "Offset of field: CUpti_ActivityPCSampling::sourceLocatorId",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling, sourceLocatorId) - 8usize];
    [
        "Offset of field: CUpti_ActivityPCSampling::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling, correlationId) - 12usize];
    [
        "Offset of field: CUpti_ActivityPCSampling::functionId",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling, functionId) - 16usize];
    [
        "Offset of field: CUpti_ActivityPCSampling::pcOffset",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling, pcOffset) - 20usize];
    [
        "Offset of field: CUpti_ActivityPCSampling::samples",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling, samples) - 24usize];
    [
        "Offset of field: CUpti_ActivityPCSampling::stallReason",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling, stallReason) - 28usize];
};
impl Default for CUpti_ActivityPCSampling {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for PC sampling. (deprecated in CUDA 9.0)

 This activity records information obtained by sampling PC
 (CUPTI_ACTIVITY_KIND_PC_SAMPLING).
 PC sampling activities are now reported using the
 CUpti_ActivityPCSampling3 activity record.*/
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityPCSampling2 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_PC_SAMPLING.
    pub kind: CUpti_ActivityKind,
    /// The properties of this instruction.
    pub flags: CUpti_ActivityFlag,
    /// The ID for source locator.
    pub sourceLocatorId: u32,
    /// The correlation ID of the kernel to which this result is associated.
    pub correlationId: u32,
    /// Correlation ID with global/device function name
    pub functionId: u32,
    /// The pc offset for the instruction.
    pub pcOffset: u32,
    /** Number of times the PC was sampled with the stallReason in the record.
 These samples indicate that no instruction was issued in that cycle from
 the warp scheduler from where the warp was sampled.
 Field is valid for devices with compute capability 6.0 and higher*/
    pub latencySamples: u32,
    /** Number of times the PC was sampled with the stallReason in the record.
 The same PC can be sampled with different stall reasons. The count includes
 latencySamples.*/
    pub samples: u32,
    /** Current stall reason. Includes one of the reasons from
 \ref CUpti_ActivityPCSamplingStallReason*/
    pub stallReason: CUpti_ActivityPCSamplingStallReason,
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityPCSampling2",
    ][::std::mem::size_of::<CUpti_ActivityPCSampling2>() - 40usize];
    [
        "Alignment of CUpti_ActivityPCSampling2",
    ][::std::mem::align_of::<CUpti_ActivityPCSampling2>() - 8usize];
    [
        "Offset of field: CUpti_ActivityPCSampling2::kind",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling2, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityPCSampling2::flags",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling2, flags) - 4usize];
    [
        "Offset of field: CUpti_ActivityPCSampling2::sourceLocatorId",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling2, sourceLocatorId) - 8usize];
    [
        "Offset of field: CUpti_ActivityPCSampling2::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling2, correlationId) - 12usize];
    [
        "Offset of field: CUpti_ActivityPCSampling2::functionId",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling2, functionId) - 16usize];
    [
        "Offset of field: CUpti_ActivityPCSampling2::pcOffset",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling2, pcOffset) - 20usize];
    [
        "Offset of field: CUpti_ActivityPCSampling2::latencySamples",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling2, latencySamples) - 24usize];
    [
        "Offset of field: CUpti_ActivityPCSampling2::samples",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling2, samples) - 28usize];
    [
        "Offset of field: CUpti_ActivityPCSampling2::stallReason",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling2, stallReason) - 32usize];
    [
        "Offset of field: CUpti_ActivityPCSampling2::pad",
    ][::std::mem::offset_of!(CUpti_ActivityPCSampling2, pad) - 36usize];
};
impl Default for CUpti_ActivityPCSampling2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for Unified Memory counters (deprecated in CUDA 7.0)

 This activity record represents a Unified Memory counter
 (CUPTI_ACTIVITY_KIND_UNIFIED_MEMORY_COUNTER).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityUnifiedMemoryCounter {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_UNIFIED_MEMORY_COUNTER
    pub kind: CUpti_ActivityKind,
    /// The Unified Memory counter kind. See \ref CUpti_ActivityUnifiedMemoryCounterKind
    pub counterKind: CUpti_ActivityUnifiedMemoryCounterKind,
    /// Scope of the Unified Memory counter. See \ref CUpti_ActivityUnifiedMemoryCounterScope
    pub scope: CUpti_ActivityUnifiedMemoryCounterScope,
    /** The ID of the device involved in the memory transfer operation.
 It is not relevant if the scope of the counter is global (all devices).*/
    pub deviceId: u32,
    /** Value of the counter
*/
    pub value: u64,
    /** The timestamp when this sample was retrieved, in ns. A value of 0
 indicates that timestamp information could not be collected*/
    pub timestamp: u64,
    /** The ID of the process to which this record belongs to. In case of
 global scope, processId is undefined.*/
    pub processId: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityUnifiedMemoryCounter",
    ][::std::mem::size_of::<CUpti_ActivityUnifiedMemoryCounter>() - 40usize];
    [
        "Alignment of CUpti_ActivityUnifiedMemoryCounter",
    ][::std::mem::align_of::<CUpti_ActivityUnifiedMemoryCounter>() - 8usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter::kind",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter::counterKind",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter, counterKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter::scope",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter, scope) - 8usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter, deviceId) - 12usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter::value",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter, value) - 16usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter::timestamp",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter, timestamp) - 24usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter::processId",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter, processId) - 32usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter::pad",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter, pad) - 36usize];
};
impl Default for CUpti_ActivityUnifiedMemoryCounter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for Unified Memory counters (deprecated in 12.8)

 This activity record represents a Unified Memory counter
 (CUPTI_ACTIVITY_KIND_UNIFIED_MEMORY_COUNTER).*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityUnifiedMemoryCounter2 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_UNIFIED_MEMORY_COUNTER
    pub kind: CUpti_ActivityKind,
    /// The Unified Memory counter kind
    pub counterKind: CUpti_ActivityUnifiedMemoryCounterKind,
    /** Value of the counter
 For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD,
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_DTOH,
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THREASHING and
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_REMOTE_MAP, it is the size of the
 memory region in bytes.
 For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT, it
 is the number of page fault groups for the same page.
 For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT,
 it is the program counter for the instruction that caused fault.*/
    pub value: u64,
    /** The start timestamp of the counter, in ns.
 For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD and
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_DTOH, timestamp is
 captured when activity starts on GPU.
 For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT and
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT, timestamp is
 captured when CUDA driver started processing the fault.
 For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING, timestamp
 is captured when CUDA driver detected thrashing of memory region.
 For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING,
 timestamp is captured when throttling operation was started by CUDA driver.
 For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_REMOTE_MAP,
 timestamp is captured when CUDA driver has pushed all required operations
 to the processor specified by dstId.*/
    pub start: u64,
    /** The end timestamp of the counter, in ns.
 Ignore this field if counterKind is
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT or
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING or
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_REMOTE_MAP.
 For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD and
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_DTOH, timestamp is
 captured when activity finishes on GPU.
 For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT, timestamp is
 captured when CUDA driver queues the replay of faulting memory accesses on the GPU
 For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING, timestamp
 is captured when throttling operation was finished by CUDA driver*/
    pub end: u64,
    /** This is the virtual base address of the page/s being transferred. For cpu and
 gpu faults, the virtual address for the page that faulted.*/
    pub address: u64,
    /** The ID of the source CPU/device involved in the memory transfer, page fault, thrashing,
 throttling or remote map operation. For counterKind
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING, it is a bitwise ORing of the
 device IDs fighting for the memory region. Ignore this field if counterKind is
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT*/
    pub srcId: u32,
    /** The ID of the destination CPU/device involved in the memory transfer or remote map
 operation. Ignore this field if counterKind is
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT or
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT or
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING or
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING*/
    pub dstId: u32,
    /** The ID of the stream causing the transfer.
 This value of this field is invalid.*/
    pub streamId: u32,
    /// The ID of the process to which this record belongs to.
    pub processId: u32,
    /** The flags associated with this record. See enums \ref CUpti_ActivityUnifiedMemoryAccessType
 if counterKind is CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT
 and \ref CUpti_ActivityUnifiedMemoryMigrationCause if counterKind is
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD or
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD
 and \ref CUpti_ActivityUnifiedMemoryRemoteMapCause if counterKind is
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_REMOTE_MAP and \ref CUpti_ActivityFlag
 if counterKind is CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING or
 CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING*/
    pub flags: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityUnifiedMemoryCounter2",
    ][::std::mem::size_of::<CUpti_ActivityUnifiedMemoryCounter2>() - 64usize];
    [
        "Alignment of CUpti_ActivityUnifiedMemoryCounter2",
    ][::std::mem::align_of::<CUpti_ActivityUnifiedMemoryCounter2>() - 8usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter2::kind",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter2::counterKind",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, counterKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter2::value",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, value) - 8usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter2::start",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter2::end",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter2::address",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, address) - 32usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter2::srcId",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, srcId) - 40usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter2::dstId",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, dstId) - 44usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter2::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, streamId) - 48usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter2::processId",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, processId) - 52usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter2::flags",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, flags) - 56usize];
    [
        "Offset of field: CUpti_ActivityUnifiedMemoryCounter2::pad",
    ][::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, pad) - 60usize];
};
impl Default for CUpti_ActivityUnifiedMemoryCounter2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief NVLink information. (deprecated in CUDA 9.0)

 This structure gives capabilities of each logical NVLink connection between two devices,
 gpu<->gpu or gpu<->CPU which can be used to understand the topology.
 NVLink information are now reported using the
 CUpti_ActivityNvLink2 activity record.*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityNvLink {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_NVLINK.
    pub kind: CUpti_ActivityKind,
    /// NVLink version.
    pub nvlinkVersion: u32,
    /// Type of device 0 \ref CUpti_DevType
    pub typeDev0: CUpti_DevType,
    /// Type of device 1 \ref CUpti_DevType
    pub typeDev1: CUpti_DevType,
    pub idDev0: CUpti_ActivityNvLink__bindgen_ty_1,
    pub idDev1: CUpti_ActivityNvLink__bindgen_ty_2,
    /// Flag gives capabilities of the link \see CUpti_LinkFlag
    pub flag: u32,
    /// Number of physical NVLinks present between two devices.
    pub physicalNvLinkCount: u32,
    /** Port numbers for maximum 4 NVLinks connected to device 0.
 If typeDev0 is CUPTI_DEV_TYPE_NPU, ignore this field.
 In case of invalid/unknown port number, this field will be set
 to value CUPTI_NVLINK_INVALID_PORT.
 This will be used to correlate the metric values to individual
 physical link and attribute traffic to the logical NVLink in
 the topology.*/
    pub portDev0: [i8; 4usize],
    /** Port numbers for maximum 4 NVLinks connected to device 1.
 If typeDev1 is CUPTI_DEV_TYPE_NPU, ignore this field.
 In case of invalid/unknown port number, this field will be set
 to value CUPTI_NVLINK_INVALID_PORT.
 This will be used to correlate the metric values to individual
 physical link and attribute traffic to the logical NVLink in
 the topology.*/
    pub portDev1: [i8; 4usize],
    /// Bandwidth of NVLink in kbytes/sec
    pub bandwidth: u64,
}
/** If typeDev0 is CUPTI_DEV_TYPE_GPU, UUID for device 0. \ref CUpti_ActivityDevice5.
 If typeDev0 is CUPTI_DEV_TYPE_NPU, struct npu for NPU.*/
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityNvLink__bindgen_ty_1 {
    pub uuidDev: CUuuid,
    pub npu: CUpti_ActivityNvLink__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityNvLink__bindgen_ty_1__bindgen_ty_1 {
    /// Index of the NPU. First index will always be zero.
    pub index: u32,
    /// Domain ID of NPU. On Linux, this can be queried using lspci.
    pub domainId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityNvLink__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityNvLink__bindgen_ty_1__bindgen_ty_1>()
        - 8usize];
    [
        "Alignment of CUpti_ActivityNvLink__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityNvLink__bindgen_ty_1__bindgen_ty_1>()
        - 4usize];
    [
        "Offset of field: CUpti_ActivityNvLink__bindgen_ty_1__bindgen_ty_1::index",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink__bindgen_ty_1__bindgen_ty_1, index)
        - 0usize];
    [
        "Offset of field: CUpti_ActivityNvLink__bindgen_ty_1__bindgen_ty_1::domainId",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink__bindgen_ty_1__bindgen_ty_1, domainId)
        - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityNvLink__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityNvLink__bindgen_ty_1>() - 16usize];
    [
        "Alignment of CUpti_ActivityNvLink__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityNvLink__bindgen_ty_1>() - 4usize];
    [
        "Offset of field: CUpti_ActivityNvLink__bindgen_ty_1::uuidDev",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink__bindgen_ty_1, uuidDev) - 0usize];
    [
        "Offset of field: CUpti_ActivityNvLink__bindgen_ty_1::npu",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink__bindgen_ty_1, npu) - 0usize];
};
impl Default for CUpti_ActivityNvLink__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityNvLink__bindgen_ty_1 {{ union }}")
    }
}
/** If typeDev1 is CUPTI_DEV_TYPE_GPU, UUID for device 1. \ref CUpti_ActivityDevice5.
 If typeDev1 is CUPTI_DEV_TYPE_NPU, struct npu for NPU.*/
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityNvLink__bindgen_ty_2 {
    pub uuidDev: CUuuid,
    pub npu: CUpti_ActivityNvLink__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityNvLink__bindgen_ty_2__bindgen_ty_1 {
    /// Index of the NPU. First index will always be zero.
    pub index: u32,
    /// Domain ID of NPU. On Linux, this can be queried using lspci.
    pub domainId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityNvLink__bindgen_ty_2__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityNvLink__bindgen_ty_2__bindgen_ty_1>()
        - 8usize];
    [
        "Alignment of CUpti_ActivityNvLink__bindgen_ty_2__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityNvLink__bindgen_ty_2__bindgen_ty_1>()
        - 4usize];
    [
        "Offset of field: CUpti_ActivityNvLink__bindgen_ty_2__bindgen_ty_1::index",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink__bindgen_ty_2__bindgen_ty_1, index)
        - 0usize];
    [
        "Offset of field: CUpti_ActivityNvLink__bindgen_ty_2__bindgen_ty_1::domainId",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink__bindgen_ty_2__bindgen_ty_1, domainId)
        - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityNvLink__bindgen_ty_2",
    ][::std::mem::size_of::<CUpti_ActivityNvLink__bindgen_ty_2>() - 16usize];
    [
        "Alignment of CUpti_ActivityNvLink__bindgen_ty_2",
    ][::std::mem::align_of::<CUpti_ActivityNvLink__bindgen_ty_2>() - 4usize];
    [
        "Offset of field: CUpti_ActivityNvLink__bindgen_ty_2::uuidDev",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink__bindgen_ty_2, uuidDev) - 0usize];
    [
        "Offset of field: CUpti_ActivityNvLink__bindgen_ty_2::npu",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink__bindgen_ty_2, npu) - 0usize];
};
impl Default for CUpti_ActivityNvLink__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityNvLink__bindgen_ty_2 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityNvLink",
    ][::std::mem::size_of::<CUpti_ActivityNvLink>() - 72usize];
    [
        "Alignment of CUpti_ActivityNvLink",
    ][::std::mem::align_of::<CUpti_ActivityNvLink>() - 8usize];
    [
        "Offset of field: CUpti_ActivityNvLink::kind",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityNvLink::nvlinkVersion",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink, nvlinkVersion) - 4usize];
    [
        "Offset of field: CUpti_ActivityNvLink::typeDev0",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink, typeDev0) - 8usize];
    [
        "Offset of field: CUpti_ActivityNvLink::typeDev1",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink, typeDev1) - 12usize];
    [
        "Offset of field: CUpti_ActivityNvLink::idDev0",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink, idDev0) - 16usize];
    [
        "Offset of field: CUpti_ActivityNvLink::idDev1",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink, idDev1) - 32usize];
    [
        "Offset of field: CUpti_ActivityNvLink::flag",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink, flag) - 48usize];
    [
        "Offset of field: CUpti_ActivityNvLink::physicalNvLinkCount",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink, physicalNvLinkCount) - 52usize];
    [
        "Offset of field: CUpti_ActivityNvLink::portDev0",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink, portDev0) - 56usize];
    [
        "Offset of field: CUpti_ActivityNvLink::portDev1",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink, portDev1) - 60usize];
    [
        "Offset of field: CUpti_ActivityNvLink::bandwidth",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink, bandwidth) - 64usize];
};
impl Default for CUpti_ActivityNvLink {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityNvLink {{ kind: {:?}, typeDev0: {:?}, typeDev1: {:?}, idDev0: {:?}, idDev1: {:?}, portDev0: {:?}, portDev1: {:?} }}",
            self.kind,
            self.typeDev0,
            self.typeDev1,
            self.idDev0,
            self.idDev1,
            self.portDev0,
            self.portDev1,
        )
    }
}
/** \brief NVLink information. (deprecated in CUDA 10.0)

 This structure gives capabilities of each logical NVLink connection between two devices,
 gpu<->gpu or gpu<->CPU which can be used to understand the topology.
 NvLink information are now reported using the
 CUpti_ActivityNvLink4 activity record.*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityNvLink2 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_NVLINK.
    pub kind: CUpti_ActivityKind,
    /// NvLink version.
    pub nvlinkVersion: u32,
    /// Type of device 0 \ref CUpti_DevType
    pub typeDev0: CUpti_DevType,
    /// Type of device 1 \ref CUpti_DevType
    pub typeDev1: CUpti_DevType,
    pub idDev0: CUpti_ActivityNvLink2__bindgen_ty_1,
    pub idDev1: CUpti_ActivityNvLink2__bindgen_ty_2,
    /// Flag gives capabilities of the link \see CUpti_LinkFlag
    pub flag: u32,
    /// Number of physical NVLinks present between two devices.
    pub physicalNvLinkCount: u32,
    /** Port numbers for maximum 16 NVLinks connected to device 0.
 If typeDev0 is CUPTI_DEV_TYPE_NPU, ignore this field.
 In case of invalid/unknown port number, this field will be set
 to value CUPTI_NVLINK_INVALID_PORT.
 This will be used to correlate the metric values to individual
 physical link and attribute traffic to the logical NVLink in
 the topology.*/
    pub portDev0: [i8; 32usize],
    /** Port numbers for maximum 16 NVLinks connected to device 1.
 If typeDev1 is CUPTI_DEV_TYPE_NPU, ignore this field.
 In case of invalid/unknown port number, this field will be set
 to value CUPTI_NVLINK_INVALID_PORT.
 This will be used to correlate the metric values to individual
 physical link and attribute traffic to the logical NVLink in
 the topology.*/
    pub portDev1: [i8; 32usize],
    /// Bandwidth of NVLink in kbytes/sec
    pub bandwidth: u64,
}
/** If typeDev0 is CUPTI_DEV_TYPE_GPU, UUID for device 0. \ref CUpti_ActivityDevice5.
 If typeDev0 is CUPTI_DEV_TYPE_NPU, struct npu for NPU.*/
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityNvLink2__bindgen_ty_1 {
    pub uuidDev: CUuuid,
    pub npu: CUpti_ActivityNvLink2__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityNvLink2__bindgen_ty_1__bindgen_ty_1 {
    /// Index of the NPU. First index will always be zero.
    pub index: u32,
    /// Domain ID of NPU. On Linux, this can be queried using lspci.
    pub domainId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityNvLink2__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityNvLink2__bindgen_ty_1__bindgen_ty_1>()
        - 8usize];
    [
        "Alignment of CUpti_ActivityNvLink2__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityNvLink2__bindgen_ty_1__bindgen_ty_1>()
        - 4usize];
    [
        "Offset of field: CUpti_ActivityNvLink2__bindgen_ty_1__bindgen_ty_1::index",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink2__bindgen_ty_1__bindgen_ty_1, index)
        - 0usize];
    [
        "Offset of field: CUpti_ActivityNvLink2__bindgen_ty_1__bindgen_ty_1::domainId",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink2__bindgen_ty_1__bindgen_ty_1, domainId)
        - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityNvLink2__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityNvLink2__bindgen_ty_1>() - 16usize];
    [
        "Alignment of CUpti_ActivityNvLink2__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityNvLink2__bindgen_ty_1>() - 4usize];
    [
        "Offset of field: CUpti_ActivityNvLink2__bindgen_ty_1::uuidDev",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink2__bindgen_ty_1, uuidDev) - 0usize];
    [
        "Offset of field: CUpti_ActivityNvLink2__bindgen_ty_1::npu",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink2__bindgen_ty_1, npu) - 0usize];
};
impl Default for CUpti_ActivityNvLink2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink2__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityNvLink2__bindgen_ty_1 {{ union }}")
    }
}
/** If typeDev1 is CUPTI_DEV_TYPE_GPU, UUID for device 1. \ref CUpti_ActivityDevice5.
 If typeDev1 is CUPTI_DEV_TYPE_NPU, struct npu for NPU.*/
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityNvLink2__bindgen_ty_2 {
    pub uuidDev: CUuuid,
    pub npu: CUpti_ActivityNvLink2__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityNvLink2__bindgen_ty_2__bindgen_ty_1 {
    /// Index of the NPU. First index will always be zero.
    pub index: u32,
    /// Domain ID of NPU. On Linux, this can be queried using lspci.
    pub domainId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityNvLink2__bindgen_ty_2__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityNvLink2__bindgen_ty_2__bindgen_ty_1>()
        - 8usize];
    [
        "Alignment of CUpti_ActivityNvLink2__bindgen_ty_2__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityNvLink2__bindgen_ty_2__bindgen_ty_1>()
        - 4usize];
    [
        "Offset of field: CUpti_ActivityNvLink2__bindgen_ty_2__bindgen_ty_1::index",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink2__bindgen_ty_2__bindgen_ty_1, index)
        - 0usize];
    [
        "Offset of field: CUpti_ActivityNvLink2__bindgen_ty_2__bindgen_ty_1::domainId",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink2__bindgen_ty_2__bindgen_ty_1, domainId)
        - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityNvLink2__bindgen_ty_2",
    ][::std::mem::size_of::<CUpti_ActivityNvLink2__bindgen_ty_2>() - 16usize];
    [
        "Alignment of CUpti_ActivityNvLink2__bindgen_ty_2",
    ][::std::mem::align_of::<CUpti_ActivityNvLink2__bindgen_ty_2>() - 4usize];
    [
        "Offset of field: CUpti_ActivityNvLink2__bindgen_ty_2::uuidDev",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink2__bindgen_ty_2, uuidDev) - 0usize];
    [
        "Offset of field: CUpti_ActivityNvLink2__bindgen_ty_2::npu",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink2__bindgen_ty_2, npu) - 0usize];
};
impl Default for CUpti_ActivityNvLink2__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink2__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityNvLink2__bindgen_ty_2 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityNvLink2",
    ][::std::mem::size_of::<CUpti_ActivityNvLink2>() - 128usize];
    [
        "Alignment of CUpti_ActivityNvLink2",
    ][::std::mem::align_of::<CUpti_ActivityNvLink2>() - 8usize];
    [
        "Offset of field: CUpti_ActivityNvLink2::kind",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink2, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityNvLink2::nvlinkVersion",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink2, nvlinkVersion) - 4usize];
    [
        "Offset of field: CUpti_ActivityNvLink2::typeDev0",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink2, typeDev0) - 8usize];
    [
        "Offset of field: CUpti_ActivityNvLink2::typeDev1",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink2, typeDev1) - 12usize];
    [
        "Offset of field: CUpti_ActivityNvLink2::idDev0",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink2, idDev0) - 16usize];
    [
        "Offset of field: CUpti_ActivityNvLink2::idDev1",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink2, idDev1) - 32usize];
    [
        "Offset of field: CUpti_ActivityNvLink2::flag",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink2, flag) - 48usize];
    [
        "Offset of field: CUpti_ActivityNvLink2::physicalNvLinkCount",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink2, physicalNvLinkCount) - 52usize];
    [
        "Offset of field: CUpti_ActivityNvLink2::portDev0",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink2, portDev0) - 56usize];
    [
        "Offset of field: CUpti_ActivityNvLink2::portDev1",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink2, portDev1) - 88usize];
    [
        "Offset of field: CUpti_ActivityNvLink2::bandwidth",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink2, bandwidth) - 120usize];
};
impl Default for CUpti_ActivityNvLink2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityNvLink2 {{ kind: {:?}, typeDev0: {:?}, typeDev1: {:?}, idDev0: {:?}, idDev1: {:?}, portDev0: {:?}, portDev1: {:?} }}",
            self.kind,
            self.typeDev0,
            self.typeDev1,
            self.idDev0,
            self.idDev1,
            self.portDev0,
            self.portDev1,
        )
    }
}
/** \brief NVLink information.

 This structure gives capabilities of each logical NVLink connection between two devices,
 gpu<->gpu or gpu<->CPU which can be used to understand the topology.
 NvLink information are now reported using the
 CUpti_ActivityNvLink4 activity record.*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityNvLink3 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_NVLINK.
    pub kind: CUpti_ActivityKind,
    /// NvLink version.
    pub nvlinkVersion: u32,
    /// Type of device 0 \ref CUpti_DevType
    pub typeDev0: CUpti_DevType,
    /// Type of device 1 \ref CUpti_DevType
    pub typeDev1: CUpti_DevType,
    pub idDev0: CUpti_ActivityNvLink3__bindgen_ty_1,
    pub idDev1: CUpti_ActivityNvLink3__bindgen_ty_2,
    /// Flag gives capabilities of the link \see CUpti_LinkFlag
    pub flag: u32,
    /// Number of physical NVLinks present between two devices.
    pub physicalNvLinkCount: u32,
    /** Port numbers for maximum 16 NVLinks connected to device 0.
 If typeDev0 is CUPTI_DEV_TYPE_NPU, ignore this field.
 In case of invalid/unknown port number, this field will be set
 to value CUPTI_NVLINK_INVALID_PORT.
 This will be used to correlate the metric values to individual
 physical link and attribute traffic to the logical NVLink in
 the topology.*/
    pub portDev0: [i8; 32usize],
    /** Port numbers for maximum 16 NVLinks connected to device 1.
 If typeDev1 is CUPTI_DEV_TYPE_NPU, ignore this field.
 In case of invalid/unknown port number, this field will be set
 to value CUPTI_NVLINK_INVALID_PORT.
 This will be used to correlate the metric values to individual
 physical link and attribute traffic to the logical NVLink in
 the topology.*/
    pub portDev1: [i8; 32usize],
    /// Bandwidth of NVLink in kbytes/sec
    pub bandwidth: u64,
    /// NVSwitch is connected as an intermediate node.
    pub nvswitchConnected: u8,
    /// Undefined. reserved for internal use
    pub pad: [u8; 7usize],
}
/** If typeDev0 is CUPTI_DEV_TYPE_GPU, UUID for device 0. \ref CUpti_ActivityDevice5.
 If typeDev0 is CUPTI_DEV_TYPE_NPU, struct npu for NPU.*/
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityNvLink3__bindgen_ty_1 {
    pub uuidDev: CUuuid,
    pub npu: CUpti_ActivityNvLink3__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityNvLink3__bindgen_ty_1__bindgen_ty_1 {
    /// Index of the NPU. First index will always be zero.
    pub index: u32,
    /// Domain ID of NPU. On Linux, this can be queried using lspci.
    pub domainId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityNvLink3__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityNvLink3__bindgen_ty_1__bindgen_ty_1>()
        - 8usize];
    [
        "Alignment of CUpti_ActivityNvLink3__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityNvLink3__bindgen_ty_1__bindgen_ty_1>()
        - 4usize];
    [
        "Offset of field: CUpti_ActivityNvLink3__bindgen_ty_1__bindgen_ty_1::index",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink3__bindgen_ty_1__bindgen_ty_1, index)
        - 0usize];
    [
        "Offset of field: CUpti_ActivityNvLink3__bindgen_ty_1__bindgen_ty_1::domainId",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink3__bindgen_ty_1__bindgen_ty_1, domainId)
        - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityNvLink3__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityNvLink3__bindgen_ty_1>() - 16usize];
    [
        "Alignment of CUpti_ActivityNvLink3__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityNvLink3__bindgen_ty_1>() - 4usize];
    [
        "Offset of field: CUpti_ActivityNvLink3__bindgen_ty_1::uuidDev",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink3__bindgen_ty_1, uuidDev) - 0usize];
    [
        "Offset of field: CUpti_ActivityNvLink3__bindgen_ty_1::npu",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink3__bindgen_ty_1, npu) - 0usize];
};
impl Default for CUpti_ActivityNvLink3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink3__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityNvLink3__bindgen_ty_1 {{ union }}")
    }
}
/** If typeDev1 is CUPTI_DEV_TYPE_GPU, UUID for device 1. \ref CUpti_ActivityDevice5.
 If typeDev1 is CUPTI_DEV_TYPE_NPU, struct npu for NPU.*/
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityNvLink3__bindgen_ty_2 {
    pub uuidDev: CUuuid,
    pub npu: CUpti_ActivityNvLink3__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityNvLink3__bindgen_ty_2__bindgen_ty_1 {
    /// Index of the NPU. First index will always be zero.
    pub index: u32,
    /// Domain ID of NPU. On Linux, this can be queried using lspci.
    pub domainId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityNvLink3__bindgen_ty_2__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_ActivityNvLink3__bindgen_ty_2__bindgen_ty_1>()
        - 8usize];
    [
        "Alignment of CUpti_ActivityNvLink3__bindgen_ty_2__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_ActivityNvLink3__bindgen_ty_2__bindgen_ty_1>()
        - 4usize];
    [
        "Offset of field: CUpti_ActivityNvLink3__bindgen_ty_2__bindgen_ty_1::index",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink3__bindgen_ty_2__bindgen_ty_1, index)
        - 0usize];
    [
        "Offset of field: CUpti_ActivityNvLink3__bindgen_ty_2__bindgen_ty_1::domainId",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink3__bindgen_ty_2__bindgen_ty_1, domainId)
        - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityNvLink3__bindgen_ty_2",
    ][::std::mem::size_of::<CUpti_ActivityNvLink3__bindgen_ty_2>() - 16usize];
    [
        "Alignment of CUpti_ActivityNvLink3__bindgen_ty_2",
    ][::std::mem::align_of::<CUpti_ActivityNvLink3__bindgen_ty_2>() - 4usize];
    [
        "Offset of field: CUpti_ActivityNvLink3__bindgen_ty_2::uuidDev",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink3__bindgen_ty_2, uuidDev) - 0usize];
    [
        "Offset of field: CUpti_ActivityNvLink3__bindgen_ty_2::npu",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink3__bindgen_ty_2, npu) - 0usize];
};
impl Default for CUpti_ActivityNvLink3__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink3__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityNvLink3__bindgen_ty_2 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityNvLink3",
    ][::std::mem::size_of::<CUpti_ActivityNvLink3>() - 136usize];
    [
        "Alignment of CUpti_ActivityNvLink3",
    ][::std::mem::align_of::<CUpti_ActivityNvLink3>() - 8usize];
    [
        "Offset of field: CUpti_ActivityNvLink3::kind",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink3, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityNvLink3::nvlinkVersion",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink3, nvlinkVersion) - 4usize];
    [
        "Offset of field: CUpti_ActivityNvLink3::typeDev0",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink3, typeDev0) - 8usize];
    [
        "Offset of field: CUpti_ActivityNvLink3::typeDev1",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink3, typeDev1) - 12usize];
    [
        "Offset of field: CUpti_ActivityNvLink3::idDev0",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink3, idDev0) - 16usize];
    [
        "Offset of field: CUpti_ActivityNvLink3::idDev1",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink3, idDev1) - 32usize];
    [
        "Offset of field: CUpti_ActivityNvLink3::flag",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink3, flag) - 48usize];
    [
        "Offset of field: CUpti_ActivityNvLink3::physicalNvLinkCount",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink3, physicalNvLinkCount) - 52usize];
    [
        "Offset of field: CUpti_ActivityNvLink3::portDev0",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink3, portDev0) - 56usize];
    [
        "Offset of field: CUpti_ActivityNvLink3::portDev1",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink3, portDev1) - 88usize];
    [
        "Offset of field: CUpti_ActivityNvLink3::bandwidth",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink3, bandwidth) - 120usize];
    [
        "Offset of field: CUpti_ActivityNvLink3::nvswitchConnected",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink3, nvswitchConnected) - 128usize];
    [
        "Offset of field: CUpti_ActivityNvLink3::pad",
    ][::std::mem::offset_of!(CUpti_ActivityNvLink3, pad) - 129usize];
};
impl Default for CUpti_ActivityNvLink3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityNvLink3 {{ kind: {:?}, typeDev0: {:?}, typeDev1: {:?}, idDev0: {:?}, idDev1: {:?}, portDev0: {:?}, portDev1: {:?}, pad: {:?} }}",
            self.kind,
            self.typeDev0,
            self.typeDev1,
            self.idDev0,
            self.idDev1,
            self.portDev0,
            self.portDev1,
            self.pad,
        )
    }
}
/** \brief The activity record for trace of graph execution.

 This activity record represents execution for a graph without giving visibility
 about the execution of its nodes. This is intended to reduce overheads in tracing
 each node. The activity kind is CUPTI_ACTIVITY_KIND_GRAPH_TRACE
 Graph trace activity is now reported using CUpti_ActivityGraphTrace2 record.*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityGraphTrace {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_GRAPH_TRACE
    pub kind: CUpti_ActivityKind,
    /** The correlation ID of the graph launch. Each graph launch is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver API activity record that launched
 the graph.*/
    pub correlationId: u32,
    /** The start timestamp for the graph execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the graph.*/
    pub start: u64,
    /** The end timestamp for the graph execution, in ns. A value of 0
 for both the start and end timestamps indicates that timestamp
 information could not be collected for the graph.*/
    pub end: u64,
    /// The ID of the device where the graph execution is occurring.
    pub deviceId: u32,
    /// The unique ID of the graph that is launched.
    pub graphId: u32,
    /// The ID of the context where the graph is being launched.
    pub contextId: u32,
    /// The ID of the stream where the graph is being launched.
    pub streamId: u32,
    /// This field is reserved for internal use
    pub reserved: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityGraphTrace",
    ][::std::mem::size_of::<CUpti_ActivityGraphTrace>() - 48usize];
    [
        "Alignment of CUpti_ActivityGraphTrace",
    ][::std::mem::align_of::<CUpti_ActivityGraphTrace>() - 8usize];
    [
        "Offset of field: CUpti_ActivityGraphTrace::kind",
    ][::std::mem::offset_of!(CUpti_ActivityGraphTrace, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityGraphTrace::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityGraphTrace, correlationId) - 4usize];
    [
        "Offset of field: CUpti_ActivityGraphTrace::start",
    ][::std::mem::offset_of!(CUpti_ActivityGraphTrace, start) - 8usize];
    [
        "Offset of field: CUpti_ActivityGraphTrace::end",
    ][::std::mem::offset_of!(CUpti_ActivityGraphTrace, end) - 16usize];
    [
        "Offset of field: CUpti_ActivityGraphTrace::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityGraphTrace, deviceId) - 24usize];
    [
        "Offset of field: CUpti_ActivityGraphTrace::graphId",
    ][::std::mem::offset_of!(CUpti_ActivityGraphTrace, graphId) - 28usize];
    [
        "Offset of field: CUpti_ActivityGraphTrace::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityGraphTrace, contextId) - 32usize];
    [
        "Offset of field: CUpti_ActivityGraphTrace::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityGraphTrace, streamId) - 36usize];
    [
        "Offset of field: CUpti_ActivityGraphTrace::reserved",
    ][::std::mem::offset_of!(CUpti_ActivityGraphTrace, reserved) - 40usize];
};
impl Default for CUpti_ActivityGraphTrace {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for a context.

 This activity record represents information about a context
 (CUPTI_ACTIVITY_KIND_CONTEXT).
 Context activity is now reported using CUpti_ActivityContext3 record*/
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityContext {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_CONTEXT.
    pub kind: CUpti_ActivityKind,
    /// The context ID.
    pub contextId: u32,
    /// The device ID.
    pub deviceId: u32,
    /// The compute API kind. \see CUpti_ActivityComputeApiKind
    pub computeApiKind: u16,
    /// The ID for the NULL stream in this context
    pub nullStreamId: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityContext",
    ][::std::mem::size_of::<CUpti_ActivityContext>() - 16usize];
    [
        "Alignment of CUpti_ActivityContext",
    ][::std::mem::align_of::<CUpti_ActivityContext>() - 8usize];
    [
        "Offset of field: CUpti_ActivityContext::kind",
    ][::std::mem::offset_of!(CUpti_ActivityContext, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityContext::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityContext, contextId) - 4usize];
    [
        "Offset of field: CUpti_ActivityContext::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityContext, deviceId) - 8usize];
    [
        "Offset of field: CUpti_ActivityContext::computeApiKind",
    ][::std::mem::offset_of!(CUpti_ActivityContext, computeApiKind) - 12usize];
    [
        "Offset of field: CUpti_ActivityContext::nullStreamId",
    ][::std::mem::offset_of!(CUpti_ActivityContext, nullStreamId) - 14usize];
};
impl Default for CUpti_ActivityContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for a context.

 This activity record represents information about a context
 (CUPTI_ACTIVITY_KIND_CONTEXT).
 Context activity is now reported using CUpti_ActivityContext3 record*/
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityContext2 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_CONTEXT.
    pub kind: CUpti_ActivityKind,
    /// The context ID.
    pub contextId: u32,
    /// The device ID.
    pub deviceId: u32,
    /// The compute API kind. \see CUpti_ActivityComputeApiKind
    pub computeApiKind: u16,
    /// The ID for the NULL stream in this context
    pub nullStreamId: u16,
    /** The ID of the parent context. It would be 0 if
 context does not have parent*/
    pub parentContextId: u32,
    /// This field indicates whether the context is a green context
    pub isGreenContext: u8,
    pub padding: u8,
    /** Number of multiprocessors assigned to the green context
 Invalid if the field 'isGreenContext' is 0*/
    pub numMultiprocessors: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityContext2",
    ][::std::mem::size_of::<CUpti_ActivityContext2>() - 24usize];
    [
        "Alignment of CUpti_ActivityContext2",
    ][::std::mem::align_of::<CUpti_ActivityContext2>() - 8usize];
    [
        "Offset of field: CUpti_ActivityContext2::kind",
    ][::std::mem::offset_of!(CUpti_ActivityContext2, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityContext2::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityContext2, contextId) - 4usize];
    [
        "Offset of field: CUpti_ActivityContext2::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityContext2, deviceId) - 8usize];
    [
        "Offset of field: CUpti_ActivityContext2::computeApiKind",
    ][::std::mem::offset_of!(CUpti_ActivityContext2, computeApiKind) - 12usize];
    [
        "Offset of field: CUpti_ActivityContext2::nullStreamId",
    ][::std::mem::offset_of!(CUpti_ActivityContext2, nullStreamId) - 14usize];
    [
        "Offset of field: CUpti_ActivityContext2::parentContextId",
    ][::std::mem::offset_of!(CUpti_ActivityContext2, parentContextId) - 16usize];
    [
        "Offset of field: CUpti_ActivityContext2::isGreenContext",
    ][::std::mem::offset_of!(CUpti_ActivityContext2, isGreenContext) - 20usize];
    [
        "Offset of field: CUpti_ActivityContext2::padding",
    ][::std::mem::offset_of!(CUpti_ActivityContext2, padding) - 21usize];
    [
        "Offset of field: CUpti_ActivityContext2::numMultiprocessors",
    ][::std::mem::offset_of!(CUpti_ActivityContext2, numMultiprocessors) - 22usize];
};
impl Default for CUpti_ActivityContext2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for JIT operations.
 This activity represents the JIT operations (compile, load, store) of a CUmodule
 from the Compute Cache.
 Gives the exact hashed path of where the cached module is loaded from,
 or where the module will be stored after Just-In-Time (JIT) compilation.

 JIT activity is now reported using CUpti_ActivityJit2 record*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityJit {
    /// The activity record kind must be CUPTI_ACTIVITY_KIND_JIT.
    pub kind: CUpti_ActivityKind,
    /// The JIT entry type.
    pub jitEntryType: CUpti_ActivityJitEntryType,
    /// The JIT operation type.
    pub jitOperationType: CUpti_ActivityJitOperationType,
    /// The device ID.
    pub deviceId: u32,
    /** The start timestamp for the JIT operation, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the JIT operation.*/
    pub start: u64,
    /** The end timestamp for the JIT operation, in ns. A value of 0 for both
 the start and end timestamps indicates that timestamp information
 could not be collected for the JIT operation.*/
    pub end: u64,
    /** The correlation ID of the JIT operation to which
 records belong to. Each JIT operation is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver or runtime API activity record that
 launched the JIT operation.*/
    pub correlationId: u32,
    /// Internal use.
    pub padding: u32,
    /** The correlation ID to correlate JIT compilation, load and store operations.
 Each JIT compilation unit is assigned a unique correlation ID
 at the time of the JIT compilation. This correlation id can be used
 to find the matching JIT cache load/store records.*/
    pub jitOperationCorrelationId: u64,
    /// The size of compute cache.
    pub cacheSize: u64,
    /// The path where the fat binary is cached.
    pub cachePath: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityJit"][::std::mem::size_of::<CUpti_ActivityJit>() - 64usize];
    [
        "Alignment of CUpti_ActivityJit",
    ][::std::mem::align_of::<CUpti_ActivityJit>() - 8usize];
    [
        "Offset of field: CUpti_ActivityJit::kind",
    ][::std::mem::offset_of!(CUpti_ActivityJit, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityJit::jitEntryType",
    ][::std::mem::offset_of!(CUpti_ActivityJit, jitEntryType) - 4usize];
    [
        "Offset of field: CUpti_ActivityJit::jitOperationType",
    ][::std::mem::offset_of!(CUpti_ActivityJit, jitOperationType) - 8usize];
    [
        "Offset of field: CUpti_ActivityJit::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityJit, deviceId) - 12usize];
    [
        "Offset of field: CUpti_ActivityJit::start",
    ][::std::mem::offset_of!(CUpti_ActivityJit, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityJit::end",
    ][::std::mem::offset_of!(CUpti_ActivityJit, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityJit::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityJit, correlationId) - 32usize];
    [
        "Offset of field: CUpti_ActivityJit::padding",
    ][::std::mem::offset_of!(CUpti_ActivityJit, padding) - 36usize];
    [
        "Offset of field: CUpti_ActivityJit::jitOperationCorrelationId",
    ][::std::mem::offset_of!(CUpti_ActivityJit, jitOperationCorrelationId) - 40usize];
    [
        "Offset of field: CUpti_ActivityJit::cacheSize",
    ][::std::mem::offset_of!(CUpti_ActivityJit, cacheSize) - 48usize];
    [
        "Offset of field: CUpti_ActivityJit::cachePath",
    ][::std::mem::offset_of!(CUpti_ActivityJit, cachePath) - 56usize];
};
impl Default for CUpti_ActivityJit {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for CUDA event.

 This activity is used to track recorded events.
 (CUPTI_ACTIVITY_KIND_CUDA_EVENT).

 Structure deprecated in CUDA 12.8: Refer to CUpti_ActivityCudaEvent2
 for the latest structure.*/
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityCudaEvent {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_CUDA_EVENT.
    pub kind: CUpti_ActivityKind,
    /// The correlation ID of the API to which this result is associated.
    pub correlationId: u32,
    /// The ID of the context where the event was recorded.
    pub contextId: u32,
    /// The compute stream where the event was recorded.
    pub streamId: u32,
    /// A unique event ID to identify the event record.
    pub eventId: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityCudaEvent",
    ][::std::mem::size_of::<CUpti_ActivityCudaEvent>() - 24usize];
    [
        "Alignment of CUpti_ActivityCudaEvent",
    ][::std::mem::align_of::<CUpti_ActivityCudaEvent>() - 8usize];
    [
        "Offset of field: CUpti_ActivityCudaEvent::kind",
    ][::std::mem::offset_of!(CUpti_ActivityCudaEvent, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityCudaEvent::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityCudaEvent, correlationId) - 4usize];
    [
        "Offset of field: CUpti_ActivityCudaEvent::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityCudaEvent, contextId) - 8usize];
    [
        "Offset of field: CUpti_ActivityCudaEvent::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityCudaEvent, streamId) - 12usize];
    [
        "Offset of field: CUpti_ActivityCudaEvent::eventId",
    ][::std::mem::offset_of!(CUpti_ActivityCudaEvent, eventId) - 16usize];
    [
        "Offset of field: CUpti_ActivityCudaEvent::pad",
    ][::std::mem::offset_of!(CUpti_ActivityCudaEvent, pad) - 20usize];
};
impl Default for CUpti_ActivityCudaEvent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for synchronization management.

 This activity is used to track various CUDA synchronization APIs.
 (CUPTI_ACTIVITY_KIND_SYNCHRONIZATION).

 Structure deprecated in CUDA 12.8: Refer to CUpti_ActivitySynchronization2
 for the latest structure.*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivitySynchronization {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_SYNCHRONIZATION.
    pub kind: CUpti_ActivityKind,
    /// The type of record.
    pub type_: CUpti_ActivitySynchronizationType,
    /** The start timestamp for the function, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the function.*/
    pub start: u64,
    /** The end timestamp for the function, in ns. A value of 0 for both
 the start and end timestamps indicates that timestamp information
 could not be collected for the function.*/
    pub end: u64,
    /// The correlation ID of the API to which this result is associated.
    pub correlationId: u32,
    /** The ID of the context for which the synchronization API is called.
 In case of context synchronization API it is the context id for which the API is called.
 In case of stream/event synchronization it is the ID of the context where the stream/event was created.*/
    pub contextId: u32,
    /** The compute stream for which the synchronization API is called.
 A CUPTI_SYNCHRONIZATION_INVALID_VALUE value indicate the field is not applicable for this record.
 Not valid for cuCtxSynchronize, cuEventSynchronize.*/
    pub streamId: u32,
    /** The event ID for which the synchronization API is called.
 A CUPTI_SYNCHRONIZATION_INVALID_VALUE value indicate the field is not applicable for this record.
 Not valid for cuCtxSynchronize, cuStreamSynchronize.*/
    pub cudaEventId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivitySynchronization",
    ][::std::mem::size_of::<CUpti_ActivitySynchronization>() - 40usize];
    [
        "Alignment of CUpti_ActivitySynchronization",
    ][::std::mem::align_of::<CUpti_ActivitySynchronization>() - 8usize];
    [
        "Offset of field: CUpti_ActivitySynchronization::kind",
    ][::std::mem::offset_of!(CUpti_ActivitySynchronization, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivitySynchronization::type_",
    ][::std::mem::offset_of!(CUpti_ActivitySynchronization, type_) - 4usize];
    [
        "Offset of field: CUpti_ActivitySynchronization::start",
    ][::std::mem::offset_of!(CUpti_ActivitySynchronization, start) - 8usize];
    [
        "Offset of field: CUpti_ActivitySynchronization::end",
    ][::std::mem::offset_of!(CUpti_ActivitySynchronization, end) - 16usize];
    [
        "Offset of field: CUpti_ActivitySynchronization::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivitySynchronization, correlationId) - 24usize];
    [
        "Offset of field: CUpti_ActivitySynchronization::contextId",
    ][::std::mem::offset_of!(CUpti_ActivitySynchronization, contextId) - 28usize];
    [
        "Offset of field: CUpti_ActivitySynchronization::streamId",
    ][::std::mem::offset_of!(CUpti_ActivitySynchronization, streamId) - 32usize];
    [
        "Offset of field: CUpti_ActivitySynchronization::cudaEventId",
    ][::std::mem::offset_of!(CUpti_ActivitySynchronization, cudaEventId) - 36usize];
};
impl Default for CUpti_ActivitySynchronization {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record for memory copies.

 This activity record represents a memory copy
 (CUPTI_ACTIVITY_KIND_MEMCPY).

 Structure deprecated in CUDA 12.8: Refer to CUpti_ActivityMemcpy6
 for the latest structure.*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemcpy5 {
    /// The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMCPY.
    pub kind: CUpti_ActivityKind,
    /** The kind of the memory copy, stored as a byte to reduce record
 size. \see CUpti_ActivityMemcpyKind*/
    pub copyKind: u8,
    /** The source memory kind read by the memory copy, stored as a byte
 to reduce record size. \see CUpti_ActivityMemoryKind*/
    pub srcKind: u8,
    /** The destination memory kind read by the memory copy, stored as a
 byte to reduce record size. \see CUpti_ActivityMemoryKind*/
    pub dstKind: u8,
    /// The flags associated with the memory copy. \see CUpti_ActivityFlag
    pub flags: u8,
    /// The number of bytes transferred by the memory copy.
    pub bytes: u64,
    /** The start timestamp for the memory copy, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory copy.*/
    pub start: u64,
    /** The end timestamp for the memory copy, in ns. A value of 0 for
 both the start and end timestamps indicates that timestamp
 information could not be collected for the memory copy.*/
    pub end: u64,
    /// The ID of the device where the memory copy is occurring.
    pub deviceId: u32,
    /// The ID of the context where the memory copy is occurring.
    pub contextId: u32,
    /// The ID of the stream where the memory copy is occurring.
    pub streamId: u32,
    /** The correlation ID of the memory copy. Each memory copy is
 assigned a unique correlation ID that is identical to the
 correlation ID in the driver API activity record that launched
 the memory copy.*/
    pub correlationId: u32,
    /** The runtime correlation ID of the memory copy. Each memory copy
 is assigned a unique runtime correlation ID that is identical to
 the correlation ID in the runtime API activity record that
 launched the memory copy.*/
    pub runtimeCorrelationId: u32,
    /// Undefined. Reserved for internal use.
    pub pad: u32,
    /// Undefined. Reserved for internal use.
    pub reserved0: *mut ::std::os::raw::c_void,
    /** The unique ID of the graph node that executed this memcpy through graph launch.
 This field will be 0 if the memcpy is not done through graph launch.*/
    pub graphNodeId: u64,
    /** The unique ID of the graph that executed this memcpy through graph launch.
 This field will be 0 if the memcpy is not done through graph launch.*/
    pub graphId: u32,
    /// The ID of the HW channel on which the memory copy is occurring.
    pub channelID: u32,
    /// The type of the channel
    pub channelType: CUpti_ChannelType,
    ///  Reserved for internal use.
    pub pad2: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMemcpy5",
    ][::std::mem::size_of::<CUpti_ActivityMemcpy5>() - 88usize];
    [
        "Alignment of CUpti_ActivityMemcpy5",
    ][::std::mem::align_of::<CUpti_ActivityMemcpy5>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMemcpy5::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy5, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMemcpy5::copyKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy5, copyKind) - 4usize];
    [
        "Offset of field: CUpti_ActivityMemcpy5::srcKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy5, srcKind) - 5usize];
    [
        "Offset of field: CUpti_ActivityMemcpy5::dstKind",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy5, dstKind) - 6usize];
    [
        "Offset of field: CUpti_ActivityMemcpy5::flags",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy5, flags) - 7usize];
    [
        "Offset of field: CUpti_ActivityMemcpy5::bytes",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy5, bytes) - 8usize];
    [
        "Offset of field: CUpti_ActivityMemcpy5::start",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy5, start) - 16usize];
    [
        "Offset of field: CUpti_ActivityMemcpy5::end",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy5, end) - 24usize];
    [
        "Offset of field: CUpti_ActivityMemcpy5::deviceId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy5, deviceId) - 32usize];
    [
        "Offset of field: CUpti_ActivityMemcpy5::contextId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy5, contextId) - 36usize];
    [
        "Offset of field: CUpti_ActivityMemcpy5::streamId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy5, streamId) - 40usize];
    [
        "Offset of field: CUpti_ActivityMemcpy5::correlationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy5, correlationId) - 44usize];
    [
        "Offset of field: CUpti_ActivityMemcpy5::runtimeCorrelationId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy5, runtimeCorrelationId) - 48usize];
    [
        "Offset of field: CUpti_ActivityMemcpy5::pad",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy5, pad) - 52usize];
    [
        "Offset of field: CUpti_ActivityMemcpy5::reserved0",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy5, reserved0) - 56usize];
    [
        "Offset of field: CUpti_ActivityMemcpy5::graphNodeId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy5, graphNodeId) - 64usize];
    [
        "Offset of field: CUpti_ActivityMemcpy5::graphId",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy5, graphId) - 72usize];
    [
        "Offset of field: CUpti_ActivityMemcpy5::channelID",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy5, channelID) - 76usize];
    [
        "Offset of field: CUpti_ActivityMemcpy5::channelType",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy5, channelType) - 80usize];
    [
        "Offset of field: CUpti_ActivityMemcpy5::pad2",
    ][::std::mem::offset_of!(CUpti_ActivityMemcpy5, pad2) - 84usize];
};
impl Default for CUpti_ActivityMemcpy5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/** \brief The activity record providing detailed information for a marker.

 User must enable CUPTI_ACTIVITY_KIND_MARKER as well
 to get records for marker data.
 The marker data contains color, payload, and category.
 (CUPTI_ACTIVITY_KIND_MARKER_DATA).

 Structure deprecated in CUDA 13.1: Refer to CUpti_ActivityMarkerData2
 for the latest structure.*/
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMarkerData {
    /** The activity record kind, must be
 CUPTI_ACTIVITY_KIND_MARKER_DATA.*/
    pub kind: CUpti_ActivityKind,
    /// The flags associated with the marker. \see CUpti_ActivityFlag
    pub flags: CUpti_ActivityFlag,
    /// The marker ID.
    pub id: u32,
    /// Defines the payload format for the value associated with the marker.
    pub payloadKind: CUpti_MetricValueKind,
    /// The payload value.
    pub payload: CUpti_MetricValue,
    /// The color for the marker.
    pub color: u32,
    /// The category for the marker.
    pub category: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_ActivityMarkerData",
    ][::std::mem::size_of::<CUpti_ActivityMarkerData>() - 32usize];
    [
        "Alignment of CUpti_ActivityMarkerData",
    ][::std::mem::align_of::<CUpti_ActivityMarkerData>() - 8usize];
    [
        "Offset of field: CUpti_ActivityMarkerData::kind",
    ][::std::mem::offset_of!(CUpti_ActivityMarkerData, kind) - 0usize];
    [
        "Offset of field: CUpti_ActivityMarkerData::flags",
    ][::std::mem::offset_of!(CUpti_ActivityMarkerData, flags) - 4usize];
    [
        "Offset of field: CUpti_ActivityMarkerData::id",
    ][::std::mem::offset_of!(CUpti_ActivityMarkerData, id) - 8usize];
    [
        "Offset of field: CUpti_ActivityMarkerData::payloadKind",
    ][::std::mem::offset_of!(CUpti_ActivityMarkerData, payloadKind) - 12usize];
    [
        "Offset of field: CUpti_ActivityMarkerData::payload",
    ][::std::mem::offset_of!(CUpti_ActivityMarkerData, payload) - 16usize];
    [
        "Offset of field: CUpti_ActivityMarkerData::color",
    ][::std::mem::offset_of!(CUpti_ActivityMarkerData, color) - 24usize];
    [
        "Offset of field: CUpti_ActivityMarkerData::category",
    ][::std::mem::offset_of!(CUpti_ActivityMarkerData, category) - 28usize];
};
impl Default for CUpti_ActivityMarkerData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMarkerData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMarkerData {{ kind: {:?}, flags: {:?}, payloadKind: {:?}, payload: {:?} }}",
            self.kind,
            self.flags,
            self.payloadKind,
            self.payload,
        )
    }
}
pub const CUPTI_DRIVER_TRACE_CBID_INVALID: CUpti_driver_api_trace_cbid_enum = 0;
pub const CUPTI_DRIVER_TRACE_CBID_cuInit: CUpti_driver_api_trace_cbid_enum = 1;
pub const CUPTI_DRIVER_TRACE_CBID_cuDriverGetVersion: CUpti_driver_api_trace_cbid_enum = 2;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGet: CUpti_driver_api_trace_cbid_enum = 3;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetCount: CUpti_driver_api_trace_cbid_enum = 4;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetName: CUpti_driver_api_trace_cbid_enum = 5;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceComputeCapability: CUpti_driver_api_trace_cbid_enum = 6;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceTotalMem: CUpti_driver_api_trace_cbid_enum = 7;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetProperties: CUpti_driver_api_trace_cbid_enum = 8;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetAttribute: CUpti_driver_api_trace_cbid_enum = 9;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxCreate: CUpti_driver_api_trace_cbid_enum = 10;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxDestroy: CUpti_driver_api_trace_cbid_enum = 11;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxAttach: CUpti_driver_api_trace_cbid_enum = 12;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxDetach: CUpti_driver_api_trace_cbid_enum = 13;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxPushCurrent: CUpti_driver_api_trace_cbid_enum = 14;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxPopCurrent: CUpti_driver_api_trace_cbid_enum = 15;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetDevice: CUpti_driver_api_trace_cbid_enum = 16;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxSynchronize: CUpti_driver_api_trace_cbid_enum = 17;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleLoad: CUpti_driver_api_trace_cbid_enum = 18;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleLoadData: CUpti_driver_api_trace_cbid_enum = 19;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleLoadDataEx: CUpti_driver_api_trace_cbid_enum = 20;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleLoadFatBinary: CUpti_driver_api_trace_cbid_enum = 21;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleUnload: CUpti_driver_api_trace_cbid_enum = 22;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleGetFunction: CUpti_driver_api_trace_cbid_enum = 23;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleGetGlobal: CUpti_driver_api_trace_cbid_enum = 24;
pub const CUPTI_DRIVER_TRACE_CBID_cu64ModuleGetGlobal: CUpti_driver_api_trace_cbid_enum = 25;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleGetTexRef: CUpti_driver_api_trace_cbid_enum = 26;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemGetInfo: CUpti_driver_api_trace_cbid_enum = 27;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemGetInfo: CUpti_driver_api_trace_cbid_enum = 28;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAlloc: CUpti_driver_api_trace_cbid_enum = 29;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemAlloc: CUpti_driver_api_trace_cbid_enum = 30;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAllocPitch: CUpti_driver_api_trace_cbid_enum = 31;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemAllocPitch: CUpti_driver_api_trace_cbid_enum = 32;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemFree: CUpti_driver_api_trace_cbid_enum = 33;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemFree: CUpti_driver_api_trace_cbid_enum = 34;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemGetAddressRange: CUpti_driver_api_trace_cbid_enum = 35;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemGetAddressRange: CUpti_driver_api_trace_cbid_enum = 36;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAllocHost: CUpti_driver_api_trace_cbid_enum = 37;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemFreeHost: CUpti_driver_api_trace_cbid_enum = 38;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemHostAlloc: CUpti_driver_api_trace_cbid_enum = 39;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemHostGetDevicePointer: CUpti_driver_api_trace_cbid_enum = 40;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemHostGetDevicePointer: CUpti_driver_api_trace_cbid_enum = 41;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemHostGetFlags: CUpti_driver_api_trace_cbid_enum = 42;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoD: CUpti_driver_api_trace_cbid_enum = 43;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemcpyHtoD: CUpti_driver_api_trace_cbid_enum = 44;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoH: CUpti_driver_api_trace_cbid_enum = 45;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemcpyDtoH: CUpti_driver_api_trace_cbid_enum = 46;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoD: CUpti_driver_api_trace_cbid_enum = 47;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemcpyDtoD: CUpti_driver_api_trace_cbid_enum = 48;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoA: CUpti_driver_api_trace_cbid_enum = 49;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemcpyDtoA: CUpti_driver_api_trace_cbid_enum = 50;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoD: CUpti_driver_api_trace_cbid_enum = 51;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemcpyAtoD: CUpti_driver_api_trace_cbid_enum = 52;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoA: CUpti_driver_api_trace_cbid_enum = 53;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoH: CUpti_driver_api_trace_cbid_enum = 54;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoA: CUpti_driver_api_trace_cbid_enum = 55;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy2D: CUpti_driver_api_trace_cbid_enum = 56;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy2DUnaligned: CUpti_driver_api_trace_cbid_enum = 57;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3D: CUpti_driver_api_trace_cbid_enum = 58;
pub const CUPTI_DRIVER_TRACE_CBID_cu64Memcpy3D: CUpti_driver_api_trace_cbid_enum = 59;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoDAsync: CUpti_driver_api_trace_cbid_enum = 60;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemcpyHtoDAsync: CUpti_driver_api_trace_cbid_enum = 61;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoHAsync: CUpti_driver_api_trace_cbid_enum = 62;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemcpyDtoHAsync: CUpti_driver_api_trace_cbid_enum = 63;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoDAsync: CUpti_driver_api_trace_cbid_enum = 64;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemcpyDtoDAsync: CUpti_driver_api_trace_cbid_enum = 65;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoAAsync: CUpti_driver_api_trace_cbid_enum = 66;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoHAsync: CUpti_driver_api_trace_cbid_enum = 67;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy2DAsync: CUpti_driver_api_trace_cbid_enum = 68;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3DAsync: CUpti_driver_api_trace_cbid_enum = 69;
pub const CUPTI_DRIVER_TRACE_CBID_cu64Memcpy3DAsync: CUpti_driver_api_trace_cbid_enum = 70;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD8: CUpti_driver_api_trace_cbid_enum = 71;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD8: CUpti_driver_api_trace_cbid_enum = 72;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD16: CUpti_driver_api_trace_cbid_enum = 73;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD16: CUpti_driver_api_trace_cbid_enum = 74;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD32: CUpti_driver_api_trace_cbid_enum = 75;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD32: CUpti_driver_api_trace_cbid_enum = 76;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D8: CUpti_driver_api_trace_cbid_enum = 77;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD2D8: CUpti_driver_api_trace_cbid_enum = 78;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D16: CUpti_driver_api_trace_cbid_enum = 79;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD2D16: CUpti_driver_api_trace_cbid_enum = 80;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D32: CUpti_driver_api_trace_cbid_enum = 81;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD2D32: CUpti_driver_api_trace_cbid_enum = 82;
pub const CUPTI_DRIVER_TRACE_CBID_cuFuncSetBlockShape: CUpti_driver_api_trace_cbid_enum = 83;
pub const CUPTI_DRIVER_TRACE_CBID_cuFuncSetSharedSize: CUpti_driver_api_trace_cbid_enum = 84;
pub const CUPTI_DRIVER_TRACE_CBID_cuFuncGetAttribute: CUpti_driver_api_trace_cbid_enum = 85;
pub const CUPTI_DRIVER_TRACE_CBID_cuFuncSetCacheConfig: CUpti_driver_api_trace_cbid_enum = 86;
pub const CUPTI_DRIVER_TRACE_CBID_cuArrayCreate: CUpti_driver_api_trace_cbid_enum = 87;
pub const CUPTI_DRIVER_TRACE_CBID_cuArrayGetDescriptor: CUpti_driver_api_trace_cbid_enum = 88;
pub const CUPTI_DRIVER_TRACE_CBID_cuArrayDestroy: CUpti_driver_api_trace_cbid_enum = 89;
pub const CUPTI_DRIVER_TRACE_CBID_cuArray3DCreate: CUpti_driver_api_trace_cbid_enum = 90;
pub const CUPTI_DRIVER_TRACE_CBID_cuArray3DGetDescriptor: CUpti_driver_api_trace_cbid_enum = 91;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefCreate: CUpti_driver_api_trace_cbid_enum = 92;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefDestroy: CUpti_driver_api_trace_cbid_enum = 93;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetArray: CUpti_driver_api_trace_cbid_enum = 94;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetAddress: CUpti_driver_api_trace_cbid_enum = 95;
pub const CUPTI_DRIVER_TRACE_CBID_cu64TexRefSetAddress: CUpti_driver_api_trace_cbid_enum = 96;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetAddress2D: CUpti_driver_api_trace_cbid_enum = 97;
pub const CUPTI_DRIVER_TRACE_CBID_cu64TexRefSetAddress2D: CUpti_driver_api_trace_cbid_enum = 98;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetFormat: CUpti_driver_api_trace_cbid_enum = 99;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetAddressMode: CUpti_driver_api_trace_cbid_enum = 100;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetFilterMode: CUpti_driver_api_trace_cbid_enum = 101;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetFlags: CUpti_driver_api_trace_cbid_enum = 102;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetAddress: CUpti_driver_api_trace_cbid_enum = 103;
pub const CUPTI_DRIVER_TRACE_CBID_cu64TexRefGetAddress: CUpti_driver_api_trace_cbid_enum = 104;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetArray: CUpti_driver_api_trace_cbid_enum = 105;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetAddressMode: CUpti_driver_api_trace_cbid_enum = 106;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetFilterMode: CUpti_driver_api_trace_cbid_enum = 107;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetFormat: CUpti_driver_api_trace_cbid_enum = 108;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetFlags: CUpti_driver_api_trace_cbid_enum = 109;
pub const CUPTI_DRIVER_TRACE_CBID_cuParamSetSize: CUpti_driver_api_trace_cbid_enum = 110;
pub const CUPTI_DRIVER_TRACE_CBID_cuParamSeti: CUpti_driver_api_trace_cbid_enum = 111;
pub const CUPTI_DRIVER_TRACE_CBID_cuParamSetf: CUpti_driver_api_trace_cbid_enum = 112;
pub const CUPTI_DRIVER_TRACE_CBID_cuParamSetv: CUpti_driver_api_trace_cbid_enum = 113;
pub const CUPTI_DRIVER_TRACE_CBID_cuParamSetTexRef: CUpti_driver_api_trace_cbid_enum = 114;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunch: CUpti_driver_api_trace_cbid_enum = 115;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunchGrid: CUpti_driver_api_trace_cbid_enum = 116;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunchGridAsync: CUpti_driver_api_trace_cbid_enum = 117;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventCreate: CUpti_driver_api_trace_cbid_enum = 118;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventRecord: CUpti_driver_api_trace_cbid_enum = 119;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventQuery: CUpti_driver_api_trace_cbid_enum = 120;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventSynchronize: CUpti_driver_api_trace_cbid_enum = 121;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventDestroy: CUpti_driver_api_trace_cbid_enum = 122;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventElapsedTime: CUpti_driver_api_trace_cbid_enum = 123;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamCreate: CUpti_driver_api_trace_cbid_enum = 124;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamQuery: CUpti_driver_api_trace_cbid_enum = 125;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamSynchronize: CUpti_driver_api_trace_cbid_enum = 126;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamDestroy: CUpti_driver_api_trace_cbid_enum = 127;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsUnregisterResource: CUpti_driver_api_trace_cbid_enum = 128;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsSubResourceGetMappedArray: CUpti_driver_api_trace_cbid_enum = 129;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsResourceGetMappedPointer: CUpti_driver_api_trace_cbid_enum = 130;
pub const CUPTI_DRIVER_TRACE_CBID_cu64GraphicsResourceGetMappedPointer: CUpti_driver_api_trace_cbid_enum = 131;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsResourceSetMapFlags: CUpti_driver_api_trace_cbid_enum = 132;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsMapResources: CUpti_driver_api_trace_cbid_enum = 133;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsUnmapResources: CUpti_driver_api_trace_cbid_enum = 134;
pub const CUPTI_DRIVER_TRACE_CBID_cuGetExportTable: CUpti_driver_api_trace_cbid_enum = 135;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxSetLimit: CUpti_driver_api_trace_cbid_enum = 136;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetLimit: CUpti_driver_api_trace_cbid_enum = 137;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10GetDevice: CUpti_driver_api_trace_cbid_enum = 138;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10CtxCreate: CUpti_driver_api_trace_cbid_enum = 139;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsD3D10RegisterResource: CUpti_driver_api_trace_cbid_enum = 140;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10RegisterResource: CUpti_driver_api_trace_cbid_enum = 141;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10UnregisterResource: CUpti_driver_api_trace_cbid_enum = 142;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10MapResources: CUpti_driver_api_trace_cbid_enum = 143;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10UnmapResources: CUpti_driver_api_trace_cbid_enum = 144;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10ResourceSetMapFlags: CUpti_driver_api_trace_cbid_enum = 145;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10ResourceGetMappedArray: CUpti_driver_api_trace_cbid_enum = 146;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10ResourceGetMappedPointer: CUpti_driver_api_trace_cbid_enum = 147;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10ResourceGetMappedSize: CUpti_driver_api_trace_cbid_enum = 148;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10ResourceGetMappedPitch: CUpti_driver_api_trace_cbid_enum = 149;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10ResourceGetSurfaceDimensions: CUpti_driver_api_trace_cbid_enum = 150;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D11GetDevice: CUpti_driver_api_trace_cbid_enum = 151;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D11CtxCreate: CUpti_driver_api_trace_cbid_enum = 152;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsD3D11RegisterResource: CUpti_driver_api_trace_cbid_enum = 153;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9GetDevice: CUpti_driver_api_trace_cbid_enum = 154;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9CtxCreate: CUpti_driver_api_trace_cbid_enum = 155;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsD3D9RegisterResource: CUpti_driver_api_trace_cbid_enum = 156;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9GetDirect3DDevice: CUpti_driver_api_trace_cbid_enum = 157;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9RegisterResource: CUpti_driver_api_trace_cbid_enum = 158;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9UnregisterResource: CUpti_driver_api_trace_cbid_enum = 159;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9MapResources: CUpti_driver_api_trace_cbid_enum = 160;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9UnmapResources: CUpti_driver_api_trace_cbid_enum = 161;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9ResourceSetMapFlags: CUpti_driver_api_trace_cbid_enum = 162;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9ResourceGetSurfaceDimensions: CUpti_driver_api_trace_cbid_enum = 163;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9ResourceGetMappedArray: CUpti_driver_api_trace_cbid_enum = 164;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9ResourceGetMappedPointer: CUpti_driver_api_trace_cbid_enum = 165;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9ResourceGetMappedSize: CUpti_driver_api_trace_cbid_enum = 166;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9ResourceGetMappedPitch: CUpti_driver_api_trace_cbid_enum = 167;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9Begin: CUpti_driver_api_trace_cbid_enum = 168;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9End: CUpti_driver_api_trace_cbid_enum = 169;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9RegisterVertexBuffer: CUpti_driver_api_trace_cbid_enum = 170;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9MapVertexBuffer: CUpti_driver_api_trace_cbid_enum = 171;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9UnmapVertexBuffer: CUpti_driver_api_trace_cbid_enum = 172;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9UnregisterVertexBuffer: CUpti_driver_api_trace_cbid_enum = 173;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLCtxCreate: CUpti_driver_api_trace_cbid_enum = 174;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsGLRegisterBuffer: CUpti_driver_api_trace_cbid_enum = 175;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsGLRegisterImage: CUpti_driver_api_trace_cbid_enum = 176;
pub const CUPTI_DRIVER_TRACE_CBID_cuWGLGetDevice: CUpti_driver_api_trace_cbid_enum = 177;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLInit: CUpti_driver_api_trace_cbid_enum = 178;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLRegisterBufferObject: CUpti_driver_api_trace_cbid_enum = 179;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLMapBufferObject: CUpti_driver_api_trace_cbid_enum = 180;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLUnmapBufferObject: CUpti_driver_api_trace_cbid_enum = 181;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLUnregisterBufferObject: CUpti_driver_api_trace_cbid_enum = 182;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLSetBufferObjectMapFlags: CUpti_driver_api_trace_cbid_enum = 183;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLMapBufferObjectAsync: CUpti_driver_api_trace_cbid_enum = 184;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLUnmapBufferObjectAsync: CUpti_driver_api_trace_cbid_enum = 185;
pub const CUPTI_DRIVER_TRACE_CBID_cuVDPAUGetDevice: CUpti_driver_api_trace_cbid_enum = 186;
pub const CUPTI_DRIVER_TRACE_CBID_cuVDPAUCtxCreate: CUpti_driver_api_trace_cbid_enum = 187;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsVDPAURegisterVideoSurface: CUpti_driver_api_trace_cbid_enum = 188;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsVDPAURegisterOutputSurface: CUpti_driver_api_trace_cbid_enum = 189;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleGetSurfRef: CUpti_driver_api_trace_cbid_enum = 190;
pub const CUPTI_DRIVER_TRACE_CBID_cuSurfRefCreate: CUpti_driver_api_trace_cbid_enum = 191;
pub const CUPTI_DRIVER_TRACE_CBID_cuSurfRefDestroy: CUpti_driver_api_trace_cbid_enum = 192;
pub const CUPTI_DRIVER_TRACE_CBID_cuSurfRefSetFormat: CUpti_driver_api_trace_cbid_enum = 193;
pub const CUPTI_DRIVER_TRACE_CBID_cuSurfRefSetArray: CUpti_driver_api_trace_cbid_enum = 194;
pub const CUPTI_DRIVER_TRACE_CBID_cuSurfRefGetFormat: CUpti_driver_api_trace_cbid_enum = 195;
pub const CUPTI_DRIVER_TRACE_CBID_cuSurfRefGetArray: CUpti_driver_api_trace_cbid_enum = 196;
pub const CUPTI_DRIVER_TRACE_CBID_cu64DeviceTotalMem: CUpti_driver_api_trace_cbid_enum = 197;
pub const CUPTI_DRIVER_TRACE_CBID_cu64D3D10ResourceGetMappedPointer: CUpti_driver_api_trace_cbid_enum = 198;
pub const CUPTI_DRIVER_TRACE_CBID_cu64D3D10ResourceGetMappedSize: CUpti_driver_api_trace_cbid_enum = 199;
pub const CUPTI_DRIVER_TRACE_CBID_cu64D3D10ResourceGetMappedPitch: CUpti_driver_api_trace_cbid_enum = 200;
pub const CUPTI_DRIVER_TRACE_CBID_cu64D3D10ResourceGetSurfaceDimensions: CUpti_driver_api_trace_cbid_enum = 201;
pub const CUPTI_DRIVER_TRACE_CBID_cu64D3D9ResourceGetSurfaceDimensions: CUpti_driver_api_trace_cbid_enum = 202;
pub const CUPTI_DRIVER_TRACE_CBID_cu64D3D9ResourceGetMappedPointer: CUpti_driver_api_trace_cbid_enum = 203;
pub const CUPTI_DRIVER_TRACE_CBID_cu64D3D9ResourceGetMappedSize: CUpti_driver_api_trace_cbid_enum = 204;
pub const CUPTI_DRIVER_TRACE_CBID_cu64D3D9ResourceGetMappedPitch: CUpti_driver_api_trace_cbid_enum = 205;
pub const CUPTI_DRIVER_TRACE_CBID_cu64D3D9MapVertexBuffer: CUpti_driver_api_trace_cbid_enum = 206;
pub const CUPTI_DRIVER_TRACE_CBID_cu64GLMapBufferObject: CUpti_driver_api_trace_cbid_enum = 207;
pub const CUPTI_DRIVER_TRACE_CBID_cu64GLMapBufferObjectAsync: CUpti_driver_api_trace_cbid_enum = 208;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D11GetDevices: CUpti_driver_api_trace_cbid_enum = 209;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D11CtxCreateOnDevice: CUpti_driver_api_trace_cbid_enum = 210;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10GetDevices: CUpti_driver_api_trace_cbid_enum = 211;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10CtxCreateOnDevice: CUpti_driver_api_trace_cbid_enum = 212;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9GetDevices: CUpti_driver_api_trace_cbid_enum = 213;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9CtxCreateOnDevice: CUpti_driver_api_trace_cbid_enum = 214;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemHostAlloc: CUpti_driver_api_trace_cbid_enum = 215;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD8Async: CUpti_driver_api_trace_cbid_enum = 216;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD8Async: CUpti_driver_api_trace_cbid_enum = 217;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD16Async: CUpti_driver_api_trace_cbid_enum = 218;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD16Async: CUpti_driver_api_trace_cbid_enum = 219;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD32Async: CUpti_driver_api_trace_cbid_enum = 220;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD32Async: CUpti_driver_api_trace_cbid_enum = 221;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D8Async: CUpti_driver_api_trace_cbid_enum = 222;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD2D8Async: CUpti_driver_api_trace_cbid_enum = 223;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D16Async: CUpti_driver_api_trace_cbid_enum = 224;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD2D16Async: CUpti_driver_api_trace_cbid_enum = 225;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D32Async: CUpti_driver_api_trace_cbid_enum = 226;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD2D32Async: CUpti_driver_api_trace_cbid_enum = 227;
pub const CUPTI_DRIVER_TRACE_CBID_cu64ArrayCreate: CUpti_driver_api_trace_cbid_enum = 228;
pub const CUPTI_DRIVER_TRACE_CBID_cu64ArrayGetDescriptor: CUpti_driver_api_trace_cbid_enum = 229;
pub const CUPTI_DRIVER_TRACE_CBID_cu64Array3DCreate: CUpti_driver_api_trace_cbid_enum = 230;
pub const CUPTI_DRIVER_TRACE_CBID_cu64Array3DGetDescriptor: CUpti_driver_api_trace_cbid_enum = 231;
pub const CUPTI_DRIVER_TRACE_CBID_cu64Memcpy2D: CUpti_driver_api_trace_cbid_enum = 232;
pub const CUPTI_DRIVER_TRACE_CBID_cu64Memcpy2DUnaligned: CUpti_driver_api_trace_cbid_enum = 233;
pub const CUPTI_DRIVER_TRACE_CBID_cu64Memcpy2DAsync: CUpti_driver_api_trace_cbid_enum = 234;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxCreate_v2: CUpti_driver_api_trace_cbid_enum = 235;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10CtxCreate_v2: CUpti_driver_api_trace_cbid_enum = 236;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D11CtxCreate_v2: CUpti_driver_api_trace_cbid_enum = 237;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9CtxCreate_v2: CUpti_driver_api_trace_cbid_enum = 238;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLCtxCreate_v2: CUpti_driver_api_trace_cbid_enum = 239;
pub const CUPTI_DRIVER_TRACE_CBID_cuVDPAUCtxCreate_v2: CUpti_driver_api_trace_cbid_enum = 240;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleGetGlobal_v2: CUpti_driver_api_trace_cbid_enum = 241;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemGetInfo_v2: CUpti_driver_api_trace_cbid_enum = 242;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAlloc_v2: CUpti_driver_api_trace_cbid_enum = 243;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAllocPitch_v2: CUpti_driver_api_trace_cbid_enum = 244;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemFree_v2: CUpti_driver_api_trace_cbid_enum = 245;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemGetAddressRange_v2: CUpti_driver_api_trace_cbid_enum = 246;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemHostGetDevicePointer_v2: CUpti_driver_api_trace_cbid_enum = 247;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy_v2: CUpti_driver_api_trace_cbid_enum = 248;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD8_v2: CUpti_driver_api_trace_cbid_enum = 249;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD16_v2: CUpti_driver_api_trace_cbid_enum = 250;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD32_v2: CUpti_driver_api_trace_cbid_enum = 251;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D8_v2: CUpti_driver_api_trace_cbid_enum = 252;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D16_v2: CUpti_driver_api_trace_cbid_enum = 253;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D32_v2: CUpti_driver_api_trace_cbid_enum = 254;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetAddress_v2: CUpti_driver_api_trace_cbid_enum = 255;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetAddress2D_v2: CUpti_driver_api_trace_cbid_enum = 256;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetAddress_v2: CUpti_driver_api_trace_cbid_enum = 257;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsResourceGetMappedPointer_v2: CUpti_driver_api_trace_cbid_enum = 258;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceTotalMem_v2: CUpti_driver_api_trace_cbid_enum = 259;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10ResourceGetMappedPointer_v2: CUpti_driver_api_trace_cbid_enum = 260;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10ResourceGetMappedSize_v2: CUpti_driver_api_trace_cbid_enum = 261;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10ResourceGetMappedPitch_v2: CUpti_driver_api_trace_cbid_enum = 262;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10ResourceGetSurfaceDimensions_v2: CUpti_driver_api_trace_cbid_enum = 263;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9ResourceGetSurfaceDimensions_v2: CUpti_driver_api_trace_cbid_enum = 264;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9ResourceGetMappedPointer_v2: CUpti_driver_api_trace_cbid_enum = 265;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9ResourceGetMappedSize_v2: CUpti_driver_api_trace_cbid_enum = 266;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9ResourceGetMappedPitch_v2: CUpti_driver_api_trace_cbid_enum = 267;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9MapVertexBuffer_v2: CUpti_driver_api_trace_cbid_enum = 268;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLMapBufferObject_v2: CUpti_driver_api_trace_cbid_enum = 269;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLMapBufferObjectAsync_v2: CUpti_driver_api_trace_cbid_enum = 270;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemHostAlloc_v2: CUpti_driver_api_trace_cbid_enum = 271;
pub const CUPTI_DRIVER_TRACE_CBID_cuArrayCreate_v2: CUpti_driver_api_trace_cbid_enum = 272;
pub const CUPTI_DRIVER_TRACE_CBID_cuArrayGetDescriptor_v2: CUpti_driver_api_trace_cbid_enum = 273;
pub const CUPTI_DRIVER_TRACE_CBID_cuArray3DCreate_v2: CUpti_driver_api_trace_cbid_enum = 274;
pub const CUPTI_DRIVER_TRACE_CBID_cuArray3DGetDescriptor_v2: CUpti_driver_api_trace_cbid_enum = 275;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoD_v2: CUpti_driver_api_trace_cbid_enum = 276;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoDAsync_v2: CUpti_driver_api_trace_cbid_enum = 277;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoH_v2: CUpti_driver_api_trace_cbid_enum = 278;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoHAsync_v2: CUpti_driver_api_trace_cbid_enum = 279;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoD_v2: CUpti_driver_api_trace_cbid_enum = 280;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoDAsync_v2: CUpti_driver_api_trace_cbid_enum = 281;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoH_v2: CUpti_driver_api_trace_cbid_enum = 282;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoHAsync_v2: CUpti_driver_api_trace_cbid_enum = 283;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoD_v2: CUpti_driver_api_trace_cbid_enum = 284;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoA_v2: CUpti_driver_api_trace_cbid_enum = 285;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoA_v2: CUpti_driver_api_trace_cbid_enum = 286;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy2D_v2: CUpti_driver_api_trace_cbid_enum = 287;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy2DUnaligned_v2: CUpti_driver_api_trace_cbid_enum = 288;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy2DAsync_v2: CUpti_driver_api_trace_cbid_enum = 289;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3D_v2: CUpti_driver_api_trace_cbid_enum = 290;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3DAsync_v2: CUpti_driver_api_trace_cbid_enum = 291;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoA_v2: CUpti_driver_api_trace_cbid_enum = 292;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoAAsync_v2: CUpti_driver_api_trace_cbid_enum = 293;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAllocHost_v2: CUpti_driver_api_trace_cbid_enum = 294;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWaitEvent: CUpti_driver_api_trace_cbid_enum = 295;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetApiVersion: CUpti_driver_api_trace_cbid_enum = 296;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10GetDirect3DDevice: CUpti_driver_api_trace_cbid_enum = 297;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D11GetDirect3DDevice: CUpti_driver_api_trace_cbid_enum = 298;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetCacheConfig: CUpti_driver_api_trace_cbid_enum = 299;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxSetCacheConfig: CUpti_driver_api_trace_cbid_enum = 300;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemHostRegister: CUpti_driver_api_trace_cbid_enum = 301;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemHostUnregister: CUpti_driver_api_trace_cbid_enum = 302;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxSetCurrent: CUpti_driver_api_trace_cbid_enum = 303;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetCurrent: CUpti_driver_api_trace_cbid_enum = 304;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy: CUpti_driver_api_trace_cbid_enum = 305;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAsync: CUpti_driver_api_trace_cbid_enum = 306;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunchKernel: CUpti_driver_api_trace_cbid_enum = 307;
pub const CUPTI_DRIVER_TRACE_CBID_cuProfilerStart: CUpti_driver_api_trace_cbid_enum = 308;
pub const CUPTI_DRIVER_TRACE_CBID_cuProfilerStop: CUpti_driver_api_trace_cbid_enum = 309;
pub const CUPTI_DRIVER_TRACE_CBID_cuPointerGetAttribute: CUpti_driver_api_trace_cbid_enum = 310;
pub const CUPTI_DRIVER_TRACE_CBID_cuProfilerInitialize: CUpti_driver_api_trace_cbid_enum = 311;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceCanAccessPeer: CUpti_driver_api_trace_cbid_enum = 312;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxEnablePeerAccess: CUpti_driver_api_trace_cbid_enum = 313;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxDisablePeerAccess: CUpti_driver_api_trace_cbid_enum = 314;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPeerRegister: CUpti_driver_api_trace_cbid_enum = 315;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPeerUnregister: CUpti_driver_api_trace_cbid_enum = 316;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPeerGetDevicePointer: CUpti_driver_api_trace_cbid_enum = 317;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyPeer: CUpti_driver_api_trace_cbid_enum = 318;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyPeerAsync: CUpti_driver_api_trace_cbid_enum = 319;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3DPeer: CUpti_driver_api_trace_cbid_enum = 320;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3DPeerAsync: CUpti_driver_api_trace_cbid_enum = 321;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxDestroy_v2: CUpti_driver_api_trace_cbid_enum = 322;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxPushCurrent_v2: CUpti_driver_api_trace_cbid_enum = 323;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxPopCurrent_v2: CUpti_driver_api_trace_cbid_enum = 324;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventDestroy_v2: CUpti_driver_api_trace_cbid_enum = 325;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamDestroy_v2: CUpti_driver_api_trace_cbid_enum = 326;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetAddress2D_v3: CUpti_driver_api_trace_cbid_enum = 327;
pub const CUPTI_DRIVER_TRACE_CBID_cuIpcGetMemHandle: CUpti_driver_api_trace_cbid_enum = 328;
pub const CUPTI_DRIVER_TRACE_CBID_cuIpcOpenMemHandle: CUpti_driver_api_trace_cbid_enum = 329;
pub const CUPTI_DRIVER_TRACE_CBID_cuIpcCloseMemHandle: CUpti_driver_api_trace_cbid_enum = 330;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetByPCIBusId: CUpti_driver_api_trace_cbid_enum = 331;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetPCIBusId: CUpti_driver_api_trace_cbid_enum = 332;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLGetDevices: CUpti_driver_api_trace_cbid_enum = 333;
pub const CUPTI_DRIVER_TRACE_CBID_cuIpcGetEventHandle: CUpti_driver_api_trace_cbid_enum = 334;
pub const CUPTI_DRIVER_TRACE_CBID_cuIpcOpenEventHandle: CUpti_driver_api_trace_cbid_enum = 335;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxSetSharedMemConfig: CUpti_driver_api_trace_cbid_enum = 336;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetSharedMemConfig: CUpti_driver_api_trace_cbid_enum = 337;
pub const CUPTI_DRIVER_TRACE_CBID_cuFuncSetSharedMemConfig: CUpti_driver_api_trace_cbid_enum = 338;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexObjectCreate: CUpti_driver_api_trace_cbid_enum = 339;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexObjectDestroy: CUpti_driver_api_trace_cbid_enum = 340;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexObjectGetResourceDesc: CUpti_driver_api_trace_cbid_enum = 341;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexObjectGetTextureDesc: CUpti_driver_api_trace_cbid_enum = 342;
pub const CUPTI_DRIVER_TRACE_CBID_cuSurfObjectCreate: CUpti_driver_api_trace_cbid_enum = 343;
pub const CUPTI_DRIVER_TRACE_CBID_cuSurfObjectDestroy: CUpti_driver_api_trace_cbid_enum = 344;
pub const CUPTI_DRIVER_TRACE_CBID_cuSurfObjectGetResourceDesc: CUpti_driver_api_trace_cbid_enum = 345;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamAddCallback: CUpti_driver_api_trace_cbid_enum = 346;
pub const CUPTI_DRIVER_TRACE_CBID_cuMipmappedArrayCreate: CUpti_driver_api_trace_cbid_enum = 347;
pub const CUPTI_DRIVER_TRACE_CBID_cuMipmappedArrayGetLevel: CUpti_driver_api_trace_cbid_enum = 348;
pub const CUPTI_DRIVER_TRACE_CBID_cuMipmappedArrayDestroy: CUpti_driver_api_trace_cbid_enum = 349;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetMipmappedArray: CUpti_driver_api_trace_cbid_enum = 350;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetMipmapFilterMode: CUpti_driver_api_trace_cbid_enum = 351;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetMipmapLevelBias: CUpti_driver_api_trace_cbid_enum = 352;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetMipmapLevelClamp: CUpti_driver_api_trace_cbid_enum = 353;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetMaxAnisotropy: CUpti_driver_api_trace_cbid_enum = 354;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetMipmappedArray: CUpti_driver_api_trace_cbid_enum = 355;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetMipmapFilterMode: CUpti_driver_api_trace_cbid_enum = 356;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetMipmapLevelBias: CUpti_driver_api_trace_cbid_enum = 357;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetMipmapLevelClamp: CUpti_driver_api_trace_cbid_enum = 358;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetMaxAnisotropy: CUpti_driver_api_trace_cbid_enum = 359;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsResourceGetMappedMipmappedArray: CUpti_driver_api_trace_cbid_enum = 360;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexObjectGetResourceViewDesc: CUpti_driver_api_trace_cbid_enum = 361;
pub const CUPTI_DRIVER_TRACE_CBID_cuLinkCreate: CUpti_driver_api_trace_cbid_enum = 362;
pub const CUPTI_DRIVER_TRACE_CBID_cuLinkAddData: CUpti_driver_api_trace_cbid_enum = 363;
pub const CUPTI_DRIVER_TRACE_CBID_cuLinkAddFile: CUpti_driver_api_trace_cbid_enum = 364;
pub const CUPTI_DRIVER_TRACE_CBID_cuLinkComplete: CUpti_driver_api_trace_cbid_enum = 365;
pub const CUPTI_DRIVER_TRACE_CBID_cuLinkDestroy: CUpti_driver_api_trace_cbid_enum = 366;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamCreateWithPriority: CUpti_driver_api_trace_cbid_enum = 367;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetPriority: CUpti_driver_api_trace_cbid_enum = 368;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetFlags: CUpti_driver_api_trace_cbid_enum = 369;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetStreamPriorityRange: CUpti_driver_api_trace_cbid_enum = 370;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAllocManaged: CUpti_driver_api_trace_cbid_enum = 371;
pub const CUPTI_DRIVER_TRACE_CBID_cuGetErrorString: CUpti_driver_api_trace_cbid_enum = 372;
pub const CUPTI_DRIVER_TRACE_CBID_cuGetErrorName: CUpti_driver_api_trace_cbid_enum = 373;
pub const CUPTI_DRIVER_TRACE_CBID_cuOccupancyMaxActiveBlocksPerMultiprocessor: CUpti_driver_api_trace_cbid_enum = 374;
pub const CUPTI_DRIVER_TRACE_CBID_cuCompilePtx: CUpti_driver_api_trace_cbid_enum = 375;
pub const CUPTI_DRIVER_TRACE_CBID_cuBinaryFree: CUpti_driver_api_trace_cbid_enum = 376;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamAttachMemAsync: CUpti_driver_api_trace_cbid_enum = 377;
pub const CUPTI_DRIVER_TRACE_CBID_cuPointerSetAttribute: CUpti_driver_api_trace_cbid_enum = 378;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemHostRegister_v2: CUpti_driver_api_trace_cbid_enum = 379;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsResourceSetMapFlags_v2: CUpti_driver_api_trace_cbid_enum = 380;
pub const CUPTI_DRIVER_TRACE_CBID_cuLinkCreate_v2: CUpti_driver_api_trace_cbid_enum = 381;
pub const CUPTI_DRIVER_TRACE_CBID_cuLinkAddData_v2: CUpti_driver_api_trace_cbid_enum = 382;
pub const CUPTI_DRIVER_TRACE_CBID_cuLinkAddFile_v2: CUpti_driver_api_trace_cbid_enum = 383;
pub const CUPTI_DRIVER_TRACE_CBID_cuOccupancyMaxPotentialBlockSize: CUpti_driver_api_trace_cbid_enum = 384;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLGetDevices_v2: CUpti_driver_api_trace_cbid_enum = 385;
pub const CUPTI_DRIVER_TRACE_CBID_cuDevicePrimaryCtxRetain: CUpti_driver_api_trace_cbid_enum = 386;
pub const CUPTI_DRIVER_TRACE_CBID_cuDevicePrimaryCtxRelease: CUpti_driver_api_trace_cbid_enum = 387;
pub const CUPTI_DRIVER_TRACE_CBID_cuDevicePrimaryCtxSetFlags: CUpti_driver_api_trace_cbid_enum = 388;
pub const CUPTI_DRIVER_TRACE_CBID_cuDevicePrimaryCtxReset: CUpti_driver_api_trace_cbid_enum = 389;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsEGLRegisterImage: CUpti_driver_api_trace_cbid_enum = 390;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetFlags: CUpti_driver_api_trace_cbid_enum = 391;
pub const CUPTI_DRIVER_TRACE_CBID_cuDevicePrimaryCtxGetState: CUpti_driver_api_trace_cbid_enum = 392;
pub const CUPTI_DRIVER_TRACE_CBID_cuEGLStreamConsumerConnect: CUpti_driver_api_trace_cbid_enum = 393;
pub const CUPTI_DRIVER_TRACE_CBID_cuEGLStreamConsumerDisconnect: CUpti_driver_api_trace_cbid_enum = 394;
pub const CUPTI_DRIVER_TRACE_CBID_cuEGLStreamConsumerAcquireFrame: CUpti_driver_api_trace_cbid_enum = 395;
pub const CUPTI_DRIVER_TRACE_CBID_cuEGLStreamConsumerReleaseFrame: CUpti_driver_api_trace_cbid_enum = 396;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoD_v2_ptds: CUpti_driver_api_trace_cbid_enum = 397;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoH_v2_ptds: CUpti_driver_api_trace_cbid_enum = 398;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoD_v2_ptds: CUpti_driver_api_trace_cbid_enum = 399;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoA_v2_ptds: CUpti_driver_api_trace_cbid_enum = 400;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoD_v2_ptds: CUpti_driver_api_trace_cbid_enum = 401;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoA_v2_ptds: CUpti_driver_api_trace_cbid_enum = 402;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoH_v2_ptds: CUpti_driver_api_trace_cbid_enum = 403;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoA_v2_ptds: CUpti_driver_api_trace_cbid_enum = 404;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy2D_v2_ptds: CUpti_driver_api_trace_cbid_enum = 405;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy2DUnaligned_v2_ptds: CUpti_driver_api_trace_cbid_enum = 406;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3D_v2_ptds: CUpti_driver_api_trace_cbid_enum = 407;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy_ptds: CUpti_driver_api_trace_cbid_enum = 408;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyPeer_ptds: CUpti_driver_api_trace_cbid_enum = 409;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3DPeer_ptds: CUpti_driver_api_trace_cbid_enum = 410;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD8_v2_ptds: CUpti_driver_api_trace_cbid_enum = 411;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD16_v2_ptds: CUpti_driver_api_trace_cbid_enum = 412;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD32_v2_ptds: CUpti_driver_api_trace_cbid_enum = 413;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D8_v2_ptds: CUpti_driver_api_trace_cbid_enum = 414;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D16_v2_ptds: CUpti_driver_api_trace_cbid_enum = 415;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D32_v2_ptds: CUpti_driver_api_trace_cbid_enum = 416;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLMapBufferObject_v2_ptds: CUpti_driver_api_trace_cbid_enum = 417;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 418;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoAAsync_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 419;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoHAsync_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 420;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoDAsync_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 421;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoHAsync_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 422;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoDAsync_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 423;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy2DAsync_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 424;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3DAsync_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 425;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyPeerAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 426;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3DPeerAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 427;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD8Async_ptsz: CUpti_driver_api_trace_cbid_enum = 428;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD16Async_ptsz: CUpti_driver_api_trace_cbid_enum = 429;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD32Async_ptsz: CUpti_driver_api_trace_cbid_enum = 430;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D8Async_ptsz: CUpti_driver_api_trace_cbid_enum = 431;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D16Async_ptsz: CUpti_driver_api_trace_cbid_enum = 432;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D32Async_ptsz: CUpti_driver_api_trace_cbid_enum = 433;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetPriority_ptsz: CUpti_driver_api_trace_cbid_enum = 434;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetFlags_ptsz: CUpti_driver_api_trace_cbid_enum = 435;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWaitEvent_ptsz: CUpti_driver_api_trace_cbid_enum = 436;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamAddCallback_ptsz: CUpti_driver_api_trace_cbid_enum = 437;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamAttachMemAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 438;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamQuery_ptsz: CUpti_driver_api_trace_cbid_enum = 439;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamSynchronize_ptsz: CUpti_driver_api_trace_cbid_enum = 440;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventRecord_ptsz: CUpti_driver_api_trace_cbid_enum = 441;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunchKernel_ptsz: CUpti_driver_api_trace_cbid_enum = 442;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsMapResources_ptsz: CUpti_driver_api_trace_cbid_enum = 443;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsUnmapResources_ptsz: CUpti_driver_api_trace_cbid_enum = 444;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLMapBufferObjectAsync_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 445;
pub const CUPTI_DRIVER_TRACE_CBID_cuEGLStreamProducerConnect: CUpti_driver_api_trace_cbid_enum = 446;
pub const CUPTI_DRIVER_TRACE_CBID_cuEGLStreamProducerDisconnect: CUpti_driver_api_trace_cbid_enum = 447;
pub const CUPTI_DRIVER_TRACE_CBID_cuEGLStreamProducerPresentFrame: CUpti_driver_api_trace_cbid_enum = 448;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsResourceGetMappedEglFrame: CUpti_driver_api_trace_cbid_enum = 449;
pub const CUPTI_DRIVER_TRACE_CBID_cuPointerGetAttributes: CUpti_driver_api_trace_cbid_enum = 450;
pub const CUPTI_DRIVER_TRACE_CBID_cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags: CUpti_driver_api_trace_cbid_enum = 451;
pub const CUPTI_DRIVER_TRACE_CBID_cuOccupancyMaxPotentialBlockSizeWithFlags: CUpti_driver_api_trace_cbid_enum = 452;
pub const CUPTI_DRIVER_TRACE_CBID_cuEGLStreamProducerReturnFrame: CUpti_driver_api_trace_cbid_enum = 453;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetP2PAttribute: CUpti_driver_api_trace_cbid_enum = 454;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetBorderColor: CUpti_driver_api_trace_cbid_enum = 455;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetBorderColor: CUpti_driver_api_trace_cbid_enum = 456;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAdvise: CUpti_driver_api_trace_cbid_enum = 457;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWaitValue32: CUpti_driver_api_trace_cbid_enum = 458;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWaitValue32_ptsz: CUpti_driver_api_trace_cbid_enum = 459;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWriteValue32: CUpti_driver_api_trace_cbid_enum = 460;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWriteValue32_ptsz: CUpti_driver_api_trace_cbid_enum = 461;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamBatchMemOp: CUpti_driver_api_trace_cbid_enum = 462;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamBatchMemOp_ptsz: CUpti_driver_api_trace_cbid_enum = 463;
pub const CUPTI_DRIVER_TRACE_CBID_cuNVNbufferGetPointer: CUpti_driver_api_trace_cbid_enum = 464;
pub const CUPTI_DRIVER_TRACE_CBID_cuNVNtextureGetArray: CUpti_driver_api_trace_cbid_enum = 465;
pub const CUPTI_DRIVER_TRACE_CBID_cuNNSetAllocator: CUpti_driver_api_trace_cbid_enum = 466;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPrefetchAsync: CUpti_driver_api_trace_cbid_enum = 467;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPrefetchAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 468;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventCreateFromNVNSync: CUpti_driver_api_trace_cbid_enum = 469;
pub const CUPTI_DRIVER_TRACE_CBID_cuEGLStreamConsumerConnectWithFlags: CUpti_driver_api_trace_cbid_enum = 470;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemRangeGetAttribute: CUpti_driver_api_trace_cbid_enum = 471;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemRangeGetAttributes: CUpti_driver_api_trace_cbid_enum = 472;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWaitValue64: CUpti_driver_api_trace_cbid_enum = 473;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWaitValue64_ptsz: CUpti_driver_api_trace_cbid_enum = 474;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWriteValue64: CUpti_driver_api_trace_cbid_enum = 475;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWriteValue64_ptsz: CUpti_driver_api_trace_cbid_enum = 476;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunchCooperativeKernel: CUpti_driver_api_trace_cbid_enum = 477;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunchCooperativeKernel_ptsz: CUpti_driver_api_trace_cbid_enum = 478;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventCreateFromEGLSync: CUpti_driver_api_trace_cbid_enum = 479;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunchCooperativeKernelMultiDevice: CUpti_driver_api_trace_cbid_enum = 480;
pub const CUPTI_DRIVER_TRACE_CBID_cuFuncSetAttribute: CUpti_driver_api_trace_cbid_enum = 481;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetUuid: CUpti_driver_api_trace_cbid_enum = 482;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetCtx: CUpti_driver_api_trace_cbid_enum = 483;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetCtx_ptsz: CUpti_driver_api_trace_cbid_enum = 484;
pub const CUPTI_DRIVER_TRACE_CBID_cuImportExternalMemory: CUpti_driver_api_trace_cbid_enum = 485;
pub const CUPTI_DRIVER_TRACE_CBID_cuExternalMemoryGetMappedBuffer: CUpti_driver_api_trace_cbid_enum = 486;
pub const CUPTI_DRIVER_TRACE_CBID_cuExternalMemoryGetMappedMipmappedArray: CUpti_driver_api_trace_cbid_enum = 487;
pub const CUPTI_DRIVER_TRACE_CBID_cuDestroyExternalMemory: CUpti_driver_api_trace_cbid_enum = 488;
pub const CUPTI_DRIVER_TRACE_CBID_cuImportExternalSemaphore: CUpti_driver_api_trace_cbid_enum = 489;
pub const CUPTI_DRIVER_TRACE_CBID_cuSignalExternalSemaphoresAsync: CUpti_driver_api_trace_cbid_enum = 490;
pub const CUPTI_DRIVER_TRACE_CBID_cuSignalExternalSemaphoresAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 491;
pub const CUPTI_DRIVER_TRACE_CBID_cuWaitExternalSemaphoresAsync: CUpti_driver_api_trace_cbid_enum = 492;
pub const CUPTI_DRIVER_TRACE_CBID_cuWaitExternalSemaphoresAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 493;
pub const CUPTI_DRIVER_TRACE_CBID_cuDestroyExternalSemaphore: CUpti_driver_api_trace_cbid_enum = 494;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamBeginCapture: CUpti_driver_api_trace_cbid_enum = 495;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamBeginCapture_ptsz: CUpti_driver_api_trace_cbid_enum = 496;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamEndCapture: CUpti_driver_api_trace_cbid_enum = 497;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamEndCapture_ptsz: CUpti_driver_api_trace_cbid_enum = 498;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamIsCapturing: CUpti_driver_api_trace_cbid_enum = 499;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamIsCapturing_ptsz: CUpti_driver_api_trace_cbid_enum = 500;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphCreate: CUpti_driver_api_trace_cbid_enum = 501;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddKernelNode: CUpti_driver_api_trace_cbid_enum = 502;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphKernelNodeGetParams: CUpti_driver_api_trace_cbid_enum = 503;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddMemcpyNode: CUpti_driver_api_trace_cbid_enum = 504;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphMemcpyNodeGetParams: CUpti_driver_api_trace_cbid_enum = 505;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddMemsetNode: CUpti_driver_api_trace_cbid_enum = 506;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphMemsetNodeGetParams: CUpti_driver_api_trace_cbid_enum = 507;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphMemsetNodeSetParams: CUpti_driver_api_trace_cbid_enum = 508;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphNodeGetType: CUpti_driver_api_trace_cbid_enum = 509;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphGetRootNodes: CUpti_driver_api_trace_cbid_enum = 510;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphNodeGetDependencies: CUpti_driver_api_trace_cbid_enum = 511;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphNodeGetDependentNodes: CUpti_driver_api_trace_cbid_enum = 512;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphInstantiate: CUpti_driver_api_trace_cbid_enum = 513;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphLaunch: CUpti_driver_api_trace_cbid_enum = 514;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphLaunch_ptsz: CUpti_driver_api_trace_cbid_enum = 515;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecDestroy: CUpti_driver_api_trace_cbid_enum = 516;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphDestroy: CUpti_driver_api_trace_cbid_enum = 517;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddDependencies: CUpti_driver_api_trace_cbid_enum = 518;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphRemoveDependencies: CUpti_driver_api_trace_cbid_enum = 519;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphMemcpyNodeSetParams: CUpti_driver_api_trace_cbid_enum = 520;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphKernelNodeSetParams: CUpti_driver_api_trace_cbid_enum = 521;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphDestroyNode: CUpti_driver_api_trace_cbid_enum = 522;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphClone: CUpti_driver_api_trace_cbid_enum = 523;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphNodeFindInClone: CUpti_driver_api_trace_cbid_enum = 524;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddChildGraphNode: CUpti_driver_api_trace_cbid_enum = 525;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddEmptyNode: CUpti_driver_api_trace_cbid_enum = 526;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunchHostFunc: CUpti_driver_api_trace_cbid_enum = 527;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunchHostFunc_ptsz: CUpti_driver_api_trace_cbid_enum = 528;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphChildGraphNodeGetGraph: CUpti_driver_api_trace_cbid_enum = 529;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddHostNode: CUpti_driver_api_trace_cbid_enum = 530;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphHostNodeGetParams: CUpti_driver_api_trace_cbid_enum = 531;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetLuid: CUpti_driver_api_trace_cbid_enum = 532;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphHostNodeSetParams: CUpti_driver_api_trace_cbid_enum = 533;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphGetNodes: CUpti_driver_api_trace_cbid_enum = 534;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphGetEdges: CUpti_driver_api_trace_cbid_enum = 535;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetCaptureInfo: CUpti_driver_api_trace_cbid_enum = 536;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetCaptureInfo_ptsz: CUpti_driver_api_trace_cbid_enum = 537;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecKernelNodeSetParams: CUpti_driver_api_trace_cbid_enum = 538;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamBeginCapture_v2: CUpti_driver_api_trace_cbid_enum = 539;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamBeginCapture_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 540;
pub const CUPTI_DRIVER_TRACE_CBID_cuThreadExchangeStreamCaptureMode: CUpti_driver_api_trace_cbid_enum = 541;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetNvSciSyncAttributes: CUpti_driver_api_trace_cbid_enum = 542;
pub const CUPTI_DRIVER_TRACE_CBID_cuOccupancyAvailableDynamicSMemPerBlock: CUpti_driver_api_trace_cbid_enum = 543;
pub const CUPTI_DRIVER_TRACE_CBID_cuDevicePrimaryCtxRelease_v2: CUpti_driver_api_trace_cbid_enum = 544;
pub const CUPTI_DRIVER_TRACE_CBID_cuDevicePrimaryCtxReset_v2: CUpti_driver_api_trace_cbid_enum = 545;
pub const CUPTI_DRIVER_TRACE_CBID_cuDevicePrimaryCtxSetFlags_v2: CUpti_driver_api_trace_cbid_enum = 546;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAddressReserve: CUpti_driver_api_trace_cbid_enum = 547;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAddressFree: CUpti_driver_api_trace_cbid_enum = 548;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemCreate: CUpti_driver_api_trace_cbid_enum = 549;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemRelease: CUpti_driver_api_trace_cbid_enum = 550;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemMap: CUpti_driver_api_trace_cbid_enum = 551;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemUnmap: CUpti_driver_api_trace_cbid_enum = 552;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemSetAccess: CUpti_driver_api_trace_cbid_enum = 553;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemExportToShareableHandle: CUpti_driver_api_trace_cbid_enum = 554;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemImportFromShareableHandle: CUpti_driver_api_trace_cbid_enum = 555;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemGetAllocationGranularity: CUpti_driver_api_trace_cbid_enum = 556;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemGetAllocationPropertiesFromHandle: CUpti_driver_api_trace_cbid_enum = 557;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemGetAccess: CUpti_driver_api_trace_cbid_enum = 558;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamSetFlags: CUpti_driver_api_trace_cbid_enum = 559;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamSetFlags_ptsz: CUpti_driver_api_trace_cbid_enum = 560;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecUpdate: CUpti_driver_api_trace_cbid_enum = 561;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecMemcpyNodeSetParams: CUpti_driver_api_trace_cbid_enum = 562;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecMemsetNodeSetParams: CUpti_driver_api_trace_cbid_enum = 563;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecHostNodeSetParams: CUpti_driver_api_trace_cbid_enum = 564;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemRetainAllocationHandle: CUpti_driver_api_trace_cbid_enum = 565;
pub const CUPTI_DRIVER_TRACE_CBID_cuFuncGetModule: CUpti_driver_api_trace_cbid_enum = 566;
pub const CUPTI_DRIVER_TRACE_CBID_cuIpcOpenMemHandle_v2: CUpti_driver_api_trace_cbid_enum = 567;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxResetPersistingL2Cache: CUpti_driver_api_trace_cbid_enum = 568;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphKernelNodeCopyAttributes: CUpti_driver_api_trace_cbid_enum = 569;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphKernelNodeGetAttribute: CUpti_driver_api_trace_cbid_enum = 570;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphKernelNodeSetAttribute: CUpti_driver_api_trace_cbid_enum = 571;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamCopyAttributes: CUpti_driver_api_trace_cbid_enum = 572;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamCopyAttributes_ptsz: CUpti_driver_api_trace_cbid_enum = 573;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetAttribute: CUpti_driver_api_trace_cbid_enum = 574;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetAttribute_ptsz: CUpti_driver_api_trace_cbid_enum = 575;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamSetAttribute: CUpti_driver_api_trace_cbid_enum = 576;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamSetAttribute_ptsz: CUpti_driver_api_trace_cbid_enum = 577;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphInstantiate_v2: CUpti_driver_api_trace_cbid_enum = 578;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetTexture1DLinearMaxWidth: CUpti_driver_api_trace_cbid_enum = 579;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphUpload: CUpti_driver_api_trace_cbid_enum = 580;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphUpload_ptsz: CUpti_driver_api_trace_cbid_enum = 581;
pub const CUPTI_DRIVER_TRACE_CBID_cuArrayGetSparseProperties: CUpti_driver_api_trace_cbid_enum = 582;
pub const CUPTI_DRIVER_TRACE_CBID_cuMipmappedArrayGetSparseProperties: CUpti_driver_api_trace_cbid_enum = 583;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemMapArrayAsync: CUpti_driver_api_trace_cbid_enum = 584;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemMapArrayAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 585;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecChildGraphNodeSetParams: CUpti_driver_api_trace_cbid_enum = 586;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventRecordWithFlags: CUpti_driver_api_trace_cbid_enum = 587;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventRecordWithFlags_ptsz: CUpti_driver_api_trace_cbid_enum = 588;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddEventRecordNode: CUpti_driver_api_trace_cbid_enum = 589;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddEventWaitNode: CUpti_driver_api_trace_cbid_enum = 590;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphEventRecordNodeGetEvent: CUpti_driver_api_trace_cbid_enum = 591;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphEventWaitNodeGetEvent: CUpti_driver_api_trace_cbid_enum = 592;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphEventRecordNodeSetEvent: CUpti_driver_api_trace_cbid_enum = 593;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphEventWaitNodeSetEvent: CUpti_driver_api_trace_cbid_enum = 594;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecEventRecordNodeSetEvent: CUpti_driver_api_trace_cbid_enum = 595;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecEventWaitNodeSetEvent: CUpti_driver_api_trace_cbid_enum = 596;
pub const CUPTI_DRIVER_TRACE_CBID_cuArrayGetPlane: CUpti_driver_api_trace_cbid_enum = 597;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAllocAsync: CUpti_driver_api_trace_cbid_enum = 598;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAllocAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 599;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemFreeAsync: CUpti_driver_api_trace_cbid_enum = 600;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemFreeAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 601;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPoolTrimTo: CUpti_driver_api_trace_cbid_enum = 602;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPoolSetAttribute: CUpti_driver_api_trace_cbid_enum = 603;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPoolGetAttribute: CUpti_driver_api_trace_cbid_enum = 604;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPoolSetAccess: CUpti_driver_api_trace_cbid_enum = 605;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetDefaultMemPool: CUpti_driver_api_trace_cbid_enum = 606;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPoolCreate: CUpti_driver_api_trace_cbid_enum = 607;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPoolDestroy: CUpti_driver_api_trace_cbid_enum = 608;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceSetMemPool: CUpti_driver_api_trace_cbid_enum = 609;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetMemPool: CUpti_driver_api_trace_cbid_enum = 610;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAllocFromPoolAsync: CUpti_driver_api_trace_cbid_enum = 611;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAllocFromPoolAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 612;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPoolExportToShareableHandle: CUpti_driver_api_trace_cbid_enum = 613;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPoolImportFromShareableHandle: CUpti_driver_api_trace_cbid_enum = 614;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPoolExportPointer: CUpti_driver_api_trace_cbid_enum = 615;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPoolImportPointer: CUpti_driver_api_trace_cbid_enum = 616;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPoolGetAccess: CUpti_driver_api_trace_cbid_enum = 617;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddExternalSemaphoresSignalNode: CUpti_driver_api_trace_cbid_enum = 618;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExternalSemaphoresSignalNodeGetParams: CUpti_driver_api_trace_cbid_enum = 619;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExternalSemaphoresSignalNodeSetParams: CUpti_driver_api_trace_cbid_enum = 620;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddExternalSemaphoresWaitNode: CUpti_driver_api_trace_cbid_enum = 621;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExternalSemaphoresWaitNodeGetParams: CUpti_driver_api_trace_cbid_enum = 622;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExternalSemaphoresWaitNodeSetParams: CUpti_driver_api_trace_cbid_enum = 623;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecExternalSemaphoresSignalNodeSetParams: CUpti_driver_api_trace_cbid_enum = 624;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecExternalSemaphoresWaitNodeSetParams: CUpti_driver_api_trace_cbid_enum = 625;
pub const CUPTI_DRIVER_TRACE_CBID_cuGetProcAddress: CUpti_driver_api_trace_cbid_enum = 626;
pub const CUPTI_DRIVER_TRACE_CBID_cuFlushGPUDirectRDMAWrites: CUpti_driver_api_trace_cbid_enum = 627;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphDebugDotPrint: CUpti_driver_api_trace_cbid_enum = 628;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetCaptureInfo_v2: CUpti_driver_api_trace_cbid_enum = 629;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetCaptureInfo_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 630;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamUpdateCaptureDependencies: CUpti_driver_api_trace_cbid_enum = 631;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamUpdateCaptureDependencies_ptsz: CUpti_driver_api_trace_cbid_enum = 632;
pub const CUPTI_DRIVER_TRACE_CBID_cuUserObjectCreate: CUpti_driver_api_trace_cbid_enum = 633;
pub const CUPTI_DRIVER_TRACE_CBID_cuUserObjectRetain: CUpti_driver_api_trace_cbid_enum = 634;
pub const CUPTI_DRIVER_TRACE_CBID_cuUserObjectRelease: CUpti_driver_api_trace_cbid_enum = 635;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphRetainUserObject: CUpti_driver_api_trace_cbid_enum = 636;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphReleaseUserObject: CUpti_driver_api_trace_cbid_enum = 637;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddMemAllocNode: CUpti_driver_api_trace_cbid_enum = 638;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddMemFreeNode: CUpti_driver_api_trace_cbid_enum = 639;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGraphMemTrim: CUpti_driver_api_trace_cbid_enum = 640;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetGraphMemAttribute: CUpti_driver_api_trace_cbid_enum = 641;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceSetGraphMemAttribute: CUpti_driver_api_trace_cbid_enum = 642;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphInstantiateWithFlags: CUpti_driver_api_trace_cbid_enum = 643;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetExecAffinitySupport: CUpti_driver_api_trace_cbid_enum = 644;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxCreate_v3: CUpti_driver_api_trace_cbid_enum = 645;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetExecAffinity: CUpti_driver_api_trace_cbid_enum = 646;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetUuid_v2: CUpti_driver_api_trace_cbid_enum = 647;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphMemAllocNodeGetParams: CUpti_driver_api_trace_cbid_enum = 648;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphMemFreeNodeGetParams: CUpti_driver_api_trace_cbid_enum = 649;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphNodeSetEnabled: CUpti_driver_api_trace_cbid_enum = 650;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphNodeGetEnabled: CUpti_driver_api_trace_cbid_enum = 651;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunchKernelEx: CUpti_driver_api_trace_cbid_enum = 652;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunchKernelEx_ptsz: CUpti_driver_api_trace_cbid_enum = 653;
pub const CUPTI_DRIVER_TRACE_CBID_cuArrayGetMemoryRequirements: CUpti_driver_api_trace_cbid_enum = 654;
pub const CUPTI_DRIVER_TRACE_CBID_cuMipmappedArrayGetMemoryRequirements: CUpti_driver_api_trace_cbid_enum = 655;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphInstantiateWithParams: CUpti_driver_api_trace_cbid_enum = 656;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphInstantiateWithParams_ptsz: CUpti_driver_api_trace_cbid_enum = 657;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecGetFlags: CUpti_driver_api_trace_cbid_enum = 658;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWaitValue32_v2: CUpti_driver_api_trace_cbid_enum = 659;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWaitValue32_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 660;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWaitValue64_v2: CUpti_driver_api_trace_cbid_enum = 661;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWaitValue64_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 662;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWriteValue32_v2: CUpti_driver_api_trace_cbid_enum = 663;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWriteValue32_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 664;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWriteValue64_v2: CUpti_driver_api_trace_cbid_enum = 665;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWriteValue64_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 666;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamBatchMemOp_v2: CUpti_driver_api_trace_cbid_enum = 667;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamBatchMemOp_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 668;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddBatchMemOpNode: CUpti_driver_api_trace_cbid_enum = 669;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphBatchMemOpNodeGetParams: CUpti_driver_api_trace_cbid_enum = 670;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphBatchMemOpNodeSetParams: CUpti_driver_api_trace_cbid_enum = 671;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecBatchMemOpNodeSetParams: CUpti_driver_api_trace_cbid_enum = 672;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleGetLoadingMode: CUpti_driver_api_trace_cbid_enum = 673;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemGetHandleForAddressRange: CUpti_driver_api_trace_cbid_enum = 674;
pub const CUPTI_DRIVER_TRACE_CBID_cuOccupancyMaxPotentialClusterSize: CUpti_driver_api_trace_cbid_enum = 675;
pub const CUPTI_DRIVER_TRACE_CBID_cuOccupancyMaxActiveClusters: CUpti_driver_api_trace_cbid_enum = 676;
pub const CUPTI_DRIVER_TRACE_CBID_cuGetProcAddress_v2: CUpti_driver_api_trace_cbid_enum = 677;
pub const CUPTI_DRIVER_TRACE_CBID_cuLibraryLoadData: CUpti_driver_api_trace_cbid_enum = 678;
pub const CUPTI_DRIVER_TRACE_CBID_cuLibraryLoadFromFile: CUpti_driver_api_trace_cbid_enum = 679;
pub const CUPTI_DRIVER_TRACE_CBID_cuLibraryUnload: CUpti_driver_api_trace_cbid_enum = 680;
pub const CUPTI_DRIVER_TRACE_CBID_cuLibraryGetKernel: CUpti_driver_api_trace_cbid_enum = 681;
pub const CUPTI_DRIVER_TRACE_CBID_cuLibraryGetModule: CUpti_driver_api_trace_cbid_enum = 682;
pub const CUPTI_DRIVER_TRACE_CBID_cuKernelGetFunction: CUpti_driver_api_trace_cbid_enum = 683;
pub const CUPTI_DRIVER_TRACE_CBID_cuLibraryGetGlobal: CUpti_driver_api_trace_cbid_enum = 684;
pub const CUPTI_DRIVER_TRACE_CBID_cuLibraryGetManaged: CUpti_driver_api_trace_cbid_enum = 685;
pub const CUPTI_DRIVER_TRACE_CBID_cuKernelGetAttribute: CUpti_driver_api_trace_cbid_enum = 686;
pub const CUPTI_DRIVER_TRACE_CBID_cuKernelSetAttribute: CUpti_driver_api_trace_cbid_enum = 687;
pub const CUPTI_DRIVER_TRACE_CBID_cuKernelSetCacheConfig: CUpti_driver_api_trace_cbid_enum = 688;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddKernelNode_v2: CUpti_driver_api_trace_cbid_enum = 689;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphKernelNodeGetParams_v2: CUpti_driver_api_trace_cbid_enum = 690;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphKernelNodeSetParams_v2: CUpti_driver_api_trace_cbid_enum = 691;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecKernelNodeSetParams_v2: CUpti_driver_api_trace_cbid_enum = 692;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetId: CUpti_driver_api_trace_cbid_enum = 693;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetId_ptsz: CUpti_driver_api_trace_cbid_enum = 694;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetId: CUpti_driver_api_trace_cbid_enum = 695;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecUpdate_v2: CUpti_driver_api_trace_cbid_enum = 696;
pub const CUPTI_DRIVER_TRACE_CBID_cuTensorMapEncodeTiled: CUpti_driver_api_trace_cbid_enum = 697;
pub const CUPTI_DRIVER_TRACE_CBID_cuTensorMapEncodeIm2col: CUpti_driver_api_trace_cbid_enum = 698;
pub const CUPTI_DRIVER_TRACE_CBID_cuTensorMapReplaceAddress: CUpti_driver_api_trace_cbid_enum = 699;
pub const CUPTI_DRIVER_TRACE_CBID_cuLibraryGetUnifiedFunction: CUpti_driver_api_trace_cbid_enum = 700;
pub const CUPTI_DRIVER_TRACE_CBID_cuCoredumpGetAttribute: CUpti_driver_api_trace_cbid_enum = 701;
pub const CUPTI_DRIVER_TRACE_CBID_cuCoredumpGetAttributeGlobal: CUpti_driver_api_trace_cbid_enum = 702;
pub const CUPTI_DRIVER_TRACE_CBID_cuCoredumpSetAttribute: CUpti_driver_api_trace_cbid_enum = 703;
pub const CUPTI_DRIVER_TRACE_CBID_cuCoredumpSetAttributeGlobal: CUpti_driver_api_trace_cbid_enum = 704;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxSetFlags: CUpti_driver_api_trace_cbid_enum = 705;
pub const CUPTI_DRIVER_TRACE_CBID_cuMulticastCreate: CUpti_driver_api_trace_cbid_enum = 706;
pub const CUPTI_DRIVER_TRACE_CBID_cuMulticastAddDevice: CUpti_driver_api_trace_cbid_enum = 707;
pub const CUPTI_DRIVER_TRACE_CBID_cuMulticastBindMem: CUpti_driver_api_trace_cbid_enum = 708;
pub const CUPTI_DRIVER_TRACE_CBID_cuMulticastBindAddr: CUpti_driver_api_trace_cbid_enum = 709;
pub const CUPTI_DRIVER_TRACE_CBID_cuMulticastUnbind: CUpti_driver_api_trace_cbid_enum = 710;
pub const CUPTI_DRIVER_TRACE_CBID_cuMulticastGetGranularity: CUpti_driver_api_trace_cbid_enum = 711;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddNode: CUpti_driver_api_trace_cbid_enum = 712;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphNodeSetParams: CUpti_driver_api_trace_cbid_enum = 713;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecNodeSetParams: CUpti_driver_api_trace_cbid_enum = 714;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAdvise_v2: CUpti_driver_api_trace_cbid_enum = 715;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPrefetchAsync_v2: CUpti_driver_api_trace_cbid_enum = 716;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPrefetchAsync_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 717;
pub const CUPTI_DRIVER_TRACE_CBID_cuFuncGetName: CUpti_driver_api_trace_cbid_enum = 718;
pub const CUPTI_DRIVER_TRACE_CBID_cuKernelGetName: CUpti_driver_api_trace_cbid_enum = 719;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamBeginCaptureToGraph: CUpti_driver_api_trace_cbid_enum = 720;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamBeginCaptureToGraph_ptsz: CUpti_driver_api_trace_cbid_enum = 721;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphConditionalHandleCreate: CUpti_driver_api_trace_cbid_enum = 722;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddNode_v2: CUpti_driver_api_trace_cbid_enum = 723;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphGetEdges_v2: CUpti_driver_api_trace_cbid_enum = 724;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphNodeGetDependencies_v2: CUpti_driver_api_trace_cbid_enum = 725;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphNodeGetDependentNodes_v2: CUpti_driver_api_trace_cbid_enum = 726;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddDependencies_v2: CUpti_driver_api_trace_cbid_enum = 727;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphRemoveDependencies_v2: CUpti_driver_api_trace_cbid_enum = 728;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetCaptureInfo_v3: CUpti_driver_api_trace_cbid_enum = 729;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetCaptureInfo_v3_ptsz: CUpti_driver_api_trace_cbid_enum = 730;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamUpdateCaptureDependencies_v2: CUpti_driver_api_trace_cbid_enum = 731;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamUpdateCaptureDependencies_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 732;
pub const CUPTI_DRIVER_TRACE_CBID_cuFuncGetParamInfo: CUpti_driver_api_trace_cbid_enum = 733;
pub const CUPTI_DRIVER_TRACE_CBID_cuKernelGetParamInfo: CUpti_driver_api_trace_cbid_enum = 734;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceRegisterAsyncNotification: CUpti_driver_api_trace_cbid_enum = 735;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceUnregisterAsyncNotification: CUpti_driver_api_trace_cbid_enum = 736;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleGetFunctionCount: CUpti_driver_api_trace_cbid_enum = 737;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleEnumerateFunctions: CUpti_driver_api_trace_cbid_enum = 738;
pub const CUPTI_DRIVER_TRACE_CBID_cuLibraryGetKernelCount: CUpti_driver_api_trace_cbid_enum = 739;
pub const CUPTI_DRIVER_TRACE_CBID_cuLibraryEnumerateKernels: CUpti_driver_api_trace_cbid_enum = 740;
pub const CUPTI_DRIVER_TRACE_CBID_cuFuncIsLoaded: CUpti_driver_api_trace_cbid_enum = 741;
pub const CUPTI_DRIVER_TRACE_CBID_cuFuncLoad: CUpti_driver_api_trace_cbid_enum = 742;
pub const CUPTI_DRIVER_TRACE_CBID_cuGreenCtxCreate: CUpti_driver_api_trace_cbid_enum = 743;
pub const CUPTI_DRIVER_TRACE_CBID_cuGreenCtxDestroy: CUpti_driver_api_trace_cbid_enum = 744;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetDevResource: CUpti_driver_api_trace_cbid_enum = 745;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetDevResource: CUpti_driver_api_trace_cbid_enum = 746;
pub const CUPTI_DRIVER_TRACE_CBID_cuGreenCtxGetDevResource: CUpti_driver_api_trace_cbid_enum = 747;
pub const CUPTI_DRIVER_TRACE_CBID_cuDevResourceGenerateDesc: CUpti_driver_api_trace_cbid_enum = 748;
pub const CUPTI_DRIVER_TRACE_CBID_cuGreenCtxRecordEvent: CUpti_driver_api_trace_cbid_enum = 749;
pub const CUPTI_DRIVER_TRACE_CBID_cuGreenCtxWaitEvent: CUpti_driver_api_trace_cbid_enum = 750;
pub const CUPTI_DRIVER_TRACE_CBID_cuDevSmResourceSplitByCount: CUpti_driver_api_trace_cbid_enum = 751;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetGreenCtx: CUpti_driver_api_trace_cbid_enum = 752;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxFromGreenCtx: CUpti_driver_api_trace_cbid_enum = 753;
pub const CUPTI_DRIVER_TRACE_CBID_cuKernelGetLibrary: CUpti_driver_api_trace_cbid_enum = 754;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxRecordEvent: CUpti_driver_api_trace_cbid_enum = 755;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxWaitEvent: CUpti_driver_api_trace_cbid_enum = 756;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxCreate_v4: CUpti_driver_api_trace_cbid_enum = 757;
pub const CUPTI_DRIVER_TRACE_CBID_cuGreenCtxStreamCreate: CUpti_driver_api_trace_cbid_enum = 758;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetCtx_v2: CUpti_driver_api_trace_cbid_enum = 759;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetCtx_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 760;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemBatchDecompressAsync: CUpti_driver_api_trace_cbid_enum = 761;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemBatchDecompressAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 762;
pub const CUPTI_DRIVER_TRACE_CBID_cuLogsRegisterCallback: CUpti_driver_api_trace_cbid_enum = 763;
pub const CUPTI_DRIVER_TRACE_CBID_cuLogsUnregisterCallback: CUpti_driver_api_trace_cbid_enum = 764;
pub const CUPTI_DRIVER_TRACE_CBID_cuLogsCurrent: CUpti_driver_api_trace_cbid_enum = 765;
pub const CUPTI_DRIVER_TRACE_CBID_cuLogsDumpToFile: CUpti_driver_api_trace_cbid_enum = 766;
pub const CUPTI_DRIVER_TRACE_CBID_cuLogsDumpToMemory: CUpti_driver_api_trace_cbid_enum = 767;
pub const CUPTI_DRIVER_TRACE_CBID_cuCheckpointProcessGetRestoreThreadId: CUpti_driver_api_trace_cbid_enum = 768;
pub const CUPTI_DRIVER_TRACE_CBID_cuCheckpointProcessGetState: CUpti_driver_api_trace_cbid_enum = 769;
pub const CUPTI_DRIVER_TRACE_CBID_cuCheckpointProcessLock: CUpti_driver_api_trace_cbid_enum = 770;
pub const CUPTI_DRIVER_TRACE_CBID_cuCheckpointProcessCheckpoint: CUpti_driver_api_trace_cbid_enum = 771;
pub const CUPTI_DRIVER_TRACE_CBID_cuCheckpointProcessRestore: CUpti_driver_api_trace_cbid_enum = 772;
pub const CUPTI_DRIVER_TRACE_CBID_cuCheckpointProcessUnlock: CUpti_driver_api_trace_cbid_enum = 773;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetDevice: CUpti_driver_api_trace_cbid_enum = 774;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetDevice_ptsz: CUpti_driver_api_trace_cbid_enum = 775;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyBatchAsync: CUpti_driver_api_trace_cbid_enum = 776;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyBatchAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 777;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3DBatchAsync: CUpti_driver_api_trace_cbid_enum = 778;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3DBatchAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 779;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventElapsedTime_v2: CUpti_driver_api_trace_cbid_enum = 780;
pub const CUPTI_DRIVER_TRACE_CBID_cuTensorMapEncodeIm2colWide: CUpti_driver_api_trace_cbid_enum = 781;
pub const CUPTI_DRIVER_TRACE_CBID_cuGreenCtxGetId: CUpti_driver_api_trace_cbid_enum = 782;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamCreateForCaptureToCig: CUpti_driver_api_trace_cbid_enum = 783;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPrefetchBatchAsync: CUpti_driver_api_trace_cbid_enum = 784;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPrefetchBatchAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 785;
pub const CUPTI_DRIVER_TRACE_CBID_cuSemaphoreCreate: CUpti_driver_api_trace_cbid_enum = 786;
pub const CUPTI_DRIVER_TRACE_CBID_cuSemaphoreExport: CUpti_driver_api_trace_cbid_enum = 787;
pub const CUPTI_DRIVER_TRACE_CBID_cuSemaphoreDestroy: CUpti_driver_api_trace_cbid_enum = 788;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemDiscardBatchAsync: CUpti_driver_api_trace_cbid_enum = 789;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemDiscardBatchAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 790;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemDiscardAndPrefetchBatchAsync: CUpti_driver_api_trace_cbid_enum = 791;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemDiscardAndPrefetchBatchAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 792;
pub const CUPTI_DRIVER_TRACE_CBID_cuMultiKernelCooperativeDomainCreate: CUpti_driver_api_trace_cbid_enum = 793;
pub const CUPTI_DRIVER_TRACE_CBID_cuMultiKernelCooperativeDomainDestroy: CUpti_driver_api_trace_cbid_enum = 794;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetDevice_v2: CUpti_driver_api_trace_cbid_enum = 795;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyBatchAsync_v2: CUpti_driver_api_trace_cbid_enum = 796;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyBatchAsync_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 797;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3DBatchAsync_v2: CUpti_driver_api_trace_cbid_enum = 798;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3DBatchAsync_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 799;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxSynchronize_v2: CUpti_driver_api_trace_cbid_enum = 800;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemGetDefaultMemPool: CUpti_driver_api_trace_cbid_enum = 801;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemGetMemPool: CUpti_driver_api_trace_cbid_enum = 802;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemSetMemPool: CUpti_driver_api_trace_cbid_enum = 803;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetP2PAtomicCapabilities: CUpti_driver_api_trace_cbid_enum = 804;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetHostAtomicCapabilities: CUpti_driver_api_trace_cbid_enum = 805;
pub const CUPTI_DRIVER_TRACE_CBID_cuDriverGetGpuCodeIsaVersion: CUpti_driver_api_trace_cbid_enum = 806;
pub const CUPTI_DRIVER_TRACE_CBID_SIZE: CUpti_driver_api_trace_cbid_enum = 807;
pub const CUPTI_DRIVER_TRACE_CBID_FORCE_INT: CUpti_driver_api_trace_cbid_enum = 2147483647;
pub type CUpti_driver_api_trace_cbid_enum = ::std::os::raw::c_uint;
pub use self::CUpti_driver_api_trace_cbid_enum as CUpti_driver_api_trace_cbid;
pub const CUPTI_RUNTIME_TRACE_CBID_INVALID: CUpti_runtime_api_trace_cbid_enum = 0;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDriverGetVersion_v3020: CUpti_runtime_api_trace_cbid_enum = 1;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaRuntimeGetVersion_v3020: CUpti_runtime_api_trace_cbid_enum = 2;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetDeviceCount_v3020: CUpti_runtime_api_trace_cbid_enum = 3;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetDeviceProperties_v3020: CUpti_runtime_api_trace_cbid_enum = 4;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaChooseDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 5;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetChannelDesc_v3020: CUpti_runtime_api_trace_cbid_enum = 6;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaCreateChannelDesc_v3020: CUpti_runtime_api_trace_cbid_enum = 7;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaConfigureCall_v3020: CUpti_runtime_api_trace_cbid_enum = 8;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaSetupArgument_v3020: CUpti_runtime_api_trace_cbid_enum = 9;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetLastError_v3020: CUpti_runtime_api_trace_cbid_enum = 10;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaPeekAtLastError_v3020: CUpti_runtime_api_trace_cbid_enum = 11;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetErrorString_v3020: CUpti_runtime_api_trace_cbid_enum = 12;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLaunch_v3020: CUpti_runtime_api_trace_cbid_enum = 13;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFuncSetCacheConfig_v3020: CUpti_runtime_api_trace_cbid_enum = 14;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFuncGetAttributes_v3020: CUpti_runtime_api_trace_cbid_enum = 15;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaSetDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 16;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 17;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaSetValidDevices_v3020: CUpti_runtime_api_trace_cbid_enum = 18;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaSetDeviceFlags_v3020: CUpti_runtime_api_trace_cbid_enum = 19;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMalloc_v3020: CUpti_runtime_api_trace_cbid_enum = 20;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMallocPitch_v3020: CUpti_runtime_api_trace_cbid_enum = 21;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFree_v3020: CUpti_runtime_api_trace_cbid_enum = 22;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMallocArray_v3020: CUpti_runtime_api_trace_cbid_enum = 23;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFreeArray_v3020: CUpti_runtime_api_trace_cbid_enum = 24;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMallocHost_v3020: CUpti_runtime_api_trace_cbid_enum = 25;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFreeHost_v3020: CUpti_runtime_api_trace_cbid_enum = 26;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaHostAlloc_v3020: CUpti_runtime_api_trace_cbid_enum = 27;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaHostGetDevicePointer_v3020: CUpti_runtime_api_trace_cbid_enum = 28;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaHostGetFlags_v3020: CUpti_runtime_api_trace_cbid_enum = 29;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemGetInfo_v3020: CUpti_runtime_api_trace_cbid_enum = 30;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy_v3020: CUpti_runtime_api_trace_cbid_enum = 31;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2D_v3020: CUpti_runtime_api_trace_cbid_enum = 32;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyToArray_v3020: CUpti_runtime_api_trace_cbid_enum = 33;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DToArray_v3020: CUpti_runtime_api_trace_cbid_enum = 34;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyFromArray_v3020: CUpti_runtime_api_trace_cbid_enum = 35;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DFromArray_v3020: CUpti_runtime_api_trace_cbid_enum = 36;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyArrayToArray_v3020: CUpti_runtime_api_trace_cbid_enum = 37;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DArrayToArray_v3020: CUpti_runtime_api_trace_cbid_enum = 38;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyToSymbol_v3020: CUpti_runtime_api_trace_cbid_enum = 39;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyFromSymbol_v3020: CUpti_runtime_api_trace_cbid_enum = 40;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyAsync_v3020: CUpti_runtime_api_trace_cbid_enum = 41;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyToArrayAsync_v3020: CUpti_runtime_api_trace_cbid_enum = 42;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyFromArrayAsync_v3020: CUpti_runtime_api_trace_cbid_enum = 43;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DAsync_v3020: CUpti_runtime_api_trace_cbid_enum = 44;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DToArrayAsync_v3020: CUpti_runtime_api_trace_cbid_enum = 45;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DFromArrayAsync_v3020: CUpti_runtime_api_trace_cbid_enum = 46;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyToSymbolAsync_v3020: CUpti_runtime_api_trace_cbid_enum = 47;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyFromSymbolAsync_v3020: CUpti_runtime_api_trace_cbid_enum = 48;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemset_v3020: CUpti_runtime_api_trace_cbid_enum = 49;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemset2D_v3020: CUpti_runtime_api_trace_cbid_enum = 50;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemsetAsync_v3020: CUpti_runtime_api_trace_cbid_enum = 51;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemset2DAsync_v3020: CUpti_runtime_api_trace_cbid_enum = 52;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetSymbolAddress_v3020: CUpti_runtime_api_trace_cbid_enum = 53;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetSymbolSize_v3020: CUpti_runtime_api_trace_cbid_enum = 54;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaBindTexture_v3020: CUpti_runtime_api_trace_cbid_enum = 55;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaBindTexture2D_v3020: CUpti_runtime_api_trace_cbid_enum = 56;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaBindTextureToArray_v3020: CUpti_runtime_api_trace_cbid_enum = 57;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaUnbindTexture_v3020: CUpti_runtime_api_trace_cbid_enum = 58;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetTextureAlignmentOffset_v3020: CUpti_runtime_api_trace_cbid_enum = 59;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetTextureReference_v3020: CUpti_runtime_api_trace_cbid_enum = 60;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaBindSurfaceToArray_v3020: CUpti_runtime_api_trace_cbid_enum = 61;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetSurfaceReference_v3020: CUpti_runtime_api_trace_cbid_enum = 62;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGLSetGLDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 63;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGLRegisterBufferObject_v3020: CUpti_runtime_api_trace_cbid_enum = 64;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGLMapBufferObject_v3020: CUpti_runtime_api_trace_cbid_enum = 65;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGLUnmapBufferObject_v3020: CUpti_runtime_api_trace_cbid_enum = 66;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGLUnregisterBufferObject_v3020: CUpti_runtime_api_trace_cbid_enum = 67;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGLSetBufferObjectMapFlags_v3020: CUpti_runtime_api_trace_cbid_enum = 68;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGLMapBufferObjectAsync_v3020: CUpti_runtime_api_trace_cbid_enum = 69;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGLUnmapBufferObjectAsync_v3020: CUpti_runtime_api_trace_cbid_enum = 70;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaWGLGetDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 71;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsGLRegisterImage_v3020: CUpti_runtime_api_trace_cbid_enum = 72;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsGLRegisterBuffer_v3020: CUpti_runtime_api_trace_cbid_enum = 73;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsUnregisterResource_v3020: CUpti_runtime_api_trace_cbid_enum = 74;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsResourceSetMapFlags_v3020: CUpti_runtime_api_trace_cbid_enum = 75;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsMapResources_v3020: CUpti_runtime_api_trace_cbid_enum = 76;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsUnmapResources_v3020: CUpti_runtime_api_trace_cbid_enum = 77;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsResourceGetMappedPointer_v3020: CUpti_runtime_api_trace_cbid_enum = 78;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsSubResourceGetMappedArray_v3020: CUpti_runtime_api_trace_cbid_enum = 79;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaVDPAUGetDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 80;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaVDPAUSetVDPAUDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 81;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsVDPAURegisterVideoSurface_v3020: CUpti_runtime_api_trace_cbid_enum = 82;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsVDPAURegisterOutputSurface_v3020: CUpti_runtime_api_trace_cbid_enum = 83;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D11GetDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 84;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D11GetDevices_v3020: CUpti_runtime_api_trace_cbid_enum = 85;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D11SetDirect3DDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 86;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsD3D11RegisterResource_v3020: CUpti_runtime_api_trace_cbid_enum = 87;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10GetDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 88;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10GetDevices_v3020: CUpti_runtime_api_trace_cbid_enum = 89;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10SetDirect3DDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 90;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsD3D10RegisterResource_v3020: CUpti_runtime_api_trace_cbid_enum = 91;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10RegisterResource_v3020: CUpti_runtime_api_trace_cbid_enum = 92;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10UnregisterResource_v3020: CUpti_runtime_api_trace_cbid_enum = 93;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10MapResources_v3020: CUpti_runtime_api_trace_cbid_enum = 94;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10UnmapResources_v3020: CUpti_runtime_api_trace_cbid_enum = 95;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10ResourceSetMapFlags_v3020: CUpti_runtime_api_trace_cbid_enum = 96;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10ResourceGetSurfaceDimensions_v3020: CUpti_runtime_api_trace_cbid_enum = 97;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10ResourceGetMappedArray_v3020: CUpti_runtime_api_trace_cbid_enum = 98;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10ResourceGetMappedPointer_v3020: CUpti_runtime_api_trace_cbid_enum = 99;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10ResourceGetMappedSize_v3020: CUpti_runtime_api_trace_cbid_enum = 100;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10ResourceGetMappedPitch_v3020: CUpti_runtime_api_trace_cbid_enum = 101;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9GetDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 102;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9GetDevices_v3020: CUpti_runtime_api_trace_cbid_enum = 103;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9SetDirect3DDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 104;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9GetDirect3DDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 105;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsD3D9RegisterResource_v3020: CUpti_runtime_api_trace_cbid_enum = 106;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9RegisterResource_v3020: CUpti_runtime_api_trace_cbid_enum = 107;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9UnregisterResource_v3020: CUpti_runtime_api_trace_cbid_enum = 108;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9MapResources_v3020: CUpti_runtime_api_trace_cbid_enum = 109;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9UnmapResources_v3020: CUpti_runtime_api_trace_cbid_enum = 110;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9ResourceSetMapFlags_v3020: CUpti_runtime_api_trace_cbid_enum = 111;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9ResourceGetSurfaceDimensions_v3020: CUpti_runtime_api_trace_cbid_enum = 112;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9ResourceGetMappedArray_v3020: CUpti_runtime_api_trace_cbid_enum = 113;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9ResourceGetMappedPointer_v3020: CUpti_runtime_api_trace_cbid_enum = 114;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9ResourceGetMappedSize_v3020: CUpti_runtime_api_trace_cbid_enum = 115;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9ResourceGetMappedPitch_v3020: CUpti_runtime_api_trace_cbid_enum = 116;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9Begin_v3020: CUpti_runtime_api_trace_cbid_enum = 117;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9End_v3020: CUpti_runtime_api_trace_cbid_enum = 118;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9RegisterVertexBuffer_v3020: CUpti_runtime_api_trace_cbid_enum = 119;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9UnregisterVertexBuffer_v3020: CUpti_runtime_api_trace_cbid_enum = 120;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9MapVertexBuffer_v3020: CUpti_runtime_api_trace_cbid_enum = 121;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9UnmapVertexBuffer_v3020: CUpti_runtime_api_trace_cbid_enum = 122;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaThreadExit_v3020: CUpti_runtime_api_trace_cbid_enum = 123;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaSetDoubleForDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 124;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaSetDoubleForHost_v3020: CUpti_runtime_api_trace_cbid_enum = 125;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaThreadSynchronize_v3020: CUpti_runtime_api_trace_cbid_enum = 126;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaThreadGetLimit_v3020: CUpti_runtime_api_trace_cbid_enum = 127;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaThreadSetLimit_v3020: CUpti_runtime_api_trace_cbid_enum = 128;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamCreate_v3020: CUpti_runtime_api_trace_cbid_enum = 129;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamDestroy_v3020: CUpti_runtime_api_trace_cbid_enum = 130;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamSynchronize_v3020: CUpti_runtime_api_trace_cbid_enum = 131;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamQuery_v3020: CUpti_runtime_api_trace_cbid_enum = 132;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventCreate_v3020: CUpti_runtime_api_trace_cbid_enum = 133;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventCreateWithFlags_v3020: CUpti_runtime_api_trace_cbid_enum = 134;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventRecord_v3020: CUpti_runtime_api_trace_cbid_enum = 135;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventDestroy_v3020: CUpti_runtime_api_trace_cbid_enum = 136;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventSynchronize_v3020: CUpti_runtime_api_trace_cbid_enum = 137;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventQuery_v3020: CUpti_runtime_api_trace_cbid_enum = 138;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventElapsedTime_v3020: CUpti_runtime_api_trace_cbid_enum = 139;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMalloc3D_v3020: CUpti_runtime_api_trace_cbid_enum = 140;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMalloc3DArray_v3020: CUpti_runtime_api_trace_cbid_enum = 141;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemset3D_v3020: CUpti_runtime_api_trace_cbid_enum = 142;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemset3DAsync_v3020: CUpti_runtime_api_trace_cbid_enum = 143;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3D_v3020: CUpti_runtime_api_trace_cbid_enum = 144;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3DAsync_v3020: CUpti_runtime_api_trace_cbid_enum = 145;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaThreadSetCacheConfig_v3020: CUpti_runtime_api_trace_cbid_enum = 146;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamWaitEvent_v3020: CUpti_runtime_api_trace_cbid_enum = 147;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D11GetDirect3DDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 148;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10GetDirect3DDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 149;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaThreadGetCacheConfig_v3020: CUpti_runtime_api_trace_cbid_enum = 150;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaPointerGetAttributes_v4000: CUpti_runtime_api_trace_cbid_enum = 151;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaHostRegister_v4000: CUpti_runtime_api_trace_cbid_enum = 152;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaHostUnregister_v4000: CUpti_runtime_api_trace_cbid_enum = 153;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceCanAccessPeer_v4000: CUpti_runtime_api_trace_cbid_enum = 154;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceEnablePeerAccess_v4000: CUpti_runtime_api_trace_cbid_enum = 155;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceDisablePeerAccess_v4000: CUpti_runtime_api_trace_cbid_enum = 156;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaPeerRegister_v4000: CUpti_runtime_api_trace_cbid_enum = 157;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaPeerUnregister_v4000: CUpti_runtime_api_trace_cbid_enum = 158;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaPeerGetDevicePointer_v4000: CUpti_runtime_api_trace_cbid_enum = 159;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyPeer_v4000: CUpti_runtime_api_trace_cbid_enum = 160;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyPeerAsync_v4000: CUpti_runtime_api_trace_cbid_enum = 161;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3DPeer_v4000: CUpti_runtime_api_trace_cbid_enum = 162;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3DPeerAsync_v4000: CUpti_runtime_api_trace_cbid_enum = 163;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceReset_v3020: CUpti_runtime_api_trace_cbid_enum = 164;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceSynchronize_v3020: CUpti_runtime_api_trace_cbid_enum = 165;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetLimit_v3020: CUpti_runtime_api_trace_cbid_enum = 166;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceSetLimit_v3020: CUpti_runtime_api_trace_cbid_enum = 167;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetCacheConfig_v3020: CUpti_runtime_api_trace_cbid_enum = 168;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceSetCacheConfig_v3020: CUpti_runtime_api_trace_cbid_enum = 169;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaProfilerInitialize_v4000: CUpti_runtime_api_trace_cbid_enum = 170;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaProfilerStart_v4000: CUpti_runtime_api_trace_cbid_enum = 171;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaProfilerStop_v4000: CUpti_runtime_api_trace_cbid_enum = 172;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetByPCIBusId_v4010: CUpti_runtime_api_trace_cbid_enum = 173;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetPCIBusId_v4010: CUpti_runtime_api_trace_cbid_enum = 174;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGLGetDevices_v4010: CUpti_runtime_api_trace_cbid_enum = 175;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaIpcGetEventHandle_v4010: CUpti_runtime_api_trace_cbid_enum = 176;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaIpcOpenEventHandle_v4010: CUpti_runtime_api_trace_cbid_enum = 177;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaIpcGetMemHandle_v4010: CUpti_runtime_api_trace_cbid_enum = 178;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaIpcOpenMemHandle_v4010: CUpti_runtime_api_trace_cbid_enum = 179;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaIpcCloseMemHandle_v4010: CUpti_runtime_api_trace_cbid_enum = 180;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaArrayGetInfo_v4010: CUpti_runtime_api_trace_cbid_enum = 181;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFuncSetSharedMemConfig_v4020: CUpti_runtime_api_trace_cbid_enum = 182;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetSharedMemConfig_v4020: CUpti_runtime_api_trace_cbid_enum = 183;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceSetSharedMemConfig_v4020: CUpti_runtime_api_trace_cbid_enum = 184;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaCreateTextureObject_v5000: CUpti_runtime_api_trace_cbid_enum = 185;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDestroyTextureObject_v5000: CUpti_runtime_api_trace_cbid_enum = 186;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetTextureObjectResourceDesc_v5000: CUpti_runtime_api_trace_cbid_enum = 187;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetTextureObjectTextureDesc_v5000: CUpti_runtime_api_trace_cbid_enum = 188;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaCreateSurfaceObject_v5000: CUpti_runtime_api_trace_cbid_enum = 189;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDestroySurfaceObject_v5000: CUpti_runtime_api_trace_cbid_enum = 190;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetSurfaceObjectResourceDesc_v5000: CUpti_runtime_api_trace_cbid_enum = 191;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMallocMipmappedArray_v5000: CUpti_runtime_api_trace_cbid_enum = 192;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetMipmappedArrayLevel_v5000: CUpti_runtime_api_trace_cbid_enum = 193;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFreeMipmappedArray_v5000: CUpti_runtime_api_trace_cbid_enum = 194;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaBindTextureToMipmappedArray_v5000: CUpti_runtime_api_trace_cbid_enum = 195;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsResourceGetMappedMipmappedArray_v5000: CUpti_runtime_api_trace_cbid_enum = 196;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamAddCallback_v5000: CUpti_runtime_api_trace_cbid_enum = 197;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamCreateWithFlags_v5000: CUpti_runtime_api_trace_cbid_enum = 198;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetTextureObjectResourceViewDesc_v5000: CUpti_runtime_api_trace_cbid_enum = 199;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetAttribute_v5000: CUpti_runtime_api_trace_cbid_enum = 200;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamDestroy_v5050: CUpti_runtime_api_trace_cbid_enum = 201;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamCreateWithPriority_v5050: CUpti_runtime_api_trace_cbid_enum = 202;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetPriority_v5050: CUpti_runtime_api_trace_cbid_enum = 203;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetFlags_v5050: CUpti_runtime_api_trace_cbid_enum = 204;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetStreamPriorityRange_v5050: CUpti_runtime_api_trace_cbid_enum = 205;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMallocManaged_v6000: CUpti_runtime_api_trace_cbid_enum = 206;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaOccupancyMaxActiveBlocksPerMultiprocessor_v6000: CUpti_runtime_api_trace_cbid_enum = 207;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamAttachMemAsync_v6000: CUpti_runtime_api_trace_cbid_enum = 208;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetErrorName_v6050: CUpti_runtime_api_trace_cbid_enum = 209;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaOccupancyMaxActiveBlocksPerMultiprocessor_v6050: CUpti_runtime_api_trace_cbid_enum = 210;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLaunchKernel_v7000: CUpti_runtime_api_trace_cbid_enum = 211;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetDeviceFlags_v7000: CUpti_runtime_api_trace_cbid_enum = 212;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLaunch_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 213;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLaunchKernel_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 214;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy_ptds_v7000: CUpti_runtime_api_trace_cbid_enum = 215;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2D_ptds_v7000: CUpti_runtime_api_trace_cbid_enum = 216;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyToArray_ptds_v7000: CUpti_runtime_api_trace_cbid_enum = 217;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DToArray_ptds_v7000: CUpti_runtime_api_trace_cbid_enum = 218;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyFromArray_ptds_v7000: CUpti_runtime_api_trace_cbid_enum = 219;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DFromArray_ptds_v7000: CUpti_runtime_api_trace_cbid_enum = 220;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyArrayToArray_ptds_v7000: CUpti_runtime_api_trace_cbid_enum = 221;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DArrayToArray_ptds_v7000: CUpti_runtime_api_trace_cbid_enum = 222;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyToSymbol_ptds_v7000: CUpti_runtime_api_trace_cbid_enum = 223;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyFromSymbol_ptds_v7000: CUpti_runtime_api_trace_cbid_enum = 224;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyAsync_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 225;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyToArrayAsync_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 226;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyFromArrayAsync_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 227;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DAsync_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 228;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DToArrayAsync_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 229;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DFromArrayAsync_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 230;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyToSymbolAsync_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 231;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyFromSymbolAsync_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 232;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemset_ptds_v7000: CUpti_runtime_api_trace_cbid_enum = 233;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemset2D_ptds_v7000: CUpti_runtime_api_trace_cbid_enum = 234;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemsetAsync_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 235;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemset2DAsync_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 236;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetPriority_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 237;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetFlags_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 238;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamSynchronize_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 239;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamQuery_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 240;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamAttachMemAsync_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 241;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventRecord_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 242;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemset3D_ptds_v7000: CUpti_runtime_api_trace_cbid_enum = 243;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemset3DAsync_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 244;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3D_ptds_v7000: CUpti_runtime_api_trace_cbid_enum = 245;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3DAsync_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 246;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamWaitEvent_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 247;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamAddCallback_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 248;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3DPeer_ptds_v7000: CUpti_runtime_api_trace_cbid_enum = 249;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3DPeerAsync_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 250;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_v7000: CUpti_runtime_api_trace_cbid_enum = 251;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPrefetchAsync_v8000: CUpti_runtime_api_trace_cbid_enum = 252;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPrefetchAsync_ptsz_v8000: CUpti_runtime_api_trace_cbid_enum = 253;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemAdvise_v8000: CUpti_runtime_api_trace_cbid_enum = 254;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetP2PAttribute_v8000: CUpti_runtime_api_trace_cbid_enum = 255;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsEGLRegisterImage_v7000: CUpti_runtime_api_trace_cbid_enum = 256;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEGLStreamConsumerConnect_v7000: CUpti_runtime_api_trace_cbid_enum = 257;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEGLStreamConsumerDisconnect_v7000: CUpti_runtime_api_trace_cbid_enum = 258;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEGLStreamConsumerAcquireFrame_v7000: CUpti_runtime_api_trace_cbid_enum = 259;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEGLStreamConsumerReleaseFrame_v7000: CUpti_runtime_api_trace_cbid_enum = 260;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEGLStreamProducerConnect_v7000: CUpti_runtime_api_trace_cbid_enum = 261;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEGLStreamProducerDisconnect_v7000: CUpti_runtime_api_trace_cbid_enum = 262;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEGLStreamProducerPresentFrame_v7000: CUpti_runtime_api_trace_cbid_enum = 263;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEGLStreamProducerReturnFrame_v7000: CUpti_runtime_api_trace_cbid_enum = 264;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsResourceGetMappedEglFrame_v7000: CUpti_runtime_api_trace_cbid_enum = 265;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemRangeGetAttribute_v8000: CUpti_runtime_api_trace_cbid_enum = 266;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemRangeGetAttributes_v8000: CUpti_runtime_api_trace_cbid_enum = 267;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEGLStreamConsumerConnectWithFlags_v7000: CUpti_runtime_api_trace_cbid_enum = 268;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLaunchCooperativeKernel_v9000: CUpti_runtime_api_trace_cbid_enum = 269;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLaunchCooperativeKernel_ptsz_v9000: CUpti_runtime_api_trace_cbid_enum = 270;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventCreateFromEGLSync_v9000: CUpti_runtime_api_trace_cbid_enum = 271;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLaunchCooperativeKernelMultiDevice_v9000: CUpti_runtime_api_trace_cbid_enum = 272;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFuncSetAttribute_v9000: CUpti_runtime_api_trace_cbid_enum = 273;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaImportExternalMemory_v10000: CUpti_runtime_api_trace_cbid_enum = 274;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaExternalMemoryGetMappedBuffer_v10000: CUpti_runtime_api_trace_cbid_enum = 275;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaExternalMemoryGetMappedMipmappedArray_v10000: CUpti_runtime_api_trace_cbid_enum = 276;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDestroyExternalMemory_v10000: CUpti_runtime_api_trace_cbid_enum = 277;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaImportExternalSemaphore_v10000: CUpti_runtime_api_trace_cbid_enum = 278;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaSignalExternalSemaphoresAsync_v10000: CUpti_runtime_api_trace_cbid_enum = 279;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaSignalExternalSemaphoresAsync_ptsz_v10000: CUpti_runtime_api_trace_cbid_enum = 280;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaWaitExternalSemaphoresAsync_v10000: CUpti_runtime_api_trace_cbid_enum = 281;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaWaitExternalSemaphoresAsync_ptsz_v10000: CUpti_runtime_api_trace_cbid_enum = 282;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDestroyExternalSemaphore_v10000: CUpti_runtime_api_trace_cbid_enum = 283;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLaunchHostFunc_v10000: CUpti_runtime_api_trace_cbid_enum = 284;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLaunchHostFunc_ptsz_v10000: CUpti_runtime_api_trace_cbid_enum = 285;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphCreate_v10000: CUpti_runtime_api_trace_cbid_enum = 286;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphKernelNodeGetParams_v10000: CUpti_runtime_api_trace_cbid_enum = 287;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphKernelNodeSetParams_v10000: CUpti_runtime_api_trace_cbid_enum = 288;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddKernelNode_v10000: CUpti_runtime_api_trace_cbid_enum = 289;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddMemcpyNode_v10000: CUpti_runtime_api_trace_cbid_enum = 290;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphMemcpyNodeGetParams_v10000: CUpti_runtime_api_trace_cbid_enum = 291;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphMemcpyNodeSetParams_v10000: CUpti_runtime_api_trace_cbid_enum = 292;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddMemsetNode_v10000: CUpti_runtime_api_trace_cbid_enum = 293;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphMemsetNodeGetParams_v10000: CUpti_runtime_api_trace_cbid_enum = 294;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphMemsetNodeSetParams_v10000: CUpti_runtime_api_trace_cbid_enum = 295;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddHostNode_v10000: CUpti_runtime_api_trace_cbid_enum = 296;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphHostNodeGetParams_v10000: CUpti_runtime_api_trace_cbid_enum = 297;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddChildGraphNode_v10000: CUpti_runtime_api_trace_cbid_enum = 298;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphChildGraphNodeGetGraph_v10000: CUpti_runtime_api_trace_cbid_enum = 299;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddEmptyNode_v10000: CUpti_runtime_api_trace_cbid_enum = 300;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphClone_v10000: CUpti_runtime_api_trace_cbid_enum = 301;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphNodeFindInClone_v10000: CUpti_runtime_api_trace_cbid_enum = 302;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphNodeGetType_v10000: CUpti_runtime_api_trace_cbid_enum = 303;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphGetRootNodes_v10000: CUpti_runtime_api_trace_cbid_enum = 304;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphNodeGetDependencies_v10000: CUpti_runtime_api_trace_cbid_enum = 305;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphNodeGetDependentNodes_v10000: CUpti_runtime_api_trace_cbid_enum = 306;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddDependencies_v10000: CUpti_runtime_api_trace_cbid_enum = 307;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphRemoveDependencies_v10000: CUpti_runtime_api_trace_cbid_enum = 308;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphDestroyNode_v10000: CUpti_runtime_api_trace_cbid_enum = 309;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphInstantiate_v10000: CUpti_runtime_api_trace_cbid_enum = 310;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphLaunch_v10000: CUpti_runtime_api_trace_cbid_enum = 311;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphLaunch_ptsz_v10000: CUpti_runtime_api_trace_cbid_enum = 312;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecDestroy_v10000: CUpti_runtime_api_trace_cbid_enum = 313;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphDestroy_v10000: CUpti_runtime_api_trace_cbid_enum = 314;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamBeginCapture_v10000: CUpti_runtime_api_trace_cbid_enum = 315;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamBeginCapture_ptsz_v10000: CUpti_runtime_api_trace_cbid_enum = 316;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamIsCapturing_v10000: CUpti_runtime_api_trace_cbid_enum = 317;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamIsCapturing_ptsz_v10000: CUpti_runtime_api_trace_cbid_enum = 318;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamEndCapture_v10000: CUpti_runtime_api_trace_cbid_enum = 319;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamEndCapture_ptsz_v10000: CUpti_runtime_api_trace_cbid_enum = 320;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphHostNodeSetParams_v10000: CUpti_runtime_api_trace_cbid_enum = 321;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphGetNodes_v10000: CUpti_runtime_api_trace_cbid_enum = 322;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphGetEdges_v10000: CUpti_runtime_api_trace_cbid_enum = 323;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetCaptureInfo_v10010: CUpti_runtime_api_trace_cbid_enum = 324;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetCaptureInfo_ptsz_v10010: CUpti_runtime_api_trace_cbid_enum = 325;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecKernelNodeSetParams_v10010: CUpti_runtime_api_trace_cbid_enum = 326;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaThreadExchangeStreamCaptureMode_v10010: CUpti_runtime_api_trace_cbid_enum = 327;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetNvSciSyncAttributes_v10020: CUpti_runtime_api_trace_cbid_enum = 328;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaOccupancyAvailableDynamicSMemPerBlock_v10200: CUpti_runtime_api_trace_cbid_enum = 329;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamSetFlags_v10200: CUpti_runtime_api_trace_cbid_enum = 330;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamSetFlags_ptsz_v10200: CUpti_runtime_api_trace_cbid_enum = 331;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecMemcpyNodeSetParams_v10020: CUpti_runtime_api_trace_cbid_enum = 332;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecMemsetNodeSetParams_v10020: CUpti_runtime_api_trace_cbid_enum = 333;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecHostNodeSetParams_v10020: CUpti_runtime_api_trace_cbid_enum = 334;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecUpdate_v10020: CUpti_runtime_api_trace_cbid_enum = 335;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetFuncBySymbol_v11000: CUpti_runtime_api_trace_cbid_enum = 336;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaCtxResetPersistingL2Cache_v11000: CUpti_runtime_api_trace_cbid_enum = 337;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphKernelNodeCopyAttributes_v11000: CUpti_runtime_api_trace_cbid_enum = 338;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphKernelNodeGetAttribute_v11000: CUpti_runtime_api_trace_cbid_enum = 339;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphKernelNodeSetAttribute_v11000: CUpti_runtime_api_trace_cbid_enum = 340;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamCopyAttributes_v11000: CUpti_runtime_api_trace_cbid_enum = 341;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamCopyAttributes_ptsz_v11000: CUpti_runtime_api_trace_cbid_enum = 342;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetAttribute_v11000: CUpti_runtime_api_trace_cbid_enum = 343;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetAttribute_ptsz_v11000: CUpti_runtime_api_trace_cbid_enum = 344;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamSetAttribute_v11000: CUpti_runtime_api_trace_cbid_enum = 345;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamSetAttribute_ptsz_v11000: CUpti_runtime_api_trace_cbid_enum = 346;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetTexture1DLinearMaxWidth_v11010: CUpti_runtime_api_trace_cbid_enum = 347;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphUpload_v10000: CUpti_runtime_api_trace_cbid_enum = 348;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphUpload_ptsz_v10000: CUpti_runtime_api_trace_cbid_enum = 349;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddMemcpyNodeToSymbol_v11010: CUpti_runtime_api_trace_cbid_enum = 350;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddMemcpyNodeFromSymbol_v11010: CUpti_runtime_api_trace_cbid_enum = 351;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddMemcpyNode1D_v11010: CUpti_runtime_api_trace_cbid_enum = 352;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphMemcpyNodeSetParamsToSymbol_v11010: CUpti_runtime_api_trace_cbid_enum = 353;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphMemcpyNodeSetParamsFromSymbol_v11010: CUpti_runtime_api_trace_cbid_enum = 354;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphMemcpyNodeSetParams1D_v11010: CUpti_runtime_api_trace_cbid_enum = 355;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecMemcpyNodeSetParamsToSymbol_v11010: CUpti_runtime_api_trace_cbid_enum = 356;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecMemcpyNodeSetParamsFromSymbol_v11010: CUpti_runtime_api_trace_cbid_enum = 357;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecMemcpyNodeSetParams1D_v11010: CUpti_runtime_api_trace_cbid_enum = 358;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaArrayGetSparseProperties_v11010: CUpti_runtime_api_trace_cbid_enum = 359;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMipmappedArrayGetSparseProperties_v11010: CUpti_runtime_api_trace_cbid_enum = 360;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecChildGraphNodeSetParams_v11010: CUpti_runtime_api_trace_cbid_enum = 361;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddEventRecordNode_v11010: CUpti_runtime_api_trace_cbid_enum = 362;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphEventRecordNodeGetEvent_v11010: CUpti_runtime_api_trace_cbid_enum = 363;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphEventRecordNodeSetEvent_v11010: CUpti_runtime_api_trace_cbid_enum = 364;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddEventWaitNode_v11010: CUpti_runtime_api_trace_cbid_enum = 365;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphEventWaitNodeGetEvent_v11010: CUpti_runtime_api_trace_cbid_enum = 366;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphEventWaitNodeSetEvent_v11010: CUpti_runtime_api_trace_cbid_enum = 367;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecEventRecordNodeSetEvent_v11010: CUpti_runtime_api_trace_cbid_enum = 368;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecEventWaitNodeSetEvent_v11010: CUpti_runtime_api_trace_cbid_enum = 369;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventRecordWithFlags_v11010: CUpti_runtime_api_trace_cbid_enum = 370;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventRecordWithFlags_ptsz_v11010: CUpti_runtime_api_trace_cbid_enum = 371;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetDefaultMemPool_v11020: CUpti_runtime_api_trace_cbid_enum = 372;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMallocAsync_v11020: CUpti_runtime_api_trace_cbid_enum = 373;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMallocAsync_ptsz_v11020: CUpti_runtime_api_trace_cbid_enum = 374;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFreeAsync_v11020: CUpti_runtime_api_trace_cbid_enum = 375;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFreeAsync_ptsz_v11020: CUpti_runtime_api_trace_cbid_enum = 376;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPoolTrimTo_v11020: CUpti_runtime_api_trace_cbid_enum = 377;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPoolSetAttribute_v11020: CUpti_runtime_api_trace_cbid_enum = 378;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPoolGetAttribute_v11020: CUpti_runtime_api_trace_cbid_enum = 379;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPoolSetAccess_v11020: CUpti_runtime_api_trace_cbid_enum = 380;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaArrayGetPlane_v11020: CUpti_runtime_api_trace_cbid_enum = 381;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPoolGetAccess_v11020: CUpti_runtime_api_trace_cbid_enum = 382;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPoolCreate_v11020: CUpti_runtime_api_trace_cbid_enum = 383;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPoolDestroy_v11020: CUpti_runtime_api_trace_cbid_enum = 384;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceSetMemPool_v11020: CUpti_runtime_api_trace_cbid_enum = 385;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetMemPool_v11020: CUpti_runtime_api_trace_cbid_enum = 386;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPoolExportToShareableHandle_v11020: CUpti_runtime_api_trace_cbid_enum = 387;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPoolImportFromShareableHandle_v11020: CUpti_runtime_api_trace_cbid_enum = 388;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPoolExportPointer_v11020: CUpti_runtime_api_trace_cbid_enum = 389;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPoolImportPointer_v11020: CUpti_runtime_api_trace_cbid_enum = 390;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMallocFromPoolAsync_v11020: CUpti_runtime_api_trace_cbid_enum = 391;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMallocFromPoolAsync_ptsz_v11020: CUpti_runtime_api_trace_cbid_enum = 392;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaSignalExternalSemaphoresAsync_v11020: CUpti_runtime_api_trace_cbid_enum = 393;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaSignalExternalSemaphoresAsync_ptsz_v11020: CUpti_runtime_api_trace_cbid_enum = 394;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaWaitExternalSemaphoresAsync_v11020: CUpti_runtime_api_trace_cbid_enum = 395;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaWaitExternalSemaphoresAsync_ptsz_v11020: CUpti_runtime_api_trace_cbid_enum = 396;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddExternalSemaphoresSignalNode_v11020: CUpti_runtime_api_trace_cbid_enum = 397;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExternalSemaphoresSignalNodeGetParams_v11020: CUpti_runtime_api_trace_cbid_enum = 398;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExternalSemaphoresSignalNodeSetParams_v11020: CUpti_runtime_api_trace_cbid_enum = 399;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddExternalSemaphoresWaitNode_v11020: CUpti_runtime_api_trace_cbid_enum = 400;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExternalSemaphoresWaitNodeGetParams_v11020: CUpti_runtime_api_trace_cbid_enum = 401;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExternalSemaphoresWaitNodeSetParams_v11020: CUpti_runtime_api_trace_cbid_enum = 402;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecExternalSemaphoresSignalNodeSetParams_v11020: CUpti_runtime_api_trace_cbid_enum = 403;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecExternalSemaphoresWaitNodeSetParams_v11020: CUpti_runtime_api_trace_cbid_enum = 404;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceFlushGPUDirectRDMAWrites_v11030: CUpti_runtime_api_trace_cbid_enum = 405;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetDriverEntryPoint_v11030: CUpti_runtime_api_trace_cbid_enum = 406;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetDriverEntryPoint_ptsz_v11030: CUpti_runtime_api_trace_cbid_enum = 407;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphDebugDotPrint_v11030: CUpti_runtime_api_trace_cbid_enum = 408;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetCaptureInfo_v2_v11030: CUpti_runtime_api_trace_cbid_enum = 409;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetCaptureInfo_v2_ptsz_v11030: CUpti_runtime_api_trace_cbid_enum = 410;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamUpdateCaptureDependencies_v11030: CUpti_runtime_api_trace_cbid_enum = 411;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamUpdateCaptureDependencies_ptsz_v11030: CUpti_runtime_api_trace_cbid_enum = 412;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaUserObjectCreate_v11030: CUpti_runtime_api_trace_cbid_enum = 413;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaUserObjectRetain_v11030: CUpti_runtime_api_trace_cbid_enum = 414;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaUserObjectRelease_v11030: CUpti_runtime_api_trace_cbid_enum = 415;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphRetainUserObject_v11030: CUpti_runtime_api_trace_cbid_enum = 416;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphReleaseUserObject_v11030: CUpti_runtime_api_trace_cbid_enum = 417;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphInstantiateWithFlags_v11040: CUpti_runtime_api_trace_cbid_enum = 418;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddMemAllocNode_v11040: CUpti_runtime_api_trace_cbid_enum = 419;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphMemAllocNodeGetParams_v11040: CUpti_runtime_api_trace_cbid_enum = 420;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddMemFreeNode_v11040: CUpti_runtime_api_trace_cbid_enum = 421;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphMemFreeNodeGetParams_v11040: CUpti_runtime_api_trace_cbid_enum = 422;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGraphMemTrim_v11040: CUpti_runtime_api_trace_cbid_enum = 423;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetGraphMemAttribute_v11040: CUpti_runtime_api_trace_cbid_enum = 424;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceSetGraphMemAttribute_v11040: CUpti_runtime_api_trace_cbid_enum = 425;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphNodeSetEnabled_v11060: CUpti_runtime_api_trace_cbid_enum = 426;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphNodeGetEnabled_v11060: CUpti_runtime_api_trace_cbid_enum = 427;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaArrayGetMemoryRequirements_v11060: CUpti_runtime_api_trace_cbid_enum = 428;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMipmappedArrayGetMemoryRequirements_v11060: CUpti_runtime_api_trace_cbid_enum = 429;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLaunchKernelExC_v11060: CUpti_runtime_api_trace_cbid_enum = 430;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLaunchKernelExC_ptsz_v11060: CUpti_runtime_api_trace_cbid_enum = 431;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaOccupancyMaxPotentialClusterSize_v11070: CUpti_runtime_api_trace_cbid_enum = 432;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaOccupancyMaxActiveClusters_v11070: CUpti_runtime_api_trace_cbid_enum = 433;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaCreateTextureObject_v2_v11080: CUpti_runtime_api_trace_cbid_enum = 434;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetTextureObjectTextureDesc_v2_v11080: CUpti_runtime_api_trace_cbid_enum = 435;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphInstantiateWithParams_v12000: CUpti_runtime_api_trace_cbid_enum = 436;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphInstantiateWithParams_ptsz_v12000: CUpti_runtime_api_trace_cbid_enum = 437;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecGetFlags_v12000: CUpti_runtime_api_trace_cbid_enum = 438;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetKernel_v12000: CUpti_runtime_api_trace_cbid_enum = 439;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetDeviceProperties_v12000: CUpti_runtime_api_trace_cbid_enum = 440;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetId_v12000: CUpti_runtime_api_trace_cbid_enum = 441;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetId_ptsz_v12000: CUpti_runtime_api_trace_cbid_enum = 442;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphInstantiate_v12000: CUpti_runtime_api_trace_cbid_enum = 443;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaInitDevice_v12000: CUpti_runtime_api_trace_cbid_enum = 444;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddNode_v12020: CUpti_runtime_api_trace_cbid_enum = 445;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphNodeSetParams_v12020: CUpti_runtime_api_trace_cbid_enum = 446;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecNodeSetParams_v12020: CUpti_runtime_api_trace_cbid_enum = 447;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemAdvise_v12020: CUpti_runtime_api_trace_cbid_enum = 448;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPrefetchAsync_v12020: CUpti_runtime_api_trace_cbid_enum = 449;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPrefetchAsync_ptsz_v12020: CUpti_runtime_api_trace_cbid_enum = 450;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFuncGetName_v12030: CUpti_runtime_api_trace_cbid_enum = 451;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamBeginCaptureToGraph_v12030: CUpti_runtime_api_trace_cbid_enum = 452;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamBeginCaptureToGraph_ptsz_v12030: CUpti_runtime_api_trace_cbid_enum = 453;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphConditionalHandleCreate_v12030: CUpti_runtime_api_trace_cbid_enum = 454;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphGetEdges_v12030: CUpti_runtime_api_trace_cbid_enum = 455;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphNodeGetDependencies_v12030: CUpti_runtime_api_trace_cbid_enum = 456;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphNodeGetDependentNodes_v12030: CUpti_runtime_api_trace_cbid_enum = 457;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddDependencies_v12030: CUpti_runtime_api_trace_cbid_enum = 458;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphRemoveDependencies_v12030: CUpti_runtime_api_trace_cbid_enum = 459;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddNode_v12030: CUpti_runtime_api_trace_cbid_enum = 460;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetCaptureInfo_v12030: CUpti_runtime_api_trace_cbid_enum = 461;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetCaptureInfo_ptsz_v12030: CUpti_runtime_api_trace_cbid_enum = 462;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamUpdateCaptureDependencies_v12030: CUpti_runtime_api_trace_cbid_enum = 463;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamUpdateCaptureDependencies_ptsz_v12030: CUpti_runtime_api_trace_cbid_enum = 464;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceRegisterAsyncNotification_v12040: CUpti_runtime_api_trace_cbid_enum = 465;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceUnregisterAsyncNotification_v12040: CUpti_runtime_api_trace_cbid_enum = 466;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFuncGetParamInfo_v12040: CUpti_runtime_api_trace_cbid_enum = 467;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetDriverEntryPointByVersion_v12050: CUpti_runtime_api_trace_cbid_enum = 468;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetDriverEntryPointByVersion_ptsz_v12050: CUpti_runtime_api_trace_cbid_enum = 469;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLibraryLoadData_v12060: CUpti_runtime_api_trace_cbid_enum = 470;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLibraryLoadFromFile_v12060: CUpti_runtime_api_trace_cbid_enum = 471;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLibraryUnload_v12060: CUpti_runtime_api_trace_cbid_enum = 472;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLibraryGetKernel_v12060: CUpti_runtime_api_trace_cbid_enum = 473;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLibraryGetGlobal_v12060: CUpti_runtime_api_trace_cbid_enum = 474;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLibraryGetManaged_v12060: CUpti_runtime_api_trace_cbid_enum = 475;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLibraryGetUnifiedFunction_v12060: CUpti_runtime_api_trace_cbid_enum = 476;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLibraryGetKernelCount_v12060: CUpti_runtime_api_trace_cbid_enum = 477;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLibraryEnumerateKernels_v12060: CUpti_runtime_api_trace_cbid_enum = 478;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaKernelSetAttributeForDevice_v12060: CUpti_runtime_api_trace_cbid_enum = 479;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetDevice_v12080: CUpti_runtime_api_trace_cbid_enum = 480;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetDevice_ptsz_v12080: CUpti_runtime_api_trace_cbid_enum = 481;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyBatchAsync_v12080: CUpti_runtime_api_trace_cbid_enum = 482;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyBatchAsync_ptsz_v12080: CUpti_runtime_api_trace_cbid_enum = 483;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3DBatchAsync_v12080: CUpti_runtime_api_trace_cbid_enum = 484;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3DBatchAsync_ptsz_v12080: CUpti_runtime_api_trace_cbid_enum = 485;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventElapsedTime_v12080: CUpti_runtime_api_trace_cbid_enum = 486;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPrefetchBatchAsync_v13000: CUpti_runtime_api_trace_cbid_enum = 487;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPrefetchBatchAsync_ptsz_v13000: CUpti_runtime_api_trace_cbid_enum = 488;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemDiscardBatchAsync_v13000: CUpti_runtime_api_trace_cbid_enum = 489;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemDiscardBatchAsync_ptsz_v13000: CUpti_runtime_api_trace_cbid_enum = 490;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemDiscardAndPrefetchBatchAsync_v13000: CUpti_runtime_api_trace_cbid_enum = 491;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemDiscardAndPrefetchBatchAsync_ptsz_v13000: CUpti_runtime_api_trace_cbid_enum = 492;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetExportTable_v13000: CUpti_runtime_api_trace_cbid_enum = 493;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaRegisterFatBinary_v13000: CUpti_runtime_api_trace_cbid_enum = 494;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaRegisterFatBinaryEnd_v13000: CUpti_runtime_api_trace_cbid_enum = 495;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaUnregisterFatBinary_v13000: CUpti_runtime_api_trace_cbid_enum = 496;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaRegisterVar_v13000: CUpti_runtime_api_trace_cbid_enum = 497;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaRegisterHostVar_v13000: CUpti_runtime_api_trace_cbid_enum = 498;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaRegisterFunction_v13000: CUpti_runtime_api_trace_cbid_enum = 499;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaRegisterManagedVar_v13000: CUpti_runtime_api_trace_cbid_enum = 500;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaInitModule_v13000: CUpti_runtime_api_trace_cbid_enum = 501;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaPushCallConfiguration_v13000: CUpti_runtime_api_trace_cbid_enum = 502;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaPopCallConfiguration_v13000: CUpti_runtime_api_trace_cbid_enum = 503;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaGetKernel_v13000: CUpti_runtime_api_trace_cbid_enum = 504;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaLaunchKernel_v13000: CUpti_runtime_api_trace_cbid_enum = 505;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaLaunchKernel_ptsz_v13000: CUpti_runtime_api_trace_cbid_enum = 506;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaRegisterUnifiedTable_v13000: CUpti_runtime_api_trace_cbid_enum = 507;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaGetProcAddress_v13000: CUpti_runtime_api_trace_cbid_enum = 508;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyBatchAsync_v13000: CUpti_runtime_api_trace_cbid_enum = 509;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyBatchAsync_ptsz_v13000: CUpti_runtime_api_trace_cbid_enum = 510;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3DBatchAsync_v13000: CUpti_runtime_api_trace_cbid_enum = 511;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3DBatchAsync_ptsz_v13000: CUpti_runtime_api_trace_cbid_enum = 512;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLogsRegisterCallback_v13000: CUpti_runtime_api_trace_cbid_enum = 513;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLogsUnregisterCallback_v13000: CUpti_runtime_api_trace_cbid_enum = 514;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLogsCurrent_v13000: CUpti_runtime_api_trace_cbid_enum = 515;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLogsDumpToFile_v13000: CUpti_runtime_api_trace_cbid_enum = 516;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLogsDumpToMemory_v13000: CUpti_runtime_api_trace_cbid_enum = 517;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemGetDefaultMemPool_v13000: CUpti_runtime_api_trace_cbid_enum = 518;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemGetMemPool_v13000: CUpti_runtime_api_trace_cbid_enum = 519;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemSetMemPool_v13000: CUpti_runtime_api_trace_cbid_enum = 520;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetHostAtomicCapabilities_v13000: CUpti_runtime_api_trace_cbid_enum = 521;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetP2PAtomicCapabilities_v13000: CUpti_runtime_api_trace_cbid_enum = 522;
pub const CUPTI_RUNTIME_TRACE_CBID_SIZE: CUpti_runtime_api_trace_cbid_enum = 523;
pub const CUPTI_RUNTIME_TRACE_CBID_FORCE_INT: CUpti_runtime_api_trace_cbid_enum = 2147483647;
pub type CUpti_runtime_api_trace_cbid_enum = ::std::os::raw::c_uint;
pub use self::CUpti_runtime_api_trace_cbid_enum as CUpti_runtime_api_trace_cbid;
pub const CUPTI_CBID_NVTX_INVALID: CUpti_nvtx_api_trace_cbid = 0;
pub const CUPTI_CBID_NVTX_nvtxMarkA: CUpti_nvtx_api_trace_cbid = 1;
pub const CUPTI_CBID_NVTX_nvtxMarkW: CUpti_nvtx_api_trace_cbid = 2;
pub const CUPTI_CBID_NVTX_nvtxMarkEx: CUpti_nvtx_api_trace_cbid = 3;
pub const CUPTI_CBID_NVTX_nvtxRangeStartA: CUpti_nvtx_api_trace_cbid = 4;
pub const CUPTI_CBID_NVTX_nvtxRangeStartW: CUpti_nvtx_api_trace_cbid = 5;
pub const CUPTI_CBID_NVTX_nvtxRangeStartEx: CUpti_nvtx_api_trace_cbid = 6;
pub const CUPTI_CBID_NVTX_nvtxRangeEnd: CUpti_nvtx_api_trace_cbid = 7;
pub const CUPTI_CBID_NVTX_nvtxRangePushA: CUpti_nvtx_api_trace_cbid = 8;
pub const CUPTI_CBID_NVTX_nvtxRangePushW: CUpti_nvtx_api_trace_cbid = 9;
pub const CUPTI_CBID_NVTX_nvtxRangePushEx: CUpti_nvtx_api_trace_cbid = 10;
pub const CUPTI_CBID_NVTX_nvtxRangePop: CUpti_nvtx_api_trace_cbid = 11;
pub const CUPTI_CBID_NVTX_nvtxNameCategoryA: CUpti_nvtx_api_trace_cbid = 12;
pub const CUPTI_CBID_NVTX_nvtxNameCategoryW: CUpti_nvtx_api_trace_cbid = 13;
pub const CUPTI_CBID_NVTX_nvtxNameOsThreadA: CUpti_nvtx_api_trace_cbid = 14;
pub const CUPTI_CBID_NVTX_nvtxNameOsThreadW: CUpti_nvtx_api_trace_cbid = 15;
pub const CUPTI_CBID_NVTX_nvtxNameCuDeviceA: CUpti_nvtx_api_trace_cbid = 16;
pub const CUPTI_CBID_NVTX_nvtxNameCuDeviceW: CUpti_nvtx_api_trace_cbid = 17;
pub const CUPTI_CBID_NVTX_nvtxNameCuContextA: CUpti_nvtx_api_trace_cbid = 18;
pub const CUPTI_CBID_NVTX_nvtxNameCuContextW: CUpti_nvtx_api_trace_cbid = 19;
pub const CUPTI_CBID_NVTX_nvtxNameCuStreamA: CUpti_nvtx_api_trace_cbid = 20;
pub const CUPTI_CBID_NVTX_nvtxNameCuStreamW: CUpti_nvtx_api_trace_cbid = 21;
pub const CUPTI_CBID_NVTX_nvtxNameCuEventA: CUpti_nvtx_api_trace_cbid = 22;
pub const CUPTI_CBID_NVTX_nvtxNameCuEventW: CUpti_nvtx_api_trace_cbid = 23;
pub const CUPTI_CBID_NVTX_nvtxNameCudaDeviceA: CUpti_nvtx_api_trace_cbid = 24;
pub const CUPTI_CBID_NVTX_nvtxNameCudaDeviceW: CUpti_nvtx_api_trace_cbid = 25;
pub const CUPTI_CBID_NVTX_nvtxNameCudaStreamA: CUpti_nvtx_api_trace_cbid = 26;
pub const CUPTI_CBID_NVTX_nvtxNameCudaStreamW: CUpti_nvtx_api_trace_cbid = 27;
pub const CUPTI_CBID_NVTX_nvtxNameCudaEventA: CUpti_nvtx_api_trace_cbid = 28;
pub const CUPTI_CBID_NVTX_nvtxNameCudaEventW: CUpti_nvtx_api_trace_cbid = 29;
pub const CUPTI_CBID_NVTX_nvtxDomainMarkEx: CUpti_nvtx_api_trace_cbid = 30;
pub const CUPTI_CBID_NVTX_nvtxDomainRangeStartEx: CUpti_nvtx_api_trace_cbid = 31;
pub const CUPTI_CBID_NVTX_nvtxDomainRangeEnd: CUpti_nvtx_api_trace_cbid = 32;
pub const CUPTI_CBID_NVTX_nvtxDomainRangePushEx: CUpti_nvtx_api_trace_cbid = 33;
pub const CUPTI_CBID_NVTX_nvtxDomainRangePop: CUpti_nvtx_api_trace_cbid = 34;
pub const CUPTI_CBID_NVTX_nvtxDomainResourceCreate: CUpti_nvtx_api_trace_cbid = 35;
pub const CUPTI_CBID_NVTX_nvtxDomainResourceDestroy: CUpti_nvtx_api_trace_cbid = 36;
pub const CUPTI_CBID_NVTX_nvtxDomainNameCategoryA: CUpti_nvtx_api_trace_cbid = 37;
pub const CUPTI_CBID_NVTX_nvtxDomainNameCategoryW: CUpti_nvtx_api_trace_cbid = 38;
pub const CUPTI_CBID_NVTX_nvtxDomainRegisterStringA: CUpti_nvtx_api_trace_cbid = 39;
pub const CUPTI_CBID_NVTX_nvtxDomainRegisterStringW: CUpti_nvtx_api_trace_cbid = 40;
pub const CUPTI_CBID_NVTX_nvtxDomainCreateA: CUpti_nvtx_api_trace_cbid = 41;
pub const CUPTI_CBID_NVTX_nvtxDomainCreateW: CUpti_nvtx_api_trace_cbid = 42;
pub const CUPTI_CBID_NVTX_nvtxDomainDestroy: CUpti_nvtx_api_trace_cbid = 43;
pub const CUPTI_CBID_NVTX_nvtxDomainSyncUserCreate: CUpti_nvtx_api_trace_cbid = 44;
pub const CUPTI_CBID_NVTX_nvtxDomainSyncUserDestroy: CUpti_nvtx_api_trace_cbid = 45;
pub const CUPTI_CBID_NVTX_nvtxDomainSyncUserAcquireStart: CUpti_nvtx_api_trace_cbid = 46;
pub const CUPTI_CBID_NVTX_nvtxDomainSyncUserAcquireFailed: CUpti_nvtx_api_trace_cbid = 47;
pub const CUPTI_CBID_NVTX_nvtxDomainSyncUserAcquireSuccess: CUpti_nvtx_api_trace_cbid = 48;
pub const CUPTI_CBID_NVTX_nvtxDomainSyncUserReleasing: CUpti_nvtx_api_trace_cbid = 49;
pub const CUPTI_CBID_NVTX_SIZE: CUpti_nvtx_api_trace_cbid = 50;
pub const CUPTI_CBID_NVTX_FORCE_INT: CUpti_nvtx_api_trace_cbid = 2147483647;
pub type CUpti_nvtx_api_trace_cbid = ::std::os::raw::c_uint;
///!< Default behavior
pub const CUPTI_CHECKPOINT_OPT_NONE: CUpti_CheckpointOptimizations = 0;
///!< Determine which mem blocks have changed, and only restore those. This optimization is cached, which means cuptiCheckpointRestore must always be called at the same point in the application when this option is enabled, or the result may be incorrect.
pub const CUPTI_CHECKPOINT_OPT_TRANSFER: CUpti_CheckpointOptimizations = 1;
/// \brief Specifies optimization options for a checkpoint, may be OR'd together to specify multiple options.
pub type CUpti_CheckpointOptimizations = ::std::os::raw::c_uint;
/** \brief Configuration and handle for a CUPTI Checkpoint

 A CUptiCheckpoint object should be initialized with desired options prior to passing into any
 CUPTI Checkpoint API function.  The first call into a Checkpoint API function will initialize internal
 state based on these options.  Subsequent changes to these options will not have any effect.

 Checkpoint data is saved in device, host, and filesystem space.  There are options to reserve memory
 at each level (device, host, filesystem) which are intended to allow a guarantee that a certain amount
 of memory will remain free for use after the checkpoint is saved.
 Note, however, that falling back to slower levels of memory (host, and then filesystem) to save the checkpoint
 will result in performance degradation.
 Currently, the filesystem limitation is not implemented.  Note that falling back to filesystem storage may
 significantly impact the performance for saving and restoring a checkpoint.*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Checkpoint {
    ///!< [in] Must be set to CUpti_Checkpoint_STRUCT_SIZE
    pub structSize: usize,
    ///!< [in] Set to context to save from, or will use current context if NULL
    pub ctx: CUcontext,
    ///!< [in] Restrict checkpoint from using last N MB of device memory (-1 = use no device memory)
    pub reserveDeviceMB: usize,
    ///!< [in] Restrict checkpoint from using last N MB of host memory (-1 = use no host memory)
    pub reserveHostMB: usize,
    ///!< [in] Boolean, Allow checkpoint to save over existing checkpoint
    pub allowOverwrite: u8,
    ///!< [in] Mask of CUpti_CheckpointOptimizations flags for this checkpoint
    pub optimizations: u8,
    ///!< [in] Assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Checkpoint"][::std::mem::size_of::<CUpti_Checkpoint>() - 48usize];
    [
        "Alignment of CUpti_Checkpoint",
    ][::std::mem::align_of::<CUpti_Checkpoint>() - 8usize];
    [
        "Offset of field: CUpti_Checkpoint::structSize",
    ][::std::mem::offset_of!(CUpti_Checkpoint, structSize) - 0usize];
    [
        "Offset of field: CUpti_Checkpoint::ctx",
    ][::std::mem::offset_of!(CUpti_Checkpoint, ctx) - 8usize];
    [
        "Offset of field: CUpti_Checkpoint::reserveDeviceMB",
    ][::std::mem::offset_of!(CUpti_Checkpoint, reserveDeviceMB) - 16usize];
    [
        "Offset of field: CUpti_Checkpoint::reserveHostMB",
    ][::std::mem::offset_of!(CUpti_Checkpoint, reserveHostMB) - 24usize];
    [
        "Offset of field: CUpti_Checkpoint::allowOverwrite",
    ][::std::mem::offset_of!(CUpti_Checkpoint, allowOverwrite) - 32usize];
    [
        "Offset of field: CUpti_Checkpoint::optimizations",
    ][::std::mem::offset_of!(CUpti_Checkpoint, optimizations) - 33usize];
    [
        "Offset of field: CUpti_Checkpoint::pPriv",
    ][::std::mem::offset_of!(CUpti_Checkpoint, pPriv) - 40usize];
};
impl Default for CUpti_Checkpoint {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Initialize and save a checkpoint of the device state associated with the handle context

 Uses the handle options to configure and save a checkpoint of the device state associated with the specified context.

 \param handle A pointer to a CUpti_Checkpoint object

 \retval CUPTI_SUCCESS if a checkpoint was successfully initialized and saved
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p handle does not appear to refer to a valid CUpti_Checkpoint
 \retval CUPTI_ERROR_INVALID_CONTEXT
 \retval CUPTI_ERROR_INVALID_DEVICE if device associated with context is not compatible with checkpoint API
 \retval CUPTI_ERROR_INVALID_OPERATION if Save is requested over an existing checkpoint, but \p allowOverwrite was not originally specified
 \retval CUPTI_ERROR_OUT_OF_MEMORY if as configured, not enough backing storage space to save the checkpoint*/
    #[link_name = "\u{1}_Z19cuptiCheckpointSaveP16CUpti_Checkpoint"]
    pub fn cuptiCheckpointSave(handle: *mut CUpti_Checkpoint) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Restore a checkpoint to the device associated with its context

 Restores device, pinned, and allocated memory to the state when the checkpoint was saved

 \param handle A pointer to a previously saved CUpti_Checkpoint object

 \retval CUTPI_SUCCESS if the checkpoint was successfully restored
 \retval CUPTI_ERROR_NOT_INITIALIZED if the checkpoint was not previously initialized
 \retval CUPTI_ERROR_INVALID_CONTEXT
 \retval CUPTI_ERROR_INVALID_PARAMETER if the handle appears invalid
 \retval CUPTI_ERROR_UNKNOWN if the restore or optimization operation fails*/
    #[link_name = "\u{1}_Z22cuptiCheckpointRestoreP16CUpti_Checkpoint"]
    pub fn cuptiCheckpointRestore(handle: *mut CUpti_Checkpoint) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Free the backing data for a checkpoint

 Frees all associated device, host memory and filesystem storage used for this context.
 After freeing a handle, it may be re-used as if it was new - options may be re-configured and will
 take effect on the next call to \p cuptiCheckpointSave.

 \param handle A pointer to a previously saved CUpti_Checkpoint object

 \retval CUPTI_SUCCESS if the handle was successfully freed
 \retval CUPTI_ERROR_INVALID_PARAMETER if the handle was already freed or appears invalid
 \retval CUPTI_ERROR_INVALID_CONTEXT if the context is no longer valid*/
    #[link_name = "\u{1}_Z19cuptiCheckpointFreeP16CUpti_Checkpoint"]
    pub fn cuptiCheckpointFree(handle: *mut CUpti_Checkpoint) -> CUptiResult;
}
/// INVALID Value
pub const CUPTI_PC_SAMPLING_COLLECTION_MODE_INVALID: CUpti_PCSamplingCollectionMode = 0;
/// Continuous mode. Kernels are not serialized in this mode.
pub const CUPTI_PC_SAMPLING_COLLECTION_MODE_CONTINUOUS: CUpti_PCSamplingCollectionMode = 1;
/// Serialized mode. Kernels are serialized in this mode.
pub const CUPTI_PC_SAMPLING_COLLECTION_MODE_KERNEL_SERIALIZED: CUpti_PCSamplingCollectionMode = 2;
/// \brief PC Sampling collection mode
pub type CUpti_PCSamplingCollectionMode = ::std::os::raw::c_uint;
/// \brief PC Sampling stall reasons
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_PCSamplingStallReason {
    /// [r] Collected stall reason index
    pub pcSamplingStallReasonIndex: u32,
    /// [r] Number of times the PC was sampled with the stallReason.
    pub samples: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PCSamplingStallReason",
    ][::std::mem::size_of::<CUpti_PCSamplingStallReason>() - 8usize];
    [
        "Alignment of CUpti_PCSamplingStallReason",
    ][::std::mem::align_of::<CUpti_PCSamplingStallReason>() - 8usize];
    [
        "Offset of field: CUpti_PCSamplingStallReason::pcSamplingStallReasonIndex",
    ][::std::mem::offset_of!(CUpti_PCSamplingStallReason, pcSamplingStallReasonIndex)
        - 0usize];
    [
        "Offset of field: CUpti_PCSamplingStallReason::samples",
    ][::std::mem::offset_of!(CUpti_PCSamplingStallReason, samples) - 4usize];
};
/// \brief PC Sampling data
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingPCData {
    /** [w] Size of the data structure.
 CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are
 available in the structure. Used to preserve backward compatibility.*/
    pub size: usize,
    /// [r] Unique cubin id
    pub cubinCrc: u64,
    /// [r] PC offset
    pub pcOffset: u64,
    /// The function's unique symbol index in the module.
    pub functionIndex: u32,
    /// Padding
    pub pad: u32,
    /** [r] The function name. This name string might be shared across all the records
 including records from activity APIs representing the same function, and so it should not be
 modified or freed until post processing of all the records is done. Once done, it is users responsibility to
 free the memory using free() function.*/
    pub functionName: *mut ::std::os::raw::c_char,
    /// [r] Collected stall reason count
    pub stallReasonCount: usize,
    /** [r] Stall reason id
 Total samples*/
    pub stallReason: *mut CUpti_PCSamplingStallReason,
    /** The correlation ID of the kernel to which this result is associated. Only valid for serialized mode of pc sampling collection.
 For continous mode of collection the correlationId will be set to 0.*/
    pub correlationId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PCSamplingPCData",
    ][::std::mem::size_of::<CUpti_PCSamplingPCData>() - 64usize];
    [
        "Alignment of CUpti_PCSamplingPCData",
    ][::std::mem::align_of::<CUpti_PCSamplingPCData>() - 8usize];
    [
        "Offset of field: CUpti_PCSamplingPCData::size",
    ][::std::mem::offset_of!(CUpti_PCSamplingPCData, size) - 0usize];
    [
        "Offset of field: CUpti_PCSamplingPCData::cubinCrc",
    ][::std::mem::offset_of!(CUpti_PCSamplingPCData, cubinCrc) - 8usize];
    [
        "Offset of field: CUpti_PCSamplingPCData::pcOffset",
    ][::std::mem::offset_of!(CUpti_PCSamplingPCData, pcOffset) - 16usize];
    [
        "Offset of field: CUpti_PCSamplingPCData::functionIndex",
    ][::std::mem::offset_of!(CUpti_PCSamplingPCData, functionIndex) - 24usize];
    [
        "Offset of field: CUpti_PCSamplingPCData::pad",
    ][::std::mem::offset_of!(CUpti_PCSamplingPCData, pad) - 28usize];
    [
        "Offset of field: CUpti_PCSamplingPCData::functionName",
    ][::std::mem::offset_of!(CUpti_PCSamplingPCData, functionName) - 32usize];
    [
        "Offset of field: CUpti_PCSamplingPCData::stallReasonCount",
    ][::std::mem::offset_of!(CUpti_PCSamplingPCData, stallReasonCount) - 40usize];
    [
        "Offset of field: CUpti_PCSamplingPCData::stallReason",
    ][::std::mem::offset_of!(CUpti_PCSamplingPCData, stallReason) - 48usize];
    [
        "Offset of field: CUpti_PCSamplingPCData::correlationId",
    ][::std::mem::offset_of!(CUpti_PCSamplingPCData, correlationId) - 56usize];
};
impl Default for CUpti_PCSamplingPCData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CUPTI_PC_SAMPLING_OUTPUT_DATA_FORMAT_INVALID: CUpti_PCSamplingOutputDataFormat = 0;
/// HW buffer data will be parsed during collection of data
pub const CUPTI_PC_SAMPLING_OUTPUT_DATA_FORMAT_PARSED: CUpti_PCSamplingOutputDataFormat = 1;
/// \brief PC Sampling output data format
pub type CUpti_PCSamplingOutputDataFormat = ::std::os::raw::c_uint;
/** \brief Collected PC Sampling data
*/
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingData {
    /** [w] Size of the data structure.
 CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are
 available in the structure. Used to preserve backward compatibility.*/
    pub size: usize,
    /// [w] Number of PCs to be collected
    pub collectNumPcs: usize,
    /** [r] Number of samples collected across all PCs.
 It includes samples for user modules, samples for non-user kernels and dropped samples.
 It includes counts for all non selected stall reasons.
 CUPTI does not provide PC records for non-user kernels.
 CUPTI does not provide PC records for instructions for which all selected stall reason metrics counts are zero.*/
    pub totalSamples: u64,
    /// [r] Number of samples that were dropped by hardware due to backpressure/overflow.
    pub droppedSamples: u64,
    /// [r] Number of PCs collected
    pub totalNumPcs: usize,
    /// [r] Number of PCs available for collection
    pub remainingNumPcs: usize,
    /** [r] Unique identifier for each range.
 Data collected across multiple ranges in multiple buffers can be identified using range id.*/
    pub rangeId: u64,
    /** [r] Profiled PC data
 This data struct should have enough memory to collect number of PCs mentioned in \brief collectNumPcs*/
    pub pPcData: *mut CUpti_PCSamplingPCData,
    /** [r] Number of samples collected across all non user kernels PCs.
 It includes samples for non-user kernels.
 It includes counts for all non selected stall reasons as well.
 CUPTI does not provide PC records for non-user kernels.*/
    pub nonUsrKernelsTotalSamples: u64,
    /** [r] Status of the hardware buffer.
 CUPTI returns the error code CUPTI_ERROR_OUT_OF_MEMORY when hardware buffer is full.
 When hardware buffer is full, user will get pc data as 0. To mitigate this issue, one or more of the below options can be tried:
 1. Increase the hardware buffer size using the attribute CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_HARDWARE_BUFFER_SIZE
 2. Decrease the thread sleep span using the attribute CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_WORKER_THREAD_PERIODIC_SLEEP_SPAN
 3. Decrease the sampling frequency using the attribute CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_SAMPLING_PERIOD*/
    pub hardwareBufferFull: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PCSamplingData",
    ][::std::mem::size_of::<CUpti_PCSamplingData>() - 80usize];
    [
        "Alignment of CUpti_PCSamplingData",
    ][::std::mem::align_of::<CUpti_PCSamplingData>() - 8usize];
    [
        "Offset of field: CUpti_PCSamplingData::size",
    ][::std::mem::offset_of!(CUpti_PCSamplingData, size) - 0usize];
    [
        "Offset of field: CUpti_PCSamplingData::collectNumPcs",
    ][::std::mem::offset_of!(CUpti_PCSamplingData, collectNumPcs) - 8usize];
    [
        "Offset of field: CUpti_PCSamplingData::totalSamples",
    ][::std::mem::offset_of!(CUpti_PCSamplingData, totalSamples) - 16usize];
    [
        "Offset of field: CUpti_PCSamplingData::droppedSamples",
    ][::std::mem::offset_of!(CUpti_PCSamplingData, droppedSamples) - 24usize];
    [
        "Offset of field: CUpti_PCSamplingData::totalNumPcs",
    ][::std::mem::offset_of!(CUpti_PCSamplingData, totalNumPcs) - 32usize];
    [
        "Offset of field: CUpti_PCSamplingData::remainingNumPcs",
    ][::std::mem::offset_of!(CUpti_PCSamplingData, remainingNumPcs) - 40usize];
    [
        "Offset of field: CUpti_PCSamplingData::rangeId",
    ][::std::mem::offset_of!(CUpti_PCSamplingData, rangeId) - 48usize];
    [
        "Offset of field: CUpti_PCSamplingData::pPcData",
    ][::std::mem::offset_of!(CUpti_PCSamplingData, pPcData) - 56usize];
    [
        "Offset of field: CUpti_PCSamplingData::nonUsrKernelsTotalSamples",
    ][::std::mem::offset_of!(CUpti_PCSamplingData, nonUsrKernelsTotalSamples) - 64usize];
    [
        "Offset of field: CUpti_PCSamplingData::hardwareBufferFull",
    ][::std::mem::offset_of!(CUpti_PCSamplingData, hardwareBufferFull) - 72usize];
};
impl Default for CUpti_PCSamplingData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_INVALID: CUpti_PCSamplingConfigurationAttributeType = 0;
/** [rw] Sampling period for PC Sampling.
 DEFAULT - CUPTI defined value based on number of SMs
 Valid values for the sampling
 periods are between 5 to 31 both inclusive. This will set the
 sampling period to (2^samplingPeriod) cycles.
 For e.g. for sampling period = 5 to 31, cycles = 32, 64, 128,..., 2^31
 Value is a uint32_t*/
pub const CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_SAMPLING_PERIOD: CUpti_PCSamplingConfigurationAttributeType = 1;
/** [w] Number of stall reasons to collect.
 DEFAULT - All stall reasons will be collected
 Value is a size_t
 [w] Stall reasons to collect
 DEFAULT - All stall reasons will be collected
 Input value should be a pointer pointing to array of stall reason indexes
 containing all the stall reason indexes to collect.*/
pub const CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_STALL_REASON: CUpti_PCSamplingConfigurationAttributeType = 2;
/** [rw] Size of SW buffer for raw PC counter data downloaded from HW buffer
 DEFAULT - 1 MB, which can accommodate approximately 5500 PCs
 with all stall reasons
 Approximately it takes 16 Bytes (and some fixed size memory)
 to accommodate one PC with one stall reason
 For e.g. 1 PC with 1 stall reason = 32 Bytes
          1 PC with 2 stall reason = 48 Bytes
          1 PC with 4 stall reason = 96 Bytes
 Value is a size_t*/
pub const CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_SCRATCH_BUFFER_SIZE: CUpti_PCSamplingConfigurationAttributeType = 3;
/** [rw] Size of HW buffer in bytes
 DEFAULT - 512 MB
 If sampling period is too less, HW buffer can overflow
 and drop PC data
 Value is a size_t*/
pub const CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_HARDWARE_BUFFER_SIZE: CUpti_PCSamplingConfigurationAttributeType = 4;
/** [rw] PC Sampling collection mode
 DEFAULT - CUPTI_PC_SAMPLING_COLLECTION_MODE_CONTINUOUS
 Input value should be of type \ref CUpti_PCSamplingCollectionMode.*/
pub const CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_COLLECTION_MODE: CUpti_PCSamplingConfigurationAttributeType = 5;
/** [rw] Control over PC Sampling data collection range
 Default - 0
 1 - Allows user to start and stop PC Sampling using APIs -
 \ref cuptiPCSamplingStart() - Start PC Sampling
 \ref cuptiPCSamplingStop() - Stop PC Sampling
 Value is a uint32_t*/
pub const CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_ENABLE_START_STOP_CONTROL: CUpti_PCSamplingConfigurationAttributeType = 6;
/** [w] Value for output data format
 Default - CUPTI_PC_SAMPLING_OUTPUT_DATA_FORMAT_PARSED
 Input value should be of type \ref CUpti_PCSamplingOutputDataFormat.*/
pub const CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_OUTPUT_DATA_FORMAT: CUpti_PCSamplingConfigurationAttributeType = 7;
/** [w] Data buffer to hold collected PC Sampling data PARSED_DATA
 Default - none.
 Buffer type is void * which can point to PARSED_DATA
 Refer \ref CUpti_PCSamplingData for buffer format for PARSED_DATA*/
pub const CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_SAMPLING_DATA_BUFFER: CUpti_PCSamplingConfigurationAttributeType = 8;
/** [rw] Control sleep time of the worker threads created by CUPTI for various PC sampling operations.
 CUPTI creates multiple worker threads to offload certain operations to these threads. This includes decoding of HW data to
 the CUPTI PC sampling data and correlating PC data to SASS instructions. CUPTI wakes up these threads periodically.
 Default - 100 milliseconds.
 Value is a uint32_t*/
pub const CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_WORKER_THREAD_PERIODIC_SLEEP_SPAN: CUpti_PCSamplingConfigurationAttributeType = 9;
/** [rw] Control sleep time of the worker threads created by CUPTI for various PC sampling operations.
 CUPTI creates multiple worker threads to offload certain operations to these threads. This includes decoding of HW data to
 the CUPTI PC sampling data and correlating PC data to SASS instructions. CUPTI wakes up these threads periodically.
 Default - 100 milliseconds.
 Value is a uint32_t*/
pub const CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_FORCE_INT: CUpti_PCSamplingConfigurationAttributeType = 2147483647;
/** \brief PC Sampling configuration attributes

 PC Sampling configuration attribute types. These attributes can be read
 using \ref cuptiPCSamplingGetConfigurationAttribute and can be written
 using \ref cuptiPCSamplingSetConfigurationAttribute. Attributes marked
 [r] can only be read using \ref cuptiPCSamplingGetConfigurationAttribute
 [w] can only be written using \ref cuptiPCSamplingSetConfigurationAttribute
 [rw] can be read using \ref cuptiPCSamplingGetConfigurationAttribute and
 written using \ref cuptiPCSamplingSetConfigurationAttribute*/
pub type CUpti_PCSamplingConfigurationAttributeType = ::std::os::raw::c_uint;
/** \brief PC sampling configuration information structure

 This structure provides \ref CUpti_PCSamplingConfigurationAttributeType which can be configured
 or queried for PC sampling configuration*/
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfo {
    /// Refer \ref CUpti_PCSamplingConfigurationAttributeType for all supported attribute types
    pub attributeType: CUpti_PCSamplingConfigurationAttributeType,
    pub attributeStatus: CUptiResult,
    pub attributeData: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_PCSamplingConfigurationInfo__bindgen_ty_1 {
    pub invalidData: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_1,
    pub samplingPeriodData: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_2,
    pub stallReasonData: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_3,
    pub scratchBufferSizeData: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_4,
    pub hardwareBufferSizeData: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_5,
    pub collectionModeData: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_6,
    pub enableStartStopControlData: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_7,
    pub outputDataFormatData: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_8,
    pub samplingDataBufferData: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_9,
    pub workerThreadPeriodicSleepSpanData: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_10,
}
/// Invalid Value
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_1 {
    pub data: [u64; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::size_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_1,
    >() - 24usize];
    [
        "Alignment of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_1",
    ][::std::mem::align_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_1,
    >() - 8usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_1::data",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_1, data
    ) - 0usize];
};
/// Refer \ref CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_SAMPLING_PERIOD
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_2 {
    pub samplingPeriod: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_2",
    ][::std::mem::size_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_2,
    >() - 4usize];
    [
        "Alignment of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_2",
    ][::std::mem::align_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_2,
    >() - 4usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_2::samplingPeriod",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_2, samplingPeriod
    ) - 0usize];
};
/// Refer \ref CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_STALL_REASON
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_3 {
    pub stallReasonCount: usize,
    pub pStallReasonIndex: *mut u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_3",
    ][::std::mem::size_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_3,
    >() - 16usize];
    [
        "Alignment of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_3",
    ][::std::mem::align_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_3,
    >() - 8usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_3::stallReasonCount",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_3, stallReasonCount
    ) - 0usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_3::pStallReasonIndex",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_3, pStallReasonIndex
    ) - 8usize];
};
impl Default for CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// Refer \ref CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_SCRATCH_BUFFER_SIZE
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_4 {
    pub scratchBufferSize: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_4",
    ][::std::mem::size_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_4,
    >() - 8usize];
    [
        "Alignment of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_4",
    ][::std::mem::align_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_4,
    >() - 8usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_4::scratchBufferSize",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_4, scratchBufferSize
    ) - 0usize];
};
/// Refer \ref CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_HARDWARE_BUFFER_SIZE
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_5 {
    pub hardwareBufferSize: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_5",
    ][::std::mem::size_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_5,
    >() - 8usize];
    [
        "Alignment of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_5",
    ][::std::mem::align_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_5,
    >() - 8usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_5::hardwareBufferSize",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_5, hardwareBufferSize
    ) - 0usize];
};
/// Refer \ref CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_COLLECTION_MODE
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_6 {
    pub collectionMode: CUpti_PCSamplingCollectionMode,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_6",
    ][::std::mem::size_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_6,
    >() - 4usize];
    [
        "Alignment of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_6",
    ][::std::mem::align_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_6,
    >() - 4usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_6::collectionMode",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_6, collectionMode
    ) - 0usize];
};
impl Default for CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// Refer \ref CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_ENABLE_START_STOP_CONTROL
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_7 {
    pub enableStartStopControl: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_7",
    ][::std::mem::size_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_7,
    >() - 4usize];
    [
        "Alignment of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_7",
    ][::std::mem::align_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_7,
    >() - 4usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_7::enableStartStopControl",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_7,
        enableStartStopControl
    ) - 0usize];
};
/// Refer \ref CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_OUTPUT_DATA_FORMAT
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_8 {
    pub outputDataFormat: CUpti_PCSamplingOutputDataFormat,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_8",
    ][::std::mem::size_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_8,
    >() - 4usize];
    [
        "Alignment of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_8",
    ][::std::mem::align_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_8,
    >() - 4usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_8::outputDataFormat",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_8, outputDataFormat
    ) - 0usize];
};
impl Default for CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// Refer \ref CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_SAMPLING_DATA_BUFFER
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_9 {
    pub samplingDataBuffer: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_9",
    ][::std::mem::size_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_9,
    >() - 8usize];
    [
        "Alignment of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_9",
    ][::std::mem::align_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_9,
    >() - 8usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_9::samplingDataBuffer",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_9, samplingDataBuffer
    ) - 0usize];
};
impl Default for CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_9 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// Refer \ref CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_WORKER_THREAD_PERIODIC_SLEEP_SPAN
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_10 {
    pub workerThreadPeriodicSleepSpan: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_10",
    ][::std::mem::size_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_10,
    >() - 4usize];
    [
        "Alignment of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_10",
    ][::std::mem::align_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_10,
    >() - 4usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_10::workerThreadPeriodicSleepSpan",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_10,
        workerThreadPeriodicSleepSpan
    ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1",
    ][::std::mem::size_of::<CUpti_PCSamplingConfigurationInfo__bindgen_ty_1>()
        - 24usize];
    [
        "Alignment of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1",
    ][::std::mem::align_of::<CUpti_PCSamplingConfigurationInfo__bindgen_ty_1>()
        - 8usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1::invalidData",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1, invalidData
    ) - 0usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1::samplingPeriodData",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1, samplingPeriodData
    ) - 0usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1::stallReasonData",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1, stallReasonData
    ) - 0usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1::scratchBufferSizeData",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1, scratchBufferSizeData
    ) - 0usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1::hardwareBufferSizeData",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1, hardwareBufferSizeData
    ) - 0usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1::collectionModeData",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1, collectionModeData
    ) - 0usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1::enableStartStopControlData",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1, enableStartStopControlData
    ) - 0usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1::outputDataFormatData",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1, outputDataFormatData
    ) - 0usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1::samplingDataBufferData",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1, samplingDataBufferData
    ) - 0usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1::workerThreadPeriodicSleepSpanData",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1,
        workerThreadPeriodicSleepSpanData
    ) - 0usize];
};
impl Default for CUpti_PCSamplingConfigurationInfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_PCSamplingConfigurationInfo__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_PCSamplingConfigurationInfo__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PCSamplingConfigurationInfo",
    ][::std::mem::size_of::<CUpti_PCSamplingConfigurationInfo>() - 32usize];
    [
        "Alignment of CUpti_PCSamplingConfigurationInfo",
    ][::std::mem::align_of::<CUpti_PCSamplingConfigurationInfo>() - 8usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo::attributeType",
    ][::std::mem::offset_of!(CUpti_PCSamplingConfigurationInfo, attributeType) - 0usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo::attributeStatus",
    ][::std::mem::offset_of!(CUpti_PCSamplingConfigurationInfo, attributeStatus)
        - 4usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo::attributeData",
    ][::std::mem::offset_of!(CUpti_PCSamplingConfigurationInfo, attributeData) - 8usize];
};
impl Default for CUpti_PCSamplingConfigurationInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_PCSamplingConfigurationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_PCSamplingConfigurationInfo {{ attributeType: {:?}, attributeStatus: {:?}, attributeData: {:?} }}",
            self.attributeType,
            self.attributeStatus,
            self.attributeData,
        )
    }
}
/** \brief PC sampling configuration structure

 This structure configures PC sampling using \ref cuptiPCSamplingSetConfigurationAttribute
 and queries PC sampling default configuration using \ref cuptiPCSamplingGetConfigurationAttribute*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfoParams {
    /** [w] Size of the data structure i.e. CUpti_PCSamplingConfigurationInfoParamsSize
 CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are
 available in the structure. Used to preserve backward compatibility.*/
    pub size: usize,
    /// [w] Assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [w] CUcontext
    pub ctx: CUcontext,
    /** [w] Number of attributes to configure using \ref cuptiPCSamplingSetConfigurationAttribute or query
 using \ref cuptiPCSamplingGetConfigurationAttribute*/
    pub numAttributes: usize,
    /// Refer \ref CUpti_PCSamplingConfigurationInfo
    pub pPCSamplingConfigurationInfo: *mut CUpti_PCSamplingConfigurationInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PCSamplingConfigurationInfoParams",
    ][::std::mem::size_of::<CUpti_PCSamplingConfigurationInfoParams>() - 40usize];
    [
        "Alignment of CUpti_PCSamplingConfigurationInfoParams",
    ][::std::mem::align_of::<CUpti_PCSamplingConfigurationInfoParams>() - 8usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfoParams::size",
    ][::std::mem::offset_of!(CUpti_PCSamplingConfigurationInfoParams, size) - 0usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfoParams::pPriv",
    ][::std::mem::offset_of!(CUpti_PCSamplingConfigurationInfoParams, pPriv) - 8usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfoParams::ctx",
    ][::std::mem::offset_of!(CUpti_PCSamplingConfigurationInfoParams, ctx) - 16usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfoParams::numAttributes",
    ][::std::mem::offset_of!(CUpti_PCSamplingConfigurationInfoParams, numAttributes)
        - 24usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfoParams::pPCSamplingConfigurationInfo",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfoParams, pPCSamplingConfigurationInfo
    ) - 32usize];
};
impl Default for CUpti_PCSamplingConfigurationInfoParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Write PC Sampling configuration attribute.

 \param pParams A pointer to \ref CUpti_PCSamplingConfigurationInfoParams
 containing PC sampling configuration.

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_OPERATION if this API is called with
 some invalid \p attrib.
 \retval CUPTI_ERROR_INVALID_PARAMETER if attribute \p value is not valid
 or any \p pParams is not valid
 \retval CUPTI_ERROR_NOT_SUPPORTED indicates that the system/device
 does not support the API*/
    pub fn cuptiPCSamplingSetConfigurationAttribute(
        pParams: *mut CUpti_PCSamplingConfigurationInfoParams,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Read PC Sampling configuration attribute.

 \param pParams A pointer to \ref CUpti_PCSamplingConfigurationInfoParams
 containing PC sampling configuration.

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_OPERATION if this API is called with
 some invalid attribute.
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p attrib is not valid
 or any \p pParams is not valid
 \retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT indicates that
 the \p value buffer is too small to hold the attribute value
 \retval CUPTI_ERROR_NOT_SUPPORTED indicates that the system/device
 does not support the API*/
    pub fn cuptiPCSamplingGetConfigurationAttribute(
        pParams: *mut CUpti_PCSamplingConfigurationInfoParams,
    ) -> CUptiResult;
}
/// \brief Params for cuptiPCSamplingEnable
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingGetDataParams {
    /** [w] Size of the data structure i.e. CUpti_PCSamplingGetDataParamsSize
 CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are
 available in the structure. Used to preserve backward compatibility.*/
    pub size: usize,
    /// [w] Assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [w] CUcontext
    pub ctx: CUcontext,
    /** \param pcSamplingData Data buffer to hold collected PC Sampling data PARSED_DATA
 Buffer type is void * which can point to PARSED_DATA
 Refer \ref CUpti_PCSamplingData for buffer format for PARSED_DATA*/
    pub pcSamplingData: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PCSamplingGetDataParams",
    ][::std::mem::size_of::<CUpti_PCSamplingGetDataParams>() - 32usize];
    [
        "Alignment of CUpti_PCSamplingGetDataParams",
    ][::std::mem::align_of::<CUpti_PCSamplingGetDataParams>() - 8usize];
    [
        "Offset of field: CUpti_PCSamplingGetDataParams::size",
    ][::std::mem::offset_of!(CUpti_PCSamplingGetDataParams, size) - 0usize];
    [
        "Offset of field: CUpti_PCSamplingGetDataParams::pPriv",
    ][::std::mem::offset_of!(CUpti_PCSamplingGetDataParams, pPriv) - 8usize];
    [
        "Offset of field: CUpti_PCSamplingGetDataParams::ctx",
    ][::std::mem::offset_of!(CUpti_PCSamplingGetDataParams, ctx) - 16usize];
    [
        "Offset of field: CUpti_PCSamplingGetDataParams::pcSamplingData",
    ][::std::mem::offset_of!(CUpti_PCSamplingGetDataParams, pcSamplingData) - 24usize];
};
impl Default for CUpti_PCSamplingGetDataParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Flush GPU PC sampling data periodically.

 Flushing of GPU PC Sampling data is required at following point to maintain uniqueness of PCs:
 For \brief CUPTI_PC_SAMPLING_COLLECTION_MODE_CONTINUOUS, after every module load-unload-load
 For \brief CUPTI_PC_SAMPLING_COLLECTION_MODE_KERNEL_SERIALIZED, after every kernel ends
 If configuration option \brief CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_ENABLE_START_STOP_CONTROL
 is enabled, then after every range end i.e. \brief cuptiPCSamplingStop()

 If application is profiled in \brief CUPTI_PC_SAMPLING_COLLECTION_MODE_CONTINUOUS, with disabled
 \brief CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_ENABLE_START_STOP_CONTROL, and there is no module unload,
 user can collect data in two ways:
 Use \brief cuptiPCSamplingGetData() API periodically
 Use \brief cuptiPCSamplingDisable() on application exit and read GPU PC sampling data from sampling
 data buffer passed during configuration.
 Note: In case, \brief cuptiPCSamplingGetData() API is not called periodically, then sampling data buffer
 passed during configuration should be large enough to hold all PCs data.
       \brief cuptiPCSamplingGetData() API never does device synchronization.
       It is possible that when the API is called there is some unconsumed data from the HW buffer. In this case
 CUPTI provides only the data available with it at that moment.

 \param pParams A pointer to \ref CUpti_PCSamplingGetDataParams

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_OPERATION if this API is called without
 enabling PC sampling.
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_NOT_SUPPORTED indicates that the system/device
 \retval CUPTI_ERROR_OUT_OF_MEMORY indicates that the HW buffer is full
 does not support the API*/
    pub fn cuptiPCSamplingGetData(
        pParams: *mut CUpti_PCSamplingGetDataParams,
    ) -> CUptiResult;
}
/// \brief Params for cuptiPCSamplingEnable
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingEnableParams {
    /** [w] Size of the data structure i.e. CUpti_PCSamplingEnableParamsSize
 CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are
 available in the structure. Used to preserve backward compatibility.*/
    pub size: usize,
    /// [w] Assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [w] CUcontext
    pub ctx: CUcontext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PCSamplingEnableParams",
    ][::std::mem::size_of::<CUpti_PCSamplingEnableParams>() - 24usize];
    [
        "Alignment of CUpti_PCSamplingEnableParams",
    ][::std::mem::align_of::<CUpti_PCSamplingEnableParams>() - 8usize];
    [
        "Offset of field: CUpti_PCSamplingEnableParams::size",
    ][::std::mem::offset_of!(CUpti_PCSamplingEnableParams, size) - 0usize];
    [
        "Offset of field: CUpti_PCSamplingEnableParams::pPriv",
    ][::std::mem::offset_of!(CUpti_PCSamplingEnableParams, pPriv) - 8usize];
    [
        "Offset of field: CUpti_PCSamplingEnableParams::ctx",
    ][::std::mem::offset_of!(CUpti_PCSamplingEnableParams, ctx) - 16usize];
};
impl Default for CUpti_PCSamplingEnableParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Enable PC sampling.

 \param pParams A pointer to \ref CUpti_PCSamplingEnableParams

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_NOT_SUPPORTED indicates that the system/device
 does not support the API*/
    pub fn cuptiPCSamplingEnable(
        pParams: *mut CUpti_PCSamplingEnableParams,
    ) -> CUptiResult;
}
/// \brief Params for cuptiPCSamplingDisable
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingDisableParams {
    /** [w] Size of the data structure i.e. CUpti_PCSamplingDisableParamsSize
 CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are
 available in the structure. Used to preserve backward compatibility.*/
    pub size: usize,
    /// [w] Assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [w] CUcontext
    pub ctx: CUcontext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PCSamplingDisableParams",
    ][::std::mem::size_of::<CUpti_PCSamplingDisableParams>() - 24usize];
    [
        "Alignment of CUpti_PCSamplingDisableParams",
    ][::std::mem::align_of::<CUpti_PCSamplingDisableParams>() - 8usize];
    [
        "Offset of field: CUpti_PCSamplingDisableParams::size",
    ][::std::mem::offset_of!(CUpti_PCSamplingDisableParams, size) - 0usize];
    [
        "Offset of field: CUpti_PCSamplingDisableParams::pPriv",
    ][::std::mem::offset_of!(CUpti_PCSamplingDisableParams, pPriv) - 8usize];
    [
        "Offset of field: CUpti_PCSamplingDisableParams::ctx",
    ][::std::mem::offset_of!(CUpti_PCSamplingDisableParams, ctx) - 16usize];
};
impl Default for CUpti_PCSamplingDisableParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Disable PC sampling.

 For application which doesn't destroy the CUDA context explicitly,
 this API does the PC Sampling tear-down, joins threads and copies PC records in the buffer provided
 during the PC sampling configuration. PC records which can't be accommodated in the buffer are discarded.

 \param pParams A pointer to \ref CUpti_PCSamplingDisableParams

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_NOT_SUPPORTED indicates that the system/device
 does not support the API*/
    pub fn cuptiPCSamplingDisable(
        pParams: *mut CUpti_PCSamplingDisableParams,
    ) -> CUptiResult;
}
/// \brief Params for cuptiPCSamplingStart
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingStartParams {
    /** [w] Size of the data structure i.e. CUpti_PCSamplingStartParamsSize
 CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are
 available in the structure. Used to preserve backward compatibility.*/
    pub size: usize,
    /// [w] Assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [w] CUcontext
    pub ctx: CUcontext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PCSamplingStartParams",
    ][::std::mem::size_of::<CUpti_PCSamplingStartParams>() - 24usize];
    [
        "Alignment of CUpti_PCSamplingStartParams",
    ][::std::mem::align_of::<CUpti_PCSamplingStartParams>() - 8usize];
    [
        "Offset of field: CUpti_PCSamplingStartParams::size",
    ][::std::mem::offset_of!(CUpti_PCSamplingStartParams, size) - 0usize];
    [
        "Offset of field: CUpti_PCSamplingStartParams::pPriv",
    ][::std::mem::offset_of!(CUpti_PCSamplingStartParams, pPriv) - 8usize];
    [
        "Offset of field: CUpti_PCSamplingStartParams::ctx",
    ][::std::mem::offset_of!(CUpti_PCSamplingStartParams, ctx) - 16usize];
};
impl Default for CUpti_PCSamplingStartParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Start PC sampling.

 User can collect PC Sampling data for user-defined range specified by Start/Stop APIs.
 This API can be used to mark starting of range. Set configuration option
 \brief CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_ENABLE_START_STOP_CONTROL to use this API.

 \param pParams A pointer to \ref CUpti_PCSamplingStartParams

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_OPERATION if this API is called with
 incorrect PC Sampling configuration.
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_NOT_SUPPORTED indicates that the system/device
 does not support the API*/
    pub fn cuptiPCSamplingStart(
        pParams: *mut CUpti_PCSamplingStartParams,
    ) -> CUptiResult;
}
/// \brief Params for cuptiPCSamplingStop
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingStopParams {
    /** [w] Size of the data structure i.e. CUpti_PCSamplingStopParamsSize
 CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are
 available in the structure. Used to preserve backward compatibility.*/
    pub size: usize,
    /// [w] Assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [w] CUcontext
    pub ctx: CUcontext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PCSamplingStopParams",
    ][::std::mem::size_of::<CUpti_PCSamplingStopParams>() - 24usize];
    [
        "Alignment of CUpti_PCSamplingStopParams",
    ][::std::mem::align_of::<CUpti_PCSamplingStopParams>() - 8usize];
    [
        "Offset of field: CUpti_PCSamplingStopParams::size",
    ][::std::mem::offset_of!(CUpti_PCSamplingStopParams, size) - 0usize];
    [
        "Offset of field: CUpti_PCSamplingStopParams::pPriv",
    ][::std::mem::offset_of!(CUpti_PCSamplingStopParams, pPriv) - 8usize];
    [
        "Offset of field: CUpti_PCSamplingStopParams::ctx",
    ][::std::mem::offset_of!(CUpti_PCSamplingStopParams, ctx) - 16usize];
};
impl Default for CUpti_PCSamplingStopParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Stop PC sampling.

 User can collect PC Sampling data for user-defined range specified by Start/Stop APIs.
 This API can be used to mark end of range. Set configuration option
 \brief CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_ENABLE_START_STOP_CONTROL to use this API.

 \param pParams A pointer to \ref CUpti_PCSamplingStopParams

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_OPERATION if this API is called with
 incorrect PC Sampling configuration.
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_NOT_SUPPORTED indicates that the system/device
 does not support the API*/
    pub fn cuptiPCSamplingStop(pParams: *mut CUpti_PCSamplingStopParams) -> CUptiResult;
}
/// \brief Params for cuptiPCSamplingGetNumStallReasons
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingGetNumStallReasonsParams {
    /** [w] Size of the data structure i.e. CUpti_PCSamplingGetNumStallReasonsParamsSize
 CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are
 available in the structure. Used to preserve backward compatibility.*/
    pub size: usize,
    /// [w] Assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [w] CUcontext
    pub ctx: CUcontext,
    /// [r] Number of stall reasons
    pub numStallReasons: *mut usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PCSamplingGetNumStallReasonsParams",
    ][::std::mem::size_of::<CUpti_PCSamplingGetNumStallReasonsParams>() - 32usize];
    [
        "Alignment of CUpti_PCSamplingGetNumStallReasonsParams",
    ][::std::mem::align_of::<CUpti_PCSamplingGetNumStallReasonsParams>() - 8usize];
    [
        "Offset of field: CUpti_PCSamplingGetNumStallReasonsParams::size",
    ][::std::mem::offset_of!(CUpti_PCSamplingGetNumStallReasonsParams, size) - 0usize];
    [
        "Offset of field: CUpti_PCSamplingGetNumStallReasonsParams::pPriv",
    ][::std::mem::offset_of!(CUpti_PCSamplingGetNumStallReasonsParams, pPriv) - 8usize];
    [
        "Offset of field: CUpti_PCSamplingGetNumStallReasonsParams::ctx",
    ][::std::mem::offset_of!(CUpti_PCSamplingGetNumStallReasonsParams, ctx) - 16usize];
    [
        "Offset of field: CUpti_PCSamplingGetNumStallReasonsParams::numStallReasons",
    ][::std::mem::offset_of!(CUpti_PCSamplingGetNumStallReasonsParams, numStallReasons)
        - 24usize];
};
impl Default for CUpti_PCSamplingGetNumStallReasonsParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Get PC sampling stall reason count.

 \param pParams A pointer to \ref CUpti_PCSamplingGetNumStallReasonsParams

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_NOT_SUPPORTED indicates that the system/device
 does not support the API*/
    pub fn cuptiPCSamplingGetNumStallReasons(
        pParams: *mut CUpti_PCSamplingGetNumStallReasonsParams,
    ) -> CUptiResult;
}
/// \brief Params for cuptiPCSamplingGetStallReasons
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingGetStallReasonsParams {
    /** [w] Size of the data structure i.e. CUpti_PCSamplingGetStallReasonsParamsSize
 CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are
 available in the structure. Used to preserve backward compatibility.*/
    pub size: usize,
    /// [w] Assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [w] CUcontext
    pub ctx: CUcontext,
    /// [w] Number of stall reasons
    pub numStallReasons: usize,
    /// [r] Stall reason index
    pub stallReasonIndex: *mut u32,
    /// [r] Stall reasons name
    pub stallReasons: *mut *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PCSamplingGetStallReasonsParams",
    ][::std::mem::size_of::<CUpti_PCSamplingGetStallReasonsParams>() - 48usize];
    [
        "Alignment of CUpti_PCSamplingGetStallReasonsParams",
    ][::std::mem::align_of::<CUpti_PCSamplingGetStallReasonsParams>() - 8usize];
    [
        "Offset of field: CUpti_PCSamplingGetStallReasonsParams::size",
    ][::std::mem::offset_of!(CUpti_PCSamplingGetStallReasonsParams, size) - 0usize];
    [
        "Offset of field: CUpti_PCSamplingGetStallReasonsParams::pPriv",
    ][::std::mem::offset_of!(CUpti_PCSamplingGetStallReasonsParams, pPriv) - 8usize];
    [
        "Offset of field: CUpti_PCSamplingGetStallReasonsParams::ctx",
    ][::std::mem::offset_of!(CUpti_PCSamplingGetStallReasonsParams, ctx) - 16usize];
    [
        "Offset of field: CUpti_PCSamplingGetStallReasonsParams::numStallReasons",
    ][::std::mem::offset_of!(CUpti_PCSamplingGetStallReasonsParams, numStallReasons)
        - 24usize];
    [
        "Offset of field: CUpti_PCSamplingGetStallReasonsParams::stallReasonIndex",
    ][::std::mem::offset_of!(CUpti_PCSamplingGetStallReasonsParams, stallReasonIndex)
        - 32usize];
    [
        "Offset of field: CUpti_PCSamplingGetStallReasonsParams::stallReasons",
    ][::std::mem::offset_of!(CUpti_PCSamplingGetStallReasonsParams, stallReasons)
        - 40usize];
};
impl Default for CUpti_PCSamplingGetStallReasonsParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Get PC sampling stall reasons.

 \param pParams A pointer to \ref CUpti_PCSamplingGetStallReasonsParams

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_NOT_SUPPORTED indicates that the system/device
 does not support the API*/
    pub fn cuptiPCSamplingGetStallReasons(
        pParams: *mut CUpti_PCSamplingGetStallReasonsParams,
    ) -> CUptiResult;
}
/// \brief Params for cuptiGetSassToSourceCorrelation
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_GetSassToSourceCorrelationParams {
    /** [w] Size of the data structure i.e. CUpti_GetSassToSourceCorrelationParamsSize
 CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are
 available in the structure. Used to preserve backward compatibility.*/
    pub size: usize,
    /// [w] Pointer to cubin binary where function belongs.
    pub cubin: *const ::std::os::raw::c_void,
    /// [w] Function name to which PC belongs.
    pub functionName: *const ::std::os::raw::c_char,
    /// [w] Size of cubin binary.
    pub cubinSize: usize,
    /// [r] Line number in the source code.
    pub lineNumber: u32,
    /// [w] PC offset
    pub pcOffset: u64,
    /// [r] Path for the source file.
    pub fileName: *mut ::std::os::raw::c_char,
    /// [r] Path for the directory of source file.
    pub dirName: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_GetSassToSourceCorrelationParams",
    ][::std::mem::size_of::<CUpti_GetSassToSourceCorrelationParams>() - 64usize];
    [
        "Alignment of CUpti_GetSassToSourceCorrelationParams",
    ][::std::mem::align_of::<CUpti_GetSassToSourceCorrelationParams>() - 8usize];
    [
        "Offset of field: CUpti_GetSassToSourceCorrelationParams::size",
    ][::std::mem::offset_of!(CUpti_GetSassToSourceCorrelationParams, size) - 0usize];
    [
        "Offset of field: CUpti_GetSassToSourceCorrelationParams::cubin",
    ][::std::mem::offset_of!(CUpti_GetSassToSourceCorrelationParams, cubin) - 8usize];
    [
        "Offset of field: CUpti_GetSassToSourceCorrelationParams::functionName",
    ][::std::mem::offset_of!(CUpti_GetSassToSourceCorrelationParams, functionName)
        - 16usize];
    [
        "Offset of field: CUpti_GetSassToSourceCorrelationParams::cubinSize",
    ][::std::mem::offset_of!(CUpti_GetSassToSourceCorrelationParams, cubinSize)
        - 24usize];
    [
        "Offset of field: CUpti_GetSassToSourceCorrelationParams::lineNumber",
    ][::std::mem::offset_of!(CUpti_GetSassToSourceCorrelationParams, lineNumber)
        - 32usize];
    [
        "Offset of field: CUpti_GetSassToSourceCorrelationParams::pcOffset",
    ][::std::mem::offset_of!(CUpti_GetSassToSourceCorrelationParams, pcOffset)
        - 40usize];
    [
        "Offset of field: CUpti_GetSassToSourceCorrelationParams::fileName",
    ][::std::mem::offset_of!(CUpti_GetSassToSourceCorrelationParams, fileName)
        - 48usize];
    [
        "Offset of field: CUpti_GetSassToSourceCorrelationParams::dirName",
    ][::std::mem::offset_of!(CUpti_GetSassToSourceCorrelationParams, dirName) - 56usize];
};
impl Default for CUpti_GetSassToSourceCorrelationParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief SASS to Source correlation.

 \param pParams A pointer to \ref CUpti_GetSassToSourceCorrelationParams

 It is expected from user to free allocated memory for fileName and dirName after use.

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if either of the parameters cubin or functionName
 is NULL or cubinSize is zero or size field is not set correctly.
 \retval CUPTI_ERROR_INVALID_MODULE provided cubin is invalid.
 \retval CUPTI_ERROR_UNKNOWN an internal error occurred.
 This error code is also used for cases when the function is not present in the module.
 A better error code will be returned in the future release.*/
    pub fn cuptiGetSassToSourceCorrelation(
        pParams: *mut CUpti_GetSassToSourceCorrelationParams,
    ) -> CUptiResult;
}
/// \brief Params for cuptiGetCubinCrc
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_GetCubinCrcParams {
    /** [w] Size of configuration structure.
 CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are
 available in the structure. Used to preserve backward compatibility.*/
    pub size: usize,
    /// [w] Size of cubin binary.
    pub cubinSize: usize,
    /// [w] Pointer to cubin binary
    pub cubin: *const ::std::os::raw::c_void,
    /// [r] Computed CRC will be stored in it.
    pub cubinCrc: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_GetCubinCrcParams",
    ][::std::mem::size_of::<CUpti_GetCubinCrcParams>() - 32usize];
    [
        "Alignment of CUpti_GetCubinCrcParams",
    ][::std::mem::align_of::<CUpti_GetCubinCrcParams>() - 8usize];
    [
        "Offset of field: CUpti_GetCubinCrcParams::size",
    ][::std::mem::offset_of!(CUpti_GetCubinCrcParams, size) - 0usize];
    [
        "Offset of field: CUpti_GetCubinCrcParams::cubinSize",
    ][::std::mem::offset_of!(CUpti_GetCubinCrcParams, cubinSize) - 8usize];
    [
        "Offset of field: CUpti_GetCubinCrcParams::cubin",
    ][::std::mem::offset_of!(CUpti_GetCubinCrcParams, cubin) - 16usize];
    [
        "Offset of field: CUpti_GetCubinCrcParams::cubinCrc",
    ][::std::mem::offset_of!(CUpti_GetCubinCrcParams, cubinCrc) - 24usize];
};
impl Default for CUpti_GetCubinCrcParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Get the CRC of cubin.

 This function returns the CRC of provided cubin binary.

 \param pParams A pointer to \ref CUpti_GetCubinCrcParams

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if parameter cubin is NULL or
 provided cubinSize is zero or size field is not set.*/
    pub fn cuptiGetCubinCrc(pParams: *mut CUpti_GetCubinCrcParams) -> CUptiResult;
}
/** \brief Function type for callback used by CUPTI to request crc of
 loaded module.

 This callback function ask for crc of provided module in function.
 The provided crc will be stored in PC sampling records i.e. in the field 'cubinCrc' of the PC sampling
 struct CUpti_PCSamplingPCData. The CRC is uses during the offline source correlation to uniquely identify the module.

 \param cubin The pointer to cubin binary
 \param cubinSize The size of cubin binary.
 \param cubinCrc Returns the computed crc of cubin.*/
pub type CUpti_ComputeCrcCallbackFunc = ::std::option::Option<
    unsafe extern "C" fn(
        cubin: *const ::std::os::raw::c_void,
        cubinSize: usize,
        cubinCrc: *mut u64,
    ),
>;
unsafe extern "C" {
    /** \brief Register callback function with CUPTI to use
 your own algorithm to compute cubin crc.

 This function registers a callback function and it gets called
 from CUPTI when a CUDA module is loaded.

 \param funcComputeCubinCrc callback is invoked when a CUDA module
 is loaded.

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if \p funcComputeCubinCrc is NULL.*/
    pub fn cuptiRegisterComputeCrcCallback(
        funcComputeCubinCrc: CUpti_ComputeCrcCallbackFunc,
    ) -> CUptiResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_Object {
    _unused: [u8; 0],
}
/** The trigger is based off of the SYSCLK frequency, note SYS frequency by default is variable.
 the sample interval (set in the struct CUpti_PmSampling_SetConfig_Params) is in terms of clocks.*/
pub const CUPTI_PM_SAMPLING_TRIGGER_MODE_GPU_SYSCLK_INTERVAL: CUpti_PmSampling_TriggerMode = 0;
/** The trigger is based off of a fixed frequency source.
 The sample interval (set in the struct CUpti_PmSampling_SetConfig_Params) is in terms of nanoseconds.
 Note: This trigger mode is not supported on Turing GPU architecture and GA100 GPU.
 It is supported on Ampere GA10x and later GPU architectures.*/
pub const CUPTI_PM_SAMPLING_TRIGGER_MODE_GPU_TIME_INTERVAL: CUpti_PmSampling_TriggerMode = 1;
/** The trigger is based off of a fixed frequency source.
 The sample interval (set in the struct CUpti_PmSampling_SetConfig_Params) is in terms of nanoseconds.
 Note: This trigger mode is not supported on Turing GPU architecture and GA100 GPU.
 It is supported on Ampere GA10x and later GPU architectures.*/
pub const CUPTI_PM_SAMPLING_TRIGGER_MODE_COUNT: CUpti_PmSampling_TriggerMode = 2;
pub type CUpti_PmSampling_TriggerMode = ::std::os::raw::c_uint;
pub const CUPTI_PM_SAMPLING_DECODE_STOP_REASON_OTHER: CUpti_PmSampling_DecodeStopReason = 0;
/// Counter data image is full.
pub const CUPTI_PM_SAMPLING_DECODE_STOP_REASON_COUNTER_DATA_FULL: CUpti_PmSampling_DecodeStopReason = 1;
/// All the records in the hardware buffer is decoded.
pub const CUPTI_PM_SAMPLING_DECODE_STOP_REASON_END_OF_RECORDS: CUpti_PmSampling_DecodeStopReason = 2;
/// All the records in the hardware buffer is decoded.
pub const CUPTI_PM_SAMPLING_DECODE_STOP_REASON_COUNT: CUpti_PmSampling_DecodeStopReason = 3;
pub type CUpti_PmSampling_DecodeStopReason = ::std::os::raw::c_uint;
/** Keep the oldest records in the hardware buffer.
 CUPTI will report error for overflow in case hardware buffer is getting filled up.*/
pub const CUPTI_PM_SAMPLING_HARDWARE_BUFFER_APPEND_MODE_KEEP_OLDEST: CUpti_PmSampling_HardwareBuffer_AppendMode = 0;
/** Keep the latest records in the hardware buffer.
 Note: This mode is not supported on Turing GPU architecture.
 It is supported on Ampere and later GPU architectures.*/
pub const CUPTI_PM_SAMPLING_HARDWARE_BUFFER_APPEND_MODE_KEEP_LATEST: CUpti_PmSampling_HardwareBuffer_AppendMode = 1;
pub type CUpti_PmSampling_HardwareBuffer_AppendMode = ::std::os::raw::c_uint;
/// \brief Params for cuptiPmSamplingSetConfig
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_SetConfig_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Set to NULL.
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] PM sampling object.
    pub pPmSamplingObject: *mut CUpti_PmSampling_Object,
    /// [in] Size of the config image.
    pub configSize: usize,
    /// [in] Config image.
    pub pConfig: *const u8,
    /** [in] The hardware buffer size in which raw PM sampling data
 will be stored. These samples will be decoded to counter data
 image with \ref cuptiPmSamplingDecodeData call.*/
    pub hardwareBufferSize: usize,
    /** [in] For the trigger mode `CUPTI_PM_SAMPLING_TRIGGER_MODE_GPU_SYSCLK_INTERVAL`, sampling interval
 is the number of sys clock cycles. For the trigger mode `CUPTI_PM_SAMPLING_TRIGGER_MODE_GPU_TIME_INTERVAL`,
 sampling interval is in nanoseconds.*/
    pub samplingInterval: u64,
    /** [in] Trigger mode.
 Note: CUPTI_PM_SAMPLING_TRIGGER_MODE_GPU_TIME_INTERVAL is not supported in Turing and GA100.
 Supported from GA10x onwards.*/
    pub triggerMode: CUpti_PmSampling_TriggerMode,
    /** [in] Append mode for the records in hardware buffer.
 For KEEP_OLDEST mode, all the records will be kept in the buffer and in case hardware buffer is getting filled up.
 overflow will be set to 1 in \ref CUpti_PmSampling_DecodeData_Params. For KEEP_LATEST mode, the new records will
 overwrite the oldest records in the buffer in case of filled buffer.*/
    pub hwBufferAppendMode: CUpti_PmSampling_HardwareBuffer_AppendMode,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PmSampling_SetConfig_Params",
    ][::std::mem::size_of::<CUpti_PmSampling_SetConfig_Params>() - 64usize];
    [
        "Alignment of CUpti_PmSampling_SetConfig_Params",
    ][::std::mem::align_of::<CUpti_PmSampling_SetConfig_Params>() - 8usize];
    [
        "Offset of field: CUpti_PmSampling_SetConfig_Params::structSize",
    ][::std::mem::offset_of!(CUpti_PmSampling_SetConfig_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_PmSampling_SetConfig_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_PmSampling_SetConfig_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_PmSampling_SetConfig_Params::pPmSamplingObject",
    ][::std::mem::offset_of!(CUpti_PmSampling_SetConfig_Params, pPmSamplingObject)
        - 16usize];
    [
        "Offset of field: CUpti_PmSampling_SetConfig_Params::configSize",
    ][::std::mem::offset_of!(CUpti_PmSampling_SetConfig_Params, configSize) - 24usize];
    [
        "Offset of field: CUpti_PmSampling_SetConfig_Params::pConfig",
    ][::std::mem::offset_of!(CUpti_PmSampling_SetConfig_Params, pConfig) - 32usize];
    [
        "Offset of field: CUpti_PmSampling_SetConfig_Params::hardwareBufferSize",
    ][::std::mem::offset_of!(CUpti_PmSampling_SetConfig_Params, hardwareBufferSize)
        - 40usize];
    [
        "Offset of field: CUpti_PmSampling_SetConfig_Params::samplingInterval",
    ][::std::mem::offset_of!(CUpti_PmSampling_SetConfig_Params, samplingInterval)
        - 48usize];
    [
        "Offset of field: CUpti_PmSampling_SetConfig_Params::triggerMode",
    ][::std::mem::offset_of!(CUpti_PmSampling_SetConfig_Params, triggerMode) - 56usize];
    [
        "Offset of field: CUpti_PmSampling_SetConfig_Params::hwBufferAppendMode",
    ][::std::mem::offset_of!(CUpti_PmSampling_SetConfig_Params, hwBufferAppendMode)
        - 60usize];
};
impl Default for CUpti_PmSampling_SetConfig_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Set the configuration for PM sampling like sampling interval, maximum number of samples
 filled in HW buffer, trigger mode and the config image which has scheduling info for metric collection.

 \param pParams A pointer to \ref CUpti_PmSampling_SetConfig_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_NOT_SUPPORTED for config image which require multiple passes for data collection*/
    pub fn cuptiPmSamplingSetConfig(
        pParams: *mut CUpti_PmSampling_SetConfig_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiPmSamplingEnable
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_Enable_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Set to NULL.
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] Device index.
    pub deviceIndex: usize,
    /// [out] PM sampling object.
    pub pPmSamplingObject: *mut CUpti_PmSampling_Object,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PmSampling_Enable_Params",
    ][::std::mem::size_of::<CUpti_PmSampling_Enable_Params>() - 32usize];
    [
        "Alignment of CUpti_PmSampling_Enable_Params",
    ][::std::mem::align_of::<CUpti_PmSampling_Enable_Params>() - 8usize];
    [
        "Offset of field: CUpti_PmSampling_Enable_Params::structSize",
    ][::std::mem::offset_of!(CUpti_PmSampling_Enable_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_PmSampling_Enable_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_PmSampling_Enable_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_PmSampling_Enable_Params::deviceIndex",
    ][::std::mem::offset_of!(CUpti_PmSampling_Enable_Params, deviceIndex) - 16usize];
    [
        "Offset of field: CUpti_PmSampling_Enable_Params::pPmSamplingObject",
    ][::std::mem::offset_of!(CUpti_PmSampling_Enable_Params, pPmSamplingObject)
        - 24usize];
};
impl Default for CUpti_PmSampling_Enable_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Create a PM sampling object and enable PM sampling on the CUDA device.

 \param pParams A pointer to \ref CUpti_PmSampling_Enable_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_OUT_OF_MEMORY if memory allocation fails while creating the PM sampling object
 \retval CUPTI_ERROR_INVALID_OPERATION if PM sampling is already enabled on the device
 \retval CUPTI_ERROR_INSUFFICIENT_PRIVILEGES if the user does not have sufficient privileges to perform the operation
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiPmSamplingEnable(
        pParams: *mut CUpti_PmSampling_Enable_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiPmSamplingDisable
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_Disable_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Set to NULL.
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] PM sampling object.
    pub pPmSamplingObject: *mut CUpti_PmSampling_Object,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PmSampling_Disable_Params",
    ][::std::mem::size_of::<CUpti_PmSampling_Disable_Params>() - 24usize];
    [
        "Alignment of CUpti_PmSampling_Disable_Params",
    ][::std::mem::align_of::<CUpti_PmSampling_Disable_Params>() - 8usize];
    [
        "Offset of field: CUpti_PmSampling_Disable_Params::structSize",
    ][::std::mem::offset_of!(CUpti_PmSampling_Disable_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_PmSampling_Disable_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_PmSampling_Disable_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_PmSampling_Disable_Params::pPmSamplingObject",
    ][::std::mem::offset_of!(CUpti_PmSampling_Disable_Params, pPmSamplingObject)
        - 16usize];
};
impl Default for CUpti_PmSampling_Disable_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Disable PM sampling on the CUDA device and destroy the PM sampling object.

 \param pParams A pointer to \ref CUpti_PmSampling_Disable_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiPmSamplingDisable(
        pParams: *mut CUpti_PmSampling_Disable_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiPmSamplingStart
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_Start_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Set to NULL.
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] PM sampling object.
    pub pPmSamplingObject: *mut CUpti_PmSampling_Object,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PmSampling_Start_Params",
    ][::std::mem::size_of::<CUpti_PmSampling_Start_Params>() - 24usize];
    [
        "Alignment of CUpti_PmSampling_Start_Params",
    ][::std::mem::align_of::<CUpti_PmSampling_Start_Params>() - 8usize];
    [
        "Offset of field: CUpti_PmSampling_Start_Params::structSize",
    ][::std::mem::offset_of!(CUpti_PmSampling_Start_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_PmSampling_Start_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_PmSampling_Start_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_PmSampling_Start_Params::pPmSamplingObject",
    ][::std::mem::offset_of!(CUpti_PmSampling_Start_Params, pPmSamplingObject)
        - 16usize];
};
impl Default for CUpti_PmSampling_Start_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Start the PM sampling. The GPU will start collecting the metrics data
 periodically based on trigger type and sampling interval passed in CUpti_PmSampling_SetConfig_Params.
 The collected data will be stored in the hardware buffer.

 \param pParams A pointer to \ref CUpti_PmSampling_Start_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_INVALID_OPERATION if PM sampling Start is called without enabling PM sampling,
 and PM sampling is already started
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiPmSamplingStart(
        pParams: *mut CUpti_PmSampling_Start_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiPmSamplingStop
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_Stop_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Set to NULL.
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] PM sampling object.
    pub pPmSamplingObject: *mut CUpti_PmSampling_Object,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PmSampling_Stop_Params",
    ][::std::mem::size_of::<CUpti_PmSampling_Stop_Params>() - 24usize];
    [
        "Alignment of CUpti_PmSampling_Stop_Params",
    ][::std::mem::align_of::<CUpti_PmSampling_Stop_Params>() - 8usize];
    [
        "Offset of field: CUpti_PmSampling_Stop_Params::structSize",
    ][::std::mem::offset_of!(CUpti_PmSampling_Stop_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_PmSampling_Stop_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_PmSampling_Stop_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_PmSampling_Stop_Params::pPmSamplingObject",
    ][::std::mem::offset_of!(CUpti_PmSampling_Stop_Params, pPmSamplingObject) - 16usize];
};
impl Default for CUpti_PmSampling_Stop_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Stop the PM sampling. The GPU will stop collecting the metrics data.

 \param pParams A pointer to \ref CUpti_PmSampling_Stop_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_INVALID_OPERATION if PM sampling Stop is called without enabling PM sampling,
 and PM sampling is already stopped
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiPmSamplingStop(
        pParams: *mut CUpti_PmSampling_Stop_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiPmSamplingDecodeData
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_DecodeData_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Set to NULL.
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] PM sampling object.
    pub pPmSamplingObject: *mut CUpti_PmSampling_Object,
    /// [in] Counter data image.
    pub pCounterDataImage: *mut u8,
    /// [in] Size of the counter data image.
    pub counterDataImageSize: usize,
    /// [out] decode stop reason
    pub decodeStopReason: CUpti_PmSampling_DecodeStopReason,
    /** [out] overflow status for hardware buffer.
 To avoid overflow, either increase the maxSamples values in
 \ref CUpti_PmSampling_SetConfig_Params or reduce the sampling interval.*/
    pub overflow: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PmSampling_DecodeData_Params",
    ][::std::mem::size_of::<CUpti_PmSampling_DecodeData_Params>() - 48usize];
    [
        "Alignment of CUpti_PmSampling_DecodeData_Params",
    ][::std::mem::align_of::<CUpti_PmSampling_DecodeData_Params>() - 8usize];
    [
        "Offset of field: CUpti_PmSampling_DecodeData_Params::structSize",
    ][::std::mem::offset_of!(CUpti_PmSampling_DecodeData_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_PmSampling_DecodeData_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_PmSampling_DecodeData_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_PmSampling_DecodeData_Params::pPmSamplingObject",
    ][::std::mem::offset_of!(CUpti_PmSampling_DecodeData_Params, pPmSamplingObject)
        - 16usize];
    [
        "Offset of field: CUpti_PmSampling_DecodeData_Params::pCounterDataImage",
    ][::std::mem::offset_of!(CUpti_PmSampling_DecodeData_Params, pCounterDataImage)
        - 24usize];
    [
        "Offset of field: CUpti_PmSampling_DecodeData_Params::counterDataImageSize",
    ][::std::mem::offset_of!(CUpti_PmSampling_DecodeData_Params, counterDataImageSize)
        - 32usize];
    [
        "Offset of field: CUpti_PmSampling_DecodeData_Params::decodeStopReason",
    ][::std::mem::offset_of!(CUpti_PmSampling_DecodeData_Params, decodeStopReason)
        - 40usize];
    [
        "Offset of field: CUpti_PmSampling_DecodeData_Params::overflow",
    ][::std::mem::offset_of!(CUpti_PmSampling_DecodeData_Params, overflow) - 44usize];
};
impl Default for CUpti_PmSampling_DecodeData_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Decode the metrics data stored in the hardware buffer to the counter data image.


 \param pParams A pointer to \ref CUpti_PmSampling_DecodeData_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_INVALID_OPERATION if PM sampling DecodeData is called without enabling PM sampling
 \retval CUPTI_ERROR_OUT_OF_MEMORY if there is record overflow in the hardware buffer
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiPmSamplingDecodeData(
        pParams: *mut CUpti_PmSampling_DecodeData_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiPmSamplingGetCounterData
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_GetCounterAvailability_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Set to NULL.
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] Device index.
    pub deviceIndex: usize,
    /** [inout] Size of the counter availability image. When pCounterAvailabilityImage is NULL,
 this field is used to return the size of the counter availability image.*/
    pub counterAvailabilityImageSize: usize,
    /// [out] Counter availability image.
    pub pCounterAvailabilityImage: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PmSampling_GetCounterAvailability_Params",
    ][::std::mem::size_of::<CUpti_PmSampling_GetCounterAvailability_Params>() - 40usize];
    [
        "Alignment of CUpti_PmSampling_GetCounterAvailability_Params",
    ][::std::mem::align_of::<CUpti_PmSampling_GetCounterAvailability_Params>() - 8usize];
    [
        "Offset of field: CUpti_PmSampling_GetCounterAvailability_Params::structSize",
    ][::std::mem::offset_of!(CUpti_PmSampling_GetCounterAvailability_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_PmSampling_GetCounterAvailability_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_PmSampling_GetCounterAvailability_Params, pPriv)
        - 8usize];
    [
        "Offset of field: CUpti_PmSampling_GetCounterAvailability_Params::deviceIndex",
    ][::std::mem::offset_of!(CUpti_PmSampling_GetCounterAvailability_Params, deviceIndex)
        - 16usize];
    [
        "Offset of field: CUpti_PmSampling_GetCounterAvailability_Params::counterAvailabilityImageSize",
    ][::std::mem::offset_of!(
        CUpti_PmSampling_GetCounterAvailability_Params, counterAvailabilityImageSize
    ) - 24usize];
    [
        "Offset of field: CUpti_PmSampling_GetCounterAvailability_Params::pCounterAvailabilityImage",
    ][::std::mem::offset_of!(
        CUpti_PmSampling_GetCounterAvailability_Params, pCounterAvailabilityImage
    ) - 32usize];
};
impl Default for CUpti_PmSampling_GetCounterAvailability_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Query counter availibility information in a buffer which can be used to filter unavailable raw metrics on host.
 Note: This API may fail, if any profiling or sampling session is active on the specified device.

 \param pParams A pointer to \ref CUpti_PmSampling_GetCounterAvailability_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_INSUFFICIENT_PRIVILEGES if the user does not have sufficient privileges to perform the operation
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiPmSamplingGetCounterAvailability(
        pParams: *mut CUpti_PmSampling_GetCounterAvailability_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiPmSamplingGetCounterDataSize
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_GetCounterDataSize_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Set to NULL.
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] PM sampling object.
    pub pPmSamplingObject: *mut CUpti_PmSampling_Object,
    /// [in] Names of the metrics to be collected.
    pub pMetricNames: *mut *const ::std::os::raw::c_char,
    /// [in] Number of metrics to be collected.
    pub numMetrics: usize,
    /// [in] Maximum number of samples to be stored in the counter data image.
    pub maxSamples: u32,
    /// [out] Size of the counter data image.
    pub counterDataSize: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PmSampling_GetCounterDataSize_Params",
    ][::std::mem::size_of::<CUpti_PmSampling_GetCounterDataSize_Params>() - 56usize];
    [
        "Alignment of CUpti_PmSampling_GetCounterDataSize_Params",
    ][::std::mem::align_of::<CUpti_PmSampling_GetCounterDataSize_Params>() - 8usize];
    [
        "Offset of field: CUpti_PmSampling_GetCounterDataSize_Params::structSize",
    ][::std::mem::offset_of!(CUpti_PmSampling_GetCounterDataSize_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_PmSampling_GetCounterDataSize_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_PmSampling_GetCounterDataSize_Params, pPriv)
        - 8usize];
    [
        "Offset of field: CUpti_PmSampling_GetCounterDataSize_Params::pPmSamplingObject",
    ][::std::mem::offset_of!(
        CUpti_PmSampling_GetCounterDataSize_Params, pPmSamplingObject
    ) - 16usize];
    [
        "Offset of field: CUpti_PmSampling_GetCounterDataSize_Params::pMetricNames",
    ][::std::mem::offset_of!(CUpti_PmSampling_GetCounterDataSize_Params, pMetricNames)
        - 24usize];
    [
        "Offset of field: CUpti_PmSampling_GetCounterDataSize_Params::numMetrics",
    ][::std::mem::offset_of!(CUpti_PmSampling_GetCounterDataSize_Params, numMetrics)
        - 32usize];
    [
        "Offset of field: CUpti_PmSampling_GetCounterDataSize_Params::maxSamples",
    ][::std::mem::offset_of!(CUpti_PmSampling_GetCounterDataSize_Params, maxSamples)
        - 40usize];
    [
        "Offset of field: CUpti_PmSampling_GetCounterDataSize_Params::counterDataSize",
    ][::std::mem::offset_of!(CUpti_PmSampling_GetCounterDataSize_Params, counterDataSize)
        - 48usize];
};
impl Default for CUpti_PmSampling_GetCounterDataSize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Query the size of the counter data image which will be used to store the metrics data.
 User need to allocate the memory for the counter data image based on the size returned by this API.

 \param pParams A pointer to \ref CUpti_PmSampling_GetCounterDataSize_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_INVALID_OPERATION if PM sampling GetCounterDataSize is called without enabling PM sampling
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiPmSamplingGetCounterDataSize(
        pParams: *mut CUpti_PmSampling_GetCounterDataSize_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiPmSamplingCounterDataImageInitialize
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_CounterDataImage_Initialize_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Set to NULL.
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] PM sampling object.
    pub pPmSamplingObject: *mut CUpti_PmSampling_Object,
    /// [in] Size of the counter data image.
    pub counterDataSize: usize,
    /// [in] Counter data image.
    pub pCounterData: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PmSampling_CounterDataImage_Initialize_Params",
    ][::std::mem::size_of::<CUpti_PmSampling_CounterDataImage_Initialize_Params>()
        - 40usize];
    [
        "Alignment of CUpti_PmSampling_CounterDataImage_Initialize_Params",
    ][::std::mem::align_of::<CUpti_PmSampling_CounterDataImage_Initialize_Params>()
        - 8usize];
    [
        "Offset of field: CUpti_PmSampling_CounterDataImage_Initialize_Params::structSize",
    ][::std::mem::offset_of!(
        CUpti_PmSampling_CounterDataImage_Initialize_Params, structSize
    ) - 0usize];
    [
        "Offset of field: CUpti_PmSampling_CounterDataImage_Initialize_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_PmSampling_CounterDataImage_Initialize_Params, pPriv)
        - 8usize];
    [
        "Offset of field: CUpti_PmSampling_CounterDataImage_Initialize_Params::pPmSamplingObject",
    ][::std::mem::offset_of!(
        CUpti_PmSampling_CounterDataImage_Initialize_Params, pPmSamplingObject
    ) - 16usize];
    [
        "Offset of field: CUpti_PmSampling_CounterDataImage_Initialize_Params::counterDataSize",
    ][::std::mem::offset_of!(
        CUpti_PmSampling_CounterDataImage_Initialize_Params, counterDataSize
    ) - 24usize];
    [
        "Offset of field: CUpti_PmSampling_CounterDataImage_Initialize_Params::pCounterData",
    ][::std::mem::offset_of!(
        CUpti_PmSampling_CounterDataImage_Initialize_Params, pCounterData
    ) - 32usize];
};
impl Default for CUpti_PmSampling_CounterDataImage_Initialize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Initialize the counter data to CUPTI record format for storing the metric data.

 \param pParams A pointer to \ref CUpti_PmSampling_CounterDataImage_Initialize_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_INVALID_OPERATION if PM sampling CounterDataInitialize is called without enabling PM sampling
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiPmSamplingCounterDataImageInitialize(
        pParams: *mut CUpti_PmSampling_CounterDataImage_Initialize_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiPmSamplingGetCounterDataInfo
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_GetCounterDataInfo_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Set to NULL.
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] Counter data image.
    pub pCounterDataImage: *const u8,
    /// [in] Size of the counter data image.
    pub counterDataImageSize: usize,
    /// [out] Number of samples in the counter data image.
    pub numTotalSamples: usize,
    /// [out] Number of populated samples.
    pub numPopulatedSamples: usize,
    /// [out] Number of samples that have been completed.
    pub numCompletedSamples: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PmSampling_GetCounterDataInfo_Params",
    ][::std::mem::size_of::<CUpti_PmSampling_GetCounterDataInfo_Params>() - 56usize];
    [
        "Alignment of CUpti_PmSampling_GetCounterDataInfo_Params",
    ][::std::mem::align_of::<CUpti_PmSampling_GetCounterDataInfo_Params>() - 8usize];
    [
        "Offset of field: CUpti_PmSampling_GetCounterDataInfo_Params::structSize",
    ][::std::mem::offset_of!(CUpti_PmSampling_GetCounterDataInfo_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_PmSampling_GetCounterDataInfo_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_PmSampling_GetCounterDataInfo_Params, pPriv)
        - 8usize];
    [
        "Offset of field: CUpti_PmSampling_GetCounterDataInfo_Params::pCounterDataImage",
    ][::std::mem::offset_of!(
        CUpti_PmSampling_GetCounterDataInfo_Params, pCounterDataImage
    ) - 16usize];
    [
        "Offset of field: CUpti_PmSampling_GetCounterDataInfo_Params::counterDataImageSize",
    ][::std::mem::offset_of!(
        CUpti_PmSampling_GetCounterDataInfo_Params, counterDataImageSize
    ) - 24usize];
    [
        "Offset of field: CUpti_PmSampling_GetCounterDataInfo_Params::numTotalSamples",
    ][::std::mem::offset_of!(CUpti_PmSampling_GetCounterDataInfo_Params, numTotalSamples)
        - 32usize];
    [
        "Offset of field: CUpti_PmSampling_GetCounterDataInfo_Params::numPopulatedSamples",
    ][::std::mem::offset_of!(
        CUpti_PmSampling_GetCounterDataInfo_Params, numPopulatedSamples
    ) - 40usize];
    [
        "Offset of field: CUpti_PmSampling_GetCounterDataInfo_Params::numCompletedSamples",
    ][::std::mem::offset_of!(
        CUpti_PmSampling_GetCounterDataInfo_Params, numCompletedSamples
    ) - 48usize];
};
impl Default for CUpti_PmSampling_GetCounterDataInfo_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Get the counter data info like number of samples, number of populated
 samples and number of completed samples in a counter data image.

 \param pParams A pointer to \ref CUpti_PmSampling_GetCounterDataInfo_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiPmSamplingGetCounterDataInfo(
        pParams: *mut CUpti_PmSampling_GetCounterDataInfo_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiPmSamplingCounterDataGetSampleInfo
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_CounterData_GetSampleInfo_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Set to NULL.
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] PM sampling object.
    pub pPmSamplingObject: *mut CUpti_PmSampling_Object,
    /// [in] Counter data image.
    pub pCounterDataImage: *const u8,
    /// [in] Size of the counter data image.
    pub counterDataImageSize: usize,
    /// [in] Index of the sample.
    pub sampleIndex: usize,
    /// [out] Start time of the sample.
    pub startTimestamp: u64,
    /// [out] End time of the sample.
    pub endTimestamp: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_PmSampling_CounterData_GetSampleInfo_Params",
    ][::std::mem::size_of::<CUpti_PmSampling_CounterData_GetSampleInfo_Params>()
        - 64usize];
    [
        "Alignment of CUpti_PmSampling_CounterData_GetSampleInfo_Params",
    ][::std::mem::align_of::<CUpti_PmSampling_CounterData_GetSampleInfo_Params>()
        - 8usize];
    [
        "Offset of field: CUpti_PmSampling_CounterData_GetSampleInfo_Params::structSize",
    ][::std::mem::offset_of!(
        CUpti_PmSampling_CounterData_GetSampleInfo_Params, structSize
    ) - 0usize];
    [
        "Offset of field: CUpti_PmSampling_CounterData_GetSampleInfo_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_PmSampling_CounterData_GetSampleInfo_Params, pPriv)
        - 8usize];
    [
        "Offset of field: CUpti_PmSampling_CounterData_GetSampleInfo_Params::pPmSamplingObject",
    ][::std::mem::offset_of!(
        CUpti_PmSampling_CounterData_GetSampleInfo_Params, pPmSamplingObject
    ) - 16usize];
    [
        "Offset of field: CUpti_PmSampling_CounterData_GetSampleInfo_Params::pCounterDataImage",
    ][::std::mem::offset_of!(
        CUpti_PmSampling_CounterData_GetSampleInfo_Params, pCounterDataImage
    ) - 24usize];
    [
        "Offset of field: CUpti_PmSampling_CounterData_GetSampleInfo_Params::counterDataImageSize",
    ][::std::mem::offset_of!(
        CUpti_PmSampling_CounterData_GetSampleInfo_Params, counterDataImageSize
    ) - 32usize];
    [
        "Offset of field: CUpti_PmSampling_CounterData_GetSampleInfo_Params::sampleIndex",
    ][::std::mem::offset_of!(
        CUpti_PmSampling_CounterData_GetSampleInfo_Params, sampleIndex
    ) - 40usize];
    [
        "Offset of field: CUpti_PmSampling_CounterData_GetSampleInfo_Params::startTimestamp",
    ][::std::mem::offset_of!(
        CUpti_PmSampling_CounterData_GetSampleInfo_Params, startTimestamp
    ) - 48usize];
    [
        "Offset of field: CUpti_PmSampling_CounterData_GetSampleInfo_Params::endTimestamp",
    ][::std::mem::offset_of!(
        CUpti_PmSampling_CounterData_GetSampleInfo_Params, endTimestamp
    ) - 56usize];
};
impl Default for CUpti_PmSampling_CounterData_GetSampleInfo_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Get the sample info (start and end time stamp) for the given sample index.
 Each sample is distinguished by the start and end time stamp.

 \param pParams A pointer to \ref CUpti_PmSampling_CounterData_GetSampleInfo_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiPmSamplingCounterDataGetSampleInfo(
        pParams: *mut CUpti_PmSampling_CounterData_GetSampleInfo_Params,
    ) -> CUptiResult;
}
pub const CUPTI_METRIC_TYPE_COUNTER: CUpti_MetricType = 0;
pub const CUPTI_METRIC_TYPE_RATIO: CUpti_MetricType = 1;
pub const CUPTI_METRIC_TYPE_THROUGHPUT: CUpti_MetricType = 2;
pub const CUPTI_METRIC_TYPE__COUNT: CUpti_MetricType = 3;
pub type CUpti_MetricType = ::std::os::raw::c_uint;
pub const CUPTI_PROFILER_TYPE_RANGE_PROFILER: CUpti_ProfilerType = 0;
pub const CUPTI_PROFILER_TYPE_PM_SAMPLING: CUpti_ProfilerType = 1;
pub const CUPTI_PROFILER_TYPE_PROFILER_INVALID: CUpti_ProfilerType = 2;
pub type CUpti_ProfilerType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_Object {
    _unused: [u8; 0],
}
/// \brief Params for cuptiProfilerHostInitialize
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_Initialize_Params {
    /** [in] Size of the data structure.
 CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are
 available in the structure. Used to preserve backward compatibility.*/
    pub structSize: usize,
    /// [in] Assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] the profiler kind one from CUpti_ProfilerType
    pub profilerType: CUpti_ProfilerType,
    /// [in] accepted for chips supported at the time-of-release.
    pub pChipName: *const ::std::os::raw::c_char,
    /// [in] buffer with counter availability image - required for future chip support
    pub pCounterAvailabilityImage: *const u8,
    /// [out] binary blob allocated by CUPTI and operations associated with this object.
    pub pHostObject: *mut CUpti_Profiler_Host_Object,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_Host_Initialize_Params",
    ][::std::mem::size_of::<CUpti_Profiler_Host_Initialize_Params>() - 48usize];
    [
        "Alignment of CUpti_Profiler_Host_Initialize_Params",
    ][::std::mem::align_of::<CUpti_Profiler_Host_Initialize_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_Initialize_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_Initialize_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_Profiler_Host_Initialize_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_Initialize_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_Initialize_Params::profilerType",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_Initialize_Params, profilerType)
        - 16usize];
    [
        "Offset of field: CUpti_Profiler_Host_Initialize_Params::pChipName",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_Initialize_Params, pChipName)
        - 24usize];
    [
        "Offset of field: CUpti_Profiler_Host_Initialize_Params::pCounterAvailabilityImage",
    ][::std::mem::offset_of!(
        CUpti_Profiler_Host_Initialize_Params, pCounterAvailabilityImage
    ) - 32usize];
    [
        "Offset of field: CUpti_Profiler_Host_Initialize_Params::pHostObject",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_Initialize_Params, pHostObject)
        - 40usize];
};
impl Default for CUpti_Profiler_Host_Initialize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Create and initialize the profiler host object (CUpti_Profiler_Host_Object).

 \param pParams A pointer to \ref CUpti_Profiler_Host_Initialize_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiProfilerHostInitialize(
        pParams: *mut CUpti_Profiler_Host_Initialize_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiProfilerHostDeinitialize
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_Deinitialize_Params {
    /** [in] Size of the data structure.
 CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are
 available in the structure. Used to preserve backward compatibility.*/
    pub structSize: usize,
    /// [in] Assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] reference to the profiler host object allocated by CUPTI in cuptiProfilerHostInitialize
    pub pHostObject: *mut CUpti_Profiler_Host_Object,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_Host_Deinitialize_Params",
    ][::std::mem::size_of::<CUpti_Profiler_Host_Deinitialize_Params>() - 24usize];
    [
        "Alignment of CUpti_Profiler_Host_Deinitialize_Params",
    ][::std::mem::align_of::<CUpti_Profiler_Host_Deinitialize_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_Deinitialize_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_Deinitialize_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_Profiler_Host_Deinitialize_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_Deinitialize_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_Deinitialize_Params::pHostObject",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_Deinitialize_Params, pHostObject)
        - 16usize];
};
impl Default for CUpti_Profiler_Host_Deinitialize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Deinitialize and destroy the profiler host object (CUpti_Profiler_Host_Object).

 \param pParams A pointer to \ref CUpti_Profiler_Host_Deinitialize_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiProfilerHostDeinitialize(
        pParams: *mut CUpti_Profiler_Host_Deinitialize_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiProfilerHostGetSupportedChips
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_GetSupportedChips_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [out] number of supported chips
    pub numChips: usize,
    /// [out] list of supported chips
    pub ppChipNames: *const *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_Host_GetSupportedChips_Params",
    ][::std::mem::size_of::<CUpti_Profiler_Host_GetSupportedChips_Params>() - 32usize];
    [
        "Alignment of CUpti_Profiler_Host_GetSupportedChips_Params",
    ][::std::mem::align_of::<CUpti_Profiler_Host_GetSupportedChips_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetSupportedChips_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetSupportedChips_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetSupportedChips_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetSupportedChips_Params, pPriv)
        - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetSupportedChips_Params::numChips",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetSupportedChips_Params, numChips)
        - 16usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetSupportedChips_Params::ppChipNames",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetSupportedChips_Params, ppChipNames)
        - 24usize];
};
impl Default for CUpti_Profiler_Host_GetSupportedChips_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Get the list of supported chips.

 \param pParams A pointer to \ref CUpti_Profiler_Host_GetSupportedChips_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiProfilerHostGetSupportedChips(
        pParams: *mut CUpti_Profiler_Host_GetSupportedChips_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiProfilerHostGetSupportedMetrics
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_GetBaseMetrics_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] reference to the profiler host object allocated by CUPTI in cuptiProfilerHostInitialize
    pub pHostObject: *mut CUpti_Profiler_Host_Object,
    /// [in] metric type (counter, ratio, throughput)
    pub metricType: CUpti_MetricType,
    /// [out] list of base metrics supported of queried metric type for the chip
    pub ppMetricNames: *mut *const ::std::os::raw::c_char,
    /// [out] number of metrics
    pub numMetrics: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_Host_GetBaseMetrics_Params",
    ][::std::mem::size_of::<CUpti_Profiler_Host_GetBaseMetrics_Params>() - 48usize];
    [
        "Alignment of CUpti_Profiler_Host_GetBaseMetrics_Params",
    ][::std::mem::align_of::<CUpti_Profiler_Host_GetBaseMetrics_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetBaseMetrics_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetBaseMetrics_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetBaseMetrics_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetBaseMetrics_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetBaseMetrics_Params::pHostObject",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetBaseMetrics_Params, pHostObject)
        - 16usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetBaseMetrics_Params::metricType",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetBaseMetrics_Params, metricType)
        - 24usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetBaseMetrics_Params::ppMetricNames",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetBaseMetrics_Params, ppMetricNames)
        - 32usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetBaseMetrics_Params::numMetrics",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetBaseMetrics_Params, numMetrics)
        - 40usize];
};
impl Default for CUpti_Profiler_Host_GetBaseMetrics_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Get the list of supported base metrics for the chip.

 \param pParams A pointer to \ref CUpti_Profiler_Host_GetBaseMetrics_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiProfilerHostGetBaseMetrics(
        pParams: *mut CUpti_Profiler_Host_GetBaseMetrics_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiProfilerHostGetSubMetrics
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_GetSubMetrics_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] reference to the profiler host object allocated by CUPTI in cuptiProfilerHostInitialize
    pub pHostObject: *mut CUpti_Profiler_Host_Object,
    /// [in] the metric type for queried metric
    pub metricType: CUpti_MetricType,
    /// [in] metric name for which sub-metric will be listed. Metric name can be with or without extension (rollup or submetric)
    pub pMetricName: *const ::std::os::raw::c_char,
    /// [out] number of submetrics supported
    pub numOfSubmetrics: usize,
    /// [out] list of submetrics supported for the metric.
    pub ppSubMetrics: *mut *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_Host_GetSubMetrics_Params",
    ][::std::mem::size_of::<CUpti_Profiler_Host_GetSubMetrics_Params>() - 56usize];
    [
        "Alignment of CUpti_Profiler_Host_GetSubMetrics_Params",
    ][::std::mem::align_of::<CUpti_Profiler_Host_GetSubMetrics_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetSubMetrics_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetSubMetrics_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetSubMetrics_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetSubMetrics_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetSubMetrics_Params::pHostObject",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetSubMetrics_Params, pHostObject)
        - 16usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetSubMetrics_Params::metricType",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetSubMetrics_Params, metricType)
        - 24usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetSubMetrics_Params::pMetricName",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetSubMetrics_Params, pMetricName)
        - 32usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetSubMetrics_Params::numOfSubmetrics",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetSubMetrics_Params, numOfSubmetrics)
        - 40usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetSubMetrics_Params::ppSubMetrics",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetSubMetrics_Params, ppSubMetrics)
        - 48usize];
};
impl Default for CUpti_Profiler_Host_GetSubMetrics_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Get the list of supported sub-metrics for the metric.

 \param pParams A pointer to \ref CUpti_Profiler_Host_GetSubMetrics_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_INVALID_METRIC_NAME if the metric name is not valid or not supported for the chip
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiProfilerHostGetSubMetrics(
        pParams: *mut CUpti_Profiler_Host_GetSubMetrics_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiProfilerHostGetMetricProperties
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_GetMetricProperties_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] reference to the profiler host object allocated by CUPTI in cuptiProfilerHostInitialize
    pub pHostObject: *mut CUpti_Profiler_Host_Object,
    /// [in] metric name for which its properties will be listed. Metric name can be with or without extension (rollup or submetric)
    pub pMetricName: *const ::std::os::raw::c_char,
    /// [out] a short description about the metric
    pub pDescription: *const ::std::os::raw::c_char,
    /// [out] associated hw unit for the metric
    pub pHwUnit: *const ::std::os::raw::c_char,
    /// [out] the dimension of the metric values
    pub pDimUnit: *const ::std::os::raw::c_char,
    /// [out] the metric type (counter, ratio or throughput)
    pub metricType: CUpti_MetricType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_Host_GetMetricProperties_Params",
    ][::std::mem::size_of::<CUpti_Profiler_Host_GetMetricProperties_Params>() - 64usize];
    [
        "Alignment of CUpti_Profiler_Host_GetMetricProperties_Params",
    ][::std::mem::align_of::<CUpti_Profiler_Host_GetMetricProperties_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetMetricProperties_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetMetricProperties_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetMetricProperties_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetMetricProperties_Params, pPriv)
        - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetMetricProperties_Params::pHostObject",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetMetricProperties_Params, pHostObject)
        - 16usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetMetricProperties_Params::pMetricName",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetMetricProperties_Params, pMetricName)
        - 24usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetMetricProperties_Params::pDescription",
    ][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetMetricProperties_Params, pDescription
    ) - 32usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetMetricProperties_Params::pHwUnit",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetMetricProperties_Params, pHwUnit)
        - 40usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetMetricProperties_Params::pDimUnit",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetMetricProperties_Params, pDimUnit)
        - 48usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetMetricProperties_Params::metricType",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetMetricProperties_Params, metricType)
        - 56usize];
};
impl Default for CUpti_Profiler_Host_GetMetricProperties_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Get the properties of the metric.

 \param pParams A pointer to \ref CUpti_Profiler_Host_GetMetricProperties_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_INVALID_METRIC_NAME if the metric name is not valid or not supported for the chip
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiProfilerHostGetMetricProperties(
        pParams: *mut CUpti_Profiler_Host_GetMetricProperties_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiProfilerHostGetRangeName
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_GetRangeName_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] the counter data image where profiling data has been decoded
    pub pCounterDataImage: *const u8,
    /// [in] size of counter data image
    pub counterDataImageSize: usize,
    /// [in] range index for which the range name will be queried
    pub rangeIndex: usize,
    /// [in] used in case of nested ranges, default="/". Range1<delimiter>Range2
    pub delimiter: *const ::std::os::raw::c_char,
    /** [out] the range name.
 Note: that the CUPTI allocate the memory internal and
 its user responsibility to free up the allocated memory*/
    pub pRangeName: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_Host_GetRangeName_Params",
    ][::std::mem::size_of::<CUpti_Profiler_Host_GetRangeName_Params>() - 56usize];
    [
        "Alignment of CUpti_Profiler_Host_GetRangeName_Params",
    ][::std::mem::align_of::<CUpti_Profiler_Host_GetRangeName_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetRangeName_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetRangeName_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetRangeName_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetRangeName_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetRangeName_Params::pCounterDataImage",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetRangeName_Params, pCounterDataImage)
        - 16usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetRangeName_Params::counterDataImageSize",
    ][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetRangeName_Params, counterDataImageSize
    ) - 24usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetRangeName_Params::rangeIndex",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetRangeName_Params, rangeIndex)
        - 32usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetRangeName_Params::delimiter",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetRangeName_Params, delimiter)
        - 40usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetRangeName_Params::pRangeName",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetRangeName_Params, pRangeName)
        - 48usize];
};
impl Default for CUpti_Profiler_Host_GetRangeName_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Get the range name for the range index stored in the counter data.
 In Range profiler, for Auto range mode the range name will be numeric value
 assigned to the kernel based on execution order. For user range mode, the
 name of range will be based on the range name provided by the user using
 Push range API.

 \param pParams A pointer to \ref CUpti_Profiler_Host_GetRangeName_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiProfilerHostGetRangeName(
        pParams: *mut CUpti_Profiler_Host_GetRangeName_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiProfilerHostEvaluateToGpuValues
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_EvaluateToGpuValues_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] reference to the profiler host object allocated by CUPTI in cuptiProfilerHostInitialize
    pub pHostObject: *mut CUpti_Profiler_Host_Object,
    /// [in] the counter data image where profiling data has been decoded
    pub pCounterDataImage: *const u8,
    /// [in] size of counter data image
    pub counterDataImageSize: usize,
    /// [in] range index for which the range name will be queried
    pub rangeIndex: usize,
    /// [in] the metrics for which GPU values will be evaluated for the range
    pub ppMetricNames: *mut *const ::std::os::raw::c_char,
    /// [in] number of metrics
    pub numMetrics: usize,
    /// [out] output value for given metric and range index
    pub pMetricValues: *mut f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_Host_EvaluateToGpuValues_Params",
    ][::std::mem::size_of::<CUpti_Profiler_Host_EvaluateToGpuValues_Params>() - 72usize];
    [
        "Alignment of CUpti_Profiler_Host_EvaluateToGpuValues_Params",
    ][::std::mem::align_of::<CUpti_Profiler_Host_EvaluateToGpuValues_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_EvaluateToGpuValues_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_EvaluateToGpuValues_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_Profiler_Host_EvaluateToGpuValues_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_EvaluateToGpuValues_Params, pPriv)
        - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_EvaluateToGpuValues_Params::pHostObject",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_EvaluateToGpuValues_Params, pHostObject)
        - 16usize];
    [
        "Offset of field: CUpti_Profiler_Host_EvaluateToGpuValues_Params::pCounterDataImage",
    ][::std::mem::offset_of!(
        CUpti_Profiler_Host_EvaluateToGpuValues_Params, pCounterDataImage
    ) - 24usize];
    [
        "Offset of field: CUpti_Profiler_Host_EvaluateToGpuValues_Params::counterDataImageSize",
    ][::std::mem::offset_of!(
        CUpti_Profiler_Host_EvaluateToGpuValues_Params, counterDataImageSize
    ) - 32usize];
    [
        "Offset of field: CUpti_Profiler_Host_EvaluateToGpuValues_Params::rangeIndex",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_EvaluateToGpuValues_Params, rangeIndex)
        - 40usize];
    [
        "Offset of field: CUpti_Profiler_Host_EvaluateToGpuValues_Params::ppMetricNames",
    ][::std::mem::offset_of!(
        CUpti_Profiler_Host_EvaluateToGpuValues_Params, ppMetricNames
    ) - 48usize];
    [
        "Offset of field: CUpti_Profiler_Host_EvaluateToGpuValues_Params::numMetrics",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_EvaluateToGpuValues_Params, numMetrics)
        - 56usize];
    [
        "Offset of field: CUpti_Profiler_Host_EvaluateToGpuValues_Params::pMetricValues",
    ][::std::mem::offset_of!(
        CUpti_Profiler_Host_EvaluateToGpuValues_Params, pMetricValues
    ) - 64usize];
};
impl Default for CUpti_Profiler_Host_EvaluateToGpuValues_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Evaluate the metric values for the range index stored in the counter data.

 \param pParams A pointer to \ref CUpti_Profiler_Host_EvaluateToGpuValues_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_INVALID_METRIC_NAME if the metric name is not valid or not supported for the chip
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiProfilerHostEvaluateToGpuValues(
        pParams: *mut CUpti_Profiler_Host_EvaluateToGpuValues_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiProfilerHostConfigAddMetrics
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_ConfigAddMetrics_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] reference to the profiler host object allocated by CUPTI in cuptiProfilerHostInitialize
    pub pHostObject: *mut CUpti_Profiler_Host_Object,
    /// [in] metric names for which config image will be generated
    pub ppMetricNames: *mut *const ::std::os::raw::c_char,
    /// [in] number of metrics
    pub numMetrics: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_Host_ConfigAddMetrics_Params",
    ][::std::mem::size_of::<CUpti_Profiler_Host_ConfigAddMetrics_Params>() - 40usize];
    [
        "Alignment of CUpti_Profiler_Host_ConfigAddMetrics_Params",
    ][::std::mem::align_of::<CUpti_Profiler_Host_ConfigAddMetrics_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_ConfigAddMetrics_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_ConfigAddMetrics_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_Profiler_Host_ConfigAddMetrics_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_ConfigAddMetrics_Params, pPriv)
        - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_ConfigAddMetrics_Params::pHostObject",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_ConfigAddMetrics_Params, pHostObject)
        - 16usize];
    [
        "Offset of field: CUpti_Profiler_Host_ConfigAddMetrics_Params::ppMetricNames",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_ConfigAddMetrics_Params, ppMetricNames)
        - 24usize];
    [
        "Offset of field: CUpti_Profiler_Host_ConfigAddMetrics_Params::numMetrics",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_ConfigAddMetrics_Params, numMetrics)
        - 32usize];
};
impl Default for CUpti_Profiler_Host_ConfigAddMetrics_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Add the metrics to the profiler host object for generating the config image.
 The config image will have the required information to schedule the metrics for
 collecting the profiling data.
 Note: PM sampling only supports single pass config image.

 \param pParams A pointer to \ref CUpti_Profiler_Host_ConfigAddMetrics_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_INVALID_METRIC_NAME if the metric name is not valid or not supported for the chip
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiProfilerHostConfigAddMetrics(
        pParams: *mut CUpti_Profiler_Host_ConfigAddMetrics_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiProfilerHostGetConfigImageSize
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_GetConfigImageSize_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] reference to the profiler host object allocated by CUPTI in cuptiProfilerHostInitialize
    pub pHostObject: *mut CUpti_Profiler_Host_Object,
    /// [out] the size of config image, users need to allocate the buffer for storing
    pub configImageSize: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_Host_GetConfigImageSize_Params",
    ][::std::mem::size_of::<CUpti_Profiler_Host_GetConfigImageSize_Params>() - 32usize];
    [
        "Alignment of CUpti_Profiler_Host_GetConfigImageSize_Params",
    ][::std::mem::align_of::<CUpti_Profiler_Host_GetConfigImageSize_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetConfigImageSize_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetConfigImageSize_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetConfigImageSize_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetConfigImageSize_Params, pPriv)
        - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetConfigImageSize_Params::pHostObject",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetConfigImageSize_Params, pHostObject)
        - 16usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetConfigImageSize_Params::configImageSize",
    ][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetConfigImageSize_Params, configImageSize
    ) - 24usize];
};
impl Default for CUpti_Profiler_Host_GetConfigImageSize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Get the size of the config image for the metrics added to the profiler host object.
 Users need to allocate the buffer for storing the config image.

 \param pParams A pointer to \ref CUpti_Profiler_Host_GetConfigImageSize_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiProfilerHostGetConfigImageSize(
        pParams: *mut CUpti_Profiler_Host_GetConfigImageSize_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiProfilerHostGetConfigImage
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_GetConfigImage_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] reference to the profiler host object allocated by CUPTI in cuptiProfilerHostInitialize
    pub pHostObject: *mut CUpti_Profiler_Host_Object,
    /// [in] Number of bytes allocated for pBuffer
    pub configImageSize: usize,
    /// [out] Buffer receiving the config image
    pub pConfigImage: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_Host_GetConfigImage_Params",
    ][::std::mem::size_of::<CUpti_Profiler_Host_GetConfigImage_Params>() - 40usize];
    [
        "Alignment of CUpti_Profiler_Host_GetConfigImage_Params",
    ][::std::mem::align_of::<CUpti_Profiler_Host_GetConfigImage_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetConfigImage_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetConfigImage_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetConfigImage_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetConfigImage_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetConfigImage_Params::pHostObject",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetConfigImage_Params, pHostObject)
        - 16usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetConfigImage_Params::configImageSize",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetConfigImage_Params, configImageSize)
        - 24usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetConfigImage_Params::pConfigImage",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetConfigImage_Params, pConfigImage)
        - 32usize];
};
impl Default for CUpti_Profiler_Host_GetConfigImage_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Get the config image for the metrics added to the profiler host object.
 User will pass the allocated buffer to store the config image.

 \param pParams A pointer to \ref CUpti_Profiler_Host_GetConfigImage_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiProfilerHostGetConfigImage(
        pParams: *mut CUpti_Profiler_Host_GetConfigImage_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiProfilerHostGetNumOfPasses
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_GetNumOfPasses_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] Number of bytes allocated for pConfigImage
    pub configImageSize: usize,
    /// [in] the config image buffer
    pub pConfigImage: *mut u8,
    /// [out] number of passes required for profiling scheduled metrics in the config image
    pub numOfPasses: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_Host_GetNumOfPasses_Params",
    ][::std::mem::size_of::<CUpti_Profiler_Host_GetNumOfPasses_Params>() - 40usize];
    [
        "Alignment of CUpti_Profiler_Host_GetNumOfPasses_Params",
    ][::std::mem::align_of::<CUpti_Profiler_Host_GetNumOfPasses_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetNumOfPasses_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetNumOfPasses_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetNumOfPasses_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetNumOfPasses_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetNumOfPasses_Params::configImageSize",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetNumOfPasses_Params, configImageSize)
        - 16usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetNumOfPasses_Params::pConfigImage",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetNumOfPasses_Params, pConfigImage)
        - 24usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetNumOfPasses_Params::numOfPasses",
    ][::std::mem::offset_of!(CUpti_Profiler_Host_GetNumOfPasses_Params, numOfPasses)
        - 32usize];
};
impl Default for CUpti_Profiler_Host_GetNumOfPasses_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Get the number of passes required for profiling the scheduled metrics in the config image.

 \param pParams A pointer to \ref CUpti_Profiler_Host_GetNumOfPasses_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiProfilerHostGetNumOfPasses(
        pParams: *mut CUpti_Profiler_Host_GetNumOfPasses_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiProfilerHostGetMaxNumHardwareMetricsPerPass
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] the profiler kind one from CUpti_ProfilerType
    pub profilerType: CUpti_ProfilerType,
    /// [in] accepted for chips supported at the time-of-release.
    pub pChipName: *const ::std::os::raw::c_char,
    /// [in] buffer with counter availability image - required for future chip support
    pub pCounterAvailabilityImage: *mut u8,
    /// [out] maximum number of metrics that can be scheduled in a pass
    pub maxMetricsPerPass: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params",
    ][::std::mem::size_of::<CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params>()
        - 48usize];
    [
        "Alignment of CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params",
    ][::std::mem::align_of::<
        CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params,
    >() - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params::structSize",
    ][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params, structSize
    ) - 0usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params::pPriv",
    ][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params, pPriv
    ) - 8usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params::profilerType",
    ][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params, profilerType
    ) - 16usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params::pChipName",
    ][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params, pChipName
    ) - 24usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params::pCounterAvailabilityImage",
    ][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params,
        pCounterAvailabilityImage
    ) - 32usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params::maxMetricsPerPass",
    ][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params, maxMetricsPerPass
    ) - 40usize];
};
impl Default for CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Get the maximum number of hardware metrics (metric names which doesn't include _sass_ keyword)
 that can be scheduled in a single pass for a chip. While this represents a theoretical upper limit,
 practical constraints may prevent reaching this threshold for a specific set of metrics. Furthermore,
 the maximum achievable value is contingent upon the characteristics and architecture of the chip in question.

 Use cuptiProfilerHostGetNumOfPasses API for getting the actual number of passes required for the
 for collecting the profiling data for the scheduled metrics in a config image.

 \param pParams A pointer to \ref CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiProfilerHostGetMaxNumHardwareMetricsPerPass(
        pParams: *mut CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params,
    ) -> CUptiResult;
}
/// Invalid value
pub const CUPTI_Range_INVALID: CUpti_ProfilerRange = 0;
/// Ranges are auto defined around each kernel in a profiling session
pub const CUPTI_AutoRange: CUpti_ProfilerRange = 1;
/// A range in which metric data to be collected is defined by the user
pub const CUPTI_UserRange: CUpti_ProfilerRange = 2;
/// Range count
pub const CUPTI_Range_COUNT: CUpti_ProfilerRange = 3;
/** \brief Profiler range attribute

 A metric enabled in the session's configuration is collected separately per unique range-stack in the pass.
 This is an attribute to collect metrics around each kernel in a profiling session or in an user defined range.*/
pub type CUpti_ProfilerRange = ::std::os::raw::c_uint;
/// Invalid Value
pub const CUPTI_Replay_INVALID: CUpti_ProfilerReplayMode = 0;
/// Replay is done by CUPTI user around the process
pub const CUPTI_ApplicationReplay: CUpti_ProfilerReplayMode = 1;
/// Replay is done around kernel implicitly by CUPTI
pub const CUPTI_KernelReplay: CUpti_ProfilerReplayMode = 2;
/// Replay is done by CUPTI user within a process
pub const CUPTI_UserReplay: CUpti_ProfilerReplayMode = 3;
/// Replay count
pub const CUPTI_Replay_COUNT: CUpti_ProfilerReplayMode = 4;
/** \brief Profiler replay attribute

 For metrics which require multipass collection, a replay of the GPU kernel(s) is required.
 This is an attribute which specify how the replay of the kernel(s) to be measured is done.*/
pub type CUpti_ProfilerReplayMode = ::std::os::raw::c_uint;
/// \brief Default parameter for cuptiProfilerInitialize
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Initialize_Params {
    ///!< [in] CUpti_Profiler_Initialize_Params_STRUCT_SIZE
    pub structSize: usize,
    ///!< [in] assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_Initialize_Params",
    ][::std::mem::size_of::<CUpti_Profiler_Initialize_Params>() - 16usize];
    [
        "Alignment of CUpti_Profiler_Initialize_Params",
    ][::std::mem::align_of::<CUpti_Profiler_Initialize_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_Initialize_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_Initialize_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_Profiler_Initialize_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_Initialize_Params, pPriv) - 8usize];
};
impl Default for CUpti_Profiler_Initialize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// \brief Default parameter for cuptiProfilerDeInitialize
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_DeInitialize_Params {
    ///!< [in] CUpti_Profiler_DeInitialize_Params_STRUCT_SIZE
    pub structSize: usize,
    ///!< [in] assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_DeInitialize_Params",
    ][::std::mem::size_of::<CUpti_Profiler_DeInitialize_Params>() - 16usize];
    [
        "Alignment of CUpti_Profiler_DeInitialize_Params",
    ][::std::mem::align_of::<CUpti_Profiler_DeInitialize_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_DeInitialize_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_DeInitialize_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_Profiler_DeInitialize_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_DeInitialize_Params, pPriv) - 8usize];
};
impl Default for CUpti_Profiler_DeInitialize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Initializes the profiler interface

 Loads the required libraries in the process address space.
 Sets up the hooks with the CUDA driver.*/
    pub fn cuptiProfilerInitialize(
        pParams: *mut CUpti_Profiler_Initialize_Params,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /// \brief DeInitializes the profiler interface
    pub fn cuptiProfilerDeInitialize(
        pParams: *mut CUpti_Profiler_DeInitialize_Params,
    ) -> CUptiResult;
}
/// \brief Input parameter to define the counterDataImage
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_CounterDataImageOptions {
    ///!< [in] CUpti_Profiler_CounterDataImageOptions_Params_STRUCT_SIZE
    pub structSize: usize,
    ///!< [in] assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    /**< [in] Address of CounterDataPrefix generated from NVPW_CounterDataBuilder_GetCounterDataPrefix().
Must be align(8).*/
    pub pCounterDataPrefix: *const u8,
    ///!< [in] Size of CounterDataPrefix generated from NVPW_CounterDataBuilder_GetCounterDataPrefix().
    pub counterDataPrefixSize: usize,
    ///!< [in] Maximum number of ranges that can be profiled
    pub maxNumRanges: u32,
    ///!< [in] Maximum number of RangeTree nodes; must be >= maxNumRanges
    pub maxNumRangeTreeNodes: u32,
    ///!< [in] Maximum string length of each RangeName, including the trailing NULL character
    pub maxRangeNameLength: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_CounterDataImageOptions",
    ][::std::mem::size_of::<CUpti_Profiler_CounterDataImageOptions>() - 48usize];
    [
        "Alignment of CUpti_Profiler_CounterDataImageOptions",
    ][::std::mem::align_of::<CUpti_Profiler_CounterDataImageOptions>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImageOptions::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_CounterDataImageOptions, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImageOptions::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_CounterDataImageOptions, pPriv) - 8usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImageOptions::pCounterDataPrefix",
    ][::std::mem::offset_of!(CUpti_Profiler_CounterDataImageOptions, pCounterDataPrefix)
        - 16usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImageOptions::counterDataPrefixSize",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImageOptions, counterDataPrefixSize
    ) - 24usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImageOptions::maxNumRanges",
    ][::std::mem::offset_of!(CUpti_Profiler_CounterDataImageOptions, maxNumRanges)
        - 32usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImageOptions::maxNumRangeTreeNodes",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImageOptions, maxNumRangeTreeNodes
    ) - 36usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImageOptions::maxRangeNameLength",
    ][::std::mem::offset_of!(CUpti_Profiler_CounterDataImageOptions, maxRangeNameLength)
        - 40usize];
};
impl Default for CUpti_Profiler_CounterDataImageOptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// \brief Params for cuptiProfilerCounterDataImageCalculateSize
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_CounterDataImage_CalculateSize_Params {
    ///!< [in] CUpti_Profiler_CounterDataImage_CalculateSize_Params_STRUCT_SIZE
    pub structSize: usize,
    ///!< [in] assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    ///!< [in] CUpti_Profiler_CounterDataImageOptions_STRUCT_SIZE
    pub sizeofCounterDataImageOptions: usize,
    ///!< [in] Pointer to Counter Data Image Options
    pub pOptions: *const CUpti_Profiler_CounterDataImageOptions,
    ///!< [out]
    pub counterDataImageSize: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_CounterDataImage_CalculateSize_Params",
    ][::std::mem::size_of::<CUpti_Profiler_CounterDataImage_CalculateSize_Params>()
        - 40usize];
    [
        "Alignment of CUpti_Profiler_CounterDataImage_CalculateSize_Params",
    ][::std::mem::align_of::<CUpti_Profiler_CounterDataImage_CalculateSize_Params>()
        - 8usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_CalculateSize_Params::structSize",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_CalculateSize_Params, structSize
    ) - 0usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_CalculateSize_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_CounterDataImage_CalculateSize_Params, pPriv)
        - 8usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_CalculateSize_Params::sizeofCounterDataImageOptions",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_CalculateSize_Params,
        sizeofCounterDataImageOptions
    ) - 16usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_CalculateSize_Params::pOptions",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_CalculateSize_Params, pOptions
    ) - 24usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_CalculateSize_Params::counterDataImageSize",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_CalculateSize_Params, counterDataImageSize
    ) - 32usize];
};
impl Default for CUpti_Profiler_CounterDataImage_CalculateSize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// \brief Params for cuptiProfilerCounterDataImageInitialize
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_CounterDataImage_Initialize_Params {
    ///!< [in] CUpti_Profiler_CounterDataImage_Initialize_Params_STRUCT_SIZE
    pub structSize: usize,
    ///!< [in] assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    ///!< [in] CUpti_Profiler_CounterDataImageOptions_STRUCT_SIZE
    pub sizeofCounterDataImageOptions: usize,
    ///!< [in] Pointer to Counter Data Image Options
    pub pOptions: *const CUpti_Profiler_CounterDataImageOptions,
    ///!< [in] Size calculated from cuptiProfilerCounterDataImageCalculateSize
    pub counterDataImageSize: usize,
    ///!< [in] The buffer to be initialized.
    pub pCounterDataImage: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_CounterDataImage_Initialize_Params",
    ][::std::mem::size_of::<CUpti_Profiler_CounterDataImage_Initialize_Params>()
        - 48usize];
    [
        "Alignment of CUpti_Profiler_CounterDataImage_Initialize_Params",
    ][::std::mem::align_of::<CUpti_Profiler_CounterDataImage_Initialize_Params>()
        - 8usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_Initialize_Params::structSize",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_Initialize_Params, structSize
    ) - 0usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_Initialize_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_CounterDataImage_Initialize_Params, pPriv)
        - 8usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_Initialize_Params::sizeofCounterDataImageOptions",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_Initialize_Params, sizeofCounterDataImageOptions
    ) - 16usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_Initialize_Params::pOptions",
    ][::std::mem::offset_of!(CUpti_Profiler_CounterDataImage_Initialize_Params, pOptions)
        - 24usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_Initialize_Params::counterDataImageSize",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_Initialize_Params, counterDataImageSize
    ) - 32usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_Initialize_Params::pCounterDataImage",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_Initialize_Params, pCounterDataImage
    ) - 40usize];
};
impl Default for CUpti_Profiler_CounterDataImage_Initialize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief A CounterData image allocates space for values for each counter for each range.

 User borne the resposibility of managing the counterDataImage allocations.
 CounterDataPrefix contains meta data about the metrics that will be stored in counterDataImage.
 Use these APIs to calculate the allocation size and initialize counterData image.

 **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h.*/
    pub fn cuptiProfilerCounterDataImageCalculateSize(
        pParams: *mut CUpti_Profiler_CounterDataImage_CalculateSize_Params,
    ) -> CUptiResult;
}
unsafe extern "C" {
    pub fn cuptiProfilerCounterDataImageInitialize(
        pParams: *mut CUpti_Profiler_CounterDataImage_Initialize_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiProfilerCounterDataImageCalculateScratchBufferSize
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params {
    ///!< [in] CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params_STRUCT_SIZE
    pub structSize: usize,
    ///!< [in] assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    ///!< [in] size calculated from cuptiProfilerCounterDataImageCalculateSize
    pub counterDataImageSize: usize,
    ///!< [in]
    pub pCounterDataImage: *mut u8,
    ///!< [out]
    pub counterDataScratchBufferSize: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params",
    ][::std::mem::size_of::<
        CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params,
    >() - 40usize];
    [
        "Alignment of CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params",
    ][::std::mem::align_of::<
        CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params,
    >() - 8usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params::structSize",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params, structSize
    ) - 0usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params::pPriv",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params, pPriv
    ) - 8usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params::counterDataImageSize",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params,
        counterDataImageSize
    ) - 16usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params::pCounterDataImage",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params,
        pCounterDataImage
    ) - 24usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params::counterDataScratchBufferSize",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params,
        counterDataScratchBufferSize
    ) - 32usize];
};
impl Default for CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// \brief Params for cuptiProfilerCounterDataImageInitializeScratchBuffer
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params {
    ///!< [in] CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params_STRUCT_SIZE
    pub structSize: usize,
    ///!< [in] assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    ///!< [in] size calculated from cuptiProfilerCounterDataImageCalculateSize
    pub counterDataImageSize: usize,
    ///!< [in]
    pub pCounterDataImage: *mut u8,
    ///!< [in] size calculated using cuptiProfilerCounterDataImageCalculateScratchBufferSize
    pub counterDataScratchBufferSize: usize,
    ///!< [in] the scratch buffer to be initialized.
    pub pCounterDataScratchBuffer: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params",
    ][::std::mem::size_of::<
        CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params,
    >() - 48usize];
    [
        "Alignment of CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params",
    ][::std::mem::align_of::<
        CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params,
    >() - 8usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params::structSize",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params, structSize
    ) - 0usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params::pPriv",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params, pPriv
    ) - 8usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params::counterDataImageSize",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params,
        counterDataImageSize
    ) - 16usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params::pCounterDataImage",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params, pCounterDataImage
    ) - 24usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params::counterDataScratchBufferSize",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params,
        counterDataScratchBufferSize
    ) - 32usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params::pCounterDataScratchBuffer",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params,
        pCounterDataScratchBuffer
    ) - 40usize];
};
impl Default for CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief A temporary storage for CounterData image needed for internal operations

 Use these APIs to calculate the allocation size and initialize counterData image scratch buffer.

 **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h.*/
    pub fn cuptiProfilerCounterDataImageCalculateScratchBufferSize(
        pParams: *mut CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params,
    ) -> CUptiResult;
}
unsafe extern "C" {
    pub fn cuptiProfilerCounterDataImageInitializeScratchBuffer(
        pParams: *mut CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiProfilerBeginSession
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_BeginSession_Params {
    ///!< [in] CUpti_Profiler_BeginSession_Params_STRUCT_SIZE
    pub structSize: usize,
    ///!< [in] assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    ///!< [in] if NULL, the current CUcontext is used
    pub ctx: CUcontext,
    ///!< [in] size calculated from cuptiProfilerCounterDataImageCalculateSize
    pub counterDataImageSize: usize,
    ///!< [in] address of CounterDataImage
    pub pCounterDataImage: *mut u8,
    ///!< [in] size calculated from cuptiProfilerCounterDataImageInitializeScratchBuffer
    pub counterDataScratchBufferSize: usize,
    ///!< [in] address of CounterDataImage scratch buffer
    pub pCounterDataScratchBuffer: *mut u8,
    ///!< [in] [optional]
    pub bDumpCounterDataInFile: u8,
    ///!< [in] [optional]
    pub pCounterDataFilePath: *const ::std::os::raw::c_char,
    ///!< [in] CUpti_ProfilerRange
    pub range: CUpti_ProfilerRange,
    ///!< [in] CUpti_ProfilerReplayMode
    pub replayMode: CUpti_ProfilerReplayMode,
    ///!< [in] Maximum number of ranges that can be recorded in a single pass.
    pub maxRangesPerPass: usize,
    ///!< [in] Maximum number of kernel launches that can be recorded in a single pass; must be >= maxRangesPerPass.
    pub maxLaunchesPerPass: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_BeginSession_Params",
    ][::std::mem::size_of::<CUpti_Profiler_BeginSession_Params>() - 96usize];
    [
        "Alignment of CUpti_Profiler_BeginSession_Params",
    ][::std::mem::align_of::<CUpti_Profiler_BeginSession_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_BeginSession_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_BeginSession_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_Profiler_BeginSession_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_BeginSession_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_Profiler_BeginSession_Params::ctx",
    ][::std::mem::offset_of!(CUpti_Profiler_BeginSession_Params, ctx) - 16usize];
    [
        "Offset of field: CUpti_Profiler_BeginSession_Params::counterDataImageSize",
    ][::std::mem::offset_of!(CUpti_Profiler_BeginSession_Params, counterDataImageSize)
        - 24usize];
    [
        "Offset of field: CUpti_Profiler_BeginSession_Params::pCounterDataImage",
    ][::std::mem::offset_of!(CUpti_Profiler_BeginSession_Params, pCounterDataImage)
        - 32usize];
    [
        "Offset of field: CUpti_Profiler_BeginSession_Params::counterDataScratchBufferSize",
    ][::std::mem::offset_of!(
        CUpti_Profiler_BeginSession_Params, counterDataScratchBufferSize
    ) - 40usize];
    [
        "Offset of field: CUpti_Profiler_BeginSession_Params::pCounterDataScratchBuffer",
    ][::std::mem::offset_of!(
        CUpti_Profiler_BeginSession_Params, pCounterDataScratchBuffer
    ) - 48usize];
    [
        "Offset of field: CUpti_Profiler_BeginSession_Params::bDumpCounterDataInFile",
    ][::std::mem::offset_of!(CUpti_Profiler_BeginSession_Params, bDumpCounterDataInFile)
        - 56usize];
    [
        "Offset of field: CUpti_Profiler_BeginSession_Params::pCounterDataFilePath",
    ][::std::mem::offset_of!(CUpti_Profiler_BeginSession_Params, pCounterDataFilePath)
        - 64usize];
    [
        "Offset of field: CUpti_Profiler_BeginSession_Params::range",
    ][::std::mem::offset_of!(CUpti_Profiler_BeginSession_Params, range) - 72usize];
    [
        "Offset of field: CUpti_Profiler_BeginSession_Params::replayMode",
    ][::std::mem::offset_of!(CUpti_Profiler_BeginSession_Params, replayMode) - 76usize];
    [
        "Offset of field: CUpti_Profiler_BeginSession_Params::maxRangesPerPass",
    ][::std::mem::offset_of!(CUpti_Profiler_BeginSession_Params, maxRangesPerPass)
        - 80usize];
    [
        "Offset of field: CUpti_Profiler_BeginSession_Params::maxLaunchesPerPass",
    ][::std::mem::offset_of!(CUpti_Profiler_BeginSession_Params, maxLaunchesPerPass)
        - 88usize];
};
impl Default for CUpti_Profiler_BeginSession_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// \brief Params for cuptiProfilerEndSession
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_EndSession_Params {
    ///!< [in] CUpti_Profiler_EndSession_Params_STRUCT_SIZE
    pub structSize: usize,
    ///!< [in] assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    ///!< [in] if NULL, the current CUcontext is used
    pub ctx: CUcontext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_EndSession_Params",
    ][::std::mem::size_of::<CUpti_Profiler_EndSession_Params>() - 24usize];
    [
        "Alignment of CUpti_Profiler_EndSession_Params",
    ][::std::mem::align_of::<CUpti_Profiler_EndSession_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_EndSession_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_EndSession_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_Profiler_EndSession_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_EndSession_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_Profiler_EndSession_Params::ctx",
    ][::std::mem::offset_of!(CUpti_Profiler_EndSession_Params, ctx) - 16usize];
};
impl Default for CUpti_Profiler_EndSession_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Begin profiling session sets up the profiling on the device

 Although, it doesn't start the profiling but GPU resources needed for profiling are allocated.
 Outside of a session, the GPU will return to its normal operating state.

 **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h.*/
    pub fn cuptiProfilerBeginSession(
        pParams: *mut CUpti_Profiler_BeginSession_Params,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Ends profiling session

 Frees up the GPU resources acquired for profiling.
 Outside of a session, the GPU will return to it's normal operating state.

 **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h.*/
    pub fn cuptiProfilerEndSession(
        pParams: *mut CUpti_Profiler_EndSession_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiProfilerSetConfig
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_SetConfig_Params {
    ///!< [in] CUpti_Profiler_SetConfig_Params_STRUCT_SIZE
    pub structSize: usize,
    ///!< [in] assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    ///!< [in] if NULL, the current CUcontext is used
    pub ctx: CUcontext,
    ///!< [in] Config created by NVPW_RawMetricsConfig_GetConfigImage(). Must be align(8).
    pub pConfig: *const u8,
    ///!< [in] size of config
    pub configSize: usize,
    ///!< [in] the lowest nesting level to be profiled; must be >= 1
    pub minNestingLevel: u16,
    ///!< [in] the number of nesting levels to profile; must be >= 1
    pub numNestingLevels: u16,
    ///!< [in] Set this to zero for in-app replay; set this to the output of EndPass() for application replay
    pub passIndex: usize,
    ///!< [in] Set this to minNestingLevel for in-app replay; set this to the output of EndPass() for application
    pub targetNestingLevel: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_SetConfig_Params",
    ][::std::mem::size_of::<CUpti_Profiler_SetConfig_Params>() - 64usize];
    [
        "Alignment of CUpti_Profiler_SetConfig_Params",
    ][::std::mem::align_of::<CUpti_Profiler_SetConfig_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_SetConfig_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_SetConfig_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_Profiler_SetConfig_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_SetConfig_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_Profiler_SetConfig_Params::ctx",
    ][::std::mem::offset_of!(CUpti_Profiler_SetConfig_Params, ctx) - 16usize];
    [
        "Offset of field: CUpti_Profiler_SetConfig_Params::pConfig",
    ][::std::mem::offset_of!(CUpti_Profiler_SetConfig_Params, pConfig) - 24usize];
    [
        "Offset of field: CUpti_Profiler_SetConfig_Params::configSize",
    ][::std::mem::offset_of!(CUpti_Profiler_SetConfig_Params, configSize) - 32usize];
    [
        "Offset of field: CUpti_Profiler_SetConfig_Params::minNestingLevel",
    ][::std::mem::offset_of!(CUpti_Profiler_SetConfig_Params, minNestingLevel)
        - 40usize];
    [
        "Offset of field: CUpti_Profiler_SetConfig_Params::numNestingLevels",
    ][::std::mem::offset_of!(CUpti_Profiler_SetConfig_Params, numNestingLevels)
        - 42usize];
    [
        "Offset of field: CUpti_Profiler_SetConfig_Params::passIndex",
    ][::std::mem::offset_of!(CUpti_Profiler_SetConfig_Params, passIndex) - 48usize];
    [
        "Offset of field: CUpti_Profiler_SetConfig_Params::targetNestingLevel",
    ][::std::mem::offset_of!(CUpti_Profiler_SetConfig_Params, targetNestingLevel)
        - 56usize];
};
impl Default for CUpti_Profiler_SetConfig_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// \brief Params for cuptiProfilerUnsetConfig
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_UnsetConfig_Params {
    ///!< [in] CUpti_Profiler_UnsetConfig_Params_STRUCT_SIZE
    pub structSize: usize,
    ///!< [in] assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    ///!< [in] if NULL, the current CUcontext is used
    pub ctx: CUcontext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_UnsetConfig_Params",
    ][::std::mem::size_of::<CUpti_Profiler_UnsetConfig_Params>() - 24usize];
    [
        "Alignment of CUpti_Profiler_UnsetConfig_Params",
    ][::std::mem::align_of::<CUpti_Profiler_UnsetConfig_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_UnsetConfig_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_UnsetConfig_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_Profiler_UnsetConfig_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_UnsetConfig_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_Profiler_UnsetConfig_Params::ctx",
    ][::std::mem::offset_of!(CUpti_Profiler_UnsetConfig_Params, ctx) - 16usize];
};
impl Default for CUpti_Profiler_UnsetConfig_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Set metrics configuration to be profiled

 Use these APIs to set the config to profile in a session. It can be used for advanced cases such as where multiple
 configurations are collected into a single CounterData Image on the need basis, without restarting the session.

 **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h.*/
    pub fn cuptiProfilerSetConfig(
        pParams: *mut CUpti_Profiler_SetConfig_Params,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Unset metrics configuration profiled

 **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h.*/
    pub fn cuptiProfilerUnsetConfig(
        pParams: *mut CUpti_Profiler_UnsetConfig_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiProfilerBeginPass
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_BeginPass_Params {
    ///!< [in] CUpti_Profiler_BeginPass_Params_STRUCT_SIZE
    pub structSize: usize,
    ///!< [in] assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    ///!< [in] if NULL, the current CUcontext is used
    pub ctx: CUcontext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_BeginPass_Params",
    ][::std::mem::size_of::<CUpti_Profiler_BeginPass_Params>() - 24usize];
    [
        "Alignment of CUpti_Profiler_BeginPass_Params",
    ][::std::mem::align_of::<CUpti_Profiler_BeginPass_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_BeginPass_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_BeginPass_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_Profiler_BeginPass_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_BeginPass_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_Profiler_BeginPass_Params::ctx",
    ][::std::mem::offset_of!(CUpti_Profiler_BeginPass_Params, ctx) - 16usize];
};
impl Default for CUpti_Profiler_BeginPass_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// \brief Params for cuptiProfilerEndPass
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_EndPass_Params {
    ///!< [in] CUpti_Profiler_EndPass_Params_STRUCT_SIZE
    pub structSize: usize,
    ///!< [in] assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    ///!< [in] if NULL, the current CUcontext is used
    pub ctx: CUcontext,
    pub targetNestingLevel: u16,
    ///!< [out] The passIndex that will be collected by the *next* BeginPass
    pub passIndex: usize,
    ///!< [out] becomes true when the last pass has been queued to the GPU
    pub allPassesSubmitted: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_EndPass_Params",
    ][::std::mem::size_of::<CUpti_Profiler_EndPass_Params>() - 48usize];
    [
        "Alignment of CUpti_Profiler_EndPass_Params",
    ][::std::mem::align_of::<CUpti_Profiler_EndPass_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_EndPass_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_EndPass_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_Profiler_EndPass_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_EndPass_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_Profiler_EndPass_Params::ctx",
    ][::std::mem::offset_of!(CUpti_Profiler_EndPass_Params, ctx) - 16usize];
    [
        "Offset of field: CUpti_Profiler_EndPass_Params::targetNestingLevel",
    ][::std::mem::offset_of!(CUpti_Profiler_EndPass_Params, targetNestingLevel)
        - 24usize];
    [
        "Offset of field: CUpti_Profiler_EndPass_Params::passIndex",
    ][::std::mem::offset_of!(CUpti_Profiler_EndPass_Params, passIndex) - 32usize];
    [
        "Offset of field: CUpti_Profiler_EndPass_Params::allPassesSubmitted",
    ][::std::mem::offset_of!(CUpti_Profiler_EndPass_Params, allPassesSubmitted)
        - 40usize];
};
impl Default for CUpti_Profiler_EndPass_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Replay API: used for multipass collection.

 These APIs are used if user chooses to replay by itself \ref CUPTI_UserReplay or \ref CUPTI_ApplicationReplay
 for multipass collection of the metrics configurations.
 It's a no-op in case of \ref CUPTI_KernelReplay.

 **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h.*/
    pub fn cuptiProfilerBeginPass(
        pParams: *mut CUpti_Profiler_BeginPass_Params,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Replay API: used for multipass collection.

 These APIs are used if user chooses to replay by itself \ref CUPTI_UserReplay or \ref CUPTI_ApplicationReplay
 for multipass collection of the metrics configurations.
 Its a no-op in case of \ref CUPTI_KernelReplay.
 Returns information for next pass.

 **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h.*/
    pub fn cuptiProfilerEndPass(
        pParams: *mut CUpti_Profiler_EndPass_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiProfilerEnableProfiling
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_EnableProfiling_Params {
    ///!< [in] CUpti_Profiler_EnableProfiling_Params_STRUCT_SIZE
    pub structSize: usize,
    ///!< [in] assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    ///!< [in] if NULL, the current CUcontext is used
    pub ctx: CUcontext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_EnableProfiling_Params",
    ][::std::mem::size_of::<CUpti_Profiler_EnableProfiling_Params>() - 24usize];
    [
        "Alignment of CUpti_Profiler_EnableProfiling_Params",
    ][::std::mem::align_of::<CUpti_Profiler_EnableProfiling_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_EnableProfiling_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_EnableProfiling_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_Profiler_EnableProfiling_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_EnableProfiling_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_Profiler_EnableProfiling_Params::ctx",
    ][::std::mem::offset_of!(CUpti_Profiler_EnableProfiling_Params, ctx) - 16usize];
};
impl Default for CUpti_Profiler_EnableProfiling_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
/// \brief Params for cuptiProfilerDisableProfiling
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_DisableProfiling_Params {
    ///!< [in] CUpti_Profiler_DisableProfiling_Params_STRUCT_SIZE
    pub structSize: usize,
    ///!< [in] assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    ///!< [in] if NULL, the current CUcontext is used
    pub ctx: CUcontext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_DisableProfiling_Params",
    ][::std::mem::size_of::<CUpti_Profiler_DisableProfiling_Params>() - 24usize];
    [
        "Alignment of CUpti_Profiler_DisableProfiling_Params",
    ][::std::mem::align_of::<CUpti_Profiler_DisableProfiling_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_DisableProfiling_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_DisableProfiling_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_Profiler_DisableProfiling_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_DisableProfiling_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_Profiler_DisableProfiling_Params::ctx",
    ][::std::mem::offset_of!(CUpti_Profiler_DisableProfiling_Params, ctx) - 16usize];
};
impl Default for CUpti_Profiler_DisableProfiling_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Enables Profiling

 In \ref CUPTI_AutoRange, these APIs are used to enable/disable profiling for the kernels to be executed in
 a profiling session.

 **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h.*/
    pub fn cuptiProfilerEnableProfiling(
        pParams: *mut CUpti_Profiler_EnableProfiling_Params,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Disable Profiling

 In \ref CUPTI_AutoRange, these APIs are used to enable/disable profiling for the kernels to be executed in
 a profiling session.

 **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h.*/
    pub fn cuptiProfilerDisableProfiling(
        pParams: *mut CUpti_Profiler_DisableProfiling_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiProfilerIsPassCollected
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_IsPassCollected_Params {
    ///!< [in] CUpti_Profiler_IsPassCollected_Params_STRUCT_SIZE
    pub structSize: usize,
    ///!< [in] assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    ///!< [in] if NULL, the current CUcontext is used
    pub ctx: CUcontext,
    ///!< [out] number of ranges whose data was dropped in the processed pass
    pub numRangesDropped: usize,
    ///!< [out] number of bytes not written to TraceBuffer due to buffer full
    pub numTraceBytesDropped: usize,
    ///!< [out] true if a pass was successfully decoded
    pub onePassCollected: u8,
    ///!< [out] becomes true when the last pass has been decoded
    pub allPassesCollected: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_IsPassCollected_Params",
    ][::std::mem::size_of::<CUpti_Profiler_IsPassCollected_Params>() - 48usize];
    [
        "Alignment of CUpti_Profiler_IsPassCollected_Params",
    ][::std::mem::align_of::<CUpti_Profiler_IsPassCollected_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_IsPassCollected_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_IsPassCollected_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_Profiler_IsPassCollected_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_IsPassCollected_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_Profiler_IsPassCollected_Params::ctx",
    ][::std::mem::offset_of!(CUpti_Profiler_IsPassCollected_Params, ctx) - 16usize];
    [
        "Offset of field: CUpti_Profiler_IsPassCollected_Params::numRangesDropped",
    ][::std::mem::offset_of!(CUpti_Profiler_IsPassCollected_Params, numRangesDropped)
        - 24usize];
    [
        "Offset of field: CUpti_Profiler_IsPassCollected_Params::numTraceBytesDropped",
    ][::std::mem::offset_of!(CUpti_Profiler_IsPassCollected_Params, numTraceBytesDropped)
        - 32usize];
    [
        "Offset of field: CUpti_Profiler_IsPassCollected_Params::onePassCollected",
    ][::std::mem::offset_of!(CUpti_Profiler_IsPassCollected_Params, onePassCollected)
        - 40usize];
    [
        "Offset of field: CUpti_Profiler_IsPassCollected_Params::allPassesCollected",
    ][::std::mem::offset_of!(CUpti_Profiler_IsPassCollected_Params, allPassesCollected)
        - 41usize];
};
impl Default for CUpti_Profiler_IsPassCollected_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Asynchronous call to query if the submitted pass to GPU is collected

 **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h.*/
    pub fn cuptiProfilerIsPassCollected(
        pParams: *mut CUpti_Profiler_IsPassCollected_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiProfilerFlushCounterData
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_FlushCounterData_Params {
    ///!< [in] CUpti_Profiler_FlushCounterData_Params_STRUCT_SIZE
    pub structSize: usize,
    ///!< [in] assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    ///!< [in] if NULL, the current CUcontext is used
    pub ctx: CUcontext,
    ///!< [out] number of ranges whose data was dropped in the processed passes
    pub numRangesDropped: usize,
    ///!< [out] number of bytes not written to TraceBuffer due to buffer full
    pub numTraceBytesDropped: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_FlushCounterData_Params",
    ][::std::mem::size_of::<CUpti_Profiler_FlushCounterData_Params>() - 40usize];
    [
        "Alignment of CUpti_Profiler_FlushCounterData_Params",
    ][::std::mem::align_of::<CUpti_Profiler_FlushCounterData_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_FlushCounterData_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_FlushCounterData_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_Profiler_FlushCounterData_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_FlushCounterData_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_Profiler_FlushCounterData_Params::ctx",
    ][::std::mem::offset_of!(CUpti_Profiler_FlushCounterData_Params, ctx) - 16usize];
    [
        "Offset of field: CUpti_Profiler_FlushCounterData_Params::numRangesDropped",
    ][::std::mem::offset_of!(CUpti_Profiler_FlushCounterData_Params, numRangesDropped)
        - 24usize];
    [
        "Offset of field: CUpti_Profiler_FlushCounterData_Params::numTraceBytesDropped",
    ][::std::mem::offset_of!(
        CUpti_Profiler_FlushCounterData_Params, numTraceBytesDropped
    ) - 32usize];
};
impl Default for CUpti_Profiler_FlushCounterData_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Decode all the submitted passes

 Flush Counter data API to ensure every pass is decoded into the counterDataImage passed at beginSession.
 This will cause the CPU/GPU sync to collect all the undecoded pass.

 **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h.*/
    pub fn cuptiProfilerFlushCounterData(
        pParams: *mut CUpti_Profiler_FlushCounterData_Params,
    ) -> CUptiResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_PushRange_Params {
    ///!< [in] CUpti_Profiler_PushRange_Params_STRUCT_SIZE
    pub structSize: usize,
    ///!< [in] assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    ///!< [in] if NULL, the current CUcontext is used
    pub ctx: CUcontext,
    ///!< [in] specifies the range for subsequent launches; must not be NULL
    pub pRangeName: *const ::std::os::raw::c_char,
    ///!< [in] assign to strlen(pRangeName) if known; if set to zero, the library will call strlen()
    pub rangeNameLength: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_PushRange_Params",
    ][::std::mem::size_of::<CUpti_Profiler_PushRange_Params>() - 40usize];
    [
        "Alignment of CUpti_Profiler_PushRange_Params",
    ][::std::mem::align_of::<CUpti_Profiler_PushRange_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_PushRange_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_PushRange_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_Profiler_PushRange_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_PushRange_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_Profiler_PushRange_Params::ctx",
    ][::std::mem::offset_of!(CUpti_Profiler_PushRange_Params, ctx) - 16usize];
    [
        "Offset of field: CUpti_Profiler_PushRange_Params::pRangeName",
    ][::std::mem::offset_of!(CUpti_Profiler_PushRange_Params, pRangeName) - 24usize];
    [
        "Offset of field: CUpti_Profiler_PushRange_Params::rangeNameLength",
    ][::std::mem::offset_of!(CUpti_Profiler_PushRange_Params, rangeNameLength)
        - 32usize];
};
impl Default for CUpti_Profiler_PushRange_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_PopRange_Params {
    ///!< [in] CUpti_Profiler_PopRange_Params_STRUCT_SIZE
    pub structSize: usize,
    ///!< [in] assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    ///!< [in] if NULL, the current CUcontext is used
    pub ctx: CUcontext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_PopRange_Params",
    ][::std::mem::size_of::<CUpti_Profiler_PopRange_Params>() - 24usize];
    [
        "Alignment of CUpti_Profiler_PopRange_Params",
    ][::std::mem::align_of::<CUpti_Profiler_PopRange_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_PopRange_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_PopRange_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_Profiler_PopRange_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_PopRange_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_Profiler_PopRange_Params::ctx",
    ][::std::mem::offset_of!(CUpti_Profiler_PopRange_Params, ctx) - 16usize];
};
impl Default for CUpti_Profiler_PopRange_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Range API's : Push user range

 Counter data is collected per unique range-stack. Identified by a string label passsed by the user.
 It's an invalid operation in case of \ref CUPTI_AutoRange.

 **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h.*/
    pub fn cuptiProfilerPushRange(
        pParams: *mut CUpti_Profiler_PushRange_Params,
    ) -> CUptiResult;
}
unsafe extern "C" {
    /** \brief Range API's : Pop user range

 Counter data is collected per unique range-stack. Identified by a string label passsed by the user.
 It's an invalid operation in case of \ref CUPTI_AutoRange.

 **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h.*/
    pub fn cuptiProfilerPopRange(
        pParams: *mut CUpti_Profiler_PopRange_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiProfilerGetCounterAvailability
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_GetCounterAvailability_Params {
    ///!< [in] CUpti_Profiler_GetCounterAvailability_Params_STRUCT_SIZE
    pub structSize: usize,
    ///!< [in] assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    ///!< [in] if NULL, the current CUcontext is used
    pub ctx: CUcontext,
    /**!< [in/out] If `pCounterAvailabilityImage` is NULL, then the required size is returned in
!< `counterAvailabilityImageSize`, otherwise `counterAvailabilityImageSize` should be set to the size of
!< `pCounterAvailabilityImage`, and on return it would be overwritten with number of actual bytes copied*/
    pub counterAvailabilityImageSize: usize,
    ///!< [in] buffer receiving counter availability image, may be NULL
    pub pCounterAvailabilityImage: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_GetCounterAvailability_Params",
    ][::std::mem::size_of::<CUpti_Profiler_GetCounterAvailability_Params>() - 40usize];
    [
        "Alignment of CUpti_Profiler_GetCounterAvailability_Params",
    ][::std::mem::align_of::<CUpti_Profiler_GetCounterAvailability_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_GetCounterAvailability_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_GetCounterAvailability_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_Profiler_GetCounterAvailability_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_GetCounterAvailability_Params, pPriv)
        - 8usize];
    [
        "Offset of field: CUpti_Profiler_GetCounterAvailability_Params::ctx",
    ][::std::mem::offset_of!(CUpti_Profiler_GetCounterAvailability_Params, ctx)
        - 16usize];
    [
        "Offset of field: CUpti_Profiler_GetCounterAvailability_Params::counterAvailabilityImageSize",
    ][::std::mem::offset_of!(
        CUpti_Profiler_GetCounterAvailability_Params, counterAvailabilityImageSize
    ) - 24usize];
    [
        "Offset of field: CUpti_Profiler_GetCounterAvailability_Params::pCounterAvailabilityImage",
    ][::std::mem::offset_of!(
        CUpti_Profiler_GetCounterAvailability_Params, pCounterAvailabilityImage
    ) - 32usize];
};
impl Default for CUpti_Profiler_GetCounterAvailability_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Query counter availibility

 Use this API to query counter availability information in a buffer which can be used to filter unavailable raw metrics on host.
 Note: This API may fail, if any profiling or sampling session is active on the specified context or its device.*/
    pub fn cuptiProfilerGetCounterAvailability(
        pParams: *mut CUpti_Profiler_GetCounterAvailability_Params,
    ) -> CUptiResult;
}
///!< Configuration support level unknown - either detection code errored out before setting this value, or unable to determine it
pub const CUPTI_PROFILER_CONFIGURATION_UNKNOWN: CUpti_Profiler_Support_Level = 0;
///!< Profiling is unavailable.  For specific feature fields, this means that the current configuration of this feature does not work with profiling.  For instance, SLI-enabled devices do not support profiling, and this value would be returned for SLI on an SLI-enabled device.
pub const CUPTI_PROFILER_CONFIGURATION_UNSUPPORTED: CUpti_Profiler_Support_Level = 1;
///!< Profiling would be available for this configuration, but was disabled by the system
pub const CUPTI_PROFILER_CONFIGURATION_DISABLED: CUpti_Profiler_Support_Level = 2;
///!< Profiling is supported.  For specific feature fields, this means that the current configuration of this feature works with profiling.  For instance, SLI-enabled devices do not support profiling, and this value would only be returned for devices which are not SLI-enabled.
pub const CUPTI_PROFILER_CONFIGURATION_SUPPORTED: CUpti_Profiler_Support_Level = 3;
/// Generic support level enum for CUPTI
pub type CUpti_Profiler_Support_Level = ::std::os::raw::c_uint;
///!< CUPTI APIs for range based profiling (cuptiProfiler*)
pub const CUPTI_PROFILER_RANGE_PROFILING: CUpti_Profiler_API = 0;
///!< CUPTI APIs collecting pc sampling data (cuptiPcSampling*)
pub const CUPTI_PROFILER_PC_SAMPLING: CUpti_Profiler_API = 1;
///!< CUPTI APIs collecting SASS metrics data (cuptiSassMetrics*)
pub const CUPTI_PROFILER_SASS_METRICS: CUpti_Profiler_API = 2;
///!< CUPTI APIs collecting PM Sampling data (cuptiPmSampling*)
pub const CUPTI_PROFILER_PM_SAMPLING: CUpti_Profiler_API = 3;
pub const CUPTI_PROFILER_UNKNOWN: CUpti_Profiler_API = 4;
/// \brief Profiler API types
pub type CUpti_Profiler_API = ::std::os::raw::c_uint;
/// \brief Params for cuptiProfilerDeviceSupported
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_DeviceSupported_Params {
    ///!< [in] Must be CUpti_Profiler_DeviceSupported_Params_STRUCT_SIZE
    pub structSize: usize,
    ///!< [in] assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    ///!< [in] if NULL, the current CUcontext is used
    pub cuDevice: CUdevice,
    ///!< [out] overall SUPPORTED / UNSUPPORTED flag representing whether Profiling and PC Sampling APIs work on the given device and configuration. SUPPORTED if all following flags are SUPPORTED, UNSUPPORTED otherwise.
    pub isSupported: CUpti_Profiler_Support_Level,
    ///!< [out] SUPPORTED if the device architecture level supports the Profiling API (Compute Capability >= 7.0), UNSUPPORTED otherwise
    pub architecture: CUpti_Profiler_Support_Level,
    ///!< [out] SUPPORTED if SLI is not enabled, UNSUPPORTED otherwise
    pub sli: CUpti_Profiler_Support_Level,
    ///!< [out] SUPPORTED if vGPU is supported and profiling is enabled, DISABLED if profiling is supported but not enabled, UNSUPPORTED otherwise
    pub vGpu: CUpti_Profiler_Support_Level,
    ///!< [out] SUPPORTED if confidential compute is not enabled, UNSUPPORTED otherwise
    pub confidentialCompute: CUpti_Profiler_Support_Level,
    ///!< [out] SUPPORTED if not NVIDIA Crypto Mining Processors (CMP), UNSUPPORTED otherwise
    pub cmp: CUpti_Profiler_Support_Level,
    ///!< [out] SUPPORTED if WSL supported, UNSUPPORTED otherwise
    pub wsl: CUpti_Profiler_Support_Level,
    ///!< [in] the CUPTI API type for which device support will be checked
    pub api: CUpti_Profiler_API,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Profiler_DeviceSupported_Params",
    ][::std::mem::size_of::<CUpti_Profiler_DeviceSupported_Params>() - 56usize];
    [
        "Alignment of CUpti_Profiler_DeviceSupported_Params",
    ][::std::mem::align_of::<CUpti_Profiler_DeviceSupported_Params>() - 8usize];
    [
        "Offset of field: CUpti_Profiler_DeviceSupported_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Profiler_DeviceSupported_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_Profiler_DeviceSupported_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Profiler_DeviceSupported_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_Profiler_DeviceSupported_Params::cuDevice",
    ][::std::mem::offset_of!(CUpti_Profiler_DeviceSupported_Params, cuDevice) - 16usize];
    [
        "Offset of field: CUpti_Profiler_DeviceSupported_Params::isSupported",
    ][::std::mem::offset_of!(CUpti_Profiler_DeviceSupported_Params, isSupported)
        - 20usize];
    [
        "Offset of field: CUpti_Profiler_DeviceSupported_Params::architecture",
    ][::std::mem::offset_of!(CUpti_Profiler_DeviceSupported_Params, architecture)
        - 24usize];
    [
        "Offset of field: CUpti_Profiler_DeviceSupported_Params::sli",
    ][::std::mem::offset_of!(CUpti_Profiler_DeviceSupported_Params, sli) - 28usize];
    [
        "Offset of field: CUpti_Profiler_DeviceSupported_Params::vGpu",
    ][::std::mem::offset_of!(CUpti_Profiler_DeviceSupported_Params, vGpu) - 32usize];
    [
        "Offset of field: CUpti_Profiler_DeviceSupported_Params::confidentialCompute",
    ][::std::mem::offset_of!(CUpti_Profiler_DeviceSupported_Params, confidentialCompute)
        - 36usize];
    [
        "Offset of field: CUpti_Profiler_DeviceSupported_Params::cmp",
    ][::std::mem::offset_of!(CUpti_Profiler_DeviceSupported_Params, cmp) - 40usize];
    [
        "Offset of field: CUpti_Profiler_DeviceSupported_Params::wsl",
    ][::std::mem::offset_of!(CUpti_Profiler_DeviceSupported_Params, wsl) - 44usize];
    [
        "Offset of field: CUpti_Profiler_DeviceSupported_Params::api",
    ][::std::mem::offset_of!(CUpti_Profiler_DeviceSupported_Params, api) - 48usize];
};
impl Default for CUpti_Profiler_DeviceSupported_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Query device compatibility with Profiling API

 Use this call to determine whether a compute device and configuration are compatible with the Profiling API.
 If the configuration does not support profiling, one of several flags will indicate why.*/
    pub fn cuptiProfilerDeviceSupported(
        pParams: *mut CUpti_Profiler_DeviceSupported_Params,
    ) -> CUptiResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_Object {
    _unused: [u8; 0],
}
/// \brief Params for cuptiRangeProfilerSetConfig
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_SetConfig_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Set to NULL.
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] Range Profiler Object.
    pub pRangeProfilerObject: *mut CUpti_RangeProfiler_Object,
    /// [in] Size of the config image.
    pub configSize: usize,
    /// [in] Config image.
    pub pConfig: *const u8,
    /// [in] Size of the counter data image.
    pub counterDataImageSize: usize,
    /// [in] Counter data image.
    pub pCounterDataImage: *mut u8,
    /// [in] Profiling Range mode.
    pub range: CUpti_ProfilerRange,
    /// [in] Replay mode.
    pub replayMode: CUpti_ProfilerReplayMode,
    /// [in] Maximum number of ranges that can be profiled in a pass.
    pub maxRangesPerPass: usize,
    /// [in] number of nesting level to be profiled. For Auto range mode, this should be set to 1.
    pub numNestingLevels: u16,
    /// [in] minimum nesting level to be profiled.
    pub minNestingLevel: u16,
    /// [in] Pass index for the replay session.
    pub passIndex: usize,
    /// [in] Target nesting level for the replay session.
    pub targetNestingLevel: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_RangeProfiler_SetConfig_Params",
    ][::std::mem::size_of::<CUpti_RangeProfiler_SetConfig_Params>() - 96usize];
    [
        "Alignment of CUpti_RangeProfiler_SetConfig_Params",
    ][::std::mem::align_of::<CUpti_RangeProfiler_SetConfig_Params>() - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_SetConfig_Params::structSize",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_RangeProfiler_SetConfig_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_SetConfig_Params::pRangeProfilerObject",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, pRangeProfilerObject)
        - 16usize];
    [
        "Offset of field: CUpti_RangeProfiler_SetConfig_Params::configSize",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, configSize)
        - 24usize];
    [
        "Offset of field: CUpti_RangeProfiler_SetConfig_Params::pConfig",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, pConfig) - 32usize];
    [
        "Offset of field: CUpti_RangeProfiler_SetConfig_Params::counterDataImageSize",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, counterDataImageSize)
        - 40usize];
    [
        "Offset of field: CUpti_RangeProfiler_SetConfig_Params::pCounterDataImage",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, pCounterDataImage)
        - 48usize];
    [
        "Offset of field: CUpti_RangeProfiler_SetConfig_Params::range",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, range) - 56usize];
    [
        "Offset of field: CUpti_RangeProfiler_SetConfig_Params::replayMode",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, replayMode)
        - 60usize];
    [
        "Offset of field: CUpti_RangeProfiler_SetConfig_Params::maxRangesPerPass",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, maxRangesPerPass)
        - 64usize];
    [
        "Offset of field: CUpti_RangeProfiler_SetConfig_Params::numNestingLevels",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, numNestingLevels)
        - 72usize];
    [
        "Offset of field: CUpti_RangeProfiler_SetConfig_Params::minNestingLevel",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, minNestingLevel)
        - 74usize];
    [
        "Offset of field: CUpti_RangeProfiler_SetConfig_Params::passIndex",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, passIndex) - 80usize];
    [
        "Offset of field: CUpti_RangeProfiler_SetConfig_Params::targetNestingLevel",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, targetNestingLevel)
        - 88usize];
};
impl Default for CUpti_RangeProfiler_SetConfig_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Set the configuration for range profiler like maximum number of ranges per pass, number of nesting levels,
 range and replay mode and the config image which has scheduling info for metric collection.

 \param pParams A pointer to \ref CUpti_RangeProfiler_SetConfig_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid*/
    pub fn cuptiRangeProfilerSetConfig(
        pParams: *mut CUpti_RangeProfiler_SetConfig_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiRangeProfilerEnable
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_Enable_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Set to NULL.
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] Context to be used for profiling.
    pub ctx: CUcontext,
    /// [out] Range Profiler Object.
    pub pRangeProfilerObject: *mut CUpti_RangeProfiler_Object,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_RangeProfiler_Enable_Params",
    ][::std::mem::size_of::<CUpti_RangeProfiler_Enable_Params>() - 32usize];
    [
        "Alignment of CUpti_RangeProfiler_Enable_Params",
    ][::std::mem::align_of::<CUpti_RangeProfiler_Enable_Params>() - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_Enable_Params::structSize",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_Enable_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_RangeProfiler_Enable_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_Enable_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_Enable_Params::ctx",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_Enable_Params, ctx) - 16usize];
    [
        "Offset of field: CUpti_RangeProfiler_Enable_Params::pRangeProfilerObject",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_Enable_Params, pRangeProfilerObject)
        - 24usize];
};
impl Default for CUpti_RangeProfiler_Enable_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Create a range profiler object and enable range profiling on the CUDA context.

 \param pParams A pointer to \ref CUpti_RangeProfiler_Enable_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_OUT_OF_MEMORY if memory allocation fails while creating the PM sampling object
 \retval CUPTI_ERROR_INSUFFICIENT_PRIVILEGES if the user does not have sufficient privileges to perform the operation
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiRangeProfilerEnable(
        pParams: *mut CUpti_RangeProfiler_Enable_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiRangeProfilerDisable
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_Disable_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Set to NULL.
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] Range Profiler Object.
    pub pRangeProfilerObject: *mut CUpti_RangeProfiler_Object,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_RangeProfiler_Disable_Params",
    ][::std::mem::size_of::<CUpti_RangeProfiler_Disable_Params>() - 24usize];
    [
        "Alignment of CUpti_RangeProfiler_Disable_Params",
    ][::std::mem::align_of::<CUpti_RangeProfiler_Disable_Params>() - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_Disable_Params::structSize",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_Disable_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_RangeProfiler_Disable_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_Disable_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_Disable_Params::pRangeProfilerObject",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_Disable_Params, pRangeProfilerObject)
        - 16usize];
};
impl Default for CUpti_RangeProfiler_Disable_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Disable the range profiler on the CUDA context and destroy the range profiler object.

 \param pParams A pointer to \ref CUpti_RangeProfiler_Disable_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid*/
    pub fn cuptiRangeProfilerDisable(
        pParams: *mut CUpti_RangeProfiler_Disable_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiRangeProfilerStart
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_Start_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Set to NULL.
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] Range Profiler Object.
    pub pRangeProfilerObject: *mut CUpti_RangeProfiler_Object,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_RangeProfiler_Start_Params",
    ][::std::mem::size_of::<CUpti_RangeProfiler_Start_Params>() - 24usize];
    [
        "Alignment of CUpti_RangeProfiler_Start_Params",
    ][::std::mem::align_of::<CUpti_RangeProfiler_Start_Params>() - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_Start_Params::structSize",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_Start_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_RangeProfiler_Start_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_Start_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_Start_Params::pRangeProfilerObject",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_Start_Params, pRangeProfilerObject)
        - 16usize];
};
impl Default for CUpti_RangeProfiler_Start_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Start the range profiler.

 \param pParams A pointer to \ref CUpti_RangeProfiler_Start_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_INVALID_OPERATION if range profiler Start is called without enabling range profiler
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiRangeProfilerStart(
        pParams: *mut CUpti_RangeProfiler_Start_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiRangeProfilerStop
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_Stop_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Set to NULL.
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] Range Profiler Object.
    pub pRangeProfilerObject: *mut CUpti_RangeProfiler_Object,
    /// [out] pass index for the replay session.
    pub passIndex: usize,
    /// [out] target nesting level for the replay session.
    pub targetNestingLevel: usize,
    /// [out] 1 if all passes are submitted to GPU for collection, 0 otherwise.
    pub isAllPassSubmitted: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_RangeProfiler_Stop_Params",
    ][::std::mem::size_of::<CUpti_RangeProfiler_Stop_Params>() - 48usize];
    [
        "Alignment of CUpti_RangeProfiler_Stop_Params",
    ][::std::mem::align_of::<CUpti_RangeProfiler_Stop_Params>() - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_Stop_Params::structSize",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_Stop_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_RangeProfiler_Stop_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_Stop_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_Stop_Params::pRangeProfilerObject",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_Stop_Params, pRangeProfilerObject)
        - 16usize];
    [
        "Offset of field: CUpti_RangeProfiler_Stop_Params::passIndex",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_Stop_Params, passIndex) - 24usize];
    [
        "Offset of field: CUpti_RangeProfiler_Stop_Params::targetNestingLevel",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_Stop_Params, targetNestingLevel)
        - 32usize];
    [
        "Offset of field: CUpti_RangeProfiler_Stop_Params::isAllPassSubmitted",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_Stop_Params, isAllPassSubmitted)
        - 40usize];
};
impl Default for CUpti_RangeProfiler_Stop_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Stop the range profiler.

 \param pParams A pointer to \ref CUpti_RangeProfiler_Stop_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_INVALID_OPERATION if range profiler Stop is called without enabling range profiler
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiRangeProfilerStop(
        pParams: *mut CUpti_RangeProfiler_Stop_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiRangeProfilerPushRange
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_PushRange_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Set to NULL.
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] Range Profiler Object.
    pub pRangeProfilerObject: *mut CUpti_RangeProfiler_Object,
    /// [in] Name of the range to be profiled (only valid for User range mode).
    pub pRangeName: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_RangeProfiler_PushRange_Params",
    ][::std::mem::size_of::<CUpti_RangeProfiler_PushRange_Params>() - 32usize];
    [
        "Alignment of CUpti_RangeProfiler_PushRange_Params",
    ][::std::mem::align_of::<CUpti_RangeProfiler_PushRange_Params>() - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_PushRange_Params::structSize",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_PushRange_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_RangeProfiler_PushRange_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_PushRange_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_PushRange_Params::pRangeProfilerObject",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_PushRange_Params, pRangeProfilerObject)
        - 16usize];
    [
        "Offset of field: CUpti_RangeProfiler_PushRange_Params::pRangeName",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_PushRange_Params, pRangeName)
        - 24usize];
};
impl Default for CUpti_RangeProfiler_PushRange_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Add a new range to the Range Profiler with a given range name.
 For nested ranges, this API should be called again for the innermost range. For profiling the nested
 range, users need to set the values for minNestingLevel and numNestingLevels in the SetConfig API.

 \param pParams A pointer to \ref CUpti_RangeProfiler_PushRange_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_INVALID_OPERATION if range profiler PushRange is called without enabling range profiler
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiRangeProfilerPushRange(
        pParams: *mut CUpti_RangeProfiler_PushRange_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiRangeProfilerPopRange
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_PopRange_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Set to NULL.
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] Range Profiler Object.
    pub pRangeProfilerObject: *mut CUpti_RangeProfiler_Object,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_RangeProfiler_PopRange_Params",
    ][::std::mem::size_of::<CUpti_RangeProfiler_PopRange_Params>() - 24usize];
    [
        "Alignment of CUpti_RangeProfiler_PopRange_Params",
    ][::std::mem::align_of::<CUpti_RangeProfiler_PopRange_Params>() - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_PopRange_Params::structSize",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_PopRange_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_RangeProfiler_PopRange_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_PopRange_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_PopRange_Params::pRangeProfilerObject",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_PopRange_Params, pRangeProfilerObject)
        - 16usize];
};
impl Default for CUpti_RangeProfiler_PopRange_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief pop the current range to the Range Profiler.
 The number of pop range API call should be same as number of push ranges in the same order.

 \param pParams A pointer to \ref CUpti_RangeProfiler_PopRange_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_INVALID_OPERATION if range profiler PopRange is called without enabling range profiler
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiRangeProfilerPopRange(
        pParams: *mut CUpti_RangeProfiler_PopRange_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiRangeProfilerDecodeData
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_DecodeData_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Set to NULL.
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] Range Profiler Object.
    pub pRangeProfilerObject: *mut CUpti_RangeProfiler_Object,
    /// [out] Number of ranges dropped in the processed passes.
    pub numOfRangeDropped: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_RangeProfiler_DecodeData_Params",
    ][::std::mem::size_of::<CUpti_RangeProfiler_DecodeData_Params>() - 32usize];
    [
        "Alignment of CUpti_RangeProfiler_DecodeData_Params",
    ][::std::mem::align_of::<CUpti_RangeProfiler_DecodeData_Params>() - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_DecodeData_Params::structSize",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_DecodeData_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_RangeProfiler_DecodeData_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_DecodeData_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_DecodeData_Params::pRangeProfilerObject",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_DecodeData_Params, pRangeProfilerObject)
        - 16usize];
    [
        "Offset of field: CUpti_RangeProfiler_DecodeData_Params::numOfRangeDropped",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_DecodeData_Params, numOfRangeDropped)
        - 24usize];
};
impl Default for CUpti_RangeProfiler_DecodeData_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Decode the profiling data stored in the hardware to the counter data image passed in the
 SetConfig API. This API should be called after cuptiRangeProfilerStop. The counter data image
 will be updated with the profiling data for the ranges profiled.

 For the cases where the number of ranges counter data image can store is less than the number of ranges
 profiled (= maxRangesPerPass in SetConfig API), the counter data image will report dropped ranges.

 \param pParams A pointer to \ref CUpti_RangeProfiler_DecodeData_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_INVALID_OPERATION if range profiler DecodeData is called without enabling range profiler
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiRangeProfilerDecodeData(
        pParams: *mut CUpti_RangeProfiler_DecodeData_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiRangeProfilerGetCounterDataSize
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_GetCounterDataSize_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Set to NULL.
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] Periodic sampler object.
    pub pRangeProfilerObject: *mut CUpti_RangeProfiler_Object,
    /// [in] Names of the metrics to be collected.
    pub pMetricNames: *mut *const ::std::os::raw::c_char,
    /// [in] Number of metrics to be collected.
    pub numMetrics: usize,
    /// [in] Maximum number of ranges to be stored in the counter data image.
    pub maxNumOfRanges: usize,
    /// [in] Maximum number of RangeTree nodes; must be >= maxNumOfRanges
    pub maxNumRangeTreeNodes: u32,
    /// [out] Size of the counter data image.
    pub counterDataSize: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_RangeProfiler_GetCounterDataSize_Params",
    ][::std::mem::size_of::<CUpti_RangeProfiler_GetCounterDataSize_Params>() - 64usize];
    [
        "Alignment of CUpti_RangeProfiler_GetCounterDataSize_Params",
    ][::std::mem::align_of::<CUpti_RangeProfiler_GetCounterDataSize_Params>() - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_GetCounterDataSize_Params::structSize",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_GetCounterDataSize_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_RangeProfiler_GetCounterDataSize_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_GetCounterDataSize_Params, pPriv)
        - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_GetCounterDataSize_Params::pRangeProfilerObject",
    ][::std::mem::offset_of!(
        CUpti_RangeProfiler_GetCounterDataSize_Params, pRangeProfilerObject
    ) - 16usize];
    [
        "Offset of field: CUpti_RangeProfiler_GetCounterDataSize_Params::pMetricNames",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_GetCounterDataSize_Params, pMetricNames)
        - 24usize];
    [
        "Offset of field: CUpti_RangeProfiler_GetCounterDataSize_Params::numMetrics",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_GetCounterDataSize_Params, numMetrics)
        - 32usize];
    [
        "Offset of field: CUpti_RangeProfiler_GetCounterDataSize_Params::maxNumOfRanges",
    ][::std::mem::offset_of!(
        CUpti_RangeProfiler_GetCounterDataSize_Params, maxNumOfRanges
    ) - 40usize];
    [
        "Offset of field: CUpti_RangeProfiler_GetCounterDataSize_Params::maxNumRangeTreeNodes",
    ][::std::mem::offset_of!(
        CUpti_RangeProfiler_GetCounterDataSize_Params, maxNumRangeTreeNodes
    ) - 48usize];
    [
        "Offset of field: CUpti_RangeProfiler_GetCounterDataSize_Params::counterDataSize",
    ][::std::mem::offset_of!(
        CUpti_RangeProfiler_GetCounterDataSize_Params, counterDataSize
    ) - 56usize];
};
impl Default for CUpti_RangeProfiler_GetCounterDataSize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Get the size of the counter data image required to store the profiling data for the ranges profiled.

 \param pParams A pointer to \ref CUpti_RangeProfiler_GetCounterDataSize_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_INVALID_OPERATION if range profiler GetCounterDataSize is called without enabling range profiler
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiRangeProfilerGetCounterDataSize(
        pParams: *mut CUpti_RangeProfiler_GetCounterDataSize_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiRangeProfilerCounterDataImageInitialize
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_CounterDataImage_Initialize_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Set to NULL.
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] Periodic sampler object.
    pub pRangeProfilerObject: *mut CUpti_RangeProfiler_Object,
    /// [in] Size of the counter data image.
    pub counterDataSize: usize,
    /// [in] Counter data image.
    pub pCounterData: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_RangeProfiler_CounterDataImage_Initialize_Params",
    ][::std::mem::size_of::<CUpti_RangeProfiler_CounterDataImage_Initialize_Params>()
        - 40usize];
    [
        "Alignment of CUpti_RangeProfiler_CounterDataImage_Initialize_Params",
    ][::std::mem::align_of::<CUpti_RangeProfiler_CounterDataImage_Initialize_Params>()
        - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_CounterDataImage_Initialize_Params::structSize",
    ][::std::mem::offset_of!(
        CUpti_RangeProfiler_CounterDataImage_Initialize_Params, structSize
    ) - 0usize];
    [
        "Offset of field: CUpti_RangeProfiler_CounterDataImage_Initialize_Params::pPriv",
    ][::std::mem::offset_of!(
        CUpti_RangeProfiler_CounterDataImage_Initialize_Params, pPriv
    ) - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_CounterDataImage_Initialize_Params::pRangeProfilerObject",
    ][::std::mem::offset_of!(
        CUpti_RangeProfiler_CounterDataImage_Initialize_Params, pRangeProfilerObject
    ) - 16usize];
    [
        "Offset of field: CUpti_RangeProfiler_CounterDataImage_Initialize_Params::counterDataSize",
    ][::std::mem::offset_of!(
        CUpti_RangeProfiler_CounterDataImage_Initialize_Params, counterDataSize
    ) - 24usize];
    [
        "Offset of field: CUpti_RangeProfiler_CounterDataImage_Initialize_Params::pCounterData",
    ][::std::mem::offset_of!(
        CUpti_RangeProfiler_CounterDataImage_Initialize_Params, pCounterData
    ) - 32usize];
};
impl Default for CUpti_RangeProfiler_CounterDataImage_Initialize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Initialize the counter data image with the profiling data for the ranges profiled.

 \param pParams A pointer to \ref CUpti_RangeProfiler_CounterDataImage_Initialize_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_INVALID_OPERATION if range profiler CounterDataImageInitialize is called without enabling range profiler
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiRangeProfilerCounterDataImageInitialize(
        pParams: *mut CUpti_RangeProfiler_CounterDataImage_Initialize_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiRangeProfilerGetCounterDataInfo
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_GetCounterDataInfo_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Set to NULL.
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] Counter data image.
    pub pCounterDataImage: *const u8,
    /// [in] Size of the counter data image.
    pub counterDataImageSize: usize,
    /// [out] Number of ranges in the counter data image.
    pub numTotalRanges: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_RangeProfiler_GetCounterDataInfo_Params",
    ][::std::mem::size_of::<CUpti_RangeProfiler_GetCounterDataInfo_Params>() - 40usize];
    [
        "Alignment of CUpti_RangeProfiler_GetCounterDataInfo_Params",
    ][::std::mem::align_of::<CUpti_RangeProfiler_GetCounterDataInfo_Params>() - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_GetCounterDataInfo_Params::structSize",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_GetCounterDataInfo_Params, structSize)
        - 0usize];
    [
        "Offset of field: CUpti_RangeProfiler_GetCounterDataInfo_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_GetCounterDataInfo_Params, pPriv)
        - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_GetCounterDataInfo_Params::pCounterDataImage",
    ][::std::mem::offset_of!(
        CUpti_RangeProfiler_GetCounterDataInfo_Params, pCounterDataImage
    ) - 16usize];
    [
        "Offset of field: CUpti_RangeProfiler_GetCounterDataInfo_Params::counterDataImageSize",
    ][::std::mem::offset_of!(
        CUpti_RangeProfiler_GetCounterDataInfo_Params, counterDataImageSize
    ) - 24usize];
    [
        "Offset of field: CUpti_RangeProfiler_GetCounterDataInfo_Params::numTotalRanges",
    ][::std::mem::offset_of!(
        CUpti_RangeProfiler_GetCounterDataInfo_Params, numTotalRanges
    ) - 32usize];
};
impl Default for CUpti_RangeProfiler_GetCounterDataInfo_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Get the number of ranges stored in the counter data image.

 \param pParams A pointer to \ref CUpti_RangeProfiler_GetCounterDataInfo_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiRangeProfilerGetCounterDataInfo(
        pParams: *mut CUpti_RangeProfiler_GetCounterDataInfo_Params,
    ) -> CUptiResult;
}
/// \brief Params for cuptiRangeProfilerCounterDataGetRangeInfo
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_CounterData_GetRangeInfo_Params {
    /// [in] Size of the data structure.
    pub structSize: usize,
    /// [in] Set to NULL.
    pub pPriv: *mut ::std::os::raw::c_void,
    /// [in] Counter data image.
    pub pCounterDataImage: *const u8,
    /// [in] Size of the counter data image.
    pub counterDataImageSize: usize,
    /// [in] Index of the sample.
    pub rangeIndex: usize,
    /// [in] range delimiter.
    pub rangeDelimiter: *const ::std::os::raw::c_char,
    /// [out] RangeName;
    pub rangeName: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_RangeProfiler_CounterData_GetRangeInfo_Params",
    ][::std::mem::size_of::<CUpti_RangeProfiler_CounterData_GetRangeInfo_Params>()
        - 56usize];
    [
        "Alignment of CUpti_RangeProfiler_CounterData_GetRangeInfo_Params",
    ][::std::mem::align_of::<CUpti_RangeProfiler_CounterData_GetRangeInfo_Params>()
        - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_CounterData_GetRangeInfo_Params::structSize",
    ][::std::mem::offset_of!(
        CUpti_RangeProfiler_CounterData_GetRangeInfo_Params, structSize
    ) - 0usize];
    [
        "Offset of field: CUpti_RangeProfiler_CounterData_GetRangeInfo_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_RangeProfiler_CounterData_GetRangeInfo_Params, pPriv)
        - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_CounterData_GetRangeInfo_Params::pCounterDataImage",
    ][::std::mem::offset_of!(
        CUpti_RangeProfiler_CounterData_GetRangeInfo_Params, pCounterDataImage
    ) - 16usize];
    [
        "Offset of field: CUpti_RangeProfiler_CounterData_GetRangeInfo_Params::counterDataImageSize",
    ][::std::mem::offset_of!(
        CUpti_RangeProfiler_CounterData_GetRangeInfo_Params, counterDataImageSize
    ) - 24usize];
    [
        "Offset of field: CUpti_RangeProfiler_CounterData_GetRangeInfo_Params::rangeIndex",
    ][::std::mem::offset_of!(
        CUpti_RangeProfiler_CounterData_GetRangeInfo_Params, rangeIndex
    ) - 32usize];
    [
        "Offset of field: CUpti_RangeProfiler_CounterData_GetRangeInfo_Params::rangeDelimiter",
    ][::std::mem::offset_of!(
        CUpti_RangeProfiler_CounterData_GetRangeInfo_Params, rangeDelimiter
    ) - 40usize];
    [
        "Offset of field: CUpti_RangeProfiler_CounterData_GetRangeInfo_Params::rangeName",
    ][::std::mem::offset_of!(
        CUpti_RangeProfiler_CounterData_GetRangeInfo_Params, rangeName
    ) - 48usize];
};
impl Default for CUpti_RangeProfiler_CounterData_GetRangeInfo_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    /** \brief Get the range name for the given range index.

 \param pParams A pointer to \ref CUpti_RangeProfiler_CounterData_GetRangeInfo_Params

 \retval CUPTI_SUCCESS
 \retval CUPTI_ERROR_INVALID_PARAMETER if any \p pParams is not valid
 \retval CUPTI_ERROR_UNKNOWN for any internal error*/
    pub fn cuptiRangeProfilerCounterDataGetRangeInfo(
        pParams: *mut CUpti_RangeProfiler_CounterData_GetRangeInfo_Params,
    ) -> CUptiResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Device_GetChipName_Params {
    ///!< [in]
    pub structSize: usize,
    ///!< [in] assign to NULL
    pub pPriv: *mut ::std::os::raw::c_void,
    ///!< [in]
    pub deviceIndex: usize,
    ///!< [out]
    pub pChipName: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CUpti_Device_GetChipName_Params",
    ][::std::mem::size_of::<CUpti_Device_GetChipName_Params>() - 32usize];
    [
        "Alignment of CUpti_Device_GetChipName_Params",
    ][::std::mem::align_of::<CUpti_Device_GetChipName_Params>() - 8usize];
    [
        "Offset of field: CUpti_Device_GetChipName_Params::structSize",
    ][::std::mem::offset_of!(CUpti_Device_GetChipName_Params, structSize) - 0usize];
    [
        "Offset of field: CUpti_Device_GetChipName_Params::pPriv",
    ][::std::mem::offset_of!(CUpti_Device_GetChipName_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_Device_GetChipName_Params::deviceIndex",
    ][::std::mem::offset_of!(CUpti_Device_GetChipName_Params, deviceIndex) - 16usize];
    [
        "Offset of field: CUpti_Device_GetChipName_Params::pChipName",
    ][::std::mem::offset_of!(CUpti_Device_GetChipName_Params, pChipName) - 24usize];
};
impl Default for CUpti_Device_GetChipName_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn cuptiDeviceGetChipName(
        pParams: *mut CUpti_Device_GetChipName_Params,
    ) -> CUptiResult;
}
