/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
pub const CUPTI_API_VERSION: u32 = 130001;
pub const CUPTI_SUBSCRIBER_NAME_MAX_LEN: u32 = 53;
pub const CUPTI_OLD_SUBSCRIBER_NAME_MIN_LEN: u32 = 64;
pub const CUPTILP64: u32 = 1;
pub const CUPTI_SOURCE_LOCATOR_ID_UNKNOWN: u32 = 0;
pub const CUPTI_FUNCTION_INDEX_ID_INVALID: u32 = 0;
pub const CUPTI_CORRELATION_ID_UNKNOWN: u32 = 0;
pub const CUPTI_GRID_ID_UNKNOWN: u32 = 0;
pub const CUPTI_TIMESTAMP_UNKNOWN: u32 = 0;
pub const CUPTI_AUTO_BOOST_INVALID_CLIENT_PID: u32 = 0;
pub const CUPTI_NVLINK_INVALID_PORT: i32 = -1;
pub const CUPTI_MAX_NVLINK_PORTS: u32 = 32;
pub const CUPTI_DECOMPRESSED_BYTES_UNKNOWN: u32 = 0;
pub const CUPTI_MAX_GPUS: u32 = 32;
pub const CUPTI_STALL_REASON_STRING_SIZE: u32 = 128;
pub type CUdevice_v1 = ::std::os::raw::c_int;
pub type CUdevice = CUdevice_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUctx_st {
    _unused: [u8; 0],
}
pub type CUcontext = *mut CUctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUevent_st {
    _unused: [u8; 0],
}
pub type CUevent = *mut CUevent_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUstream_st {
    _unused: [u8; 0],
}
pub type CUstream = *mut CUstream_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraph_st {
    _unused: [u8; 0],
}
pub type CUgraph = *mut CUgraph_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphNode_st {
    _unused: [u8; 0],
}
pub type CUgraphNode = *mut CUgraphNode_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphExec_st {
    _unused: [u8; 0],
}
pub type CUgraphExec = *mut CUgraphExec_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUgraphDeviceUpdatableNode_st {
    _unused: [u8; 0],
}
pub type CUgraphDeviceNode = *mut CUgraphDeviceUpdatableNode_st;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUuuid_st {
    pub bytes: [::std::os::raw::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUuuid_st"][::std::mem::size_of::<CUuuid_st>() - 16usize];
    ["Alignment of CUuuid_st"][::std::mem::align_of::<CUuuid_st>() - 1usize];
    ["Offset of field: CUuuid_st::bytes"][::std::mem::offset_of!(CUuuid_st, bytes) - 0usize];
};
pub type CUuuid = CUuuid_st;
#[doc = "< Maximum number of threads per block"]
pub const CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK: CUdevice_attribute_enum = 1;
#[doc = "< Maximum block dimension X"]
pub const CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X: CUdevice_attribute_enum = 2;
#[doc = "< Maximum block dimension Y"]
pub const CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y: CUdevice_attribute_enum = 3;
#[doc = "< Maximum block dimension Z"]
pub const CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z: CUdevice_attribute_enum = 4;
#[doc = "< Maximum grid dimension X"]
pub const CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X: CUdevice_attribute_enum = 5;
#[doc = "< Maximum grid dimension Y"]
pub const CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y: CUdevice_attribute_enum = 6;
#[doc = "< Maximum grid dimension Z"]
pub const CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z: CUdevice_attribute_enum = 7;
#[doc = "< Maximum shared memory available per block in bytes"]
pub const CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK: CUdevice_attribute_enum = 8;
#[doc = "< Deprecated, use CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK"]
pub const CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK: CUdevice_attribute_enum = 8;
#[doc = "< Memory available on device for __constant__ variables in a CUDA C kernel in bytes"]
pub const CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY: CUdevice_attribute_enum = 9;
#[doc = "< Warp size in threads"]
pub const CU_DEVICE_ATTRIBUTE_WARP_SIZE: CUdevice_attribute_enum = 10;
#[doc = "< Maximum pitch in bytes allowed by memory copies"]
pub const CU_DEVICE_ATTRIBUTE_MAX_PITCH: CUdevice_attribute_enum = 11;
#[doc = "< Maximum number of 32-bit registers available per block"]
pub const CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK: CUdevice_attribute_enum = 12;
#[doc = "< Deprecated, use CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK"]
pub const CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK: CUdevice_attribute_enum = 12;
#[doc = "< Typical clock frequency in kilohertz"]
pub const CU_DEVICE_ATTRIBUTE_CLOCK_RATE: CUdevice_attribute_enum = 13;
#[doc = "< Alignment requirement for textures"]
pub const CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT: CUdevice_attribute_enum = 14;
#[doc = "< Device can possibly copy memory and execute a kernel concurrently. Deprecated. Use instead CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT."]
pub const CU_DEVICE_ATTRIBUTE_GPU_OVERLAP: CUdevice_attribute_enum = 15;
#[doc = "< Number of multiprocessors on device"]
pub const CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT: CUdevice_attribute_enum = 16;
#[doc = "< Specifies whether there is a run time limit on kernels"]
pub const CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT: CUdevice_attribute_enum = 17;
#[doc = "< Device is integrated with host memory"]
pub const CU_DEVICE_ATTRIBUTE_INTEGRATED: CUdevice_attribute_enum = 18;
#[doc = "< Device can map host memory into CUDA address space"]
pub const CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY: CUdevice_attribute_enum = 19;
#[doc = "< Compute mode (See ::CUcomputemode for details)"]
pub const CU_DEVICE_ATTRIBUTE_COMPUTE_MODE: CUdevice_attribute_enum = 20;
#[doc = "< Maximum 1D texture width"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH: CUdevice_attribute_enum = 21;
#[doc = "< Maximum 2D texture width"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH: CUdevice_attribute_enum = 22;
#[doc = "< Maximum 2D texture height"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT: CUdevice_attribute_enum = 23;
#[doc = "< Maximum 3D texture width"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH: CUdevice_attribute_enum = 24;
#[doc = "< Maximum 3D texture height"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT: CUdevice_attribute_enum = 25;
#[doc = "< Maximum 3D texture depth"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH: CUdevice_attribute_enum = 26;
#[doc = "< Maximum 2D layered texture width"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH: CUdevice_attribute_enum = 27;
#[doc = "< Maximum 2D layered texture height"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT: CUdevice_attribute_enum = 28;
#[doc = "< Maximum layers in a 2D layered texture"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS: CUdevice_attribute_enum = 29;
#[doc = "< Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH: CUdevice_attribute_enum = 27;
#[doc = "< Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT: CUdevice_attribute_enum = 28;
#[doc = "< Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES: CUdevice_attribute_enum = 29;
#[doc = "< Alignment requirement for surfaces"]
pub const CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT: CUdevice_attribute_enum = 30;
#[doc = "< Device can possibly execute multiple kernels concurrently"]
pub const CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS: CUdevice_attribute_enum = 31;
#[doc = "< Device has ECC support enabled"]
pub const CU_DEVICE_ATTRIBUTE_ECC_ENABLED: CUdevice_attribute_enum = 32;
#[doc = "< PCI bus ID of the device"]
pub const CU_DEVICE_ATTRIBUTE_PCI_BUS_ID: CUdevice_attribute_enum = 33;
#[doc = "< PCI device ID of the device"]
pub const CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID: CUdevice_attribute_enum = 34;
#[doc = "< Device is using TCC driver model"]
pub const CU_DEVICE_ATTRIBUTE_TCC_DRIVER: CUdevice_attribute_enum = 35;
#[doc = "< Peak memory clock frequency in kilohertz"]
pub const CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE: CUdevice_attribute_enum = 36;
#[doc = "< Global memory bus width in bits"]
pub const CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH: CUdevice_attribute_enum = 37;
#[doc = "< Size of L2 cache in bytes"]
pub const CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE: CUdevice_attribute_enum = 38;
#[doc = "< Maximum resident threads per multiprocessor"]
pub const CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR: CUdevice_attribute_enum = 39;
#[doc = "< Number of asynchronous engines"]
pub const CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT: CUdevice_attribute_enum = 40;
#[doc = "< Device shares a unified address space with the host"]
pub const CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING: CUdevice_attribute_enum = 41;
#[doc = "< Maximum 1D layered texture width"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH: CUdevice_attribute_enum = 42;
#[doc = "< Maximum layers in a 1D layered texture"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS: CUdevice_attribute_enum = 43;
#[doc = "< Deprecated, do not use."]
pub const CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER: CUdevice_attribute_enum = 44;
#[doc = "< Maximum 2D texture width if CUDA_ARRAY3D_TEXTURE_GATHER is set"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH: CUdevice_attribute_enum = 45;
#[doc = "< Maximum 2D texture height if CUDA_ARRAY3D_TEXTURE_GATHER is set"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT: CUdevice_attribute_enum = 46;
#[doc = "< Alternate maximum 3D texture width"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE: CUdevice_attribute_enum = 47;
#[doc = "< Alternate maximum 3D texture height"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE: CUdevice_attribute_enum = 48;
#[doc = "< Alternate maximum 3D texture depth"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE: CUdevice_attribute_enum = 49;
#[doc = "< PCI domain ID of the device"]
pub const CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID: CUdevice_attribute_enum = 50;
#[doc = "< Pitch alignment requirement for textures"]
pub const CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT: CUdevice_attribute_enum = 51;
#[doc = "< Maximum cubemap texture width/height"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH: CUdevice_attribute_enum = 52;
#[doc = "< Maximum cubemap layered texture width/height"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH: CUdevice_attribute_enum = 53;
#[doc = "< Maximum layers in a cubemap layered texture"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS: CUdevice_attribute_enum = 54;
#[doc = "< Maximum 1D surface width"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH: CUdevice_attribute_enum = 55;
#[doc = "< Maximum 2D surface width"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH: CUdevice_attribute_enum = 56;
#[doc = "< Maximum 2D surface height"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT: CUdevice_attribute_enum = 57;
#[doc = "< Maximum 3D surface width"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH: CUdevice_attribute_enum = 58;
#[doc = "< Maximum 3D surface height"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT: CUdevice_attribute_enum = 59;
#[doc = "< Maximum 3D surface depth"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH: CUdevice_attribute_enum = 60;
#[doc = "< Maximum 1D layered surface width"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH: CUdevice_attribute_enum = 61;
#[doc = "< Maximum layers in a 1D layered surface"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS: CUdevice_attribute_enum = 62;
#[doc = "< Maximum 2D layered surface width"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH: CUdevice_attribute_enum = 63;
#[doc = "< Maximum 2D layered surface height"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT: CUdevice_attribute_enum = 64;
#[doc = "< Maximum layers in a 2D layered surface"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS: CUdevice_attribute_enum = 65;
#[doc = "< Maximum cubemap surface width"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH: CUdevice_attribute_enum = 66;
#[doc = "< Maximum cubemap layered surface width"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH: CUdevice_attribute_enum = 67;
#[doc = "< Maximum layers in a cubemap layered surface"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS: CUdevice_attribute_enum = 68;
#[doc = "< Deprecated, do not use. Use cudaDeviceGetTexture1DLinearMaxWidth() or cuDeviceGetTexture1DLinearMaxWidth() instead."]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH: CUdevice_attribute_enum = 69;
#[doc = "< Maximum 2D linear texture width"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH: CUdevice_attribute_enum = 70;
#[doc = "< Maximum 2D linear texture height"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT: CUdevice_attribute_enum = 71;
#[doc = "< Maximum 2D linear texture pitch in bytes"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH: CUdevice_attribute_enum = 72;
#[doc = "< Maximum mipmapped 2D texture width"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH: CUdevice_attribute_enum = 73;
#[doc = "< Maximum mipmapped 2D texture height"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT: CUdevice_attribute_enum = 74;
#[doc = "< Major compute capability version number"]
pub const CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR: CUdevice_attribute_enum = 75;
#[doc = "< Minor compute capability version number"]
pub const CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR: CUdevice_attribute_enum = 76;
#[doc = "< Maximum mipmapped 1D texture width"]
pub const CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH: CUdevice_attribute_enum = 77;
#[doc = "< Device supports stream priorities"]
pub const CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED: CUdevice_attribute_enum = 78;
#[doc = "< Device supports caching globals in L1"]
pub const CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED: CUdevice_attribute_enum = 79;
#[doc = "< Device supports caching locals in L1"]
pub const CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED: CUdevice_attribute_enum = 80;
#[doc = "< Maximum shared memory available per multiprocessor in bytes"]
pub const CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR: CUdevice_attribute_enum = 81;
#[doc = "< Maximum number of 32-bit registers available per multiprocessor"]
pub const CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR: CUdevice_attribute_enum = 82;
#[doc = "< Device can allocate managed memory on this system"]
pub const CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY: CUdevice_attribute_enum = 83;
#[doc = "< Device is on a multi-GPU board"]
pub const CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD: CUdevice_attribute_enum = 84;
#[doc = "< Unique id for a group of devices on the same multi-GPU board"]
pub const CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID: CUdevice_attribute_enum = 85;
#[doc = "< Link between the device and the host supports all native atomic operations"]
pub const CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED: CUdevice_attribute_enum = 86;
#[doc = "< Ratio of single precision performance (in floating-point operations per second) to double precision performance"]
pub const CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO: CUdevice_attribute_enum = 87;
#[doc = "< Device supports coherently accessing pageable memory without calling cudaHostRegister on it"]
pub const CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS: CUdevice_attribute_enum = 88;
#[doc = "< Device can coherently access managed memory concurrently with the CPU"]
pub const CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS: CUdevice_attribute_enum = 89;
#[doc = "< Device supports compute preemption."]
pub const CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED: CUdevice_attribute_enum = 90;
#[doc = "< Device can access host registered memory at the same virtual address as the CPU"]
pub const CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM: CUdevice_attribute_enum = 91;
#[doc = "< Deprecated, along with v1 MemOps API, ::cuStreamBatchMemOp and related APIs are supported."]
pub const CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS_V1: CUdevice_attribute_enum = 92;
#[doc = "< Deprecated, along with v1 MemOps API, 64-bit operations are supported in ::cuStreamBatchMemOp and related APIs."]
pub const CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS_V1: CUdevice_attribute_enum = 93;
#[doc = "< Deprecated, along with v1 MemOps API, ::CU_STREAM_WAIT_VALUE_NOR is supported."]
pub const CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR_V1: CUdevice_attribute_enum = 94;
#[doc = "< Device supports launching cooperative kernels via ::cuLaunchCooperativeKernel"]
pub const CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH: CUdevice_attribute_enum = 95;
#[doc = "< Deprecated, ::cuLaunchCooperativeKernelMultiDevice is deprecated."]
pub const CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH: CUdevice_attribute_enum = 96;
#[doc = "< Maximum optin shared memory per block"]
pub const CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN: CUdevice_attribute_enum = 97;
#[doc = "< The ::CU_STREAM_WAIT_VALUE_FLUSH flag and the ::CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES MemOp are supported on the device. See \\ref CUDA_MEMOP for additional details."]
pub const CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES: CUdevice_attribute_enum = 98;
#[doc = "< Device supports host memory registration via ::cudaHostRegister."]
pub const CU_DEVICE_ATTRIBUTE_HOST_REGISTER_SUPPORTED: CUdevice_attribute_enum = 99;
#[doc = "< Device accesses pageable memory via the host's page tables."]
pub const CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES:
    CUdevice_attribute_enum = 100;
#[doc = "< The host can directly access managed memory on the device without migration."]
pub const CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST: CUdevice_attribute_enum = 101;
#[doc = "< Deprecated, Use CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED"]
pub const CU_DEVICE_ATTRIBUTE_VIRTUAL_ADDRESS_MANAGEMENT_SUPPORTED: CUdevice_attribute_enum = 102;
#[doc = "< Device supports virtual memory management APIs like ::cuMemAddressReserve, ::cuMemCreate, ::cuMemMap and related APIs"]
pub const CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED: CUdevice_attribute_enum = 102;
#[doc = "< Device supports exporting memory to a posix file descriptor with ::cuMemExportToShareableHandle, if requested via ::cuMemCreate"]
pub const CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED: CUdevice_attribute_enum =
    103;
#[doc = "< Device supports exporting memory to a Win32 NT handle with ::cuMemExportToShareableHandle, if requested via ::cuMemCreate"]
pub const CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED: CUdevice_attribute_enum = 104;
#[doc = "< Device supports exporting memory to a Win32 KMT handle with ::cuMemExportToShareableHandle, if requested via ::cuMemCreate"]
pub const CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED: CUdevice_attribute_enum = 105;
#[doc = "< Maximum number of blocks per multiprocessor"]
pub const CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR: CUdevice_attribute_enum = 106;
#[doc = "< Device supports compression of memory"]
pub const CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED: CUdevice_attribute_enum = 107;
#[doc = "< Maximum L2 persisting lines capacity setting in bytes."]
pub const CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE: CUdevice_attribute_enum = 108;
#[doc = "< Maximum value of CUaccessPolicyWindow::num_bytes."]
pub const CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE: CUdevice_attribute_enum = 109;
#[doc = "< Device supports specifying the GPUDirect RDMA flag with ::cuMemCreate"]
pub const CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED: CUdevice_attribute_enum =
    110;
#[doc = "< Shared memory reserved by CUDA driver per block in bytes"]
pub const CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK: CUdevice_attribute_enum = 111;
#[doc = "< Device supports sparse CUDA arrays and sparse CUDA mipmapped arrays"]
pub const CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED: CUdevice_attribute_enum = 112;
#[doc = "< Device supports using the ::cuMemHostRegister flag ::CU_MEMHOSTERGISTER_READ_ONLY to register memory that must be mapped as read-only to the GPU"]
pub const CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED: CUdevice_attribute_enum = 113;
#[doc = "< External timeline semaphore interop is supported on the device"]
pub const CU_DEVICE_ATTRIBUTE_TIMELINE_SEMAPHORE_INTEROP_SUPPORTED: CUdevice_attribute_enum = 114;
#[doc = "< Device supports using the ::cuMemAllocAsync and ::cuMemPool family of APIs"]
pub const CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED: CUdevice_attribute_enum = 115;
#[doc = "< Device supports GPUDirect RDMA APIs, like nvidia_p2p_get_pages (see https://docs.nvidia.com/cuda/gpudirect-rdma for more information)"]
pub const CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED: CUdevice_attribute_enum = 116;
#[doc = "< The returned attribute shall be interpreted as a bitmask, where the individual bits are described by the ::CUflushGPUDirectRDMAWritesOptions enum"]
pub const CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS: CUdevice_attribute_enum = 117;
#[doc = "< GPUDirect RDMA writes to the device do not need to be flushed for consumers within the scope indicated by the returned attribute. See ::CUGPUDirectRDMAWritesOrdering for the numerical values returned here."]
pub const CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING: CUdevice_attribute_enum = 118;
#[doc = "< Handle types supported with mempool based IPC"]
pub const CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES: CUdevice_attribute_enum = 119;
#[doc = "< Indicates device supports cluster launch"]
pub const CU_DEVICE_ATTRIBUTE_CLUSTER_LAUNCH: CUdevice_attribute_enum = 120;
#[doc = "< Device supports deferred mapping CUDA arrays and CUDA mipmapped arrays"]
pub const CU_DEVICE_ATTRIBUTE_DEFERRED_MAPPING_CUDA_ARRAY_SUPPORTED: CUdevice_attribute_enum = 121;
#[doc = "< 64-bit operations are supported in ::cuStreamBatchMemOp and related MemOp APIs."]
pub const CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS: CUdevice_attribute_enum = 122;
#[doc = "< ::CU_STREAM_WAIT_VALUE_NOR is supported by MemOp APIs."]
pub const CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR: CUdevice_attribute_enum = 123;
#[doc = "< Device supports buffer sharing with dma_buf mechanism."]
pub const CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED: CUdevice_attribute_enum = 124;
#[doc = "< Device supports IPC Events."]
pub const CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED: CUdevice_attribute_enum = 125;
#[doc = "< Number of memory domains the device supports."]
pub const CU_DEVICE_ATTRIBUTE_MEM_SYNC_DOMAIN_COUNT: CUdevice_attribute_enum = 126;
#[doc = "< Device supports accessing memory using Tensor Map."]
pub const CU_DEVICE_ATTRIBUTE_TENSOR_MAP_ACCESS_SUPPORTED: CUdevice_attribute_enum = 127;
#[doc = "< Device supports exporting memory to a fabric handle with cuMemExportToShareableHandle() or requested with cuMemCreate()"]
pub const CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_FABRIC_SUPPORTED: CUdevice_attribute_enum = 128;
#[doc = "< Device supports unified function pointers."]
pub const CU_DEVICE_ATTRIBUTE_UNIFIED_FUNCTION_POINTERS: CUdevice_attribute_enum = 129;
#[doc = "< NUMA configuration of a device: value is of type ::CUdeviceNumaConfig enum"]
pub const CU_DEVICE_ATTRIBUTE_NUMA_CONFIG: CUdevice_attribute_enum = 130;
#[doc = "< NUMA node ID of the GPU memory"]
pub const CU_DEVICE_ATTRIBUTE_NUMA_ID: CUdevice_attribute_enum = 131;
#[doc = "< Device supports switch multicast and reduction operations."]
pub const CU_DEVICE_ATTRIBUTE_MULTICAST_SUPPORTED: CUdevice_attribute_enum = 132;
#[doc = "< Indicates if contexts created on this device will be shared via MPS"]
pub const CU_DEVICE_ATTRIBUTE_MPS_ENABLED: CUdevice_attribute_enum = 133;
#[doc = "< NUMA ID of the host node closest to the device. Returns -1 when system does not support NUMA."]
pub const CU_DEVICE_ATTRIBUTE_HOST_NUMA_ID: CUdevice_attribute_enum = 134;
#[doc = "< Device supports CIG with D3D12."]
pub const CU_DEVICE_ATTRIBUTE_D3D12_CIG_SUPPORTED: CUdevice_attribute_enum = 135;
#[doc = "< The returned valued shall be interpreted as a bitmask, where the individual bits are described by the ::CUmemDecompressAlgorithm enum."]
pub const CU_DEVICE_ATTRIBUTE_MEM_DECOMPRESS_ALGORITHM_MASK: CUdevice_attribute_enum = 136;
#[doc = "< The returned valued is the maximum length in bytes of a single decompress operation that is allowed."]
pub const CU_DEVICE_ATTRIBUTE_MEM_DECOMPRESS_MAXIMUM_LENGTH: CUdevice_attribute_enum = 137;
#[doc = "< Device supports CIG with Vulkan."]
pub const CU_DEVICE_ATTRIBUTE_VULKAN_CIG_SUPPORTED: CUdevice_attribute_enum = 138;
#[doc = "< The combined 16-bit PCI device ID and 16-bit PCI vendor ID."]
pub const CU_DEVICE_ATTRIBUTE_GPU_PCI_DEVICE_ID: CUdevice_attribute_enum = 139;
#[doc = "< The combined 16-bit PCI subsystem ID and 16-bit PCI subsystem vendor ID."]
pub const CU_DEVICE_ATTRIBUTE_GPU_PCI_SUBSYSTEM_ID: CUdevice_attribute_enum = 140;
#[doc = "< Device supports HOST_NUMA location with the virtual memory management APIs like ::cuMemCreate, ::cuMemMap and related APIs"]
pub const CU_DEVICE_ATTRIBUTE_HOST_NUMA_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED:
    CUdevice_attribute_enum = 141;
#[doc = "< Device supports HOST_NUMA location with the ::cuMemAllocAsync and ::cuMemPool family of APIs"]
pub const CU_DEVICE_ATTRIBUTE_HOST_NUMA_MEMORY_POOLS_SUPPORTED: CUdevice_attribute_enum = 142;
#[doc = "< Device supports HOST_NUMA location IPC between nodes in a multi-node system."]
pub const CU_DEVICE_ATTRIBUTE_HOST_NUMA_MULTINODE_IPC_SUPPORTED: CUdevice_attribute_enum = 143;
#[doc = "< Device suports HOST location with the ::cuMemAllocAsync and ::cuMemPool family of APIs"]
pub const CU_DEVICE_ATTRIBUTE_HOST_MEMORY_POOLS_SUPPORTED: CUdevice_attribute_enum = 144;
#[doc = "< Device supports HOST location with the virtual memory management APIs like ::cuMemCreate, ::cuMemMap and related APIs"]
pub const CU_DEVICE_ATTRIBUTE_HOST_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED: CUdevice_attribute_enum =
    145;
#[doc = "< Device supports page-locked host memory buffer sharing with dma_buf mechanism."]
pub const CU_DEVICE_ATTRIBUTE_HOST_ALLOC_DMA_BUF_SUPPORTED: CUdevice_attribute_enum = 146;
#[doc = "< Link between the device and the host supports only some native atomic operations"]
pub const CU_DEVICE_ATTRIBUTE_ONLY_PARTIAL_HOST_NATIVE_ATOMIC_SUPPORTED: CUdevice_attribute_enum =
    147;
pub const CU_DEVICE_ATTRIBUTE_MAX: CUdevice_attribute_enum = 148;
#[doc = " Device properties"]
pub type CUdevice_attribute_enum = ::std::os::raw::c_uint;
#[doc = " Device properties"]
pub use self::CUdevice_attribute_enum as CUdevice_attribute;
#[doc = "< Normal cache persistence."]
pub const CU_ACCESS_PROPERTY_NORMAL: CUaccessProperty_enum = 0;
#[doc = "< Streaming access is less likely to persit from cache."]
pub const CU_ACCESS_PROPERTY_STREAMING: CUaccessProperty_enum = 1;
#[doc = "< Persisting access is more likely to persist in cache."]
pub const CU_ACCESS_PROPERTY_PERSISTING: CUaccessProperty_enum = 2;
#[doc = " Specifies performance hint with ::CUaccessPolicyWindow for hitProp and missProp members."]
pub type CUaccessProperty_enum = ::std::os::raw::c_uint;
#[doc = " Specifies performance hint with ::CUaccessPolicyWindow for hitProp and missProp members."]
pub use self::CUaccessProperty_enum as CUaccessProperty;
#[doc = " Specifies an access policy for a window, a contiguous extent of memory\n beginning at base_ptr and ending at base_ptr + num_bytes.\n num_bytes is limited by CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE.\n Partition into many segments and assign segments such that:\n sum of \"hit segments\" / window == approx. ratio.\n sum of \"miss segments\" / window == approx 1-ratio.\n Segments and ratio specifications are fitted to the capabilities of\n the architecture.\n Accesses in a hit segment apply the hitProp access policy.\n Accesses in a miss segment apply the missProp access policy."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUaccessPolicyWindow_st {
    #[doc = "< Starting address of the access policy window. CUDA driver may align it."]
    pub base_ptr: *mut ::std::os::raw::c_void,
    #[doc = "< Size in bytes of the window policy. CUDA driver may restrict the maximum size and alignment."]
    pub num_bytes: usize,
    #[doc = "< hitRatio specifies percentage of lines assigned hitProp, rest are assigned missProp."]
    pub hitRatio: f32,
    #[doc = "< ::CUaccessProperty set for hit."]
    pub hitProp: CUaccessProperty,
    #[doc = "< ::CUaccessProperty set for miss. Must be either NORMAL or STREAMING"]
    pub missProp: CUaccessProperty,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUaccessPolicyWindow_st"][::std::mem::size_of::<CUaccessPolicyWindow_st>() - 32usize];
    ["Alignment of CUaccessPolicyWindow_st"]
        [::std::mem::align_of::<CUaccessPolicyWindow_st>() - 8usize];
    ["Offset of field: CUaccessPolicyWindow_st::base_ptr"]
        [::std::mem::offset_of!(CUaccessPolicyWindow_st, base_ptr) - 0usize];
    ["Offset of field: CUaccessPolicyWindow_st::num_bytes"]
        [::std::mem::offset_of!(CUaccessPolicyWindow_st, num_bytes) - 8usize];
    ["Offset of field: CUaccessPolicyWindow_st::hitRatio"]
        [::std::mem::offset_of!(CUaccessPolicyWindow_st, hitRatio) - 16usize];
    ["Offset of field: CUaccessPolicyWindow_st::hitProp"]
        [::std::mem::offset_of!(CUaccessPolicyWindow_st, hitProp) - 20usize];
    ["Offset of field: CUaccessPolicyWindow_st::missProp"]
        [::std::mem::offset_of!(CUaccessPolicyWindow_st, missProp) - 24usize];
};
impl Default for CUaccessPolicyWindow_st {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Specifies an access policy for a window, a contiguous extent of memory\n beginning at base_ptr and ending at base_ptr + num_bytes.\n num_bytes is limited by CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE.\n Partition into many segments and assign segments such that:\n sum of \"hit segments\" / window == approx. ratio.\n sum of \"miss segments\" / window == approx 1-ratio.\n Segments and ratio specifications are fitted to the capabilities of\n the architecture.\n Accesses in a hit segment apply the hitProp access policy.\n Accesses in a miss segment apply the missProp access policy."]
pub type CUaccessPolicyWindow_v1 = CUaccessPolicyWindow_st;
#[doc = " Access policy window"]
pub type CUaccessPolicyWindow = CUaccessPolicyWindow_v1;
#[doc = "< GPU kernel node"]
pub const CU_GRAPH_NODE_TYPE_KERNEL: CUgraphNodeType_enum = 0;
#[doc = "< Memcpy node"]
pub const CU_GRAPH_NODE_TYPE_MEMCPY: CUgraphNodeType_enum = 1;
#[doc = "< Memset node"]
pub const CU_GRAPH_NODE_TYPE_MEMSET: CUgraphNodeType_enum = 2;
#[doc = "< Host (executable) node"]
pub const CU_GRAPH_NODE_TYPE_HOST: CUgraphNodeType_enum = 3;
#[doc = "< Node which executes an embedded graph"]
pub const CU_GRAPH_NODE_TYPE_GRAPH: CUgraphNodeType_enum = 4;
#[doc = "< Empty (no-op) node"]
pub const CU_GRAPH_NODE_TYPE_EMPTY: CUgraphNodeType_enum = 5;
#[doc = "< External event wait node"]
pub const CU_GRAPH_NODE_TYPE_WAIT_EVENT: CUgraphNodeType_enum = 6;
#[doc = "< External event record node"]
pub const CU_GRAPH_NODE_TYPE_EVENT_RECORD: CUgraphNodeType_enum = 7;
#[doc = "< External semaphore signal node"]
pub const CU_GRAPH_NODE_TYPE_EXT_SEMAS_SIGNAL: CUgraphNodeType_enum = 8;
#[doc = "< External semaphore wait node"]
pub const CU_GRAPH_NODE_TYPE_EXT_SEMAS_WAIT: CUgraphNodeType_enum = 9;
#[doc = "< Memory Allocation Node"]
pub const CU_GRAPH_NODE_TYPE_MEM_ALLOC: CUgraphNodeType_enum = 10;
#[doc = "< Memory Free Node"]
pub const CU_GRAPH_NODE_TYPE_MEM_FREE: CUgraphNodeType_enum = 11;
#[doc = "< Batch MemOp Node\nSee ::cuStreamBatchMemOp and ::CUstreamBatchMemOpType for what these nodes can do."]
pub const CU_GRAPH_NODE_TYPE_BATCH_MEM_OP: CUgraphNodeType_enum = 12;
#[doc = "< Conditional Node\n\nMay be used to implement a conditional execution path or loop\ninside of a graph. The graph(s) contained within the body of the conditional node\ncan be selectively executed or iterated upon based on the value of a conditional\nvariable.\n\nHandles must be created in advance of creating the node\nusing ::cuGraphConditionalHandleCreate.\n\nThe following restrictions apply to graphs which contain conditional nodes:\nThe graph cannot be used in a child node.\nOnly one instantiation of the graph may exist at any point in time.\nThe graph cannot be cloned.\n\nTo set the control value, supply a default value when creating the handle and/or\ncall ::cudaGraphSetConditional from device code."]
pub const CU_GRAPH_NODE_TYPE_CONDITIONAL: CUgraphNodeType_enum = 13;
#[doc = " Graph node types"]
pub type CUgraphNodeType_enum = ::std::os::raw::c_uint;
#[doc = " Graph node types"]
pub use self::CUgraphNodeType_enum as CUgraphNodeType;
pub const CU_SYNC_POLICY_AUTO: CUsynchronizationPolicy_enum = 1;
pub const CU_SYNC_POLICY_SPIN: CUsynchronizationPolicy_enum = 2;
pub const CU_SYNC_POLICY_YIELD: CUsynchronizationPolicy_enum = 3;
pub const CU_SYNC_POLICY_BLOCKING_SYNC: CUsynchronizationPolicy_enum = 4;
pub type CUsynchronizationPolicy_enum = ::std::os::raw::c_uint;
pub use self::CUsynchronizationPolicy_enum as CUsynchronizationPolicy;
#[doc = "< the default policy"]
pub const CU_CLUSTER_SCHEDULING_POLICY_DEFAULT: CUclusterSchedulingPolicy_enum = 0;
#[doc = "< spread the blocks within a cluster to the SMs"]
pub const CU_CLUSTER_SCHEDULING_POLICY_SPREAD: CUclusterSchedulingPolicy_enum = 1;
#[doc = "< allow the hardware to load-balance the blocks in a cluster to the SMs"]
pub const CU_CLUSTER_SCHEDULING_POLICY_LOAD_BALANCING: CUclusterSchedulingPolicy_enum = 2;
#[doc = " Cluster scheduling policies. These may be passed to ::cuFuncSetAttribute or ::cuKernelSetAttribute"]
pub type CUclusterSchedulingPolicy_enum = ::std::os::raw::c_uint;
#[doc = " Cluster scheduling policies. These may be passed to ::cuFuncSetAttribute or ::cuKernelSetAttribute"]
pub use self::CUclusterSchedulingPolicy_enum as CUclusterSchedulingPolicy;
#[doc = "< Launch kernels in the default domain"]
pub const CU_LAUNCH_MEM_SYNC_DOMAIN_DEFAULT: CUlaunchMemSyncDomain_enum = 0;
#[doc = "< Launch kernels in the remote domain"]
pub const CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE: CUlaunchMemSyncDomain_enum = 1;
#[doc = " Memory Synchronization Domain\n\n A kernel can be launched in a specified memory synchronization domain that affects all memory operations issued by\n that kernel. A memory barrier issued in one domain will only order memory operations in that domain, thus eliminating\n latency increase from memory barriers ordering unrelated traffic.\n\n By default, kernels are launched in domain 0. Kernel launched with ::CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE will have a\n different domain ID. User may also alter the domain ID with ::CUlaunchMemSyncDomainMap for a specific stream /\n graph node / kernel launch. See ::CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN, ::cuStreamSetAttribute, ::cuLaunchKernelEx,\n ::cuGraphKernelNodeSetAttribute.\n\n Memory operations done in kernels launched in different domains are considered system-scope distanced. In other\n words, a GPU scoped memory synchronization is not sufficient for memory order to be observed by kernels in another\n memory synchronization domain even if they are on the same GPU."]
pub type CUlaunchMemSyncDomain_enum = ::std::os::raw::c_uint;
#[doc = " Memory Synchronization Domain\n\n A kernel can be launched in a specified memory synchronization domain that affects all memory operations issued by\n that kernel. A memory barrier issued in one domain will only order memory operations in that domain, thus eliminating\n latency increase from memory barriers ordering unrelated traffic.\n\n By default, kernels are launched in domain 0. Kernel launched with ::CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE will have a\n different domain ID. User may also alter the domain ID with ::CUlaunchMemSyncDomainMap for a specific stream /\n graph node / kernel launch. See ::CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN, ::cuStreamSetAttribute, ::cuLaunchKernelEx,\n ::cuGraphKernelNodeSetAttribute.\n\n Memory operations done in kernels launched in different domains are considered system-scope distanced. In other\n words, a GPU scoped memory synchronization is not sufficient for memory order to be observed by kernels in another\n memory synchronization domain even if they are on the same GPU."]
pub use self::CUlaunchMemSyncDomain_enum as CUlaunchMemSyncDomain;
#[doc = " Memory Synchronization Domain map\n\n See ::cudaLaunchMemSyncDomain.\n\n By default, kernels are launched in domain 0. Kernel launched with ::CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE will have a\n different domain ID. User may also alter the domain ID with ::CUlaunchMemSyncDomainMap for a specific stream /\n graph node / kernel launch. See ::CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP.\n\n Domain ID range is available through ::CU_DEVICE_ATTRIBUTE_MEM_SYNC_DOMAIN_COUNT."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUlaunchMemSyncDomainMap_st {
    #[doc = "< The default domain ID to use for designated kernels"]
    pub default_: ::std::os::raw::c_uchar,
    #[doc = "< The remote domain ID to use for designated kernels"]
    pub remote: ::std::os::raw::c_uchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUlaunchMemSyncDomainMap_st"]
        [::std::mem::size_of::<CUlaunchMemSyncDomainMap_st>() - 2usize];
    ["Alignment of CUlaunchMemSyncDomainMap_st"]
        [::std::mem::align_of::<CUlaunchMemSyncDomainMap_st>() - 1usize];
    ["Offset of field: CUlaunchMemSyncDomainMap_st::default_"]
        [::std::mem::offset_of!(CUlaunchMemSyncDomainMap_st, default_) - 0usize];
    ["Offset of field: CUlaunchMemSyncDomainMap_st::remote"]
        [::std::mem::offset_of!(CUlaunchMemSyncDomainMap_st, remote) - 1usize];
};
#[doc = " Memory Synchronization Domain map\n\n See ::cudaLaunchMemSyncDomain.\n\n By default, kernels are launched in domain 0. Kernel launched with ::CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE will have a\n different domain ID. User may also alter the domain ID with ::CUlaunchMemSyncDomainMap for a specific stream /\n graph node / kernel launch. See ::CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP.\n\n Domain ID range is available through ::CU_DEVICE_ATTRIBUTE_MEM_SYNC_DOMAIN_COUNT."]
pub type CUlaunchMemSyncDomainMap = CUlaunchMemSyncDomainMap_st;
#[doc = "< Ignored entry, for convenient composition"]
pub const CU_LAUNCH_ATTRIBUTE_IGNORE: CUlaunchAttributeID_enum = 0;
#[doc = "< Valid for streams, graph nodes, launches. See\n::CUlaunchAttributeValue::accessPolicyWindow."]
pub const CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW: CUlaunchAttributeID_enum = 1;
#[doc = "< Valid for graph nodes, launches. See\n::CUlaunchAttributeValue::cooperative."]
pub const CU_LAUNCH_ATTRIBUTE_COOPERATIVE: CUlaunchAttributeID_enum = 2;
#[doc = "< Valid for streams. See\n::CUlaunchAttributeValue::syncPolicy."]
pub const CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY: CUlaunchAttributeID_enum = 3;
#[doc = "< Valid for graph nodes, launches. See ::CUlaunchAttributeValue::clusterDim."]
pub const CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION: CUlaunchAttributeID_enum = 4;
#[doc = "< Valid for graph nodes, launches. See ::CUlaunchAttributeValue::clusterSchedulingPolicyPreference."]
pub const CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE: CUlaunchAttributeID_enum = 5;
#[doc = "< Valid for launches. Setting\n::CUlaunchAttributeValue::programmaticStreamSerializationAllowed\nto non-0 signals that the kernel will use programmatic\nmeans to resolve its stream dependency, so that the\nCUDA runtime should opportunistically allow the grid's\nexecution to overlap with the previous kernel in the\nstream, if that kernel requests the overlap. The\ndependent launches can choose to wait on the\ndependency using the programmatic sync\n(cudaGridDependencySynchronize() or equivalent PTX\ninstructions)."]
pub const CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION: CUlaunchAttributeID_enum = 6;
#[doc = "< Valid for launches. Set\n::CUlaunchAttributeValue::programmaticEvent to\nrecord the event. Event recorded through this\nlaunch attribute is guaranteed to only trigger\nafter all block in the associated kernel trigger\nthe event. A block can trigger the event through\nPTX launchdep.release or CUDA builtin function\ncudaTriggerProgrammaticLaunchCompletion(). A\ntrigger can also be inserted at the beginning of\neach block's execution if triggerAtBlockStart is\nset to non-0. The dependent launches can choose to\nwait on the dependency using the programmatic sync\n(cudaGridDependencySynchronize() or equivalent PTX\ninstructions). Note that dependents (including the\nCPU thread calling cuEventSynchronize()) are not\nguaranteed to observe the release precisely when\nit is released.  For example, cuEventSynchronize()\nmay only observe the event trigger long after the\nassociated kernel has completed. This recording\ntype is primarily meant for establishing\nprogrammatic dependency between device tasks. Note\nalso this type of dependency allows, but does not\nguarantee, concurrent execution of tasks.\n<br>\nThe event supplied must not be an interprocess or\ninterop event. The event must disable timing (i.e.\nmust be created with the ::CU_EVENT_DISABLE_TIMING\nflag set)."]
pub const CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT: CUlaunchAttributeID_enum = 7;
#[doc = "< Valid for streams, graph nodes, launches. See\n::CUlaunchAttributeValue::priority."]
pub const CU_LAUNCH_ATTRIBUTE_PRIORITY: CUlaunchAttributeID_enum = 8;
#[doc = "< Valid for streams, graph nodes, launches. See\n::CUlaunchAttributeValue::memSyncDomainMap."]
pub const CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP: CUlaunchAttributeID_enum = 9;
#[doc = "< Valid for streams, graph nodes, launches. See\n::CUlaunchAttributeValue::memSyncDomain."]
pub const CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN: CUlaunchAttributeID_enum = 10;
#[doc = "< Valid for graph nodes, launches. Set\n::CUlaunchAttributeValue::preferredClusterDim\nto allow the kernel launch to specify a preferred substitute\ncluster dimension. Blocks may be grouped according to either\nthe dimensions specified with this attribute (grouped into a\n\"preferred substitute cluster\"), or the one specified with\n::CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION attribute (grouped\ninto a \"regular cluster\"). The cluster dimensions of a\n\"preferred substitute cluster\" shall be an integer multiple\ngreater than zero of the regular cluster dimensions. The\ndevice will attempt - on a best-effort basis - to group\nthread blocks into preferred clusters over grouping them\ninto regular clusters. When it deems necessary (primarily\nwhen the device temporarily runs out of physical resources\nto launch the larger preferred clusters), the device may\nswitch to launch the regular clusters instead to attempt to\nutilize as much of the physical device resources as possible.\n<br>\nEach type of cluster will have its enumeration / coordinate\nsetup as if the grid consists solely of its type of cluster.\nFor example, if the preferred substitute cluster dimensions\ndouble the regular cluster dimensions, there might be\nsimultaneously a regular cluster indexed at (1,0,0), and a\npreferred cluster indexed at (1,0,0). In this example, the\npreferred substitute cluster (1,0,0) replaces regular\nclusters (2,0,0) and (3,0,0) and groups their blocks.\n<br>\nThis attribute will only take effect when a regular cluster\ndimension has been specified. The preferred substitute\ncluster dimension must be an integer multiple greater than\nzero of the regular cluster dimension and must divide the\ngrid. It must also be no more than `maxBlocksPerCluster`, if\nit is set in the kernel's `__launch_bounds__`. Otherwise it\nmust be less than the maximum value the driver can support.\nOtherwise, setting this attribute to a value physically\nunable to fit on any particular device is permitted."]
pub const CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION: CUlaunchAttributeID_enum = 11;
#[doc = "< Valid for launches. Set\n::CUlaunchAttributeValue::launchCompletionEvent to record the\nevent.\n<br>\nNominally, the event is triggered once all blocks of the kernel\nhave begun execution. Currently this is a best effort. If a kernel\nB has a launch completion dependency on a kernel A, B may wait\nuntil A is complete. Alternatively, blocks of B may begin before\nall blocks of A have begun, for example if B can claim execution\nresources unavailable to A (e.g. they run on different GPUs) or\nif B is a higher priority than A.\nExercise caution if such an ordering inversion could lead\nto deadlock.\n<br>\nA launch completion event is nominally similar to a programmatic\nevent with \\c triggerAtBlockStart set except that it is not\nvisible to \\c cudaGridDependencySynchronize() and can be used with\ncompute capability less than 9.0.\n<br>\nThe event supplied must not be an interprocess or interop\nevent. The event must disable timing (i.e. must be created\nwith the ::CU_EVENT_DISABLE_TIMING flag set)."]
pub const CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT: CUlaunchAttributeID_enum = 12;
#[doc = "< Valid for graph nodes, launches. This attribute is graphs-only,\nand passing it to a launch in a non-capturing stream will result\nin an error.\n<br>\n::CUlaunchAttributeValue::deviceUpdatableKernelNode::deviceUpdatable can\nonly be set to 0 or 1. Setting the field to 1 indicates that the\ncorresponding kernel node should be device-updatable. On success, a handle\nwill be returned via\n::CUlaunchAttributeValue::deviceUpdatableKernelNode::devNode which can be\npassed to the various device-side update functions to update the node's\nkernel parameters from within another kernel. For more information on the\ntypes of device updates that can be made, as well as the relevant limitations\nthereof, see ::cudaGraphKernelNodeUpdatesApply.\n<br>\nNodes which are device-updatable have additional restrictions compared to\nregular kernel nodes. Firstly, device-updatable nodes cannot be removed\nfrom their graph via ::cuGraphDestroyNode. Additionally, once opted-in\nto this functionality, a node cannot opt out, and any attempt to set the\ndeviceUpdatable attribute to 0 will result in an error. Device-updatable\nkernel nodes also cannot have their attributes copied to/from another kernel\nnode via ::cuGraphKernelNodeCopyAttributes. Graphs containing one or more\ndevice-updatable nodes also do not allow multiple instantiation, and neither\nthe graph nor its instantiated version can be passed to ::cuGraphExecUpdate.\n<br>\nIf a graph contains device-updatable nodes and updates those nodes from the device\nfrom within the graph, the graph must be uploaded with ::cuGraphUpload before it\nis launched. For such a graph, if host-side executable graph updates are made to the\ndevice-updatable nodes, the graph must be uploaded before it is launched again."]
pub const CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE: CUlaunchAttributeID_enum = 13;
#[doc = "< Valid for launches. On devices where the L1 cache and shared memory use the\nsame hardware resources, setting ::CUlaunchAttributeValue::sharedMemCarveout to a\npercentage between 0-100 signals the CUDA driver to set the shared memory carveout\npreference, in percent of the total shared memory for that kernel launch.\nThis attribute takes precedence over ::CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT.\nThis is only a hint, and the CUDA driver can choose a different configuration if\nrequired for the launch."]
pub const CU_LAUNCH_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT: CUlaunchAttributeID_enum = 14;
#[doc = "< Valid for streams, graph nodes, launches. This attribute is a hint to the CUDA runtime that the\nlaunch should attempt to make the kernel maximize its NVLINK utilization.\n<br>\nWhen possible to honor this hint, CUDA will assume each block in the grid launch will carry out an even amount\nof NVLINK traffic, and make a best-effort attempt to adjust the kernel launch based on that assumption.\n<br>\nThis attribute is a hint only. CUDA makes no functional or performance guarantee. Its applicability can be\naffected by many different factors, including driver version (i.e. CUDA doesn't guarantee the performance\ncharacteristics will be maintained between driver versions or a driver update could alter or regress\npreviously observed perf characteristics.) It also doesn't guarantee a successful result, i.e. applying\nthe attribute may not improve the performance of either the targeted kernel or the encapsulating application.\n<br>\nValid values for ::CUlaunchAttributeValue::nvlinkUtilCentricScheduling are 0 (disabled) and 1 (enabled)."]
pub const CU_LAUNCH_ATTRIBUTE_NVLINK_UTIL_CENTRIC_SCHEDULING: CUlaunchAttributeID_enum = 16;
#[doc = " Launch attributes enum; used as id field of ::CUlaunchAttribute"]
pub type CUlaunchAttributeID_enum = ::std::os::raw::c_uint;
#[doc = " Launch attributes enum; used as id field of ::CUlaunchAttribute"]
pub use self::CUlaunchAttributeID_enum as CUlaunchAttributeID;
#[doc = " Launch attributes union; used as value field of ::CUlaunchAttribute"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUlaunchAttributeValue_union {
    pub pad: [::std::os::raw::c_char; 64usize],
    #[doc = "< Value of launch attribute ::CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW."]
    pub accessPolicyWindow: CUaccessPolicyWindow,
    #[doc = "< Value of launch attribute ::CU_LAUNCH_ATTRIBUTE_COOPERATIVE. Nonzero indicates a cooperative\nkernel (see ::cuLaunchCooperativeKernel)."]
    pub cooperative: ::std::os::raw::c_int,
    #[doc = "< Value of launch attribute\n::CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY. ::CUsynchronizationPolicy for\nwork queued up in this stream"]
    pub syncPolicy: CUsynchronizationPolicy,
    pub clusterDim: CUlaunchAttributeValue_union__bindgen_ty_1,
    #[doc = "< Value of launch attribute\n::CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE. Cluster\nscheduling policy preference for the kernel."]
    pub clusterSchedulingPolicyPreference: CUclusterSchedulingPolicy,
    #[doc = "< Value of launch attribute\n::CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION."]
    pub programmaticStreamSerializationAllowed: ::std::os::raw::c_int,
    pub programmaticEvent: CUlaunchAttributeValue_union__bindgen_ty_2,
    pub launchCompletionEvent: CUlaunchAttributeValue_union__bindgen_ty_3,
    #[doc = "< Value of launch attribute ::CU_LAUNCH_ATTRIBUTE_PRIORITY. Execution priority of the kernel."]
    pub priority: ::std::os::raw::c_int,
    #[doc = "< Value of launch attribute\n::CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP. See\n::CUlaunchMemSyncDomainMap."]
    pub memSyncDomainMap: CUlaunchMemSyncDomainMap,
    #[doc = "< Value of launch attribute\n::CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN. See::CUlaunchMemSyncDomain"]
    pub memSyncDomain: CUlaunchMemSyncDomain,
    pub preferredClusterDim: CUlaunchAttributeValue_union__bindgen_ty_4,
    pub deviceUpdatableKernelNode: CUlaunchAttributeValue_union__bindgen_ty_5,
    #[doc = "< Value of launch attribute ::CU_LAUNCH_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT."]
    pub sharedMemCarveout: ::std::os::raw::c_uint,
    pub nvlinkUtilCentricScheduling: ::std::os::raw::c_uint,
}
#[doc = "  Value of launch attribute ::CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION that\n  represents the desired cluster dimensions for the kernel. Opaque type\n  with the following fields:\n      - \\p x - The X dimension of the cluster, in blocks. Must be a divisor\n               of the grid X dimension.\n      - \\p y - The Y dimension of the cluster, in blocks. Must be a divisor\n               of the grid Y dimension.\n      - \\p z - The Z dimension of the cluster, in blocks. Must be a divisor\n               of the grid Z dimension."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUlaunchAttributeValue_union__bindgen_ty_1 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
    pub z: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUlaunchAttributeValue_union__bindgen_ty_1"]
        [::std::mem::size_of::<CUlaunchAttributeValue_union__bindgen_ty_1>() - 12usize];
    ["Alignment of CUlaunchAttributeValue_union__bindgen_ty_1"]
        [::std::mem::align_of::<CUlaunchAttributeValue_union__bindgen_ty_1>() - 4usize];
    ["Offset of field: CUlaunchAttributeValue_union__bindgen_ty_1::x"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union__bindgen_ty_1, x) - 0usize];
    ["Offset of field: CUlaunchAttributeValue_union__bindgen_ty_1::y"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union__bindgen_ty_1, y) - 4usize];
    ["Offset of field: CUlaunchAttributeValue_union__bindgen_ty_1::z"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union__bindgen_ty_1, z) - 8usize];
};
#[doc = "  Value of launch attribute ::CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT\n  with the following fields:\n      - \\p CUevent event - Event to fire when all blocks trigger it.\n      - \\p Event record flags, see ::cuEventRecordWithFlags. Does not accept :CU_EVENT_RECORD_EXTERNAL.\n      - \\p triggerAtBlockStart - If this is set to non-0, each block launch will automatically trigger the event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlaunchAttributeValue_union__bindgen_ty_2 {
    pub event: CUevent,
    pub flags: ::std::os::raw::c_int,
    pub triggerAtBlockStart: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUlaunchAttributeValue_union__bindgen_ty_2"]
        [::std::mem::size_of::<CUlaunchAttributeValue_union__bindgen_ty_2>() - 16usize];
    ["Alignment of CUlaunchAttributeValue_union__bindgen_ty_2"]
        [::std::mem::align_of::<CUlaunchAttributeValue_union__bindgen_ty_2>() - 8usize];
    ["Offset of field: CUlaunchAttributeValue_union__bindgen_ty_2::event"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union__bindgen_ty_2, event) - 0usize];
    ["Offset of field: CUlaunchAttributeValue_union__bindgen_ty_2::flags"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union__bindgen_ty_2, flags) - 8usize];
    ["Offset of field: CUlaunchAttributeValue_union__bindgen_ty_2::triggerAtBlockStart"][::std::mem::offset_of!(
        CUlaunchAttributeValue_union__bindgen_ty_2,
        triggerAtBlockStart
    )
        - 12usize];
};
impl Default for CUlaunchAttributeValue_union__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Value of launch attribute ::CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT\n with the following fields:\n     - \\p CUevent event - Event to fire when the last block launches\n     - \\p int flags; - Event record flags, see ::cuEventRecordWithFlags. Does not accept ::CU_EVENT_RECORD_EXTERNAL."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlaunchAttributeValue_union__bindgen_ty_3 {
    pub event: CUevent,
    pub flags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUlaunchAttributeValue_union__bindgen_ty_3"]
        [::std::mem::size_of::<CUlaunchAttributeValue_union__bindgen_ty_3>() - 16usize];
    ["Alignment of CUlaunchAttributeValue_union__bindgen_ty_3"]
        [::std::mem::align_of::<CUlaunchAttributeValue_union__bindgen_ty_3>() - 8usize];
    ["Offset of field: CUlaunchAttributeValue_union__bindgen_ty_3::event"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union__bindgen_ty_3, event) - 0usize];
    ["Offset of field: CUlaunchAttributeValue_union__bindgen_ty_3::flags"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union__bindgen_ty_3, flags) - 8usize];
};
impl Default for CUlaunchAttributeValue_union__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  Value of launch attribute ::CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION\n  that represents the desired preferred cluster dimensions for the kernel.\n  Opaque type with the following fields:\n      - \\p x - The X dimension of the preferred cluster, in blocks. Must\n               be a divisor of the grid X dimension, and must be a\n               multiple of the \\p x field of ::CUlaunchAttributeValue::clusterDim.\n      - \\p y - The Y dimension of the preferred cluster, in blocks. Must\n               be a divisor of the grid Y dimension, and must be a\n               multiple of the \\p y field of ::CUlaunchAttributeValue::clusterDim.\n      - \\p z - The Z dimension of the preferred cluster, in blocks. Must be\n               equal to the \\p z field of ::CUlaunchAttributeValue::clusterDim."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUlaunchAttributeValue_union__bindgen_ty_4 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
    pub z: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUlaunchAttributeValue_union__bindgen_ty_4"]
        [::std::mem::size_of::<CUlaunchAttributeValue_union__bindgen_ty_4>() - 12usize];
    ["Alignment of CUlaunchAttributeValue_union__bindgen_ty_4"]
        [::std::mem::align_of::<CUlaunchAttributeValue_union__bindgen_ty_4>() - 4usize];
    ["Offset of field: CUlaunchAttributeValue_union__bindgen_ty_4::x"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union__bindgen_ty_4, x) - 0usize];
    ["Offset of field: CUlaunchAttributeValue_union__bindgen_ty_4::y"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union__bindgen_ty_4, y) - 4usize];
    ["Offset of field: CUlaunchAttributeValue_union__bindgen_ty_4::z"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union__bindgen_ty_4, z) - 8usize];
};
#[doc = "  Value of launch attribute ::CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE.\n  with the following fields:\n      - \\p int deviceUpdatable - Whether or not the resulting kernel node should be device-updatable.\n      - \\p CUgraphDeviceNode devNode - Returns a handle to pass to the various device-side update functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUlaunchAttributeValue_union__bindgen_ty_5 {
    pub deviceUpdatable: ::std::os::raw::c_int,
    pub devNode: CUgraphDeviceNode,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUlaunchAttributeValue_union__bindgen_ty_5"]
        [::std::mem::size_of::<CUlaunchAttributeValue_union__bindgen_ty_5>() - 16usize];
    ["Alignment of CUlaunchAttributeValue_union__bindgen_ty_5"]
        [::std::mem::align_of::<CUlaunchAttributeValue_union__bindgen_ty_5>() - 8usize];
    ["Offset of field: CUlaunchAttributeValue_union__bindgen_ty_5::deviceUpdatable"][::std::mem::offset_of!(
        CUlaunchAttributeValue_union__bindgen_ty_5,
        deviceUpdatable
    ) - 0usize];
    ["Offset of field: CUlaunchAttributeValue_union__bindgen_ty_5::devNode"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union__bindgen_ty_5, devNode) - 8usize];
};
impl Default for CUlaunchAttributeValue_union__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUlaunchAttributeValue_union"]
        [::std::mem::size_of::<CUlaunchAttributeValue_union>() - 64usize];
    ["Alignment of CUlaunchAttributeValue_union"]
        [::std::mem::align_of::<CUlaunchAttributeValue_union>() - 8usize];
    ["Offset of field: CUlaunchAttributeValue_union::pad"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union, pad) - 0usize];
    ["Offset of field: CUlaunchAttributeValue_union::accessPolicyWindow"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union, accessPolicyWindow) - 0usize];
    ["Offset of field: CUlaunchAttributeValue_union::cooperative"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union, cooperative) - 0usize];
    ["Offset of field: CUlaunchAttributeValue_union::syncPolicy"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union, syncPolicy) - 0usize];
    ["Offset of field: CUlaunchAttributeValue_union::clusterDim"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union, clusterDim) - 0usize];
    ["Offset of field: CUlaunchAttributeValue_union::clusterSchedulingPolicyPreference"][::std::mem::offset_of!(
        CUlaunchAttributeValue_union,
        clusterSchedulingPolicyPreference
    )
        - 0usize];
    ["Offset of field: CUlaunchAttributeValue_union::programmaticStreamSerializationAllowed"][::std::mem::offset_of!(
        CUlaunchAttributeValue_union,
        programmaticStreamSerializationAllowed
    )
        - 0usize];
    ["Offset of field: CUlaunchAttributeValue_union::programmaticEvent"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union, programmaticEvent) - 0usize];
    ["Offset of field: CUlaunchAttributeValue_union::launchCompletionEvent"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union, launchCompletionEvent) - 0usize];
    ["Offset of field: CUlaunchAttributeValue_union::priority"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union, priority) - 0usize];
    ["Offset of field: CUlaunchAttributeValue_union::memSyncDomainMap"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union, memSyncDomainMap) - 0usize];
    ["Offset of field: CUlaunchAttributeValue_union::memSyncDomain"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union, memSyncDomain) - 0usize];
    ["Offset of field: CUlaunchAttributeValue_union::preferredClusterDim"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union, preferredClusterDim) - 0usize];
    ["Offset of field: CUlaunchAttributeValue_union::deviceUpdatableKernelNode"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union, deviceUpdatableKernelNode) - 0usize];
    ["Offset of field: CUlaunchAttributeValue_union::sharedMemCarveout"]
        [::std::mem::offset_of!(CUlaunchAttributeValue_union, sharedMemCarveout) - 0usize];
    ["Offset of field: CUlaunchAttributeValue_union::nvlinkUtilCentricScheduling"][::std::mem::offset_of!(
        CUlaunchAttributeValue_union,
        nvlinkUtilCentricScheduling
    ) - 0usize];
};
impl Default for CUlaunchAttributeValue_union {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUlaunchAttributeValue_union {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUlaunchAttributeValue_union {{ union }}")
    }
}
#[doc = " Launch attributes union; used as value field of ::CUlaunchAttribute"]
pub type CUlaunchAttributeValue = CUlaunchAttributeValue_union;
#[doc = " Launch attributes enum; used as id field of ::CUlaunchAttribute"]
pub use self::CUlaunchAttributeID as CUstreamAttrID;
#[doc = " Launch attributes union; used as value field of ::CUlaunchAttribute"]
pub type CUstreamAttrValue_v1 = CUlaunchAttributeValue;
#[doc = " Launch attributes union; used as value field of ::CUlaunchAttribute"]
pub type CUstreamAttrValue = CUstreamAttrValue_v1;
#[doc = " No error."]
pub const CUPTI_SUCCESS: CUptiResult = 0;
#[doc = " One or more of the parameters is invalid."]
pub const CUPTI_ERROR_INVALID_PARAMETER: CUptiResult = 1;
#[doc = " The device does not correspond to a valid CUDA device."]
pub const CUPTI_ERROR_INVALID_DEVICE: CUptiResult = 2;
#[doc = " The context is NULL or not valid."]
pub const CUPTI_ERROR_INVALID_CONTEXT: CUptiResult = 3;
#[doc = " The event domain id is invalid."]
pub const CUPTI_ERROR_INVALID_EVENT_DOMAIN_ID: CUptiResult = 4;
#[doc = " The event id is invalid."]
pub const CUPTI_ERROR_INVALID_EVENT_ID: CUptiResult = 5;
#[doc = " The event name is invalid."]
pub const CUPTI_ERROR_INVALID_EVENT_NAME: CUptiResult = 6;
#[doc = " The current operation cannot be performed due to dependency on\n other factors."]
pub const CUPTI_ERROR_INVALID_OPERATION: CUptiResult = 7;
#[doc = " Unable to allocate enough memory to perform the requested\n operation."]
pub const CUPTI_ERROR_OUT_OF_MEMORY: CUptiResult = 8;
#[doc = " An error occurred on the performance monitoring hardware."]
pub const CUPTI_ERROR_HARDWARE: CUptiResult = 9;
#[doc = " The output buffer size is not sufficient to return all\n requested data."]
pub const CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT: CUptiResult = 10;
#[doc = " API is not implemented."]
pub const CUPTI_ERROR_API_NOT_IMPLEMENTED: CUptiResult = 11;
#[doc = " The maximum limit is reached."]
pub const CUPTI_ERROR_MAX_LIMIT_REACHED: CUptiResult = 12;
#[doc = " The object is not yet ready to perform the requested operation."]
pub const CUPTI_ERROR_NOT_READY: CUptiResult = 13;
#[doc = " The current operation is not compatible with the current state\n of the object"]
pub const CUPTI_ERROR_NOT_COMPATIBLE: CUptiResult = 14;
#[doc = " CUPTI is unable to initialize its connection to the CUDA\n driver."]
pub const CUPTI_ERROR_NOT_INITIALIZED: CUptiResult = 15;
#[doc = " The metric id is invalid."]
pub const CUPTI_ERROR_INVALID_METRIC_ID: CUptiResult = 16;
#[doc = " The metric name is invalid."]
pub const CUPTI_ERROR_INVALID_METRIC_NAME: CUptiResult = 17;
#[doc = " The queue is empty."]
pub const CUPTI_ERROR_QUEUE_EMPTY: CUptiResult = 18;
#[doc = " Invalid handle (internal?)."]
pub const CUPTI_ERROR_INVALID_HANDLE: CUptiResult = 19;
#[doc = " Invalid stream."]
pub const CUPTI_ERROR_INVALID_STREAM: CUptiResult = 20;
#[doc = " Invalid kind."]
pub const CUPTI_ERROR_INVALID_KIND: CUptiResult = 21;
#[doc = " Invalid event value."]
pub const CUPTI_ERROR_INVALID_EVENT_VALUE: CUptiResult = 22;
#[doc = " CUPTI is disabled due to conflicts with other enabled profilers"]
pub const CUPTI_ERROR_DISABLED: CUptiResult = 23;
#[doc = " Invalid module."]
pub const CUPTI_ERROR_INVALID_MODULE: CUptiResult = 24;
#[doc = " Invalid metric value."]
pub const CUPTI_ERROR_INVALID_METRIC_VALUE: CUptiResult = 25;
#[doc = " The performance monitoring hardware is in use by other client."]
pub const CUPTI_ERROR_HARDWARE_BUSY: CUptiResult = 26;
#[doc = " The attempted operation is not supported on the current\n system or device."]
pub const CUPTI_ERROR_NOT_SUPPORTED: CUptiResult = 27;
#[doc = " Unified memory profiling is not supported on the system.\n Potential reason could be unsupported OS or architecture."]
pub const CUPTI_ERROR_UM_PROFILING_NOT_SUPPORTED: CUptiResult = 28;
#[doc = " Unified memory profiling is not supported on the device"]
pub const CUPTI_ERROR_UM_PROFILING_NOT_SUPPORTED_ON_DEVICE: CUptiResult = 29;
#[doc = " Unified memory profiling is not supported on a multi-GPU\n configuration without P2P support between any pair of devices"]
pub const CUPTI_ERROR_UM_PROFILING_NOT_SUPPORTED_ON_NON_P2P_DEVICES: CUptiResult = 30;
#[doc = " Unified memory profiling is not supported under the\n Multi-Process Service (MPS) environment. CUDA 7.5 removes this\n restriction."]
pub const CUPTI_ERROR_UM_PROFILING_NOT_SUPPORTED_WITH_MPS: CUptiResult = 31;
#[doc = " In CUDA 9.0, devices with compute capability 7.0 don't\n support CDP tracing"]
pub const CUPTI_ERROR_CDP_TRACING_NOT_SUPPORTED: CUptiResult = 32;
#[doc = " Profiling on virtualized GPU is not supported."]
pub const CUPTI_ERROR_VIRTUALIZED_DEVICE_NOT_SUPPORTED: CUptiResult = 33;
#[doc = " Profiling results might be incorrect for CUDA applications\n compiled with nvcc version older than 9.0 for devices with\n compute capability 6.0 and 6.1.\n Profiling session will continue and CUPTI will notify it using this error code.\n User is advised to recompile the application code with nvcc version 9.0 or later.\n Ignore this warning if code is already compiled with the recommended nvcc version."]
pub const CUPTI_ERROR_CUDA_COMPILER_NOT_COMPATIBLE: CUptiResult = 34;
#[doc = " User doesn't have sufficient privileges which are required to\n start the profiling session.\n One possible reason for this may be that the NVIDIA driver or your system\n administrator may have restricted access to the NVIDIA GPU performance counters.\n To learn how to resolve this issue and find more information, please visit\n https://developer.nvidia.com/CUPTI_ERROR_INSUFFICIENT_PRIVILEGES"]
pub const CUPTI_ERROR_INSUFFICIENT_PRIVILEGES: CUptiResult = 35;
#[doc = " Legacy CUPTI Profiling API i.e. event API from the header cupti_events.h and\n metric API from the header cupti_metrics.h are not compatible with the\n Profiling API in the header cupti_profiler_target.h and Perfworks metrics API\n in the headers nvperf_host.h and nvperf_target.h."]
pub const CUPTI_ERROR_OLD_PROFILER_API_INITIALIZED: CUptiResult = 36;
#[doc = " Missing definition of the OpenACC API routine in the linked OpenACC library.\n\n One possible reason is that OpenACC library is linked statically in the\n user application, which might not have the definition of all the OpenACC\n API routines needed for the OpenACC profiling, as compiler might ignore\n definitions for the functions not used in the application. This issue\n can be mitigated by linking the OpenACC library dynamically."]
pub const CUPTI_ERROR_OPENACC_UNDEFINED_ROUTINE: CUptiResult = 37;
#[doc = " Legacy CUPTI Profiling API i.e. event API from the header cupti_events.h and\n metric API from the header cupti_metrics.h are not supported on devices with\n compute capability 7.5 and higher (i.e. Turing and later GPU architectures).\n These APIs were deprecated in CUDA 12.8 and removed in CUDA 13.0.\n These are replaced by the host profiling API in the header cupti_profiler_host.h and\n target profiling API in the header cupti_range_profiler.h which are supported on\n devices with compute capability 7.5 and higher (i.e. Turing and later GPU\n architectures).\n Further, the PC Sampling Activity API and the source/SASS level metrics from the header\n cupti_activity.h are removed in CUDA 13.0."]
pub const CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED: CUptiResult = 38;
#[doc = " CUPTI doesn't allow multiple callback subscribers. Only a single subscriber\n can be registered at a time.\n Same error code is used when application is launched using NVIDIA tools\n like Nsight Systems, Nsight Compute, and cuda-gdb."]
pub const CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED: CUptiResult = 39;
#[doc = " Profiling on virtualized GPU is not allowed by hypervisor."]
pub const CUPTI_ERROR_VIRTUALIZED_DEVICE_INSUFFICIENT_PRIVILEGES: CUptiResult = 40;
#[doc = " Profiling and tracing are not allowed when confidential computing mode\n is enabled."]
pub const CUPTI_ERROR_CONFIDENTIAL_COMPUTING_NOT_SUPPORTED: CUptiResult = 41;
#[doc = " CUPTI does not support NVIDIA Crypto Mining Processors (CMP).\n For more information, please visit https://developer.nvidia.com/ERR_NVCMPGPU"]
pub const CUPTI_ERROR_CMP_DEVICE_NOT_SUPPORTED: CUptiResult = 42;
#[doc = " Profiling on Multi-instance GPU (MIG) is not supported."]
pub const CUPTI_ERROR_MIG_DEVICE_NOT_SUPPORTED: CUptiResult = 43;
#[doc = " Profiling on SLI device is not supported."]
pub const CUPTI_ERROR_SLI_DEVICE_NOT_SUPPORTED: CUptiResult = 44;
#[doc = " Profiling on WSL device is not supported."]
pub const CUPTI_ERROR_WSL_DEVICE_NOT_SUPPORTED: CUptiResult = 45;
#[doc = " For invalid or unsupported chip name passed to cuptiProfilerHostInitialize."]
pub const CUPTI_ERROR_INVALID_CHIP_NAME: CUptiResult = 46;
#[doc = " An unknown internal error has occurred."]
pub const CUPTI_ERROR_UNKNOWN: CUptiResult = 999;
#[doc = " An unknown internal error has occurred."]
pub const CUPTI_ERROR_FORCE_INT: CUptiResult = 2147483647;
#[doc = " \\brief CUPTI result codes.\n\n Error and result codes returned by CUPTI functions."]
pub type CUptiResult = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " \\brief Get the descriptive string for a CUptiResult.\n\n Return the descriptive string for a CUptiResult in \\p *str.\n \\note \\b Thread-safety: this function is thread safe.\n\n \\param result The result to get the string for\n \\param str Returns the string\n\n \\retval CUPTI_SUCCESS on success\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p str is NULL or \\p\n result is not a valid CUptiResult"]
    pub fn cuptiGetResultString(
        result: CUptiResult,
        str_: *mut *const ::std::os::raw::c_char,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " @brief Get the descriptive message corresponding to error codes returned\n by CUPTI.\n\n Return the descriptive error message for a CUptiResult in \\p *str.\n \\note \\b Thread-safety: this function is thread safe.\n\n \\param result The result to get the descriptive error message for\n \\param str Returns the error message string\n\n \\retval CUPTI_SUCCESS on success\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p str is NULL or \\p\n result is not a valid CUptiResult\n"]
    pub fn cuptiGetErrorMessage(
        result: CUptiResult,
        str_: *mut *const ::std::os::raw::c_char,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get the CUPTI API version.\n\n Return the API version in \\p *version.\n\n \\param version Returns the version\n\n \\retval CUPTI_SUCCESS on success\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p version is NULL\n \\sa CUPTI_API_VERSION"]
    pub fn cuptiGetVersion(version: *mut u32) -> CUptiResult;
}
#[doc = " The callback is at the entry of the API call."]
pub const CUPTI_API_ENTER: CUpti_ApiCallbackSite = 0;
#[doc = " The callback is at the exit of the API call."]
pub const CUPTI_API_EXIT: CUpti_ApiCallbackSite = 1;
#[doc = " The callback is at the exit of the API call."]
pub const CUPTI_API_CBSITE_FORCE_INT: CUpti_ApiCallbackSite = 2147483647;
#[doc = " \\brief Specifies the point in an API call that a callback is issued.\n\n Specifies the point in an API call that a callback is issued. This\n value is communicated to the callback function via \\ref\n CUpti_CallbackData::callbackSite."]
pub type CUpti_ApiCallbackSite = ::std::os::raw::c_uint;
#[doc = " Invalid domain."]
pub const CUPTI_CB_DOMAIN_INVALID: CUpti_CallbackDomain = 0;
#[doc = " Domain containing callback points for all driver API functions."]
pub const CUPTI_CB_DOMAIN_DRIVER_API: CUpti_CallbackDomain = 1;
#[doc = " Domain containing callback points for all runtime API\n functions."]
pub const CUPTI_CB_DOMAIN_RUNTIME_API: CUpti_CallbackDomain = 2;
#[doc = " Domain containing callback points for CUDA resource tracking."]
pub const CUPTI_CB_DOMAIN_RESOURCE: CUpti_CallbackDomain = 3;
#[doc = " Domain containing callback points for CUDA synchronization."]
pub const CUPTI_CB_DOMAIN_SYNCHRONIZE: CUpti_CallbackDomain = 4;
#[doc = " Domain containing callback points for NVTX API functions."]
pub const CUPTI_CB_DOMAIN_NVTX: CUpti_CallbackDomain = 5;
#[doc = " Domain containing callback points for various states."]
pub const CUPTI_CB_DOMAIN_STATE: CUpti_CallbackDomain = 6;
#[doc = " Domain containing callback points for various states."]
pub const CUPTI_CB_DOMAIN_SIZE: CUpti_CallbackDomain = 7;
#[doc = " Domain containing callback points for various states."]
pub const CUPTI_CB_DOMAIN_FORCE_INT: CUpti_CallbackDomain = 2147483647;
#[doc = " \\brief Callback domains.\n\n Callback domains. Each domain represents callback points for a\n group of related API functions or CUDA driver activity."]
pub type CUpti_CallbackDomain = ::std::os::raw::c_uint;
#[doc = " Invalid resource callback ID."]
pub const CUPTI_CBID_RESOURCE_INVALID: CUpti_CallbackIdResource = 0;
#[doc = " A new context has been created."]
pub const CUPTI_CBID_RESOURCE_CONTEXT_CREATED: CUpti_CallbackIdResource = 1;
#[doc = " A context is about to be destroyed."]
pub const CUPTI_CBID_RESOURCE_CONTEXT_DESTROY_STARTING: CUpti_CallbackIdResource = 2;
#[doc = " A new stream has been created."]
pub const CUPTI_CBID_RESOURCE_STREAM_CREATED: CUpti_CallbackIdResource = 3;
#[doc = " A stream is about to be destroyed."]
pub const CUPTI_CBID_RESOURCE_STREAM_DESTROY_STARTING: CUpti_CallbackIdResource = 4;
#[doc = " The driver has finished initializing."]
pub const CUPTI_CBID_RESOURCE_CU_INIT_FINISHED: CUpti_CallbackIdResource = 5;
#[doc = " A module has been loaded."]
pub const CUPTI_CBID_RESOURCE_MODULE_LOADED: CUpti_CallbackIdResource = 6;
#[doc = " A module is about to be unloaded."]
pub const CUPTI_CBID_RESOURCE_MODULE_UNLOAD_STARTING: CUpti_CallbackIdResource = 7;
#[doc = " The current module which is being profiled."]
pub const CUPTI_CBID_RESOURCE_MODULE_PROFILED: CUpti_CallbackIdResource = 8;
#[doc = " CUDA graph has been created."]
pub const CUPTI_CBID_RESOURCE_GRAPH_CREATED: CUpti_CallbackIdResource = 9;
#[doc = " CUDA graph is about to be destroyed."]
pub const CUPTI_CBID_RESOURCE_GRAPH_DESTROY_STARTING: CUpti_CallbackIdResource = 10;
#[doc = " CUDA graph is cloned."]
pub const CUPTI_CBID_RESOURCE_GRAPH_CLONED: CUpti_CallbackIdResource = 11;
#[doc = " CUDA graph node is about to be created"]
pub const CUPTI_CBID_RESOURCE_GRAPHNODE_CREATE_STARTING: CUpti_CallbackIdResource = 12;
#[doc = " CUDA graph node is created."]
pub const CUPTI_CBID_RESOURCE_GRAPHNODE_CREATED: CUpti_CallbackIdResource = 13;
#[doc = " CUDA graph node is about to be destroyed."]
pub const CUPTI_CBID_RESOURCE_GRAPHNODE_DESTROY_STARTING: CUpti_CallbackIdResource = 14;
#[doc = " Dependency on a CUDA graph node is created."]
pub const CUPTI_CBID_RESOURCE_GRAPHNODE_DEPENDENCY_CREATED: CUpti_CallbackIdResource = 15;
#[doc = " Dependency on a CUDA graph node is destroyed."]
pub const CUPTI_CBID_RESOURCE_GRAPHNODE_DEPENDENCY_DESTROY_STARTING: CUpti_CallbackIdResource = 16;
#[doc = " An executable CUDA graph is about to be created."]
pub const CUPTI_CBID_RESOURCE_GRAPHEXEC_CREATE_STARTING: CUpti_CallbackIdResource = 17;
#[doc = " An executable CUDA graph is created."]
pub const CUPTI_CBID_RESOURCE_GRAPHEXEC_CREATED: CUpti_CallbackIdResource = 18;
#[doc = " An executable CUDA graph is about to be destroyed."]
pub const CUPTI_CBID_RESOURCE_GRAPHEXEC_DESTROY_STARTING: CUpti_CallbackIdResource = 19;
#[doc = " CUDA graph node is cloned."]
pub const CUPTI_CBID_RESOURCE_GRAPHNODE_CLONED: CUpti_CallbackIdResource = 20;
#[doc = " CUDA stream attribute is changed."]
pub const CUPTI_CBID_RESOURCE_STREAM_ATTRIBUTE_CHANGED: CUpti_CallbackIdResource = 21;
#[doc = " CUDA graph node is updated."]
pub const CUPTI_CBID_RESOURCE_GRAPH_NODE_UPDATED: CUpti_CallbackIdResource = 22;
#[doc = " Params are set for the CUDA graph node in the executable graph."]
pub const CUPTI_CBID_RESOURCE_GRAPH_NODE_SET_PARAMS: CUpti_CallbackIdResource = 23;
#[doc = " Params are set for the CUDA graph node in the executable graph."]
pub const CUPTI_CBID_RESOURCE_SIZE: CUpti_CallbackIdResource = 24;
#[doc = " Params are set for the CUDA graph node in the executable graph."]
pub const CUPTI_CBID_RESOURCE_FORCE_INT: CUpti_CallbackIdResource = 2147483647;
#[doc = " \\brief Callback IDs for resource domain.\n\n Callback IDs for resource domain, CUPTI_CB_DOMAIN_RESOURCE.  This\n value is communicated to the callback function via the \\p cbid\n parameter."]
pub type CUpti_CallbackIdResource = ::std::os::raw::c_uint;
#[doc = " Invalid synchronize callback ID."]
pub const CUPTI_CBID_SYNCHRONIZE_INVALID: CUpti_CallbackIdSync = 0;
#[doc = " Stream synchronization has completed for the stream."]
pub const CUPTI_CBID_SYNCHRONIZE_STREAM_SYNCHRONIZED: CUpti_CallbackIdSync = 1;
#[doc = " Context synchronization has completed for the context."]
pub const CUPTI_CBID_SYNCHRONIZE_CONTEXT_SYNCHRONIZED: CUpti_CallbackIdSync = 2;
#[doc = " Context synchronization has completed for the context."]
pub const CUPTI_CBID_SYNCHRONIZE_SIZE: CUpti_CallbackIdSync = 3;
#[doc = " Context synchronization has completed for the context."]
pub const CUPTI_CBID_SYNCHRONIZE_FORCE_INT: CUpti_CallbackIdSync = 2147483647;
#[doc = " \\brief Callback IDs for synchronization domain.\n\n Callback IDs for synchronization domain,\n CUPTI_CB_DOMAIN_SYNCHRONIZE.  This value is communicated to the\n callback function via the \\p cbid parameter."]
pub type CUpti_CallbackIdSync = ::std::os::raw::c_uint;
#[doc = " Invalid state callback ID."]
pub const CUPTI_CBID_STATE_INVALID: CUpti_CallbackIdState = 0;
#[doc = " Notification of fatal errors - high impact, non-recoverable\n When encountered, CUPTI automatically invokes cuptiFinalize()\n User can control behavior of the application in future from\n receiving this callback - such as continuing without profiling, or\n terminating the whole application."]
pub const CUPTI_CBID_STATE_FATAL_ERROR: CUpti_CallbackIdState = 1;
#[doc = " Notification of non fatal errors - high impact, but recoverable\n This notification is not issued in the current release."]
pub const CUPTI_CBID_STATE_ERROR: CUpti_CallbackIdState = 2;
#[doc = " Notification of warnings - low impact, recoverable."]
pub const CUPTI_CBID_STATE_WARNING: CUpti_CallbackIdState = 3;
#[doc = " Notification of warnings - low impact, recoverable."]
pub const CUPTI_CBID_STATE_SIZE: CUpti_CallbackIdState = 4;
#[doc = " Notification of warnings - low impact, recoverable."]
pub const CUPTI_CBID_STATE_FORCE_INT: CUpti_CallbackIdState = 2147483647;
#[doc = " \\brief Callback IDs for state domain.\n\n Callback IDs for state domain,\n CUPTI_CB_DOMAIN_STATE. This value is communicated to the\n callback function via the \\p cbid parameter."]
pub type CUpti_CallbackIdState = ::std::os::raw::c_uint;
#[doc = " \\brief Data passed into a runtime or driver API callback function.\n\n Data passed into a runtime or driver API callback function as the\n \\p cbdata argument to \\ref CUpti_CallbackFunc. The \\p cbdata will\n be this type for \\p domain equal to CUPTI_CB_DOMAIN_DRIVER_API or\n CUPTI_CB_DOMAIN_RUNTIME_API. The callback data is valid only within\n the invocation of the callback function that is passed the data. If\n you need to retain some data for use outside of the callback, you\n must make a copy of that data. For example, if you make a shallow\n copy of CUpti_CallbackData within a callback, you cannot\n dereference \\p functionParams outside of that callback to access\n the function parameters. \\p functionName is an exception: the\n string pointed to by \\p functionName is a global constant and so\n may be accessed outside of the callback."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_CallbackData {
    #[doc = " Point in the runtime or driver function from where the callback\n was issued."]
    pub callbackSite: CUpti_ApiCallbackSite,
    #[doc = " Name of the runtime or driver API function which issued the\n callback. This string is a global constant and so may be\n accessed outside of the callback."]
    pub functionName: *const ::std::os::raw::c_char,
    #[doc = " Pointer to the arguments passed to the runtime or driver API\n call. See generated_cuda_runtime_api_meta.h and\n generated_cuda_meta.h for structure definitions for the\n parameters for each runtime and driver API function."]
    pub functionParams: *const ::std::os::raw::c_void,
    #[doc = " Pointer to the return value of the runtime or driver API\n call. This field is only valid within the exit::CUPTI_API_EXIT\n callback. For a runtime API \\p functionReturnValue points to a\n \\p cudaError_t. For a driver API \\p functionReturnValue points\n to a \\p CUresult."]
    pub functionReturnValue: *mut ::std::os::raw::c_void,
    #[doc = " Name of the symbol operated on by the runtime or driver API\n function which issued the callback. This entry is valid only for\n driver and runtime launch callbacks, where it returns the name of\n the kernel."]
    pub symbolName: *const ::std::os::raw::c_char,
    #[doc = " Driver context current to the thread, or null if no context is\n current. This value can change from the entry to exit callback\n of a runtime API function if the runtime initializes a context."]
    pub context: CUcontext,
    #[doc = " Unique ID for the CUDA context associated with the thread. The\n UIDs are assigned sequentially as contexts are created and are\n unique within a process."]
    pub contextUid: u32,
    #[doc = " Pointer to data shared between the entry and exit callbacks of\n a given runtime or drive API function invocation. This field\n can be used to pass 64-bit values from the entry callback to\n the corresponding exit callback."]
    pub correlationData: *mut u64,
    #[doc = " The activity record correlation ID for this callback. For a\n driver domain callback (i.e. \\p domain\n CUPTI_CB_DOMAIN_DRIVER_API) this ID will equal the correlation ID\n in the CUpti_ActivityAPI record corresponding to the CUDA driver\n function call. For a runtime domain callback (i.e. \\p domain\n CUPTI_CB_DOMAIN_RUNTIME_API) this ID will equal the correlation\n ID in the CUpti_ActivityAPI record corresponding to the CUDA\n runtime function call. Within the callback, this ID can be\n recorded to correlate user data with the activity record. This\n field is new in 4.1."]
    pub correlationId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_CallbackData"][::std::mem::size_of::<CUpti_CallbackData>() - 72usize];
    ["Alignment of CUpti_CallbackData"][::std::mem::align_of::<CUpti_CallbackData>() - 8usize];
    ["Offset of field: CUpti_CallbackData::callbackSite"]
        [::std::mem::offset_of!(CUpti_CallbackData, callbackSite) - 0usize];
    ["Offset of field: CUpti_CallbackData::functionName"]
        [::std::mem::offset_of!(CUpti_CallbackData, functionName) - 8usize];
    ["Offset of field: CUpti_CallbackData::functionParams"]
        [::std::mem::offset_of!(CUpti_CallbackData, functionParams) - 16usize];
    ["Offset of field: CUpti_CallbackData::functionReturnValue"]
        [::std::mem::offset_of!(CUpti_CallbackData, functionReturnValue) - 24usize];
    ["Offset of field: CUpti_CallbackData::symbolName"]
        [::std::mem::offset_of!(CUpti_CallbackData, symbolName) - 32usize];
    ["Offset of field: CUpti_CallbackData::context"]
        [::std::mem::offset_of!(CUpti_CallbackData, context) - 40usize];
    ["Offset of field: CUpti_CallbackData::contextUid"]
        [::std::mem::offset_of!(CUpti_CallbackData, contextUid) - 48usize];
    ["Offset of field: CUpti_CallbackData::correlationData"]
        [::std::mem::offset_of!(CUpti_CallbackData, correlationData) - 56usize];
    ["Offset of field: CUpti_CallbackData::correlationId"]
        [::std::mem::offset_of!(CUpti_CallbackData, correlationId) - 64usize];
};
impl Default for CUpti_CallbackData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Data passed into a resource callback function.\n\n Data passed into a resource callback function as the \\p cbdata\n argument to \\ref CUpti_CallbackFunc. The \\p cbdata will be this\n type for \\p domain equal to CUPTI_CB_DOMAIN_RESOURCE. The callback\n data is valid only within the invocation of the callback function\n that is passed the data. If you need to retain some data for use\n outside of the callback, you must make a copy of that data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUpti_ResourceData {
    #[doc = " For CUPTI_CBID_RESOURCE_CONTEXT_CREATED and\n CUPTI_CBID_RESOURCE_CONTEXT_DESTROY_STARTING, the context being\n created or destroyed. For CUPTI_CBID_RESOURCE_STREAM_CREATED and\n CUPTI_CBID_RESOURCE_STREAM_DESTROY_STARTING, the context\n containing the stream being created or destroyed."]
    pub context: CUcontext,
    pub resourceHandle: CUpti_ResourceData__bindgen_ty_1,
    #[doc = " Reserved for future use."]
    pub resourceDescriptor: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ResourceData__bindgen_ty_1 {
    #[doc = " For CUPTI_CBID_RESOURCE_STREAM_CREATED and\n CUPTI_CBID_RESOURCE_STREAM_DESTROY_STARTING, the stream being\n created or destroyed."]
    pub stream: CUstream,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ResourceData__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ResourceData__bindgen_ty_1>() - 8usize];
    ["Alignment of CUpti_ResourceData__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ResourceData__bindgen_ty_1>() - 8usize];
    ["Offset of field: CUpti_ResourceData__bindgen_ty_1::stream"]
        [::std::mem::offset_of!(CUpti_ResourceData__bindgen_ty_1, stream) - 0usize];
};
impl Default for CUpti_ResourceData__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ResourceData__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ResourceData__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ResourceData"][::std::mem::size_of::<CUpti_ResourceData>() - 24usize];
    ["Alignment of CUpti_ResourceData"][::std::mem::align_of::<CUpti_ResourceData>() - 8usize];
    ["Offset of field: CUpti_ResourceData::context"]
        [::std::mem::offset_of!(CUpti_ResourceData, context) - 0usize];
    ["Offset of field: CUpti_ResourceData::resourceHandle"]
        [::std::mem::offset_of!(CUpti_ResourceData, resourceHandle) - 8usize];
    ["Offset of field: CUpti_ResourceData::resourceDescriptor"]
        [::std::mem::offset_of!(CUpti_ResourceData, resourceDescriptor) - 16usize];
};
impl Default for CUpti_ResourceData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ResourceData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ResourceData {{ context: {:?}, resourceHandle: {:?}, resourceDescriptor: {:?} }}",
            self.context, self.resourceHandle, self.resourceDescriptor
        )
    }
}
#[doc = " \\brief Module data passed into a resource callback function.\n\n CUDA module data passed into a resource callback function as the \\p cbdata\n argument to \\ref CUpti_CallbackFunc. The \\p cbdata will be this\n type for \\p domain equal to CUPTI_CB_DOMAIN_RESOURCE. The module\n data is valid only within the invocation of the callback function\n that is passed the data. If you need to retain some data for use\n outside of the callback, you must make a copy of that data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ModuleResourceData {
    #[doc = " Identifier to associate with the CUDA module."]
    pub moduleId: u32,
    #[doc = " The size of the cubin."]
    pub cubinSize: usize,
    #[doc = " Pointer to the associated cubin."]
    pub pCubin: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ModuleResourceData"]
        [::std::mem::size_of::<CUpti_ModuleResourceData>() - 24usize];
    ["Alignment of CUpti_ModuleResourceData"]
        [::std::mem::align_of::<CUpti_ModuleResourceData>() - 8usize];
    ["Offset of field: CUpti_ModuleResourceData::moduleId"]
        [::std::mem::offset_of!(CUpti_ModuleResourceData, moduleId) - 0usize];
    ["Offset of field: CUpti_ModuleResourceData::cubinSize"]
        [::std::mem::offset_of!(CUpti_ModuleResourceData, cubinSize) - 8usize];
    ["Offset of field: CUpti_ModuleResourceData::pCubin"]
        [::std::mem::offset_of!(CUpti_ModuleResourceData, pCubin) - 16usize];
};
impl Default for CUpti_ModuleResourceData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief CUDA graphs data passed into a resource callback function.\n\n CUDA graphs data passed into a resource callback function as the \\p cbdata\n argument to \\ref CUpti_CallbackFunc. The \\p cbdata will be this\n type for \\p domain equal to CUPTI_CB_DOMAIN_RESOURCE. The graph\n data is valid only within the invocation of the callback function\n that is passed the data. If you need to retain some data for use\n outside of the callback, you must make a copy of that data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_GraphData {
    #[doc = " CUDA graph"]
    pub graph: CUgraph,
    #[doc = " The original CUDA graph from which \\param graph is cloned"]
    pub originalGraph: CUgraph,
    #[doc = " CUDA graph node"]
    pub node: CUgraphNode,
    #[doc = " The original CUDA graph node from which \\param node is cloned"]
    pub originalNode: CUgraphNode,
    #[doc = " Type of the \\param node"]
    pub nodeType: CUgraphNodeType,
    #[doc = " The dependent graph node"]
    pub dependency: CUgraphNode,
    #[doc = " CUDA executable graph"]
    pub graphExec: CUgraphExec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_GraphData"][::std::mem::size_of::<CUpti_GraphData>() - 56usize];
    ["Alignment of CUpti_GraphData"][::std::mem::align_of::<CUpti_GraphData>() - 8usize];
    ["Offset of field: CUpti_GraphData::graph"]
        [::std::mem::offset_of!(CUpti_GraphData, graph) - 0usize];
    ["Offset of field: CUpti_GraphData::originalGraph"]
        [::std::mem::offset_of!(CUpti_GraphData, originalGraph) - 8usize];
    ["Offset of field: CUpti_GraphData::node"]
        [::std::mem::offset_of!(CUpti_GraphData, node) - 16usize];
    ["Offset of field: CUpti_GraphData::originalNode"]
        [::std::mem::offset_of!(CUpti_GraphData, originalNode) - 24usize];
    ["Offset of field: CUpti_GraphData::nodeType"]
        [::std::mem::offset_of!(CUpti_GraphData, nodeType) - 32usize];
    ["Offset of field: CUpti_GraphData::dependency"]
        [::std::mem::offset_of!(CUpti_GraphData, dependency) - 40usize];
    ["Offset of field: CUpti_GraphData::graphExec"]
        [::std::mem::offset_of!(CUpti_GraphData, graphExec) - 48usize];
};
impl Default for CUpti_GraphData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Data passed into a synchronize callback function.\n\n Data passed into a synchronize callback function as the \\p cbdata\n argument to \\ref CUpti_CallbackFunc. The \\p cbdata will be this\n type for \\p domain equal to CUPTI_CB_DOMAIN_SYNCHRONIZE. The\n callback data is valid only within the invocation of the callback\n function that is passed the data. If you need to retain some data\n for use outside of the callback, you must make a copy of that data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_SynchronizeData {
    #[doc = " The context of the stream being synchronized."]
    pub context: CUcontext,
    #[doc = " The stream being synchronized."]
    pub stream: CUstream,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_SynchronizeData"][::std::mem::size_of::<CUpti_SynchronizeData>() - 16usize];
    ["Alignment of CUpti_SynchronizeData"]
        [::std::mem::align_of::<CUpti_SynchronizeData>() - 8usize];
    ["Offset of field: CUpti_SynchronizeData::context"]
        [::std::mem::offset_of!(CUpti_SynchronizeData, context) - 0usize];
    ["Offset of field: CUpti_SynchronizeData::stream"]
        [::std::mem::offset_of!(CUpti_SynchronizeData, stream) - 8usize];
};
impl Default for CUpti_SynchronizeData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Data passed into a NVTX callback function.\n\n Data passed into a NVTX callback function as the \\p cbdata argument\n to \\ref CUpti_CallbackFunc. The \\p cbdata will be this type for \\p\n domain equal to CUPTI_CB_DOMAIN_NVTX. Unless otherwise notes, the\n callback data is valid only within the invocation of the callback\n function that is passed the data. If you need to retain some data\n for use outside of the callback, you must make a copy of that data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_NvtxData {
    #[doc = " Name of the NVTX API function which issued the callback. This\n string is a global constant and so may be accessed outside of the\n callback."]
    pub functionName: *const ::std::os::raw::c_char,
    #[doc = " Pointer to the arguments passed to the NVTX API call. See\n generated_nvtx_meta.h for structure definitions for the\n parameters for each NVTX API function."]
    pub functionParams: *const ::std::os::raw::c_void,
    #[doc = " Pointer to the return value of the NVTX API call. See\n nvToolsExt.h for each NVTX API function's return value."]
    pub functionReturnValue: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_NvtxData"][::std::mem::size_of::<CUpti_NvtxData>() - 24usize];
    ["Alignment of CUpti_NvtxData"][::std::mem::align_of::<CUpti_NvtxData>() - 8usize];
    ["Offset of field: CUpti_NvtxData::functionName"]
        [::std::mem::offset_of!(CUpti_NvtxData, functionName) - 0usize];
    ["Offset of field: CUpti_NvtxData::functionParams"]
        [::std::mem::offset_of!(CUpti_NvtxData, functionParams) - 8usize];
    ["Offset of field: CUpti_NvtxData::functionReturnValue"]
        [::std::mem::offset_of!(CUpti_NvtxData, functionReturnValue) - 16usize];
};
impl Default for CUpti_NvtxData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Stream attribute data passed into a resource callback function\n for CUPTI_CBID_RESOURCE_STREAM_ATTRIBUTE_CHANGED callback\n\n Data passed into a resource callback function as the \\p cbdata\n argument to \\ref CUpti_CallbackFunc. The \\p cbdata will be this\n type for \\p domain equal to CUPTI_CB_DOMAIN_RESOURCE. The\n stream attribute data is valid only within the invocation of the callback\n function that is passed the data. If you need to retain some data\n for use outside of the callback, you must make a copy of that data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_StreamAttrData {
    #[doc = " The CUDA stream handle for the attribute"]
    pub stream: CUstream,
    #[doc = " The type of the CUDA stream attribute"]
    pub attr: CUstreamAttrID,
    #[doc = " The value of the CUDA stream attribute"]
    pub value: *const CUstreamAttrValue,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_StreamAttrData"][::std::mem::size_of::<CUpti_StreamAttrData>() - 24usize];
    ["Alignment of CUpti_StreamAttrData"][::std::mem::align_of::<CUpti_StreamAttrData>() - 8usize];
    ["Offset of field: CUpti_StreamAttrData::stream"]
        [::std::mem::offset_of!(CUpti_StreamAttrData, stream) - 0usize];
    ["Offset of field: CUpti_StreamAttrData::attr"]
        [::std::mem::offset_of!(CUpti_StreamAttrData, attr) - 8usize];
    ["Offset of field: CUpti_StreamAttrData::value"]
        [::std::mem::offset_of!(CUpti_StreamAttrData, value) - 16usize];
};
impl Default for CUpti_StreamAttrData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Data passed into a State callback function.\n\n Data passed into a State callback function as the \\p cbdata argument\n to \\ref CUpti_CallbackFunc. The \\p cbdata will be this type for \\p\n domain equal to CUPTI_CB_DOMAIN_STATE and callback Ids belonging to CUpti_CallbackIdState.\n Unless otherwise noted, the callback data is valid only within the invocation of the callback\n function that is passed the data. If you need to retain some data\n for use outside of the callback, you must make a copy of that data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUpti_StateData {
    pub __bindgen_anon_1: CUpti_StateData__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_StateData__bindgen_ty_1 {
    pub notification: CUpti_StateData__bindgen_ty_1__bindgen_ty_1,
}
#[doc = " Data passed along with the callback Ids\n Enum CUpti_CallbackIdState used to denote callback ids"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_StateData__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Error code"]
    pub result: CUptiResult,
    #[doc = " String containing more details. It can be NULL."]
    pub message: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_StateData__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_StateData__bindgen_ty_1__bindgen_ty_1>() - 16usize];
    ["Alignment of CUpti_StateData__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_StateData__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: CUpti_StateData__bindgen_ty_1__bindgen_ty_1::result"]
        [::std::mem::offset_of!(CUpti_StateData__bindgen_ty_1__bindgen_ty_1, result) - 0usize];
    ["Offset of field: CUpti_StateData__bindgen_ty_1__bindgen_ty_1::message"]
        [::std::mem::offset_of!(CUpti_StateData__bindgen_ty_1__bindgen_ty_1, message) - 8usize];
};
impl Default for CUpti_StateData__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_StateData__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_StateData__bindgen_ty_1>() - 16usize];
    ["Alignment of CUpti_StateData__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_StateData__bindgen_ty_1>() - 8usize];
    ["Offset of field: CUpti_StateData__bindgen_ty_1::notification"]
        [::std::mem::offset_of!(CUpti_StateData__bindgen_ty_1, notification) - 0usize];
};
impl Default for CUpti_StateData__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_StateData__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_StateData__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_StateData"][::std::mem::size_of::<CUpti_StateData>() - 16usize];
    ["Alignment of CUpti_StateData"][::std::mem::align_of::<CUpti_StateData>() - 8usize];
};
impl Default for CUpti_StateData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_StateData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_StateData {{ __bindgen_anon_1: {:?} }}",
            self.__bindgen_anon_1
        )
    }
}
#[doc = " \\brief An ID for a driver API, runtime API, resource or\n synchronization callback.\n\n An ID for a driver API, runtime API, resource or synchronization\n callback. Within a driver API callback this should be interpreted\n as a CUpti_driver_api_trace_cbid value (these values are defined in\n cupti_driver_cbid.h). Within a runtime API callback this should be\n interpreted as a CUpti_runtime_api_trace_cbid value (these values\n are defined in cupti_runtime_cbid.h). Within a resource API\n callback this should be interpreted as a \\ref\n CUpti_CallbackIdResource value. Within a synchronize API callback\n this should be interpreted as a \\ref CUpti_CallbackIdSync value."]
pub type CUpti_CallbackId = u32;
#[doc = " \\brief Function type for a callback.\n\n Function type for a callback. The type of the data passed to the\n callback in \\p cbdata depends on the \\p domain. If \\p domain is\n CUPTI_CB_DOMAIN_DRIVER_API or CUPTI_CB_DOMAIN_RUNTIME_API the type\n of \\p cbdata will be CUpti_CallbackData. If \\p domain is\n CUPTI_CB_DOMAIN_RESOURCE the type of \\p cbdata will be\n CUpti_ResourceData. If \\p domain is CUPTI_CB_DOMAIN_SYNCHRONIZE the\n type of \\p cbdata will be CUpti_SynchronizeData. If \\p domain is\n CUPTI_CB_DOMAIN_NVTX the type of \\p cbdata will be CUpti_NvtxData.\n\n \\param userdata User data supplied at subscription of the callback\n \\param domain The domain of the callback\n \\param cbid The ID of the callback\n \\param cbdata Data passed to the callback."]
pub type CUpti_CallbackFunc = ::std::option::Option<
    unsafe extern "C" fn(
        userdata: *mut ::std::os::raw::c_void,
        domain: CUpti_CallbackDomain,
        cbid: CUpti_CallbackId,
        cbdata: *const ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Subscriber_st {
    _unused: [u8; 0],
}
#[doc = " \\brief A callback subscriber."]
pub type CUpti_SubscriberHandle = *mut CUpti_Subscriber_st;
#[doc = " \\brief Pointer to an array of callback domains."]
pub type CUpti_DomainTable = *mut CUpti_CallbackDomain;
unsafe extern "C" {
    #[doc = " \\brief Get the available callback domains.\n\n Returns in \\p *domainTable an array of size \\p *domainCount of all\n the available callback domains.\n \\note \\b Thread-safety: this function is thread safe.\n\n \\param domainCount Returns number of callback domains\n \\param domainTable Returns pointer to array of available callback domains\n\n \\retval CUPTI_SUCCESS on success\n \\retval CUPTI_ERROR_NOT_INITIALIZED if unable to initialize CUPTI\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p domainCount or \\p domainTable are NULL"]
    pub fn cuptiSupportedDomains(
        domainCount: *mut usize,
        domainTable: *mut CUpti_DomainTable,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Initialize a callback subscriber with a callback function\n and user data.\n\n Initializes a callback subscriber with a callback function and\n (optionally) a pointer to user data. The returned subscriber handle\n can be used to enable and disable the callback for specific domains\n and callback IDs.\n \\note Only a single subscriber can be registered at a time. To ensure\n that no other CUPTI client interrupts the profiling session, it's the\n responsibility of all the CUPTI clients to call this function before\n starting the profling session. In case profiling session is already\n started by another CUPTI client, this function returns the error code\n CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED.\n Note that this function returns the same error when application is\n launched using NVIDIA tools like Nsight Systems,\n Nsight Compute, cuda-gdb and cuda-memcheck.\n \\note This function does not enable any callbacks.\n \\note \\b Thread-safety: this function is thread safe.\n \\note While this API is fully supported and remains available, we recommend transitioning to the new API cuptiSubscribe_v2 moving forward.\n\n \\param subscriber Returns handle to initialize subscriber\n \\param callback The callback function\n \\param userdata A pointer to user data. This data will be passed to\n the callback function via the \\p userdata parameter.\n\n \\retval CUPTI_SUCCESS on success\n \\retval CUPTI_ERROR_NOT_INITIALIZED if unable to initialize CUPTI\n \\retval CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED if there is already a CUPTI subscriber,\n         or if the application is launched with NVIDIA tools like Nsight Systems, Nsight Compute, cuda-gdb and cuda-memcheck.\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p subscriber is NULL"]
    pub fn cuptiSubscribe(
        subscriber: *mut CUpti_SubscriberHandle,
        callback: CUpti_CallbackFunc,
        userdata: *mut ::std::os::raw::c_void,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiSubscribe_v2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_SubscriberParams {
    #[doc = " Size of the data structure. CUPTI client should set the size of the structure.\n It will be used in CUPTI to check what fields are available in the structure.\n Used to preserve backward compatibility."]
    pub structSize: usize,
    #[doc = " Name given to the subscriber. The subscriber name need not include the \"CUPTI\" prefix, as the CUPTI library automatically adds it as \"CUPTI for <subscriberName>\".\n Can be NULL. An internal copy is created. Size must not exceed CUPTI_SUBSCRIBER_NAME_MAX_LEN to avoid truncation."]
    pub subscriberName: *const ::std::os::raw::c_char,
    #[doc = " In case of CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED return code, the name of the incompatible tool or the\n existing CUPTI subscriber will be written to this location. Size should be greater than or equal to CUPTI_OLD_SUBSCRIBER_NAME_MIN_LEN to avoid truncation.\n Can be NULL."]
    pub oldSubscriberName: *mut ::std::os::raw::c_char,
    #[doc = " Size of oldSubscriberName. Minimum size should be CUPTI_OLD_SUBSCRIBER_NAME_MIN_LEN to avoid truncation."]
    pub oldSubscriberSize: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_SubscriberParams"][::std::mem::size_of::<CUpti_SubscriberParams>() - 32usize];
    ["Alignment of CUpti_SubscriberParams"]
        [::std::mem::align_of::<CUpti_SubscriberParams>() - 8usize];
    ["Offset of field: CUpti_SubscriberParams::structSize"]
        [::std::mem::offset_of!(CUpti_SubscriberParams, structSize) - 0usize];
    ["Offset of field: CUpti_SubscriberParams::subscriberName"]
        [::std::mem::offset_of!(CUpti_SubscriberParams, subscriberName) - 8usize];
    ["Offset of field: CUpti_SubscriberParams::oldSubscriberName"]
        [::std::mem::offset_of!(CUpti_SubscriberParams, oldSubscriberName) - 16usize];
    ["Offset of field: CUpti_SubscriberParams::oldSubscriberSize"]
        [::std::mem::offset_of!(CUpti_SubscriberParams, oldSubscriberSize) - 24usize];
};
impl Default for CUpti_SubscriberParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Initialize a callback subscriber with a callback function\n and user data.\n\n Initializes a callback subscriber with a callback function and\n (optionally) a pointer to user data. The returned subscriber handle\n can be used to enable and disable the callback for specific domains\n and callback IDs.\n \\note Only a single subscriber can be registered at a time. To ensure\n that no other CUPTI client interrupts the profiling session, it's the\n responsibility of all the CUPTI clients to call this function before\n starting the profling session. In case profiling session is already\n started by another CUPTI client, this function returns the error code\n CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED.\n Note that this function returns the same error when application is\n launched using NVIDIA tools like Nsight Systems,\n Nsight Compute, cuda-gdb and cuda-memcheck.\n \\note This function does not enable any callbacks.\n \\note \\b Thread-safety: this function is thread safe.\n\n \\param subscriber Returns handle to initialize subscriber\n \\param callback The callback function\n \\param userdata A pointer to user data. This data will be passed to\n the callback function via the \\p userdata parameter.\n \\param pParams A pointer to \\ref CUpti_SubscriberParams. Can be NULL.\n\n \\retval CUPTI_SUCCESS on success\n \\retval CUPTI_ERROR_NOT_INITIALIZED if unable to initialize CUPTI\n \\retval CUPTI_ERROR_MULTIPLE_SUBSCRIBERS_NOT_SUPPORTED if there is already a CUPTI subscriber,\n         or if the application is launched with NVIDIA tools like Nsight Systems, Nsight Compute, cuda-gdb and cuda-memcheck.\n \\retval CUPTI_ERROR_INVALID_PARAMETER if:\n - \\p pParams.structSize is not filled with the size of the structure"]
    pub fn cuptiSubscribe_v2(
        subscriber: *mut CUpti_SubscriberHandle,
        callback: CUpti_CallbackFunc,
        userdata: *mut ::std::os::raw::c_void,
        pParams: *mut CUpti_SubscriberParams,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Unregister a callback subscriber.\n\n Removes a callback subscriber so that no future callbacks will be\n issued to that subscriber.\n \\note \\b Thread-safety: this function is thread safe.\n\n \\param subscriber Handle to the initialize subscriber\n\n \\retval CUPTI_SUCCESS on success\n \\retval CUPTI_ERROR_NOT_INITIALIZED if unable to initialized CUPTI\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p subscriber is NULL or not initialized"]
    pub fn cuptiUnsubscribe(subscriber: CUpti_SubscriberHandle) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get the current enabled/disabled state of a callback for a specific\n domain and function ID.\n\n Returns non-zero in \\p *enable if the callback for a domain and\n callback ID is enabled, and zero if not enabled.\n\n \\note \\b Thread-safety: a subscriber must serialize access to\n cuptiGetCallbackState, cuptiEnableCallback, cuptiEnableDomain, and\n cuptiEnableAllDomains. For example, if cuptiGetCallbackState(sub,\n d, c) and cuptiEnableCallback(sub, d, c) are called concurrently,\n the results are undefined.\n\n \\param enable Returns non-zero if callback enabled, zero if not enabled\n \\param subscriber Handle to the initialize subscriber\n \\param domain The domain of the callback\n \\param cbid The ID of the callback\n\n \\retval CUPTI_SUCCESS on success\n \\retval CUPTI_ERROR_NOT_INITIALIZED if unable to initialized CUPTI\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p enabled is NULL, or if \\p\n subscriber, \\p domain or \\p cbid is invalid."]
    pub fn cuptiGetCallbackState(
        enable: *mut u32,
        subscriber: CUpti_SubscriberHandle,
        domain: CUpti_CallbackDomain,
        cbid: CUpti_CallbackId,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Enable or disabled callbacks for a specific domain and\n callback ID.\n\n Enable or disabled callbacks for a subscriber for a specific domain\n and callback ID.\n\n \\note \\b Thread-safety: a subscriber must serialize access to\n cuptiGetCallbackState, cuptiEnableCallback, cuptiEnableDomain, and\n cuptiEnableAllDomains. For example, if cuptiGetCallbackState(sub,\n d, c) and cuptiEnableCallback(sub, d, c) are called concurrently,\n the results are undefined.\n\n \\param enable New enable state for the callback. Zero disables the\n callback, non-zero enables the callback.\n \\param subscriber - Handle to callback subscription\n \\param domain The domain of the callback\n \\param cbid The ID of the callback\n\n \\retval CUPTI_SUCCESS on success\n \\retval CUPTI_ERROR_NOT_INITIALIZED if unable to initialized CUPTI\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p subscriber, \\p domain or \\p\n cbid is invalid."]
    pub fn cuptiEnableCallback(
        enable: u32,
        subscriber: CUpti_SubscriberHandle,
        domain: CUpti_CallbackDomain,
        cbid: CUpti_CallbackId,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Enable or disabled all callbacks for a specific domain.\n\n Enable or disabled all callbacks for a specific domain.\n\n \\note \\b Thread-safety: a subscriber must serialize access to\n cuptiGetCallbackState, cuptiEnableCallback, cuptiEnableDomain, and\n cuptiEnableAllDomains. For example, if cuptiGetCallbackEnabled(sub,\n d, *) and cuptiEnableDomain(sub, d) are called concurrently, the\n results are undefined.\n\n \\param enable New enable state for all callbacks in the\n domain. Zero disables all callbacks, non-zero enables all\n callbacks.\n \\param subscriber - Handle to callback subscription\n \\param domain The domain of the callback\n\n \\retval CUPTI_SUCCESS on success\n \\retval CUPTI_ERROR_NOT_INITIALIZED if unable to initialized CUPTI\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p subscriber or \\p domain is invalid"]
    pub fn cuptiEnableDomain(
        enable: u32,
        subscriber: CUpti_SubscriberHandle,
        domain: CUpti_CallbackDomain,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Enable or disable all callbacks in all domains.\n\n Enable or disable all callbacks in all domains.\n\n \\note \\b Thread-safety: a subscriber must serialize access to\n cuptiGetCallbackState, cuptiEnableCallback, cuptiEnableDomain, and\n cuptiEnableAllDomains. For example, if cuptiGetCallbackState(sub,\n d, *) and cuptiEnableAllDomains(sub) are called concurrently, the\n results are undefined.\n\n \\param enable New enable state for all callbacks in all\n domain. Zero disables all callbacks, non-zero enables all\n callbacks.\n \\param subscriber - Handle to callback subscription\n\n \\retval CUPTI_SUCCESS on success\n \\retval CUPTI_ERROR_NOT_INITIALIZED if unable to initialized CUPTI\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p subscriber is invalid"]
    pub fn cuptiEnableAllDomains(enable: u32, subscriber: CUpti_SubscriberHandle) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get the name of a callback for a specific domain and callback ID.\n\n Returns a pointer to the name c_string in \\p **name.\n\n \\note \\b Names are available only for the DRIVER and RUNTIME domains.\n\n \\param domain The domain of the callback\n \\param cbid The ID of the callback\n \\param name Returns pointer to the name string on success, NULL otherwise\n\n \\retval CUPTI_SUCCESS on success\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p name is NULL, or if\n \\p domain or \\p cbid is invalid."]
    pub fn cuptiGetCallbackName(
        domain: CUpti_CallbackDomain,
        cbid: u32,
        name: *mut *const ::std::os::raw::c_char,
    ) -> CUptiResult;
}
#[doc = " \\brief ID for an event.\n\n An event represents a countable activity, action, or occurrence on\n the device."]
pub type CUpti_EventID = u32;
#[doc = " \\brief ID for an event domain.\n\n ID for an event domain. An event domain represents a group of\n related events. A device may have multiple instances of a domain,\n indicating that the device can simultaneously record multiple\n instances of each event within that domain."]
pub type CUpti_EventDomainID = u32;
#[doc = " \\brief A group of events.\n\n An event group is a collection of events that are managed\n together. All events in an event group must belong to the same\n domain."]
pub type CUpti_EventGroup = *mut ::std::os::raw::c_void;
pub const CUPTI_DEVICE_ATTR_DEVICE_CLASS_TESLA: CUpti_DeviceAttributeDeviceClass = 0;
pub const CUPTI_DEVICE_ATTR_DEVICE_CLASS_QUADRO: CUpti_DeviceAttributeDeviceClass = 1;
pub const CUPTI_DEVICE_ATTR_DEVICE_CLASS_GEFORCE: CUpti_DeviceAttributeDeviceClass = 2;
pub const CUPTI_DEVICE_ATTR_DEVICE_CLASS_TEGRA: CUpti_DeviceAttributeDeviceClass = 3;
#[doc = " \\brief Device class.\n\n Enumeration of device classes for device attribute\n CUPTI_DEVICE_ATTR_DEVICE_CLASS."]
pub type CUpti_DeviceAttributeDeviceClass = ::std::os::raw::c_uint;
#[doc = " Number of event IDs for a device. Value is a uint32_t."]
pub const CUPTI_DEVICE_ATTR_MAX_EVENT_ID: CUpti_DeviceAttribute = 1;
#[doc = " Number of event domain IDs for a device. Value is a uint32_t."]
pub const CUPTI_DEVICE_ATTR_MAX_EVENT_DOMAIN_ID: CUpti_DeviceAttribute = 2;
#[doc = " Get global memory bandwidth in Kbytes/sec. Value is a uint64_t."]
pub const CUPTI_DEVICE_ATTR_GLOBAL_MEMORY_BANDWIDTH: CUpti_DeviceAttribute = 3;
#[doc = " Get theoretical maximum number of instructions per cycle. Value\n is a uint32_t."]
pub const CUPTI_DEVICE_ATTR_INSTRUCTION_PER_CYCLE: CUpti_DeviceAttribute = 4;
#[doc = " Get theoretical maximum number of single precision instructions\n that can be executed per second. Value is a uint64_t."]
pub const CUPTI_DEVICE_ATTR_INSTRUCTION_THROUGHPUT_SINGLE_PRECISION: CUpti_DeviceAttribute = 5;
#[doc = " Get number of frame buffers for device.  Value is a uint64_t."]
pub const CUPTI_DEVICE_ATTR_MAX_FRAME_BUFFERS: CUpti_DeviceAttribute = 6;
#[doc = " Get PCIE link rate in Mega bits/sec for device. Return 0 if bus-type\n is non-PCIE. Value is a uint64_t."]
pub const CUPTI_DEVICE_ATTR_PCIE_LINK_RATE: CUpti_DeviceAttribute = 7;
#[doc = " Get PCIE link width for device. Return 0 if bus-type\n is non-PCIE. Value is a uint64_t."]
pub const CUPTI_DEVICE_ATTR_PCIE_LINK_WIDTH: CUpti_DeviceAttribute = 8;
#[doc = " Get PCIE generation for device. Return 0 if bus-type\n is non-PCIE. Value is a uint64_t."]
pub const CUPTI_DEVICE_ATTR_PCIE_GEN: CUpti_DeviceAttribute = 9;
#[doc = " Get the class for the device. Value is a\n CUpti_DeviceAttributeDeviceClass."]
pub const CUPTI_DEVICE_ATTR_DEVICE_CLASS: CUpti_DeviceAttribute = 10;
#[doc = " Get the peak single precision flop per cycle. Value is a uint64_t."]
pub const CUPTI_DEVICE_ATTR_FLOP_SP_PER_CYCLE: CUpti_DeviceAttribute = 11;
#[doc = " Get the peak double precision flop per cycle. Value is a uint64_t."]
pub const CUPTI_DEVICE_ATTR_FLOP_DP_PER_CYCLE: CUpti_DeviceAttribute = 12;
#[doc = " Get number of L2 units. Value is a uint64_t."]
pub const CUPTI_DEVICE_ATTR_MAX_L2_UNITS: CUpti_DeviceAttribute = 13;
#[doc = " Get the maximum shared memory for the CU_FUNC_CACHE_PREFER_SHARED\n preference. Value is a uint64_t."]
pub const CUPTI_DEVICE_ATTR_MAX_SHARED_MEMORY_CACHE_CONFIG_PREFER_SHARED: CUpti_DeviceAttribute =
    14;
#[doc = " Get the maximum shared memory for the CU_FUNC_CACHE_PREFER_L1\n preference. Value is a uint64_t."]
pub const CUPTI_DEVICE_ATTR_MAX_SHARED_MEMORY_CACHE_CONFIG_PREFER_L1: CUpti_DeviceAttribute = 15;
#[doc = " Get the maximum shared memory for the CU_FUNC_CACHE_PREFER_EQUAL\n preference. Value is a uint64_t."]
pub const CUPTI_DEVICE_ATTR_MAX_SHARED_MEMORY_CACHE_CONFIG_PREFER_EQUAL: CUpti_DeviceAttribute = 16;
#[doc = " Get the peak half precision flop per cycle. Value is a uint64_t."]
pub const CUPTI_DEVICE_ATTR_FLOP_HP_PER_CYCLE: CUpti_DeviceAttribute = 17;
#[doc = " Check if Nvlink is connected to device. Returns 1, if at least one\n Nvlink is connected to the device, returns 0 otherwise.\n Value is a uint32_t."]
pub const CUPTI_DEVICE_ATTR_NVLINK_PRESENT: CUpti_DeviceAttribute = 18;
#[doc = " Check if Nvlink is present between GPU and CPU. Returns Bandwidth,\n in Bytes/sec, if Nvlink is present, returns 0 otherwise.\n Value is a uint64_t."]
pub const CUPTI_DEVICE_ATTR_GPU_CPU_NVLINK_BW: CUpti_DeviceAttribute = 19;
#[doc = " Check if NVSwitch is present in the underlying topology.\n Returns 1, if present, returns 0 otherwise.\n Value is a uint32_t."]
pub const CUPTI_DEVICE_ATTR_NVSWITCH_PRESENT: CUpti_DeviceAttribute = 20;
#[doc = " Check if NVSwitch is present in the underlying topology.\n Returns 1, if present, returns 0 otherwise.\n Value is a uint32_t."]
pub const CUPTI_DEVICE_ATTR_FORCE_INT: CUpti_DeviceAttribute = 2147483647;
#[doc = " \\brief Device attributes.\n\n CUPTI device attributes. These attributes can be read using \\ref\n cuptiDeviceGetAttribute."]
pub type CUpti_DeviceAttribute = ::std::os::raw::c_uint;
#[doc = " Event domain name. Value is a null terminated const c-string."]
pub const CUPTI_EVENT_DOMAIN_ATTR_NAME: CUpti_EventDomainAttribute = 0;
#[doc = " Number of instances of the domain for which event counts will be\n collected.  The domain may have additional instances that cannot\n be profiled (see CUPTI_EVENT_DOMAIN_ATTR_TOTAL_INSTANCE_COUNT).\n Can be read only with \\ref\n cuptiDeviceGetEventDomainAttribute. Value is a uint32_t."]
pub const CUPTI_EVENT_DOMAIN_ATTR_INSTANCE_COUNT: CUpti_EventDomainAttribute = 1;
#[doc = " Total number of instances of the domain, including instances that\n cannot be profiled.  Use CUPTI_EVENT_DOMAIN_ATTR_INSTANCE_COUNT\n to get the number of instances that can be profiled. Can be read\n only with \\ref cuptiDeviceGetEventDomainAttribute. Value is a\n uint32_t."]
pub const CUPTI_EVENT_DOMAIN_ATTR_TOTAL_INSTANCE_COUNT: CUpti_EventDomainAttribute = 3;
#[doc = " Collection method used for events contained in the event domain.\n Value is a \\ref CUpti_EventCollectionMethod."]
pub const CUPTI_EVENT_DOMAIN_ATTR_COLLECTION_METHOD: CUpti_EventDomainAttribute = 4;
#[doc = " Collection method used for events contained in the event domain.\n Value is a \\ref CUpti_EventCollectionMethod."]
pub const CUPTI_EVENT_DOMAIN_ATTR_FORCE_INT: CUpti_EventDomainAttribute = 2147483647;
#[doc = " \\brief Event domain attributes.\n\n Event domain attributes. Except where noted, all the attributes can\n be read using either \\ref cuptiDeviceGetEventDomainAttribute or\n \\ref cuptiEventDomainGetAttribute."]
pub type CUpti_EventDomainAttribute = ::std::os::raw::c_uint;
#[doc = " Event is collected using a hardware global performance monitor."]
pub const CUPTI_EVENT_COLLECTION_METHOD_PM: CUpti_EventCollectionMethod = 0;
#[doc = " Event is collected using a hardware SM performance monitor."]
pub const CUPTI_EVENT_COLLECTION_METHOD_SM: CUpti_EventCollectionMethod = 1;
#[doc = " Event is collected using software instrumentation."]
pub const CUPTI_EVENT_COLLECTION_METHOD_INSTRUMENTED: CUpti_EventCollectionMethod = 2;
#[doc = " Event is collected using NvLink throughput counter method."]
pub const CUPTI_EVENT_COLLECTION_METHOD_NVLINK_TC: CUpti_EventCollectionMethod = 3;
#[doc = " Event is collected using NvLink throughput counter method."]
pub const CUPTI_EVENT_COLLECTION_METHOD_FORCE_INT: CUpti_EventCollectionMethod = 2147483647;
#[doc = " \\brief The collection method used for an event.\n\n The collection method indicates how an event is collected."]
pub type CUpti_EventCollectionMethod = ::std::os::raw::c_uint;
#[doc = " The domain to which the event group is bound. This attribute is\n set when the first event is added to the group.  Value is a\n CUpti_EventDomainID."]
pub const CUPTI_EVENT_GROUP_ATTR_EVENT_DOMAIN_ID: CUpti_EventGroupAttribute = 0;
#[doc = " [rw] Profile all the instances of the domain for this\n eventgroup. This feature can be used to get load balancing\n across all instances of a domain. Value is an integer."]
pub const CUPTI_EVENT_GROUP_ATTR_PROFILE_ALL_DOMAIN_INSTANCES: CUpti_EventGroupAttribute = 1;
#[doc = " [rw] Reserved for user data."]
pub const CUPTI_EVENT_GROUP_ATTR_USER_DATA: CUpti_EventGroupAttribute = 2;
#[doc = " Number of events in the group. Value is a uint32_t."]
pub const CUPTI_EVENT_GROUP_ATTR_NUM_EVENTS: CUpti_EventGroupAttribute = 3;
#[doc = " Enumerates events in the group. Value is a pointer to buffer of\n size sizeof(CUpti_EventID) * num_of_events in the eventgroup.\n num_of_events can be queried using\n CUPTI_EVENT_GROUP_ATTR_NUM_EVENTS."]
pub const CUPTI_EVENT_GROUP_ATTR_EVENTS: CUpti_EventGroupAttribute = 4;
#[doc = " Number of instances of the domain bound to this event group that\n will be counted.  Value is a uint32_t."]
pub const CUPTI_EVENT_GROUP_ATTR_INSTANCE_COUNT: CUpti_EventGroupAttribute = 5;
#[doc = " Event group scope can be set to CUPTI_EVENT_PROFILING_SCOPE_DEVICE or\n CUPTI_EVENT_PROFILING_SCOPE_CONTEXT for an eventGroup, before\n adding any event.\n Sets the scope of eventgroup as CUPTI_EVENT_PROFILING_SCOPE_DEVICE or\n CUPTI_EVENT_PROFILING_SCOPE_CONTEXT when the scope of the events\n that will be added is CUPTI_EVENT_PROFILING_SCOPE_BOTH.\n If profiling scope of event is either\n CUPTI_EVENT_PROFILING_SCOPE_DEVICE or CUPTI_EVENT_PROFILING_SCOPE_CONTEXT\n then setting this attribute will not affect the default scope.\n It is not allowed to add events of different scope to same eventgroup.\n Value is a uint32_t."]
pub const CUPTI_EVENT_GROUP_ATTR_PROFILING_SCOPE: CUpti_EventGroupAttribute = 6;
#[doc = " Event group scope can be set to CUPTI_EVENT_PROFILING_SCOPE_DEVICE or\n CUPTI_EVENT_PROFILING_SCOPE_CONTEXT for an eventGroup, before\n adding any event.\n Sets the scope of eventgroup as CUPTI_EVENT_PROFILING_SCOPE_DEVICE or\n CUPTI_EVENT_PROFILING_SCOPE_CONTEXT when the scope of the events\n that will be added is CUPTI_EVENT_PROFILING_SCOPE_BOTH.\n If profiling scope of event is either\n CUPTI_EVENT_PROFILING_SCOPE_DEVICE or CUPTI_EVENT_PROFILING_SCOPE_CONTEXT\n then setting this attribute will not affect the default scope.\n It is not allowed to add events of different scope to same eventgroup.\n Value is a uint32_t."]
pub const CUPTI_EVENT_GROUP_ATTR_FORCE_INT: CUpti_EventGroupAttribute = 2147483647;
#[doc = " \\brief Event group attributes.\n\n Event group attributes. These attributes can be read using \\ref\n cuptiEventGroupGetAttribute. Attributes marked [rw] can also be\n written using \\ref cuptiEventGroupSetAttribute."]
pub type CUpti_EventGroupAttribute = ::std::os::raw::c_uint;
#[doc = " Event is collected at context scope."]
pub const CUPTI_EVENT_PROFILING_SCOPE_CONTEXT: CUpti_EventProfilingScope = 0;
#[doc = " Event is collected at device scope."]
pub const CUPTI_EVENT_PROFILING_SCOPE_DEVICE: CUpti_EventProfilingScope = 1;
#[doc = " Event can be collected at device or context scope.\n The scope can be set using \\ref cuptiEventGroupSetAttribute API."]
pub const CUPTI_EVENT_PROFILING_SCOPE_BOTH: CUpti_EventProfilingScope = 2;
#[doc = " Event can be collected at device or context scope.\n The scope can be set using \\ref cuptiEventGroupSetAttribute API."]
pub const CUPTI_EVENT_PROFILING_SCOPE_FORCE_INT: CUpti_EventProfilingScope = 2147483647;
#[doc = " \\brief Profiling scope for event.\n\n Profiling scope of event indicates if the event can be collected at context\n scope or device scope or both i.e. it can be collected at any of context or\n device scope."]
pub type CUpti_EventProfilingScope = ::std::os::raw::c_uint;
#[doc = " Event name. Value is a null terminated const c-string."]
pub const CUPTI_EVENT_ATTR_NAME: CUpti_EventAttribute = 0;
#[doc = " Short description of event. Value is a null terminated const\n c-string."]
pub const CUPTI_EVENT_ATTR_SHORT_DESCRIPTION: CUpti_EventAttribute = 1;
#[doc = " Long description of event. Value is a null terminated const\n c-string."]
pub const CUPTI_EVENT_ATTR_LONG_DESCRIPTION: CUpti_EventAttribute = 2;
#[doc = " Category of event. Value is CUpti_EventCategory."]
pub const CUPTI_EVENT_ATTR_CATEGORY: CUpti_EventAttribute = 3;
#[doc = " Profiling scope of the events. It can be either device or context or both.\n Value is a \\ref CUpti_EventProfilingScope."]
pub const CUPTI_EVENT_ATTR_PROFILING_SCOPE: CUpti_EventAttribute = 5;
#[doc = " Profiling scope of the events. It can be either device or context or both.\n Value is a \\ref CUpti_EventProfilingScope."]
pub const CUPTI_EVENT_ATTR_FORCE_INT: CUpti_EventAttribute = 2147483647;
#[doc = " \\brief Event attributes.\n\n Event attributes. These attributes can be read using \\ref\n cuptiEventGetAttribute."]
pub type CUpti_EventAttribute = ::std::os::raw::c_uint;
#[doc = " Events are collected for the entire duration between the\n cuptiEventGroupEnable and cuptiEventGroupDisable calls.\n Event values are reset when the events are read.\n For CUDA toolkit v6.0 and older this was the default mode."]
pub const CUPTI_EVENT_COLLECTION_MODE_CONTINUOUS: CUpti_EventCollectionMode = 0;
#[doc = " Events are collected only for the durations of kernel executions\n that occur between the cuptiEventGroupEnable and\n cuptiEventGroupDisable calls. Event collection begins when a\n kernel execution begins, and stops when kernel execution\n completes. Event values are reset to zero when each kernel\n execution begins. If multiple kernel executions occur between the\n cuptiEventGroupEnable and cuptiEventGroupDisable calls then the\n event values must be read after each kernel launch if those\n events need to be associated with the specific kernel launch.\n Note that collection in this mode may significantly change the\n overall performance characteristics of the application because\n kernel executions that occur between the cuptiEventGroupEnable and\n cuptiEventGroupDisable calls are serialized on the GPU.\n This is the default mode from CUDA toolkit v6.5"]
pub const CUPTI_EVENT_COLLECTION_MODE_KERNEL: CUpti_EventCollectionMode = 1;
#[doc = " Events are collected only for the durations of kernel executions\n that occur between the cuptiEventGroupEnable and\n cuptiEventGroupDisable calls. Event collection begins when a\n kernel execution begins, and stops when kernel execution\n completes. Event values are reset to zero when each kernel\n execution begins. If multiple kernel executions occur between the\n cuptiEventGroupEnable and cuptiEventGroupDisable calls then the\n event values must be read after each kernel launch if those\n events need to be associated with the specific kernel launch.\n Note that collection in this mode may significantly change the\n overall performance characteristics of the application because\n kernel executions that occur between the cuptiEventGroupEnable and\n cuptiEventGroupDisable calls are serialized on the GPU.\n This is the default mode from CUDA toolkit v6.5"]
pub const CUPTI_EVENT_COLLECTION_MODE_FORCE_INT: CUpti_EventCollectionMode = 2147483647;
#[doc = " \\brief Event collection modes.\n\n The event collection mode determines the period over which the\n events within the enabled event groups will be collected."]
pub type CUpti_EventCollectionMode = ::std::os::raw::c_uint;
#[doc = " An instruction related event."]
pub const CUPTI_EVENT_CATEGORY_INSTRUCTION: CUpti_EventCategory = 0;
#[doc = " A memory related event."]
pub const CUPTI_EVENT_CATEGORY_MEMORY: CUpti_EventCategory = 1;
#[doc = " A cache related event."]
pub const CUPTI_EVENT_CATEGORY_CACHE: CUpti_EventCategory = 2;
#[doc = " A profile-trigger event."]
pub const CUPTI_EVENT_CATEGORY_PROFILE_TRIGGER: CUpti_EventCategory = 3;
#[doc = " A system event."]
pub const CUPTI_EVENT_CATEGORY_SYSTEM: CUpti_EventCategory = 4;
#[doc = " A system event."]
pub const CUPTI_EVENT_CATEGORY_FORCE_INT: CUpti_EventCategory = 2147483647;
#[doc = " \\brief An event category.\n\n Each event is assigned to a category that represents the general\n type of the event. A event's category is accessed using \\ref\n cuptiEventGetAttribute and the CUPTI_EVENT_ATTR_CATEGORY attribute."]
pub type CUpti_EventCategory = ::std::os::raw::c_uint;
#[doc = " No flags."]
pub const CUPTI_EVENT_READ_FLAG_NONE: CUpti_ReadEventFlags = 0;
#[doc = " No flags."]
pub const CUPTI_EVENT_READ_FLAG_FORCE_INT: CUpti_ReadEventFlags = 2147483647;
#[doc = " \\brief Flags for cuptiEventGroupReadEvent an\n cuptiEventGroupReadAllEvents.\n\n Flags for \\ref cuptiEventGroupReadEvent an \\ref\n cuptiEventGroupReadAllEvents."]
pub type CUpti_ReadEventFlags = ::std::os::raw::c_uint;
#[doc = " \\brief A set of event groups.\n\n A set of event groups. When returned by \\ref\n cuptiEventGroupSetsCreate and \\ref cuptiMetricCreateEventGroupSets\n a set indicates that event groups that can be enabled at the same\n time (i.e. all the events in the set can be collected\n simultaneously)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_EventGroupSet {
    #[doc = " The number of event groups in the set."]
    pub numEventGroups: u32,
    #[doc = " An array of \\p numEventGroups event groups."]
    pub eventGroups: *mut CUpti_EventGroup,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_EventGroupSet"][::std::mem::size_of::<CUpti_EventGroupSet>() - 16usize];
    ["Alignment of CUpti_EventGroupSet"][::std::mem::align_of::<CUpti_EventGroupSet>() - 8usize];
    ["Offset of field: CUpti_EventGroupSet::numEventGroups"]
        [::std::mem::offset_of!(CUpti_EventGroupSet, numEventGroups) - 0usize];
    ["Offset of field: CUpti_EventGroupSet::eventGroups"]
        [::std::mem::offset_of!(CUpti_EventGroupSet, eventGroups) - 8usize];
};
impl Default for CUpti_EventGroupSet {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief A set of event group sets.\n\n A set of event group sets. When returned by \\ref\n cuptiEventGroupSetsCreate and \\ref cuptiMetricCreateEventGroupSets\n a CUpti_EventGroupSets indicates the number of passes required to\n collect all the events, and the event groups that should be\n collected during each pass."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_EventGroupSets {
    #[doc = " Number of event group sets."]
    pub numSets: u32,
    #[doc = " An array of \\p numSets event group sets."]
    pub sets: *mut CUpti_EventGroupSet,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_EventGroupSets"][::std::mem::size_of::<CUpti_EventGroupSets>() - 16usize];
    ["Alignment of CUpti_EventGroupSets"][::std::mem::align_of::<CUpti_EventGroupSets>() - 8usize];
    ["Offset of field: CUpti_EventGroupSets::numSets"]
        [::std::mem::offset_of!(CUpti_EventGroupSets, numSets) - 0usize];
    ["Offset of field: CUpti_EventGroupSets::sets"]
        [::std::mem::offset_of!(CUpti_EventGroupSets, sets) - 8usize];
};
impl Default for CUpti_EventGroupSets {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Set the event collection mode.\n\n Set the event collection mode for a \\p context.  The \\p mode\n controls the event collection behavior of all events in event\n groups created in the \\p context. This API is invalid in kernel\n replay mode.\n \\note \\b Thread-safety: this function is thread safe.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param context The context\n \\param mode The event collection mode\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_CONTEXT\n \\retval CUPTI_ERROR_INVALID_OPERATION if called when replay mode is enabled\n \\retval CUPTI_ERROR_NOT_SUPPORTED if mode is not supported on the device"]
    pub fn cuptiSetEventCollectionMode(
        context: CUcontext,
        mode: CUpti_EventCollectionMode,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Read a device attribute.\n\n Read a device attribute and return it in \\p *value.\n \\note \\b Thread-safety: this function is thread safe.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param device CUDA device\n \\param attrib The attribute to read\n \\param valueSize Size of buffer pointed by the value, and\n returns the number of bytes written to \\p value\n \\param value Returns the value of the attribute\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_DEVICE\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p valueSize or \\p value\n is NULL, or if \\p attrib is not a device attribute\n \\retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT For non-c-string\n attribute values, indicates that the \\p value buffer is too small\n to hold the attribute value."]
    pub fn cuptiDeviceGetAttribute(
        device: CUdevice,
        attrib: CUpti_DeviceAttribute,
        valueSize: *mut usize,
        value: *mut ::std::os::raw::c_void,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get the number of domains for a device.\n\n Returns the number of domains in \\p numDomains for a device.\n \\note \\b Thread-safety: this function is thread safe.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param device CUDA device\n \\param numDomains Returns the number of domains\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_DEVICE\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p numDomains is NULL"]
    pub fn cuptiDeviceGetNumEventDomains(device: CUdevice, numDomains: *mut u32) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get the event domains for a device.\n\n Returns the event domains IDs in \\p domainArray for a device.  The\n size of the \\p domainArray buffer is given by \\p\n *arraySizeBytes. The size of the \\p domainArray buffer must be at\n least \\p numdomains * sizeof(CUpti_EventDomainID) or else all\n domains will not be returned. The value returned in \\p\n *arraySizeBytes contains the number of bytes returned in \\p\n domainArray.\n \\note \\b Thread-safety: this function is thread safe.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param device CUDA device\n \\param arraySizeBytes The size of \\p domainArray in bytes, and\n returns the number of bytes written to \\p domainArray\n \\param domainArray Returns the IDs of the event domains for the device\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_DEVICE\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p arraySizeBytes or\n \\p domainArray are NULL"]
    pub fn cuptiDeviceEnumEventDomains(
        device: CUdevice,
        arraySizeBytes: *mut usize,
        domainArray: *mut CUpti_EventDomainID,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Read an event domain attribute.\n\n Returns an event domain attribute in \\p *value. The size of the \\p\n value buffer is given by \\p *valueSize. The value returned in \\p\n *valueSize contains the number of bytes returned in \\p value.\n\n If the attribute value is a c-string that is longer than \\p\n *valueSize, then only the first \\p *valueSize characters will be\n returned and there will be no terminating null byte.\n \\note \\b Thread-safety: this function is thread safe.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param device CUDA device\n \\param eventDomain ID of the event domain\n \\param attrib The event domain attribute to read\n \\param valueSize The size of the \\p value buffer in bytes, and\n returns the number of bytes written to \\p value\n \\param value Returns the attribute's value\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_DEVICE\n \\retval CUPTI_ERROR_INVALID_EVENT_DOMAIN_ID\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p valueSize or \\p value\n is NULL, or if \\p attrib is not an event domain attribute\n \\retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT For non-c-string\n attribute values, indicates that the \\p value buffer is too small\n to hold the attribute value."]
    pub fn cuptiDeviceGetEventDomainAttribute(
        device: CUdevice,
        eventDomain: CUpti_EventDomainID,
        attrib: CUpti_EventDomainAttribute,
        valueSize: *mut usize,
        value: *mut ::std::os::raw::c_void,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get the number of event domains available on any device.\n\n Returns the total number of event domains available on any\n CUDA-capable device.\n \\note \\b Thread-safety: this function is thread safe.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param numDomains Returns the number of domains\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p numDomains is NULL"]
    pub fn cuptiGetNumEventDomains(numDomains: *mut u32) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get the event domains available on any device.\n\n Returns all the event domains available on any CUDA-capable device.\n Event domain IDs are returned in \\p domainArray. The size of the \\p\n domainArray buffer is given by \\p *arraySizeBytes. The size of the\n \\p domainArray buffer must be at least \\p numDomains *\n sizeof(CUpti_EventDomainID) or all domains will not be\n returned. The value returned in \\p *arraySizeBytes contains the\n number of bytes returned in \\p domainArray.\n \\note \\b Thread-safety: this function is thread safe.\n\n \\param arraySizeBytes The size of \\p domainArray in bytes, and\n returns the number of bytes written to \\p domainArray\n \\param domainArray Returns all the event domains\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p arraySizeBytes or\n \\p domainArray are NULL"]
    pub fn cuptiEnumEventDomains(
        arraySizeBytes: *mut usize,
        domainArray: *mut CUpti_EventDomainID,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Read an event domain attribute.\n\n Returns an event domain attribute in \\p *value. The size of the \\p\n value buffer is given by \\p *valueSize. The value returned in \\p\n *valueSize contains the number of bytes returned in \\p value.\n\n If the attribute value is a c-string that is longer than \\p\n *valueSize, then only the first \\p *valueSize characters will be\n returned and there will be no terminating null byte.\n \\note \\b Thread-safety: this function is thread safe.\n\n \\param eventDomain ID of the event domain\n \\param attrib The event domain attribute to read\n \\param valueSize The size of the \\p value buffer in bytes, and\n returns the number of bytes written to \\p value\n \\param value Returns the attribute's value\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_EVENT_DOMAIN_ID\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p valueSize or \\p value\n is NULL, or if \\p attrib is not an event domain attribute\n \\retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT For non-c-string\n attribute values, indicates that the \\p value buffer is too small\n to hold the attribute value."]
    pub fn cuptiEventDomainGetAttribute(
        eventDomain: CUpti_EventDomainID,
        attrib: CUpti_EventDomainAttribute,
        valueSize: *mut usize,
        value: *mut ::std::os::raw::c_void,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get number of events in a domain.\n\n Returns the number of events in \\p numEvents for a domain.\n \\note \\b Thread-safety: this function is thread safe.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param eventDomain ID of the event domain\n \\param numEvents Returns the number of events in the domain\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_EVENT_DOMAIN_ID\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p numEvents is NULL"]
    pub fn cuptiEventDomainGetNumEvents(
        eventDomain: CUpti_EventDomainID,
        numEvents: *mut u32,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get the events in a domain.\n\n Returns the event IDs in \\p eventArray for a domain.  The size of\n the \\p eventArray buffer is given by \\p *arraySizeBytes. The size\n of the \\p eventArray buffer must be at least \\p numdomainevents *\n sizeof(CUpti_EventID) or else all events will not be returned. The\n value returned in \\p *arraySizeBytes contains the number of bytes\n returned in \\p eventArray.\n \\note \\b Thread-safety: this function is thread safe.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param eventDomain ID of the event domain\n \\param arraySizeBytes The size of \\p eventArray in bytes, and\n returns the number of bytes written to \\p eventArray\n \\param eventArray Returns the IDs of the events in the domain\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_EVENT_DOMAIN_ID\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p arraySizeBytes or \\p\n eventArray are NULL"]
    pub fn cuptiEventDomainEnumEvents(
        eventDomain: CUpti_EventDomainID,
        arraySizeBytes: *mut usize,
        eventArray: *mut CUpti_EventID,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get an event attribute.\n\n Returns an event attribute in \\p *value. The size of the \\p\n value buffer is given by \\p *valueSize. The value returned in \\p\n *valueSize contains the number of bytes returned in \\p value.\n\n If the attribute value is a c-string that is longer than \\p\n *valueSize, then only the first \\p *valueSize characters will be\n returned and there will be no terminating null byte.\n \\note \\b Thread-safety: this function is thread safe.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param event ID of the event\n \\param attrib The event attribute to read\n \\param valueSize The size of the \\p value buffer in bytes, and\n returns the number of bytes written to \\p value\n \\param value Returns the attribute's value\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_EVENT_ID\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p valueSize or \\p value\n is NULL, or if \\p attrib is not an event attribute\n \\retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT For non-c-string\n attribute values, indicates that the \\p value buffer is too small\n to hold the attribute value."]
    pub fn cuptiEventGetAttribute(
        event: CUpti_EventID,
        attrib: CUpti_EventAttribute,
        valueSize: *mut usize,
        value: *mut ::std::os::raw::c_void,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Find an event by name.\n\n Find an event by name and return the event ID in \\p *event.\n \\note \\b Thread-safety: this function is thread safe.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param device CUDA device\n \\param eventName The name of the event to find\n \\param event Returns the ID of the found event or undefined if\n unable to find the event\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_DEVICE\n \\retval CUPTI_ERROR_INVALID_EVENT_NAME if unable to find an event\n with name \\p eventName. In this case \\p *event is undefined\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p eventName or \\p event are NULL"]
    pub fn cuptiEventGetIdFromName(
        device: CUdevice,
        eventName: *const ::std::os::raw::c_char,
        event: *mut CUpti_EventID,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Create a new event group for a context.\n\n Creates a new event group for \\p context and returns the new group\n in \\p *eventGroup.\n \\note \\p flags are reserved for future use and should be set to zero.\n \\note \\b Thread-safety: this function is thread safe.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param context The context for the event group\n \\param eventGroup Returns the new event group\n \\param flags Reserved - must be zero\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_CONTEXT\n \\retval CUPTI_ERROR_OUT_OF_MEMORY\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p eventGroup is NULL"]
    pub fn cuptiEventGroupCreate(
        context: CUcontext,
        eventGroup: *mut CUpti_EventGroup,
        flags: u32,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Destroy an event group.\n\n Destroy an \\p eventGroup and free its resources. An event group\n cannot be destroyed if it is enabled.\n \\note \\b Thread-safety: this function is thread safe.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param eventGroup The event group to destroy\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_OPERATION if the event group is enabled\n \\retval CUPTI_ERROR_INVALID_PARAMETER if eventGroup is NULL"]
    pub fn cuptiEventGroupDestroy(eventGroup: CUpti_EventGroup) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Read an event group attribute.\n\n Read an event group attribute and return it in \\p *value.\n \\note \\b Thread-safety: this function is thread safe but client\n must guard against simultaneous destruction or modification of \\p\n eventGroup (for example, client must guard against simultaneous\n calls to \\ref cuptiEventGroupDestroy, \\ref cuptiEventGroupAddEvent,\n etc.), and must guard against simultaneous destruction of the\n context in which \\p eventGroup was created (for example, client\n must guard against simultaneous calls to cudaDeviceReset,\n cuCtxDestroy, etc.).\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param eventGroup The event group\n \\param attrib The attribute to read\n \\param valueSize Size of buffer pointed by the value, and\n returns the number of bytes written to \\p value\n \\param value Returns the value of the attribute\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p valueSize or \\p value\n is NULL, or if \\p attrib is not an eventgroup attribute\n \\retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT For non-c-string\n attribute values, indicates that the \\p value buffer is too small\n to hold the attribute value."]
    pub fn cuptiEventGroupGetAttribute(
        eventGroup: CUpti_EventGroup,
        attrib: CUpti_EventGroupAttribute,
        valueSize: *mut usize,
        value: *mut ::std::os::raw::c_void,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Write an event group attribute.\n\n Write an event group attribute.\n \\note \\b Thread-safety: this function is thread safe.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param eventGroup The event group\n \\param attrib The attribute to write\n \\param valueSize The size, in bytes, of the value\n \\param value The attribute value to write\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p valueSize or \\p value\n is NULL, or if \\p attrib is not an event group attribute, or if\n \\p attrib is not a writable attribute\n \\retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT Indicates that\n the \\p value buffer is too small to hold the attribute value."]
    pub fn cuptiEventGroupSetAttribute(
        eventGroup: CUpti_EventGroup,
        attrib: CUpti_EventGroupAttribute,
        valueSize: usize,
        value: *mut ::std::os::raw::c_void,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Add an event to an event group.\n\n Add an event to an event group. The event add can fail for a number of reasons:\n \\li The event group is enabled\n \\li The event does not belong to the same event domain as the\n events that are already in the event group\n \\li Device limitations on the events that can belong to the same group\n \\li The event group is full\n\n \\note \\b Thread-safety: this function is thread safe.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param eventGroup The event group\n \\param event The event to add to the group\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_EVENT_ID\n \\retval CUPTI_ERROR_OUT_OF_MEMORY\n \\retval CUPTI_ERROR_INVALID_OPERATION if \\p eventGroup is enabled\n \\retval CUPTI_ERROR_NOT_COMPATIBLE if \\p event belongs to a\n different event domain than the events already in \\p eventGroup, or\n if a device limitation prevents \\p event from being collected at\n the same time as the events already in \\p eventGroup\n \\retval CUPTI_ERROR_MAX_LIMIT_REACHED if \\p eventGroup is full\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p eventGroup is NULL"]
    pub fn cuptiEventGroupAddEvent(
        eventGroup: CUpti_EventGroup,
        event: CUpti_EventID,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Remove an event from an event group.\n\n Remove \\p event from the an event group. The event cannot be\n removed if the event group is enabled.\n \\note \\b Thread-safety: this function is thread safe.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param eventGroup The event group\n \\param event The event to remove from the group\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_EVENT_ID\n \\retval CUPTI_ERROR_INVALID_OPERATION if \\p eventGroup is enabled\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p eventGroup is NULL"]
    pub fn cuptiEventGroupRemoveEvent(
        eventGroup: CUpti_EventGroup,
        event: CUpti_EventID,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Remove all events from an event group.\n\n Remove all events from an event group. Events cannot be removed if\n the event group is enabled.\n \\note \\b Thread-safety: this function is thread safe.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param eventGroup The event group\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_OPERATION if \\p eventGroup is enabled\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p eventGroup is NULL"]
    pub fn cuptiEventGroupRemoveAllEvents(eventGroup: CUpti_EventGroup) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Zero all the event counts in an event group.\n\n Zero all the event counts in an event group.\n \\note \\b Thread-safety: this function is thread safe but client\n must guard against simultaneous destruction or modification of \\p\n eventGroup (for example, client must guard against simultaneous\n calls to \\ref cuptiEventGroupDestroy, \\ref cuptiEventGroupAddEvent,\n etc.), and must guard against simultaneous destruction of the\n context in which \\p eventGroup was created (for example, client\n must guard against simultaneous calls to cudaDeviceReset,\n cuCtxDestroy, etc.).\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param eventGroup The event group\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_HARDWARE\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p eventGroup is NULL"]
    pub fn cuptiEventGroupResetAllEvents(eventGroup: CUpti_EventGroup) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Enable an event group.\n\n Enable an event group. Enabling an event group zeros the value of\n all the events in the group and then starts collection of those\n events.\n \\note \\b Thread-safety: this function is thread safe.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param eventGroup The event group\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_HARDWARE\n \\retval CUPTI_ERROR_NOT_READY if \\p eventGroup does not contain any events\n \\retval CUPTI_ERROR_NOT_COMPATIBLE if \\p eventGroup cannot be\n enabled due to other already enabled event groups\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p eventGroup is NULL\n \\retval CUPTI_ERROR_HARDWARE_BUSY if another client is profiling\n and hardware is busy"]
    pub fn cuptiEventGroupEnable(eventGroup: CUpti_EventGroup) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Disable an event group.\n\n Disable an event group. Disabling an event group stops collection\n of events contained in the group.\n \\note \\b Thread-safety: this function is thread safe.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param eventGroup The event group\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_HARDWARE\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p eventGroup is NULL"]
    pub fn cuptiEventGroupDisable(eventGroup: CUpti_EventGroup) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Read the value for an event in an event group.\n\n Read the value for an event in an event group. The event value is\n returned in the \\p eventValueBuffer buffer. \\p\n eventValueBufferSizeBytes indicates the size of the \\p\n eventValueBuffer buffer. The buffer must be at least sizeof(uint64)\n if ::CUPTI_EVENT_GROUP_ATTR_PROFILE_ALL_DOMAIN_INSTANCES is not set\n on the group containing the event.  The buffer must be at least\n (sizeof(uint64) * number of domain instances) if\n ::CUPTI_EVENT_GROUP_ATTR_PROFILE_ALL_DOMAIN_INSTANCES is set on the\n group.\n\n If any instance of an event counter overflows, the value returned\n for that event instance will be ::CUPTI_EVENT_OVERFLOW.\n\n The only allowed value for \\p flags is ::CUPTI_EVENT_READ_FLAG_NONE.\n\n Reading an event from a disabled event group is not allowed. After\n being read, an event's value is reset to zero.\n \\note \\b Thread-safety: this function is thread safe but client\n must guard against simultaneous destruction or modification of \\p\n eventGroup (for example, client must guard against simultaneous\n calls to \\ref cuptiEventGroupDestroy, \\ref cuptiEventGroupAddEvent,\n etc.), and must guard against simultaneous destruction of the\n context in which \\p eventGroup was created (for example, client\n must guard against simultaneous calls to cudaDeviceReset,\n cuCtxDestroy, etc.). If \\ref cuptiEventGroupResetAllEvents is\n called simultaneously with this function, then returned event\n values are undefined.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param eventGroup The event group\n \\param flags Flags controlling the reading mode\n \\param event The event to read\n \\param eventValueBufferSizeBytes The size of \\p eventValueBuffer\n in bytes, and returns the number of bytes written to \\p\n eventValueBuffer\n \\param eventValueBuffer Returns the event value(s)\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_EVENT_ID\n \\retval CUPTI_ERROR_HARDWARE\n \\retval CUPTI_ERROR_INVALID_OPERATION if \\p eventGroup is disabled\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p eventGroup, \\p\n eventValueBufferSizeBytes or \\p eventValueBuffer is NULL\n \\retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT if size of \\p eventValueBuffer\n is not sufficient"]
    pub fn cuptiEventGroupReadEvent(
        eventGroup: CUpti_EventGroup,
        flags: CUpti_ReadEventFlags,
        event: CUpti_EventID,
        eventValueBufferSizeBytes: *mut usize,
        eventValueBuffer: *mut u64,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Read the values for all the events in an event group.\n\n Read the values for all the events in an event group. The event\n values are returned in the \\p eventValueBuffer buffer. \\p\n eventValueBufferSizeBytes indicates the size of \\p\n eventValueBuffer.  The buffer must be at least (sizeof(uint64) *\n number of events in group) if\n ::CUPTI_EVENT_GROUP_ATTR_PROFILE_ALL_DOMAIN_INSTANCES is not set on\n the group containing the events.  The buffer must be at least\n (sizeof(uint64) * number of domain instances * number of events in\n group) if ::CUPTI_EVENT_GROUP_ATTR_PROFILE_ALL_DOMAIN_INSTANCES is\n set on the group.\n\n The data format returned in \\p eventValueBuffer is:\n    - domain instance 0: event0 event1 ... eventN\n    - domain instance 1: event0 event1 ... eventN\n    - ...\n    - domain instance M: event0 event1 ... eventN\n\n The event order in \\p eventValueBuffer is returned in \\p\n eventIdArray. The size of \\p eventIdArray is specified in \\p\n eventIdArraySizeBytes. The size should be at least\n (sizeof(CUpti_EventID) * number of events in group).\n\n If any instance of any event counter overflows, the value returned\n for that event instance will be ::CUPTI_EVENT_OVERFLOW.\n\n The only allowed value for \\p flags is ::CUPTI_EVENT_READ_FLAG_NONE.\n\n Reading events from a disabled event group is not allowed. After\n being read, an event's value is reset to zero.\n \\note \\b Thread-safety: this function is thread safe but client\n must guard against simultaneous destruction or modification of \\p\n eventGroup (for example, client must guard against simultaneous\n calls to \\ref cuptiEventGroupDestroy, \\ref cuptiEventGroupAddEvent,\n etc.), and must guard against simultaneous destruction of the\n context in which \\p eventGroup was created (for example, client\n must guard against simultaneous calls to cudaDeviceReset,\n cuCtxDestroy, etc.). If \\ref cuptiEventGroupResetAllEvents is\n called simultaneously with this function, then returned event\n values are undefined.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param eventGroup The event group\n \\param flags Flags controlling the reading mode\n \\param eventValueBufferSizeBytes The size of \\p eventValueBuffer in\n bytes, and returns the number of bytes written to \\p\n eventValueBuffer\n \\param eventValueBuffer Returns the event values\n \\param eventIdArraySizeBytes The size of \\p eventIdArray in bytes,\n and returns the number of bytes written to \\p eventIdArray\n \\param eventIdArray Returns the IDs of the events in the same order\n as the values return in eventValueBuffer.\n \\param numEventIdsRead Returns the number of event IDs returned\n in \\p eventIdArray\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_HARDWARE\n \\retval CUPTI_ERROR_INVALID_OPERATION if \\p eventGroup is disabled\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p eventGroup, \\p\n eventValueBufferSizeBytes, \\p eventValueBuffer, \\p\n eventIdArraySizeBytes, \\p eventIdArray or \\p numEventIdsRead is\n NULL\n \\retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT if size of \\p eventValueBuffer\n or \\p eventIdArray is not sufficient"]
    pub fn cuptiEventGroupReadAllEvents(
        eventGroup: CUpti_EventGroup,
        flags: CUpti_ReadEventFlags,
        eventValueBufferSizeBytes: *mut usize,
        eventValueBuffer: *mut u64,
        eventIdArraySizeBytes: *mut usize,
        eventIdArray: *mut CUpti_EventID,
        numEventIdsRead: *mut usize,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief For a set of events, get the grouping that indicates the\n number of passes and the event groups necessary to collect the\n events.\n\n The number of events that can be collected simultaneously varies by\n device and by the type of the events. When events can be collected\n simultaneously, they may need to be grouped into multiple event\n groups because they are from different event domains. This function\n takes a set of events and determines how many passes are required\n to collect all those events, and which events can be collected\n simultaneously in each pass.\n\n The CUpti_EventGroupSets returned in \\p eventGroupPasses indicates\n how many passes are required to collect the events with the \\p\n numSets field. Within each event group set, the \\p sets array\n indicates the event groups that should be collected on each pass.\n \\note \\b Thread-safety: this function is thread safe, but client\n must guard against another thread simultaneously destroying \\p\n context.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param context The context for event collection\n \\param eventIdArraySizeBytes Size of \\p eventIdArray in bytes\n \\param eventIdArray Array of event IDs that need to be grouped\n \\param eventGroupPasses Returns a CUpti_EventGroupSets object that\n indicates the number of passes required to collect the events and\n the events to collect on each pass\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_CONTEXT\n \\retval CUPTI_ERROR_INVALID_EVENT_ID\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p eventIdArray or\n \\p eventGroupPasses is NULL"]
    pub fn cuptiEventGroupSetsCreate(
        context: CUcontext,
        eventIdArraySizeBytes: usize,
        eventIdArray: *mut CUpti_EventID,
        eventGroupPasses: *mut *mut CUpti_EventGroupSets,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Destroy a event group sets object.\n\n Destroy a CUpti_EventGroupSets object.\n \\note \\b Thread-safety: this function is thread safe.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param eventGroupSets The object to destroy\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_OPERATION if any of the event groups\n contained in the sets is enabled\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p eventGroupSets is NULL"]
    pub fn cuptiEventGroupSetsDestroy(eventGroupSets: *mut CUpti_EventGroupSets) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Enable an event group set.\n\n Enable a set of event groups. Enabling a set of event groups zeros the value of\n all the events in all the groups and then starts collection of those events.\n \\note \\b Thread-safety: this function is thread safe.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param eventGroupSet The pointer to the event group set\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_HARDWARE\n \\retval CUPTI_ERROR_NOT_READY if \\p eventGroup does not contain any events\n \\retval CUPTI_ERROR_NOT_COMPATIBLE if \\p eventGroup cannot be\n enabled due to other already enabled event groups\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p eventGroupSet is NULL\n \\retval CUPTI_ERROR_HARDWARE_BUSY if other client is profiling and hardware is\n busy"]
    pub fn cuptiEventGroupSetEnable(eventGroupSet: *mut CUpti_EventGroupSet) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Disable an event group set.\n\n Disable a set of event groups. Disabling a set of event groups\n stops collection of events contained in the groups.\n \\note \\b Thread-safety: this function is thread safe.\n \\note \\b If this call fails, some of the event groups in the set may be disabled\n and other event groups may remain enabled.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param eventGroupSet The pointer to the event group set\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_HARDWARE\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p eventGroupSet is NULL"]
    pub fn cuptiEventGroupSetDisable(eventGroupSet: *mut CUpti_EventGroupSet) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Enable kernel replay mode.\n\n Set profiling mode for the context to replay mode. In this mode,\n any number of events can be collected in one run of the kernel. The\n event collection mode will automatically switch to\n CUPTI_EVENT_COLLECTION_MODE_KERNEL.  In this mode, \\ref\n cuptiSetEventCollectionMode will return\n CUPTI_ERROR_INVALID_OPERATION.\n \\note \\b Kernels might take longer to run if many events are enabled.\n \\note \\b Thread-safety: this function is thread safe.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param context The context\n \\retval CUPTI_SUCCESS"]
    pub fn cuptiEnableKernelReplayMode(context: CUcontext) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Disable kernel replay mode.\n\n Set profiling mode for the context to non-replay (default)\n mode. Event collection mode will be set to\n CUPTI_EVENT_COLLECTION_MODE_KERNEL.  All previously enabled\n event groups and event group sets will be disabled.\n \\note \\b Thread-safety: this function is thread safe.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param context The context\n \\retval CUPTI_SUCCESS"]
    pub fn cuptiDisableKernelReplayMode(context: CUcontext) -> CUptiResult;
}
#[doc = " \\brief Function type for getting updates on kernel replay.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param kernelName The mangled kernel name\n \\param numReplaysDone Number of replays done so far\n \\param customData Pointer of any custom data passed in when subscribing"]
pub type CUpti_KernelReplayUpdateFunc = ::std::option::Option<
    unsafe extern "C" fn(
        kernelName: *const ::std::os::raw::c_char,
        numReplaysDone: ::std::os::raw::c_int,
        customData: *mut ::std::os::raw::c_void,
    ),
>;
unsafe extern "C" {
    #[doc = " \\brief Subscribe to kernel replay updates.\n\n When subscribed, the function pointer passed in will be called each time a\n kernel run is finished during kernel replay. Previously subscribed function\n pointer will be replaced. Pass in NULL as the function pointer unsubscribes\n the update.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param updateFunc The update function pointer\n \\param customData Pointer to any custom data\n \\retval CUPTI_SUCCESS"]
    pub fn cuptiKernelReplaySubscribeUpdate(
        updateFunc: CUpti_KernelReplayUpdateFunc,
        customData: *mut ::std::os::raw::c_void,
    ) -> CUptiResult;
}
#[doc = " \\brief ID for a metric.\n\n A metric provides a measure of some aspect of the device."]
pub type CUpti_MetricID = u32;
#[doc = " A memory related metric."]
pub const CUPTI_METRIC_CATEGORY_MEMORY: CUpti_MetricCategory = 0;
#[doc = " An instruction related metric."]
pub const CUPTI_METRIC_CATEGORY_INSTRUCTION: CUpti_MetricCategory = 1;
#[doc = " A multiprocessor related metric."]
pub const CUPTI_METRIC_CATEGORY_MULTIPROCESSOR: CUpti_MetricCategory = 2;
#[doc = " A cache related metric."]
pub const CUPTI_METRIC_CATEGORY_CACHE: CUpti_MetricCategory = 3;
#[doc = " A texture related metric."]
pub const CUPTI_METRIC_CATEGORY_TEXTURE: CUpti_MetricCategory = 4;
#[doc = "A Nvlink related metric."]
pub const CUPTI_METRIC_CATEGORY_NVLINK: CUpti_MetricCategory = 5;
#[doc = "A PCIe related metric."]
pub const CUPTI_METRIC_CATEGORY_PCIE: CUpti_MetricCategory = 6;
#[doc = "A PCIe related metric."]
pub const CUPTI_METRIC_CATEGORY_FORCE_INT: CUpti_MetricCategory = 2147483647;
#[doc = " \\brief A metric category.\n\n Each metric is assigned to a category that represents the general\n type of the metric. A metric's category is accessed using \\ref\n cuptiMetricGetAttribute and the CUPTI_METRIC_ATTR_CATEGORY\n attribute."]
pub type CUpti_MetricCategory = ::std::os::raw::c_uint;
#[doc = " If this bit is set, the metric can be profiled for each instance of the\n domain. The event values passed to \\ref cuptiMetricGetValue can contain\n values for one instance of the domain. And \\ref cuptiMetricGetValue can\n be called for each instance."]
pub const CUPTI_METRIC_EVALUATION_MODE_PER_INSTANCE: CUpti_MetricEvaluationMode = 1;
#[doc = " If this bit is set, the metric can be profiled over all instances. The\n event values passed to \\ref cuptiMetricGetValue can be aggregated values\n of events for all instances of the domain."]
pub const CUPTI_METRIC_EVALUATION_MODE_AGGREGATE: CUpti_MetricEvaluationMode = 2;
#[doc = " If this bit is set, the metric can be profiled over all instances. The\n event values passed to \\ref cuptiMetricGetValue can be aggregated values\n of events for all instances of the domain."]
pub const CUPTI_METRIC_EVALUATION_MODE_FORCE_INT: CUpti_MetricEvaluationMode = 2147483647;
#[doc = " \\brief A metric evaluation mode.\n\n A metric can be evaluated per hardware instance to know the load balancing\n across instances of a domain or the metric can be evaluated in aggregate mode\n when the events involved in metric evaluation are from different event\n domains. It might be possible to evaluate some metrics in both\n modes for convenience. A metric's evaluation mode is accessed using \\ref\n CUpti_MetricEvaluationMode and the CUPTI_METRIC_ATTR_EVALUATION_MODE\n attribute."]
pub type CUpti_MetricEvaluationMode = ::std::os::raw::c_uint;
#[doc = " The metric value is a 64-bit double."]
pub const CUPTI_METRIC_VALUE_KIND_DOUBLE: CUpti_MetricValueKind = 0;
#[doc = " The metric value is a 64-bit unsigned integer."]
pub const CUPTI_METRIC_VALUE_KIND_UINT64: CUpti_MetricValueKind = 1;
#[doc = " The metric value is a percentage represented by a 64-bit\n double. For example, 57.5% is represented by the value 57.5."]
pub const CUPTI_METRIC_VALUE_KIND_PERCENT: CUpti_MetricValueKind = 2;
#[doc = " The metric value is a throughput represented by a 64-bit\n integer. The unit for throughput values is bytes/second."]
pub const CUPTI_METRIC_VALUE_KIND_THROUGHPUT: CUpti_MetricValueKind = 3;
#[doc = " The metric value is a 64-bit signed integer."]
pub const CUPTI_METRIC_VALUE_KIND_INT64: CUpti_MetricValueKind = 4;
#[doc = " The metric value is a utilization level, as represented by\n CUpti_MetricValueUtilizationLevel."]
pub const CUPTI_METRIC_VALUE_KIND_UTILIZATION_LEVEL: CUpti_MetricValueKind = 5;
#[doc = " The metric value is a pointer to a NVTX extended payload.\n nvtxPayloadData_t is the structure that contains the payload data."]
pub const CUPTI_METRIC_VALUE_KIND_NVTX_EXTENDED_PAYLOAD: CUpti_MetricValueKind = 6;
#[doc = " The metric value is a pointer to a NVTX extended payload.\n nvtxPayloadData_t is the structure that contains the payload data."]
pub const CUPTI_METRIC_VALUE_KIND_FORCE_INT: CUpti_MetricValueKind = 2147483647;
#[doc = " \\brief Kinds of metric values.\n\n Metric values can be one of several different kinds. Corresponding\n to each kind is a member of the CUpti_MetricValue union. The metric\n value returned by \\ref cuptiMetricGetValue should be accessed using\n the appropriate member of that union based on its value kind."]
pub type CUpti_MetricValueKind = ::std::os::raw::c_uint;
pub const CUPTI_METRIC_VALUE_UTILIZATION_IDLE: CUpti_MetricValueUtilizationLevel = 0;
pub const CUPTI_METRIC_VALUE_UTILIZATION_LOW: CUpti_MetricValueUtilizationLevel = 2;
pub const CUPTI_METRIC_VALUE_UTILIZATION_MID: CUpti_MetricValueUtilizationLevel = 5;
pub const CUPTI_METRIC_VALUE_UTILIZATION_HIGH: CUpti_MetricValueUtilizationLevel = 8;
pub const CUPTI_METRIC_VALUE_UTILIZATION_MAX: CUpti_MetricValueUtilizationLevel = 10;
pub const CUPTI_METRIC_VALUE_UTILIZATION_FORCE_INT: CUpti_MetricValueUtilizationLevel = 2147483647;
#[doc = " \\brief Enumeration of utilization levels for metrics values of kind\n CUPTI_METRIC_VALUE_KIND_UTILIZATION_LEVEL. Utilization values can\n vary from IDLE (0) to MAX (10) but the enumeration only provides\n specific names for a few values."]
pub type CUpti_MetricValueUtilizationLevel = ::std::os::raw::c_uint;
#[doc = " Metric name. Value is a null terminated const c-string."]
pub const CUPTI_METRIC_ATTR_NAME: CUpti_MetricAttribute = 0;
#[doc = " Short description of metric. Value is a null terminated const c-string."]
pub const CUPTI_METRIC_ATTR_SHORT_DESCRIPTION: CUpti_MetricAttribute = 1;
#[doc = " Long description of metric. Value is a null terminated const c-string."]
pub const CUPTI_METRIC_ATTR_LONG_DESCRIPTION: CUpti_MetricAttribute = 2;
#[doc = " Category of the metric. Value is of type CUpti_MetricCategory."]
pub const CUPTI_METRIC_ATTR_CATEGORY: CUpti_MetricAttribute = 3;
#[doc = " Value type of the metric. Value is of type CUpti_MetricValueKind."]
pub const CUPTI_METRIC_ATTR_VALUE_KIND: CUpti_MetricAttribute = 4;
#[doc = " Metric evaluation mode. Value is of type CUpti_MetricEvaluationMode."]
pub const CUPTI_METRIC_ATTR_EVALUATION_MODE: CUpti_MetricAttribute = 5;
#[doc = " Metric evaluation mode. Value is of type CUpti_MetricEvaluationMode."]
pub const CUPTI_METRIC_ATTR_FORCE_INT: CUpti_MetricAttribute = 2147483647;
#[doc = " \\brief Metric attributes.\n\n Metric attributes describe properties of a metric. These attributes\n can be read using \\ref cuptiMetricGetAttribute."]
pub type CUpti_MetricAttribute = ::std::os::raw::c_uint;
#[doc = " \\brief A metric value.\n\n Metric values can be one of several different kinds. Corresponding\n to each kind is a member of the CUpti_MetricValue union. The metric\n value returned by \\ref cuptiMetricGetValue should be accessed using\n the appropriate member of that union based on its value kind."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_MetricValue {
    pub metricValueDouble: f64,
    pub metricValueUint64: u64,
    pub metricValueInt64: i64,
    pub metricValuePercent: f64,
    pub metricValueThroughput: u64,
    pub metricValueUtilizationLevel: CUpti_MetricValueUtilizationLevel,
    #[doc = " Value for CUPTI_METRIC_VALUE_KIND_NVTX_EXTENDED_PAYLOAD."]
    pub metricValueNvtxExtendedPayload: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_MetricValue"][::std::mem::size_of::<CUpti_MetricValue>() - 8usize];
    ["Alignment of CUpti_MetricValue"][::std::mem::align_of::<CUpti_MetricValue>() - 8usize];
    ["Offset of field: CUpti_MetricValue::metricValueDouble"]
        [::std::mem::offset_of!(CUpti_MetricValue, metricValueDouble) - 0usize];
    ["Offset of field: CUpti_MetricValue::metricValueUint64"]
        [::std::mem::offset_of!(CUpti_MetricValue, metricValueUint64) - 0usize];
    ["Offset of field: CUpti_MetricValue::metricValueInt64"]
        [::std::mem::offset_of!(CUpti_MetricValue, metricValueInt64) - 0usize];
    ["Offset of field: CUpti_MetricValue::metricValuePercent"]
        [::std::mem::offset_of!(CUpti_MetricValue, metricValuePercent) - 0usize];
    ["Offset of field: CUpti_MetricValue::metricValueThroughput"]
        [::std::mem::offset_of!(CUpti_MetricValue, metricValueThroughput) - 0usize];
    ["Offset of field: CUpti_MetricValue::metricValueUtilizationLevel"]
        [::std::mem::offset_of!(CUpti_MetricValue, metricValueUtilizationLevel) - 0usize];
    ["Offset of field: CUpti_MetricValue::metricValueNvtxExtendedPayload"]
        [::std::mem::offset_of!(CUpti_MetricValue, metricValueNvtxExtendedPayload) - 0usize];
};
impl Default for CUpti_MetricValue {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_MetricValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_MetricValue {{ union }}")
    }
}
pub const CUPTI_METRIC_PROPERTY_DEVICE_CLASS_TESLA: CUpti_MetricPropertyDeviceClass = 0;
pub const CUPTI_METRIC_PROPERTY_DEVICE_CLASS_QUADRO: CUpti_MetricPropertyDeviceClass = 1;
pub const CUPTI_METRIC_PROPERTY_DEVICE_CLASS_GEFORCE: CUpti_MetricPropertyDeviceClass = 2;
pub const CUPTI_METRIC_PROPERTY_DEVICE_CLASS_TEGRA: CUpti_MetricPropertyDeviceClass = 3;
#[doc = " \\brief Device class.\n\n Enumeration of device classes for metric property\n CUPTI_METRIC_PROPERTY_DEVICE_CLASS."]
pub type CUpti_MetricPropertyDeviceClass = ::std::os::raw::c_uint;
pub const CUPTI_METRIC_PROPERTY_MULTIPROCESSOR_COUNT: CUpti_MetricPropertyID = 0;
pub const CUPTI_METRIC_PROPERTY_WARPS_PER_MULTIPROCESSOR: CUpti_MetricPropertyID = 1;
pub const CUPTI_METRIC_PROPERTY_KERNEL_GPU_TIME: CUpti_MetricPropertyID = 2;
pub const CUPTI_METRIC_PROPERTY_CLOCK_RATE: CUpti_MetricPropertyID = 3;
pub const CUPTI_METRIC_PROPERTY_FRAME_BUFFER_COUNT: CUpti_MetricPropertyID = 4;
pub const CUPTI_METRIC_PROPERTY_GLOBAL_MEMORY_BANDWIDTH: CUpti_MetricPropertyID = 5;
pub const CUPTI_METRIC_PROPERTY_PCIE_LINK_RATE: CUpti_MetricPropertyID = 6;
pub const CUPTI_METRIC_PROPERTY_PCIE_LINK_WIDTH: CUpti_MetricPropertyID = 7;
pub const CUPTI_METRIC_PROPERTY_PCIE_GEN: CUpti_MetricPropertyID = 8;
pub const CUPTI_METRIC_PROPERTY_DEVICE_CLASS: CUpti_MetricPropertyID = 9;
pub const CUPTI_METRIC_PROPERTY_FLOP_SP_PER_CYCLE: CUpti_MetricPropertyID = 10;
pub const CUPTI_METRIC_PROPERTY_FLOP_DP_PER_CYCLE: CUpti_MetricPropertyID = 11;
pub const CUPTI_METRIC_PROPERTY_L2_UNITS: CUpti_MetricPropertyID = 12;
pub const CUPTI_METRIC_PROPERTY_ECC_ENABLED: CUpti_MetricPropertyID = 13;
pub const CUPTI_METRIC_PROPERTY_FLOP_HP_PER_CYCLE: CUpti_MetricPropertyID = 14;
pub const CUPTI_METRIC_PROPERTY_GPU_CPU_NVLINK_BANDWIDTH: CUpti_MetricPropertyID = 15;
#[doc = " \\brief Metric device properties.\n\n Metric device properties describe device properties which are needed for a metric.\n Some of these properties can be collected using cuDeviceGetAttribute."]
pub type CUpti_MetricPropertyID = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " \\brief Get the total number of metrics available on any device.\n\n Returns the total number of metrics available on any CUDA-capable\n devices.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param numMetrics Returns the number of metrics\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p numMetrics is NULL"]
    pub fn cuptiGetNumMetrics(numMetrics: *mut u32) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get all the metrics available on any device.\n\n Returns the metric IDs in \\p metricArray for all CUDA-capable\n devices.  The size of the \\p metricArray buffer is given by \\p\n *arraySizeBytes. The size of the \\p metricArray buffer must be at\n least \\p numMetrics * sizeof(CUpti_MetricID) or all metric IDs will\n not be returned. The value returned in \\p *arraySizeBytes contains\n the number of bytes returned in \\p metricArray.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param arraySizeBytes The size of \\p metricArray in bytes, and\n returns the number of bytes written to \\p metricArray\n \\param metricArray Returns the IDs of the metrics\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p arraySizeBytes or\n \\p metricArray are NULL"]
    pub fn cuptiEnumMetrics(
        arraySizeBytes: *mut usize,
        metricArray: *mut CUpti_MetricID,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get the number of metrics for a device.\n\n Returns the number of metrics available for a device.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param device The CUDA device\n \\param numMetrics Returns the number of metrics available for the\n device\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_DEVICE\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p numMetrics is NULL"]
    pub fn cuptiDeviceGetNumMetrics(device: CUdevice, numMetrics: *mut u32) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get the metrics for a device.\n\n Returns the metric IDs in \\p metricArray for a device.  The size of\n the \\p metricArray buffer is given by \\p *arraySizeBytes. The size\n of the \\p metricArray buffer must be at least \\p numMetrics *\n sizeof(CUpti_MetricID) or else all metric IDs will not be\n returned. The value returned in \\p *arraySizeBytes contains the\n number of bytes returned in \\p metricArray.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param device The CUDA device\n \\param arraySizeBytes The size of \\p metricArray in bytes, and\n returns the number of bytes written to \\p metricArray\n \\param metricArray Returns the IDs of the metrics for the device\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_DEVICE\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p arraySizeBytes or\n \\p metricArray are NULL"]
    pub fn cuptiDeviceEnumMetrics(
        device: CUdevice,
        arraySizeBytes: *mut usize,
        metricArray: *mut CUpti_MetricID,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get a metric attribute.\n\n Returns a metric attribute in \\p *value. The size of the \\p\n value buffer is given by \\p *valueSize. The value returned in \\p\n *valueSize contains the number of bytes returned in \\p value.\n\n If the attribute value is a c-string that is longer than \\p\n *valueSize, then only the first \\p *valueSize characters will be\n returned and there will be no terminating null byte.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param metric ID of the metric\n \\param attrib The metric attribute to read\n \\param valueSize The size of the \\p value buffer in bytes, and\n returns the number of bytes written to \\p value\n \\param value Returns the attribute's value\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_METRIC_ID\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p valueSize or \\p value\n is NULL, or if \\p attrib is not a metric attribute\n \\retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT For non-c-string\n attribute values, indicates that the \\p value buffer is too small\n to hold the attribute value."]
    pub fn cuptiMetricGetAttribute(
        metric: CUpti_MetricID,
        attrib: CUpti_MetricAttribute,
        valueSize: *mut usize,
        value: *mut ::std::os::raw::c_void,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Find an metric by name.\n\n Find a metric by name and return the metric ID in \\p *metric.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param device The CUDA device\n \\param metricName The name of metric to find\n \\param metric Returns the ID of the found metric or undefined if\n unable to find the metric\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_DEVICE\n \\retval CUPTI_ERROR_INVALID_METRIC_NAME if unable to find a metric\n with name \\p metricName. In this case \\p *metric is undefined\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p metricName or \\p\n metric are NULL."]
    pub fn cuptiMetricGetIdFromName(
        device: CUdevice,
        metricName: *const ::std::os::raw::c_char,
        metric: *mut CUpti_MetricID,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get number of events required to calculate a metric.\n\n Returns the number of events in \\p numEvents that are required to\n calculate a metric.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param metric ID of the metric\n \\param numEvents Returns the number of events required for the metric\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_METRIC_ID\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p numEvents is NULL"]
    pub fn cuptiMetricGetNumEvents(metric: CUpti_MetricID, numEvents: *mut u32) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get the events required to calculating a metric.\n\n Gets the event IDs in \\p eventIdArray required to calculate a \\p\n metric. The size of the \\p eventIdArray buffer is given by \\p\n *eventIdArraySizeBytes and must be at least \\p numEvents *\n sizeof(CUpti_EventID) or all events will not be returned. The value\n returned in \\p *eventIdArraySizeBytes contains the number of bytes\n returned in \\p eventIdArray.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param metric ID of the metric\n \\param eventIdArraySizeBytes The size of \\p eventIdArray in bytes,\n and returns the number of bytes written to \\p eventIdArray\n \\param eventIdArray Returns the IDs of the events required to\n calculate \\p metric\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_METRIC_ID\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p eventIdArraySizeBytes or \\p\n eventIdArray are NULL."]
    pub fn cuptiMetricEnumEvents(
        metric: CUpti_MetricID,
        eventIdArraySizeBytes: *mut usize,
        eventIdArray: *mut CUpti_EventID,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get number of properties required to calculate a metric.\n\n Returns the number of properties in \\p numProp that are required to\n calculate a metric.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param metric ID of the metric\n \\param numProp Returns the number of properties required for the\n metric\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_METRIC_ID\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p numProp is NULL"]
    pub fn cuptiMetricGetNumProperties(metric: CUpti_MetricID, numProp: *mut u32) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get the properties required to calculating a metric.\n\n Gets the property IDs in \\p propIdArray required to calculate a \\p\n metric. The size of the \\p propIdArray buffer is given by \\p\n *propIdArraySizeBytes and must be at least \\p numProp *\n sizeof(CUpti_DeviceAttribute) or all properties will not be\n returned. The value returned in \\p *propIdArraySizeBytes contains\n the number of bytes returned in \\p propIdArray.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param metric ID of the metric\n \\param propIdArraySizeBytes The size of \\p propIdArray in bytes,\n and returns the number of bytes written to \\p propIdArray\n \\param propIdArray Returns the IDs of the properties required to\n calculate \\p metric\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_METRIC_ID\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p propIdArraySizeBytes or \\p\n propIdArray are NULL."]
    pub fn cuptiMetricEnumProperties(
        metric: CUpti_MetricID,
        propIdArraySizeBytes: *mut usize,
        propIdArray: *mut CUpti_MetricPropertyID,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief For a metric get the groups of events that must be collected\n in the same pass.\n\n For a metric get the groups of events that must be collected in the\n same pass to ensure that the metric is calculated correctly. If the\n events are not collected as specified then the metric value may be\n inaccurate.\n\n The function returns NULL if a metric does not have any required\n event group. In this case the events needed for the metric can be\n grouped in any manner for collection.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param context The context for event collection\n \\param metric The metric ID\n \\param eventGroupSets Returns a CUpti_EventGroupSets object that\n indicates the events that must be collected in the same pass to\n ensure the metric is calculated correctly.  Returns NULL if no\n grouping is required for metric\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_METRIC_ID"]
    pub fn cuptiMetricGetRequiredEventGroupSets(
        context: CUcontext,
        metric: CUpti_MetricID,
        eventGroupSets: *mut *mut CUpti_EventGroupSets,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief For a set of metrics, get the grouping that indicates the\n number of passes and the event groups necessary to collect the\n events required for those metrics.\n\n For a set of metrics, get the grouping that indicates the number of\n passes and the event groups necessary to collect the events\n required for those metrics.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\see cuptiEventGroupSetsCreate for details on event group set\n creation.\n\n \\param context The context for event collection\n \\param metricIdArraySizeBytes Size of the metricIdArray in bytes\n \\param metricIdArray Array of metric IDs\n \\param eventGroupPasses Returns a CUpti_EventGroupSets object that\n indicates the number of passes required to collect the events and\n the events to collect on each pass\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_CONTEXT\n \\retval CUPTI_ERROR_INVALID_METRIC_ID\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p metricIdArray or\n \\p eventGroupPasses is NULL"]
    pub fn cuptiMetricCreateEventGroupSets(
        context: CUcontext,
        metricIdArraySizeBytes: usize,
        metricIdArray: *mut CUpti_MetricID,
        eventGroupPasses: *mut *mut CUpti_EventGroupSets,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Calculate the value for a metric.\n\n Use the events collected for a metric to calculate the metric\n value. Metric value evaluation depends on the evaluation mode\n \\ref CUpti_MetricEvaluationMode that the metric supports.\n If a metric has evaluation mode as CUPTI_METRIC_EVALUATION_MODE_PER_INSTANCE,\n then it assumes that the input event value is for one domain instance.\n If a metric has evaluation mode as CUPTI_METRIC_EVALUATION_MODE_AGGREGATE,\n it assumes that input event values are\n normalized to represent all domain instances on a device. For the\n most accurate metric collection, the events required for the metric\n should be collected for all profiled domain instances. For example,\n to collect all instances of an event, set the\n CUPTI_EVENT_GROUP_ATTR_PROFILE_ALL_DOMAIN_INSTANCES attribute on\n the group containing the event to 1. The normalized value for the\n event is then: (\\p sum_event_values * \\p totalInstanceCount) / \\p\n instanceCount, where \\p sum_event_values is the summation of the\n event values across all profiled domain instances, \\p\n totalInstanceCount is obtained from querying\n CUPTI_EVENT_DOMAIN_ATTR_TOTAL_INSTANCE_COUNT and \\p instanceCount\n is obtained from querying CUPTI_EVENT_GROUP_ATTR_INSTANCE_COUNT (or\n CUPTI_EVENT_DOMAIN_ATTR_INSTANCE_COUNT).\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param device The CUDA device that the metric is being calculated for\n \\param metric The metric ID\n \\param eventIdArraySizeBytes The size of \\p eventIdArray in bytes\n \\param eventIdArray The event IDs required to calculate \\p metric\n \\param eventValueArraySizeBytes The size of \\p eventValueArray in bytes\n \\param eventValueArray The normalized event values required to\n calculate \\p metric. The values must be order to match the order of\n events in \\p eventIdArray\n \\param timeDuration The duration over which the events were\n collected, in ns\n \\param metricValue Returns the value for the metric\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_METRIC_ID\n \\retval CUPTI_ERROR_INVALID_OPERATION\n \\retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT if the\n eventIdArray does not contain all the events needed for metric\n \\retval CUPTI_ERROR_INVALID_EVENT_VALUE if any of the\n event values required for the metric is CUPTI_EVENT_OVERFLOW\n \\retval CUPTI_ERROR_INVALID_METRIC_VALUE if the computed metric value\n cannot be represented in the metric's value type. For example,\n if the metric value type is unsigned and the computed metric value is negative\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p metricValue,\n \\p eventIdArray or \\p eventValueArray is NULL"]
    pub fn cuptiMetricGetValue(
        device: CUdevice,
        metric: CUpti_MetricID,
        eventIdArraySizeBytes: usize,
        eventIdArray: *mut CUpti_EventID,
        eventValueArraySizeBytes: usize,
        eventValueArray: *mut u64,
        timeDuration: u64,
        metricValue: *mut CUpti_MetricValue,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Calculate the value for a metric.\n\n Use the events and properties collected for a metric to calculate\n the metric value. Metric value evaluation depends on the evaluation\n mode \\ref CUpti_MetricEvaluationMode that the metric supports.  If\n a metric has evaluation mode as\n CUPTI_METRIC_EVALUATION_MODE_PER_INSTANCE, then it assumes that the\n input event value is for one domain instance.  If a metric has\n evaluation mode as CUPTI_METRIC_EVALUATION_MODE_AGGREGATE, it\n assumes that input event values are normalized to represent all\n domain instances on a device. For the most accurate metric\n collection, the events required for the metric should be collected\n for all profiled domain instances. For example, to collect all\n instances of an event, set the\n CUPTI_EVENT_GROUP_ATTR_PROFILE_ALL_DOMAIN_INSTANCES attribute on\n the group containing the event to 1. The normalized value for the\n event is then: (\\p sum_event_values * \\p totalInstanceCount) / \\p\n instanceCount, where \\p sum_event_values is the summation of the\n event values across all profiled domain instances, \\p\n totalInstanceCount is obtained from querying\n CUPTI_EVENT_DOMAIN_ATTR_TOTAL_INSTANCE_COUNT and \\p instanceCount\n is obtained from querying CUPTI_EVENT_GROUP_ATTR_INSTANCE_COUNT (or\n CUPTI_EVENT_DOMAIN_ATTR_INSTANCE_COUNT).\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param metric The metric ID\n \\param eventIdArraySizeBytes The size of \\p eventIdArray in bytes\n \\param eventIdArray The event IDs required to calculate \\p metric\n \\param eventValueArraySizeBytes The size of \\p eventValueArray in bytes\n \\param eventValueArray The normalized event values required to\n calculate \\p metric. The values must be order to match the order of\n events in \\p eventIdArray\n \\param propIdArraySizeBytes The size of \\p propIdArray in bytes\n \\param propIdArray The metric property IDs required to calculate \\p metric\n \\param propValueArraySizeBytes The size of \\p propValueArray in bytes\n \\param propValueArray The metric property values required to\n calculate \\p metric. The values must be order to match the order of\n metric properties in \\p propIdArray\n \\param metricValue Returns the value for the metric\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_METRIC_ID\n \\retval CUPTI_ERROR_INVALID_OPERATION\n \\retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT if the\n eventIdArray does not contain all the events needed for metric\n \\retval CUPTI_ERROR_INVALID_EVENT_VALUE if any of the\n event values required for the metric is CUPTI_EVENT_OVERFLOW\n \\retval CUPTI_ERROR_NOT_COMPATIBLE if the computed metric value\n cannot be represented in the metric's value type. For example,\n if the metric value type is unsigned and the computed metric value is negative\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p metricValue,\n \\p eventIdArray or \\p eventValueArray is NULL"]
    pub fn cuptiMetricGetValue2(
        metric: CUpti_MetricID,
        eventIdArraySizeBytes: usize,
        eventIdArray: *mut CUpti_EventID,
        eventValueArraySizeBytes: usize,
        eventValueArray: *mut u64,
        propIdArraySizeBytes: usize,
        propIdArray: *mut CUpti_MetricPropertyID,
        propValueArraySizeBytes: usize,
        propValueArray: *mut u64,
        metricValue: *mut CUpti_MetricValue,
    ) -> CUptiResult;
}
#[doc = " The activity record is invalid."]
pub const CUPTI_ACTIVITY_KIND_INVALID: CUpti_ActivityKind = 0;
#[doc = " A host<->host, host<->device, or device<->device memory copy.\n For peer to peer memory copy, use the kind CUPTI_ACTIVITY_KIND_MEMCPY2.\n The corresponding activity record structure is \\ref\n CUpti_ActivityMemcpy6."]
pub const CUPTI_ACTIVITY_KIND_MEMCPY: CUpti_ActivityKind = 1;
#[doc = " A memory set executing on the GPU. The corresponding activity\n record structure is \\ref CUpti_ActivityMemset4."]
pub const CUPTI_ACTIVITY_KIND_MEMSET: CUpti_ActivityKind = 2;
#[doc = " A kernel executing on the GPU. This activity kind may significantly change\n the overall performance characteristics of the application because all\n kernel executions are serialized on the GPU. Other activity kind for kernel\n CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL doesn't break kernel concurrency.\n The corresponding activity record structure is \\ref CUpti_ActivityKernel10."]
pub const CUPTI_ACTIVITY_KIND_KERNEL: CUpti_ActivityKind = 3;
#[doc = " A CUDA driver API function execution. The corresponding activity\n record structure is \\ref CUpti_ActivityAPI."]
pub const CUPTI_ACTIVITY_KIND_DRIVER: CUpti_ActivityKind = 4;
#[doc = " A CUDA runtime API function execution. The corresponding activity\n record structure is \\ref CUpti_ActivityAPI."]
pub const CUPTI_ACTIVITY_KIND_RUNTIME: CUpti_ActivityKind = 5;
#[doc = " A performance counter (aka event) value. The corresponding activity record\n structure is \\ref CUpti_ActivityEvent. This activity cannot be directly\n enabled or disabled. Information collected using the Event API.\n can be stored in the corresponding activity record.\n Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used."]
pub const CUPTI_ACTIVITY_KIND_EVENT: CUpti_ActivityKind = 6;
#[doc = " A performance metric value. The corresponding activity record structure is\n \\ref CUpti_ActivityMetric. This activity cannot be directly\n enabled or disabled. Information collected using the Metric API.\n can be stored in the corresponding activity record.\n Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used."]
pub const CUPTI_ACTIVITY_KIND_METRIC: CUpti_ActivityKind = 7;
#[doc = " Information about a CUDA device. The corresponding activity record\n structure is \\ref CUpti_ActivityDevice5."]
pub const CUPTI_ACTIVITY_KIND_DEVICE: CUpti_ActivityKind = 8;
#[doc = " Information about a CUDA context. The corresponding activity record\n structure is \\ref CUpti_ActivityContext3."]
pub const CUPTI_ACTIVITY_KIND_CONTEXT: CUpti_ActivityKind = 9;
#[doc = " A kernel executing on the GPU. This activity kind doesn't break\n kernel concurrency. The corresponding activity record structure\n is \\ref CUpti_ActivityKernel10."]
pub const CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL: CUpti_ActivityKind = 10;
#[doc = " Resource naming done via NVTX APIs for thread, device, context, etc.\n The corresponding activity record structure is \\ref CUpti_ActivityName."]
pub const CUPTI_ACTIVITY_KIND_NAME: CUpti_ActivityKind = 11;
#[doc = " Instantaneous, start, or end NVTX marker. The corresponding activity\n record structure is \\ref CUpti_ActivityMarker2."]
pub const CUPTI_ACTIVITY_KIND_MARKER: CUpti_ActivityKind = 12;
#[doc = " Extended, optional, data about a NVTX marker. User must enable\n CUPTI_ACTIVITY_KIND_MARKER as well to get records for marker data.\n The corresponding activity record structure is \\ref CUpti_ActivityMarkerData2."]
pub const CUPTI_ACTIVITY_KIND_MARKER_DATA: CUpti_ActivityKind = 13;
#[doc = " Source information about source level result. The corresponding\n activity record structure is \\ref CUpti_ActivitySourceLocator.\n Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.\n Enabling it will return the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n Instead, use the SASS Metric APIs from the cupti_sass_metrics.h header."]
pub const CUPTI_ACTIVITY_KIND_SOURCE_LOCATOR: CUpti_ActivityKind = 14;
#[doc = " Results for source-level global access. The\n corresponding activity record structure is \\ref\n CUpti_ActivityGlobalAccess3.\n Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.\n Enabling it will return the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n Instead, use the SASS Metric APIs from the cupti_sass_metrics.h header."]
pub const CUPTI_ACTIVITY_KIND_GLOBAL_ACCESS: CUpti_ActivityKind = 15;
#[doc = " Results for source-level branch. The corresponding\n activity record structure is \\ref CUpti_ActivityBranch2.\n Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.\n Enabling it will return the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n Instead, use the SASS Metric APIs from the cupti_sass_metrics.h header."]
pub const CUPTI_ACTIVITY_KIND_BRANCH: CUpti_ActivityKind = 16;
#[doc = " Overhead added by CUPTI, Compiler, CUDA driver etc. The\n corresponding activity record structure is\n \\ref CUpti_ActivityOverhead3."]
pub const CUPTI_ACTIVITY_KIND_OVERHEAD: CUpti_ActivityKind = 17;
#[doc = " A CDP (CUDA Dynamic Parallel) kernel executing on the GPU. The\n corresponding activity record structure is \\ref\n CUpti_ActivityCdpKernel. This activity cannot be directly\n enabled or disabled. It is enabled and disabled through\n concurrent kernel activity i.e. _CONCURRENT_KERNEL."]
pub const CUPTI_ACTIVITY_KIND_CDP_KERNEL: CUpti_ActivityKind = 18;
#[doc = " Preemption activity record indicating a preemption of a CDP (CUDA\n Dynamic Parallel) kernel executing on the GPU. The corresponding\n activity record structure is \\ref CUpti_ActivityPreemption."]
pub const CUPTI_ACTIVITY_KIND_PREEMPTION: CUpti_ActivityKind = 19;
#[doc = " Environment activity records indicating power, clock, thermal,\n etc. levels of the GPU. The corresponding activity record\n structure is \\ref CUpti_ActivityEnvironment."]
pub const CUPTI_ACTIVITY_KIND_ENVIRONMENT: CUpti_ActivityKind = 20;
#[doc = " An performance counter value associated with a specific event domain\n instance. The corresponding activity record structure is \\ref\n CUpti_ActivityEventInstance. This activity cannot be directly\n enabled or disabled. Information collected using the Event API.\n can be stored in the corresponding activity record.\n Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used."]
pub const CUPTI_ACTIVITY_KIND_EVENT_INSTANCE: CUpti_ActivityKind = 21;
#[doc = " A peer to peer memory copy. The corresponding activity record\n structure is \\ref CUpti_ActivityMemcpyPtoP4."]
pub const CUPTI_ACTIVITY_KIND_MEMCPY2: CUpti_ActivityKind = 22;
#[doc = " A performance metric value associated with a specific metric domain\n instance. The corresponding activity record structure is \\ref\n CUpti_ActivityMetricInstance. This activity cannot be directly\n enabled or disabled. Information collected using the Metric API.\n can be stored in the corresponding activity record.\n Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used."]
pub const CUPTI_ACTIVITY_KIND_METRIC_INSTANCE: CUpti_ActivityKind = 23;
#[doc = " Results for source-level instruction execution.\n The corresponding activity record structure is \\ref\n CUpti_ActivityInstructionExecution.\n Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.\n Enabling it will return the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n Instead, use the SASS Metric APIs from the cupti_sass_metrics.h header."]
pub const CUPTI_ACTIVITY_KIND_INSTRUCTION_EXECUTION: CUpti_ActivityKind = 24;
#[doc = " Unified Memory counter record. The corresponding activity\n record structure is \\ref CUpti_ActivityUnifiedMemoryCounter3."]
pub const CUPTI_ACTIVITY_KIND_UNIFIED_MEMORY_COUNTER: CUpti_ActivityKind = 25;
#[doc = " Device global/function record. The corresponding activity\n record structure is \\ref CUpti_ActivityFunction."]
pub const CUPTI_ACTIVITY_KIND_FUNCTION: CUpti_ActivityKind = 26;
#[doc = " CUDA Module record. The corresponding activity\n record structure is \\ref CUpti_ActivityModule.\n This activity cannot be directly enabled or disabled.\n Information collected using the module callback can be\n be stored in the corresponding activity record."]
pub const CUPTI_ACTIVITY_KIND_MODULE: CUpti_ActivityKind = 27;
#[doc = " A device attribute value. The corresponding activity record\n structure is \\ref CUpti_ActivityDeviceAttribute.\n This activity cannot be directly enabled or disabled.\n Information collected using attributes CUpti_DeviceAttribute\n or CUdevice_attribute can be stored in the corresponding activity record."]
pub const CUPTI_ACTIVITY_KIND_DEVICE_ATTRIBUTE: CUpti_ActivityKind = 28;
#[doc = " Results for source-level shared access. The\n corresponding activity record structure is \\ref\n CUpti_ActivitySharedAccess.\n Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.\n Enabling it will return the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n Instead, use the SASS Metric APIs from the cupti_sass_metrics.h header."]
pub const CUPTI_ACTIVITY_KIND_SHARED_ACCESS: CUpti_ActivityKind = 29;
#[doc = " PC sampling information for kernels. This will serialize\n kernels. The corresponding activity record structure\n is \\ref CUpti_ActivityPCSampling3.\n Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.\n Enabling it will return the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n Instead, use the PC Sampling API from the cupti_pcsampling.h header, which\n allows concurrent kernel execution."]
pub const CUPTI_ACTIVITY_KIND_PC_SAMPLING: CUpti_ActivityKind = 30;
#[doc = " Summary information about PC sampling records. The\n corresponding activity record structure is \\ref\n CUpti_ActivityPCSamplingRecordInfo.\n Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.\n Enabling it will return the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n Instead, use the PC Sampling API from the cupti_pcsampling.h header."]
pub const CUPTI_ACTIVITY_KIND_PC_SAMPLING_RECORD_INFO: CUpti_ActivityKind = 31;
#[doc = " SASS/Source line-by-line correlation record.\n This will generate sass/source correlation for functions that have source\n level analysis or pc sampling results. The records will be generated only\n when either of source level analysis or pc sampling activity is enabled.\n The corresponding activity record structure is \\ref\n CUpti_ActivityInstructionCorrelation.\n Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used.\n Enabling it will return the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n Instead, use the SASS Metric APIs from the cupti_sass_metrics.h header."]
pub const CUPTI_ACTIVITY_KIND_INSTRUCTION_CORRELATION: CUpti_ActivityKind = 32;
#[doc = " OpenACC data events.\n The corresponding activity record structure is \\ref\n CUpti_ActivityOpenAccData."]
pub const CUPTI_ACTIVITY_KIND_OPENACC_DATA: CUpti_ActivityKind = 33;
#[doc = " OpenACC launch events.\n The corresponding activity record structure is \\ref\n CUpti_ActivityOpenAccLaunch."]
pub const CUPTI_ACTIVITY_KIND_OPENACC_LAUNCH: CUpti_ActivityKind = 34;
#[doc = " OpenACC other events.\n The corresponding activity record structure is \\ref\n CUpti_ActivityOpenAccOther."]
pub const CUPTI_ACTIVITY_KIND_OPENACC_OTHER: CUpti_ActivityKind = 35;
#[doc = " Information about a CUDA event (cudaEvent).\n The corresponding activity record structure is \\ref\n CUpti_ActivityCudaEvent2."]
pub const CUPTI_ACTIVITY_KIND_CUDA_EVENT: CUpti_ActivityKind = 36;
#[doc = " Information about a CUDA stream. The\n corresponding activity record structure is \\ref\n CUpti_ActivityStream."]
pub const CUPTI_ACTIVITY_KIND_STREAM: CUpti_ActivityKind = 37;
#[doc = " Records for CUDA synchronization primitives. The\n corresponding activity record structure is \\ref\n CUpti_ActivitySynchronization2."]
pub const CUPTI_ACTIVITY_KIND_SYNCHRONIZATION: CUpti_ActivityKind = 38;
#[doc = " Records for correlation of different programming APIs. The\n corresponding activity record structure is \\ref\n CUpti_ActivityExternalCorrelation."]
pub const CUPTI_ACTIVITY_KIND_EXTERNAL_CORRELATION: CUpti_ActivityKind = 39;
#[doc = " NVLink topology information.\n The corresponding activity record structure is \\ref\n CUpti_ActivityNvLink4."]
pub const CUPTI_ACTIVITY_KIND_NVLINK: CUpti_ActivityKind = 40;
#[doc = " Instantaneous Event information.\n The corresponding activity record structure is \\ref\n CUpti_ActivityInstantaneousEvent.\n This activity can not be directly enabled or disabled.\n Information collected using the Event API can be stored\n in the corresponding activity record.\n Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used."]
pub const CUPTI_ACTIVITY_KIND_INSTANTANEOUS_EVENT: CUpti_ActivityKind = 41;
#[doc = " Instantaneous Event information for a specific event\n domain instance.\n The corresponding activity record structure is \\ref\n CUpti_ActivityInstantaneousEventInstance.\n This activity can not be directly enabled or disabled.\n Information collected using the Event API can be stored\n in the corresponding activity record.\n Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used."]
pub const CUPTI_ACTIVITY_KIND_INSTANTANEOUS_EVENT_INSTANCE: CUpti_ActivityKind = 42;
#[doc = " Instantaneous Metric information\n The corresponding activity record structure is \\ref\n CUpti_ActivityInstantaneousMetric.\n This activity cannot be directly enabled or disabled.\n Information collected using the Metric API can be stored\n in the corresponding activity record.\n Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used."]
pub const CUPTI_ACTIVITY_KIND_INSTANTANEOUS_METRIC: CUpti_ActivityKind = 43;
#[doc = " Instantaneous Metric information for a specific metric\n domain instance.\n The corresponding activity record structure is \\ref\n CUpti_ActivityInstantaneousMetricInstance.\n This activity cannot be directly enabled or disabled.\n Information collected using the Metric API can be stored\n in the corresponding activity record.\n Starting with the CUDA 13.0 release, this enum is unsupported and should no longer be used."]
pub const CUPTI_ACTIVITY_KIND_INSTANTANEOUS_METRIC_INSTANCE: CUpti_ActivityKind = 44;
#[doc = " Memory activity tracking allocation and freeing of the memory\n The corresponding activity record structure is \\ref\n CUpti_ActivityMemory."]
pub const CUPTI_ACTIVITY_KIND_MEMORY: CUpti_ActivityKind = 45;
#[doc = " PCI devices information used for PCI topology.\n The corresponding activity record structure is \\ref\n CUpti_ActivityPcie."]
pub const CUPTI_ACTIVITY_KIND_PCIE: CUpti_ActivityKind = 46;
#[doc = " OpenMP parallel events.\n The corresponding activity record structure is \\ref\n CUpti_ActivityOpenMp."]
pub const CUPTI_ACTIVITY_KIND_OPENMP: CUpti_ActivityKind = 47;
#[doc = " A CUDA driver kernel launch occurring outside of any\n public API function execution. Tools can handle these\n like records for driver API launch functions, although\n the cbid field is not used here.\n The corresponding activity record structure is \\ref\n CUpti_ActivityAPI."]
pub const CUPTI_ACTIVITY_KIND_INTERNAL_LAUNCH_API: CUpti_ActivityKind = 48;
#[doc = " Memory activity tracking allocation and freeing of the memory\n The corresponding activity record structure is \\ref\n CUpti_ActivityMemory4."]
pub const CUPTI_ACTIVITY_KIND_MEMORY2: CUpti_ActivityKind = 49;
#[doc = " Memory pool activity tracking creation, destruction and\n trimming of the memory pool.\n The corresponding activity record structure is \\ref\n CUpti_ActivityMemoryPool3."]
pub const CUPTI_ACTIVITY_KIND_MEMORY_POOL: CUpti_ActivityKind = 50;
#[doc = " Activity record for graph-level information.\n The corresponding activity record structure is\n \\ref CUpti_ActivityGraphTrace2."]
pub const CUPTI_ACTIVITY_KIND_GRAPH_TRACE: CUpti_ActivityKind = 51;
#[doc = " JIT (Just-in-time) operation tracking.\n The corresponding activity record structure is \\ref\n CUpti_ActivityJit."]
pub const CUPTI_ACTIVITY_KIND_JIT: CUpti_ActivityKind = 52;
#[doc = " This activity can not be directly enabled or disabled.\n It is enabled when CUPTI_ACTIVITY_KIND_GRAPH_TRACE is enabled\n and device graph trace is enabled through API cuptiActivityEnableDeviceGraph().\n The corresponding activity record structure is\n \\ref CUpti_ActivityDeviceGraphTrace."]
pub const CUPTI_ACTIVITY_KIND_DEVICE_GRAPH_TRACE: CUpti_ActivityKind = 53;
#[doc = " Tracing batches of copies that are to be decompressed.\n The corresponding activity record structure is \\ref\n CUpti_ActivityMemDecompress."]
pub const CUPTI_ACTIVITY_KIND_MEM_DECOMPRESS: CUpti_ActivityKind = 54;
#[doc = " Tracing new overheads introduced on some hardware due when\n confidential computing is enabled.\n The corresponding activity record structure is \\ref\n CUpti_ActivityConfidentialComputeRotation."]
pub const CUPTI_ACTIVITY_KIND_CONFIDENTIAL_COMPUTE_ROTATION: CUpti_ActivityKind = 55;
#[doc = " Count of supported activity kinds."]
pub const CUPTI_ACTIVITY_KIND_COUNT: CUpti_ActivityKind = 56;
#[doc = " Count of supported activity kinds."]
pub const CUPTI_ACTIVITY_KIND_FORCE_INT: CUpti_ActivityKind = 2147483647;
#[doc = " \\brief The kinds of activity records.\n\n Each activity record kind represents information about a GPU or an\n activity occurring on a CPU or GPU. Each kind is associated with a\n activity record structure that holds the information associated\n with the kind.\n \\see CUpti_Activity\n \\see CUpti_ActivityAPI\n \\see CUpti_ActivityContext\n \\see CUpti_ActivityContext2\n \\see CUpti_ActivityContext3\n \\see CUpti_ActivityDevice\n \\see CUpti_ActivityDevice2\n \\see CUpti_ActivityDevice3\n \\see CUpti_ActivityDevice4\n \\see CUpti_ActivityDevice5\n \\see CUpti_ActivityDeviceAttribute\n \\see CUpti_ActivityEvent\n \\see CUpti_ActivityEventInstance\n \\see CUpti_ActivityKernel\n \\see CUpti_ActivityKernel2\n \\see CUpti_ActivityKernel3\n \\see CUpti_ActivityKernel4\n \\see CUpti_ActivityKernel5\n \\see CUpti_ActivityKernel6\n \\see CUpti_ActivityKernel7\n \\see CUpti_ActivityKernel8\n \\see CUpti_ActivityKernel9\n \\see CUpti_ActivityKernel10\n \\see CUpti_ActivityCdpKernel\n \\see CUpti_ActivityPreemption\n \\see CUpti_ActivityMemcpy\n \\see CUpti_ActivityMemcpy3\n \\see CUpti_ActivityMemcpy4\n \\see CUpti_ActivityMemcpy5\n \\see CUpti_ActivityMemcpy6\n \\see CUpti_ActivityMemcpyPtoP\n \\see CUpti_ActivityMemcpyPtoP2\n \\see CUpti_ActivityMemcpyPtoP3\n \\see CUpti_ActivityMemcpyPtoP4\n \\see CUpti_ActivityMemset\n \\see CUpti_ActivityMemset2\n \\see CUpti_ActivityMemset3\n \\see CUpti_ActivityMemset4\n \\see CUpti_ActivityMemory\n \\see CUpti_ActivityMemory2\n \\see CUpti_ActivityMemory3\n \\see CUpti_ActivityMemory4\n \\see CUpti_ActivityMemoryPool\n \\see CUpti_ActivityMemoryPool2\n \\see CUpti_ActivityMemoryPool3\n \\see CUpti_ActivityMetric\n \\see CUpti_ActivityMetricInstance\n \\see CUpti_ActivityName\n \\see CUpti_ActivityMarker\n \\see CUpti_ActivityMarker2\n \\see CUpti_ActivityMarkerData\n \\see CUpti_ActivitySourceLocator\n \\see CUpti_ActivityGlobalAccess\n \\see CUpti_ActivityGlobalAccess2\n \\see CUpti_ActivityGlobalAccess3\n \\see CUpti_ActivityBranch\n \\see CUpti_ActivityBranch2\n \\see CUpti_ActivityOverhead3\n \\see CUpti_ActivityEnvironment\n \\see CUpti_ActivityInstructionExecution\n \\see CUpti_ActivityUnifiedMemoryCounter\n \\see CUpti_ActivityFunction\n \\see CUpti_ActivityModule\n \\see CUpti_ActivitySharedAccess\n \\see CUpti_ActivityPCSampling\n \\see CUpti_ActivityPCSampling2\n \\see CUpti_ActivityPCSampling3\n \\see CUpti_ActivityPCSamplingRecordInfo\n \\see CUpti_ActivityCudaEvent2\n \\see CUpti_ActivityStream\n \\see CUpti_ActivitySynchronization2\n \\see CUpti_ActivityInstructionCorrelation\n \\see CUpti_ActivityExternalCorrelation\n \\see CUpti_ActivityUnifiedMemoryCounter3\n \\see CUpti_ActivityOpenAccData\n \\see CUpti_ActivityOpenAccLaunch\n \\see CUpti_ActivityOpenAccOther\n \\see CUpti_ActivityOpenMp\n \\see CUpti_ActivityNvLink\n \\see CUpti_ActivityNvLink2\n \\see CUpti_ActivityNvLink3\n \\see CUpti_ActivityNvLink4\n \\see CUpti_ActivityPcie\n \\see CUpti_ActivityConfidentialComputeRotation"]
pub type CUpti_ActivityKind = ::std::os::raw::c_uint;
#[doc = " The object kind is not known."]
pub const CUPTI_ACTIVITY_OBJECT_UNKNOWN: CUpti_ActivityObjectKind = 0;
#[doc = " A process."]
pub const CUPTI_ACTIVITY_OBJECT_PROCESS: CUpti_ActivityObjectKind = 1;
#[doc = " A thread."]
pub const CUPTI_ACTIVITY_OBJECT_THREAD: CUpti_ActivityObjectKind = 2;
#[doc = " A device."]
pub const CUPTI_ACTIVITY_OBJECT_DEVICE: CUpti_ActivityObjectKind = 3;
#[doc = " A context."]
pub const CUPTI_ACTIVITY_OBJECT_CONTEXT: CUpti_ActivityObjectKind = 4;
#[doc = " A stream."]
pub const CUPTI_ACTIVITY_OBJECT_STREAM: CUpti_ActivityObjectKind = 5;
#[doc = " A stream."]
pub const CUPTI_ACTIVITY_OBJECT_FORCE_INT: CUpti_ActivityObjectKind = 2147483647;
#[doc = " \\brief The kinds of activity objects.\n \\see CUpti_ActivityObjectKindId"]
pub type CUpti_ActivityObjectKind = ::std::os::raw::c_uint;
#[doc = " \\brief Identifiers for object kinds as specified by\n CUpti_ActivityObjectKind.\n \\see CUpti_ActivityObjectKind"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityObjectKindId {
    pub pt: CUpti_ActivityObjectKindId__bindgen_ty_1,
    pub dcs: CUpti_ActivityObjectKindId__bindgen_ty_2,
}
#[doc = " A process object requires that we identify the process ID. A\n thread object requires that we identify both the process and\n thread ID."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityObjectKindId__bindgen_ty_1 {
    pub processId: u32,
    pub threadId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityObjectKindId__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityObjectKindId__bindgen_ty_1>() - 8usize];
    ["Alignment of CUpti_ActivityObjectKindId__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityObjectKindId__bindgen_ty_1>() - 4usize];
    ["Offset of field: CUpti_ActivityObjectKindId__bindgen_ty_1::processId"]
        [::std::mem::offset_of!(CUpti_ActivityObjectKindId__bindgen_ty_1, processId) - 0usize];
    ["Offset of field: CUpti_ActivityObjectKindId__bindgen_ty_1::threadId"]
        [::std::mem::offset_of!(CUpti_ActivityObjectKindId__bindgen_ty_1, threadId) - 4usize];
};
#[doc = " A device object requires that we identify the device ID. A\n context object requires that we identify both the device and\n context ID. A stream object requires that we identify device,\n context, and stream ID."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityObjectKindId__bindgen_ty_2 {
    pub deviceId: u32,
    pub contextId: u32,
    pub streamId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityObjectKindId__bindgen_ty_2"]
        [::std::mem::size_of::<CUpti_ActivityObjectKindId__bindgen_ty_2>() - 12usize];
    ["Alignment of CUpti_ActivityObjectKindId__bindgen_ty_2"]
        [::std::mem::align_of::<CUpti_ActivityObjectKindId__bindgen_ty_2>() - 4usize];
    ["Offset of field: CUpti_ActivityObjectKindId__bindgen_ty_2::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityObjectKindId__bindgen_ty_2, deviceId) - 0usize];
    ["Offset of field: CUpti_ActivityObjectKindId__bindgen_ty_2::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityObjectKindId__bindgen_ty_2, contextId) - 4usize];
    ["Offset of field: CUpti_ActivityObjectKindId__bindgen_ty_2::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityObjectKindId__bindgen_ty_2, streamId) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityObjectKindId"]
        [::std::mem::size_of::<CUpti_ActivityObjectKindId>() - 12usize];
    ["Alignment of CUpti_ActivityObjectKindId"]
        [::std::mem::align_of::<CUpti_ActivityObjectKindId>() - 4usize];
    ["Offset of field: CUpti_ActivityObjectKindId::pt"]
        [::std::mem::offset_of!(CUpti_ActivityObjectKindId, pt) - 0usize];
    ["Offset of field: CUpti_ActivityObjectKindId::dcs"]
        [::std::mem::offset_of!(CUpti_ActivityObjectKindId, dcs) - 0usize];
};
impl Default for CUpti_ActivityObjectKindId {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityObjectKindId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityObjectKindId {{ union }}")
    }
}
#[doc = " \\brief The structure to provide additional data for CUPTI_ACTIVITY_OVERHEAD_COMMAND_BUFFER_FULL."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityOverheadCommandBufferFullData {
    #[doc = " The remaining space in the command buffer. This field will always be zero\n when the command buffer is full, making it not useful in such cases.\n"]
    pub commandBufferLength: u32,
    #[doc = " The channel ID of the command buffer.\n"]
    pub channelID: u32,
    #[doc = " The channel type of the command buffer.\n"]
    pub channelType: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityOverheadCommandBufferFullData"]
        [::std::mem::size_of::<CUpti_ActivityOverheadCommandBufferFullData>() - 12usize];
    ["Alignment of CUpti_ActivityOverheadCommandBufferFullData"]
        [::std::mem::align_of::<CUpti_ActivityOverheadCommandBufferFullData>() - 4usize];
    ["Offset of field: CUpti_ActivityOverheadCommandBufferFullData::commandBufferLength"][::std::mem::offset_of!(
        CUpti_ActivityOverheadCommandBufferFullData,
        commandBufferLength
    )
        - 0usize];
    ["Offset of field: CUpti_ActivityOverheadCommandBufferFullData::channelID"]
        [::std::mem::offset_of!(CUpti_ActivityOverheadCommandBufferFullData, channelID) - 4usize];
    ["Offset of field: CUpti_ActivityOverheadCommandBufferFullData::channelType"]
        [::std::mem::offset_of!(CUpti_ActivityOverheadCommandBufferFullData, channelType) - 8usize];
};
#[doc = " The overhead kind is not known."]
pub const CUPTI_ACTIVITY_OVERHEAD_UNKNOWN: CUpti_ActivityOverheadKind = 0;
#[doc = " Compiler overhead."]
pub const CUPTI_ACTIVITY_OVERHEAD_DRIVER_COMPILER: CUpti_ActivityOverheadKind = 1;
#[doc = " Activity buffer flush overhead."]
pub const CUPTI_ACTIVITY_OVERHEAD_CUPTI_BUFFER_FLUSH: CUpti_ActivityOverheadKind = 65536;
#[doc = " CUPTI instrumentation overhead."]
pub const CUPTI_ACTIVITY_OVERHEAD_CUPTI_INSTRUMENTATION: CUpti_ActivityOverheadKind = 131072;
#[doc = " CUPTI resource creation and destruction overhead."]
pub const CUPTI_ACTIVITY_OVERHEAD_CUPTI_RESOURCE: CUpti_ActivityOverheadKind = 196608;
#[doc = " CUDA Runtime triggered module loading overhead."]
pub const CUPTI_ACTIVITY_OVERHEAD_RUNTIME_TRIGGERED_MODULE_LOADING: CUpti_ActivityOverheadKind =
    262144;
#[doc = " Lazy function loading overhead."]
pub const CUPTI_ACTIVITY_OVERHEAD_LAZY_FUNCTION_LOADING: CUpti_ActivityOverheadKind = 327680;
#[doc = " Overhead due to lack of command buffer space.\n Refer CUpti_ActivityOverheadCommandBufferFullData for more details."]
pub const CUPTI_ACTIVITY_OVERHEAD_COMMAND_BUFFER_FULL: CUpti_ActivityOverheadKind = 393216;
#[doc = " Overhead due to activity buffer request."]
pub const CUPTI_ACTIVITY_OVERHEAD_ACTIVITY_BUFFER_REQUEST: CUpti_ActivityOverheadKind = 458752;
#[doc = " Overhead due to UVM activity initialization."]
pub const CUPTI_ACTIVITY_OVERHEAD_UVM_ACTIVITY_INIT: CUpti_ActivityOverheadKind = 524288;
#[doc = " Overhead due to UVM activity initialization."]
pub const CUPTI_ACTIVITY_OVERHEAD_FORCE_INT: CUpti_ActivityOverheadKind = 2147483647;
#[doc = " \\brief The kinds of activity overhead."]
pub type CUpti_ActivityOverheadKind = ::std::os::raw::c_uint;
#[doc = " The compute API is not known."]
pub const CUPTI_ACTIVITY_COMPUTE_API_UNKNOWN: CUpti_ActivityComputeApiKind = 0;
#[doc = " The compute APIs are for CUDA."]
pub const CUPTI_ACTIVITY_COMPUTE_API_CUDA: CUpti_ActivityComputeApiKind = 1;
#[doc = " The compute APIs are for CUDA running\n in MPS (Multi-Process Service) environment."]
pub const CUPTI_ACTIVITY_COMPUTE_API_CUDA_MPS: CUpti_ActivityComputeApiKind = 2;
#[doc = " The compute APIs are for CUDA running\n in MPS (Multi-Process Service) environment."]
pub const CUPTI_ACTIVITY_COMPUTE_API_FORCE_INT: CUpti_ActivityComputeApiKind = 2147483647;
#[doc = " \\brief The kind of a compute API."]
pub type CUpti_ActivityComputeApiKind = ::std::os::raw::c_uint;
#[doc = " Indicates the activity record has no flags."]
pub const CUPTI_ACTIVITY_FLAG_NONE: CUpti_ActivityFlag = 0;
#[doc = " Indicates the activity represents a device that supports\n concurrent kernel execution. Valid for\n CUPTI_ACTIVITY_KIND_DEVICE."]
pub const CUPTI_ACTIVITY_FLAG_DEVICE_CONCURRENT_KERNELS: CUpti_ActivityFlag = 1;
#[doc = " Indicates if the activity represents a CUdevice_attribute value\n or a CUpti_DeviceAttribute value. Valid for\n CUPTI_ACTIVITY_KIND_DEVICE_ATTRIBUTE."]
pub const CUPTI_ACTIVITY_FLAG_DEVICE_ATTRIBUTE_CUDEVICE: CUpti_ActivityFlag = 1;
#[doc = " Indicates the activity represents an asynchronous memcpy\n operation. Valid for CUPTI_ACTIVITY_KIND_MEMCPY."]
pub const CUPTI_ACTIVITY_FLAG_MEMCPY_ASYNC: CUpti_ActivityFlag = 1;
#[doc = " Indicates the activity represents an instantaneous marker. Valid\n for CUPTI_ACTIVITY_KIND_MARKER."]
pub const CUPTI_ACTIVITY_FLAG_MARKER_INSTANTANEOUS: CUpti_ActivityFlag = 1;
#[doc = " Indicates the activity represents a region start marker. Valid\n for CUPTI_ACTIVITY_KIND_MARKER."]
pub const CUPTI_ACTIVITY_FLAG_MARKER_START: CUpti_ActivityFlag = 2;
#[doc = " Indicates the activity represents a region end marker. Valid for\n CUPTI_ACTIVITY_KIND_MARKER."]
pub const CUPTI_ACTIVITY_FLAG_MARKER_END: CUpti_ActivityFlag = 4;
#[doc = " Indicates the activity represents an attempt to acquire a user\n defined synchronization object.\n Valid for CUPTI_ACTIVITY_KIND_MARKER."]
pub const CUPTI_ACTIVITY_FLAG_MARKER_SYNC_ACQUIRE: CUpti_ActivityFlag = 8;
#[doc = " Indicates the activity represents success in acquiring the\n user defined synchronization object.\n Valid for CUPTI_ACTIVITY_KIND_MARKER."]
pub const CUPTI_ACTIVITY_FLAG_MARKER_SYNC_ACQUIRE_SUCCESS: CUpti_ActivityFlag = 16;
#[doc = " Indicates the activity represents failure in acquiring the\n user defined synchronization object.\n Valid for CUPTI_ACTIVITY_KIND_MARKER."]
pub const CUPTI_ACTIVITY_FLAG_MARKER_SYNC_ACQUIRE_FAILED: CUpti_ActivityFlag = 32;
#[doc = " Indicates the activity represents releasing a reservation on\n user defined synchronization object.\n Valid for CUPTI_ACTIVITY_KIND_MARKER."]
pub const CUPTI_ACTIVITY_FLAG_MARKER_SYNC_RELEASE: CUpti_ActivityFlag = 64;
#[doc = " Indicates the activity represents a marker that does not specify\n a color. Valid for CUPTI_ACTIVITY_KIND_MARKER_DATA."]
pub const CUPTI_ACTIVITY_FLAG_MARKER_COLOR_NONE: CUpti_ActivityFlag = 1;
#[doc = " Indicates the activity represents a marker that specifies a color\n in alpha-red-green-blue format. Valid for\n CUPTI_ACTIVITY_KIND_MARKER_DATA."]
pub const CUPTI_ACTIVITY_FLAG_MARKER_COLOR_ARGB: CUpti_ActivityFlag = 2;
#[doc = " The number of bytes requested by each thread\n Valid for CUpti_ActivityGlobalAccess3."]
pub const CUPTI_ACTIVITY_FLAG_GLOBAL_ACCESS_KIND_SIZE_MASK: CUpti_ActivityFlag = 255;
#[doc = " If bit in this flag is set, the access was load, else it is a\n store access. Valid for CUpti_ActivityGlobalAccess3."]
pub const CUPTI_ACTIVITY_FLAG_GLOBAL_ACCESS_KIND_LOAD: CUpti_ActivityFlag = 256;
#[doc = " If this bit in flag is set, the load access was cached else it is\n uncached. Valid for CUpti_ActivityGlobalAccess3."]
pub const CUPTI_ACTIVITY_FLAG_GLOBAL_ACCESS_KIND_CACHED: CUpti_ActivityFlag = 512;
#[doc = " If this bit in flag is set, the metric value overflowed. Valid\n for CUpti_ActivityMetric and CUpti_ActivityMetricInstance."]
pub const CUPTI_ACTIVITY_FLAG_METRIC_OVERFLOWED: CUpti_ActivityFlag = 1;
#[doc = " If this bit in flag is set, the metric value couldn't be\n calculated. This occurs when a value(s) required to calculate the\n metric is missing.  Valid for CUpti_ActivityMetric and\n CUpti_ActivityMetricInstance."]
pub const CUPTI_ACTIVITY_FLAG_METRIC_VALUE_INVALID: CUpti_ActivityFlag = 2;
#[doc = " If this bit in flag is set, the source level metric value couldn't be\n calculated. This occurs when a value(s) required to calculate the\n source level metric cannot be evaluated.\n Valid for CUpti_ActivityInstructionExecution."]
pub const CUPTI_ACTIVITY_FLAG_INSTRUCTION_VALUE_INVALID: CUpti_ActivityFlag = 1;
#[doc = " The mask for the instruction class, \\ref CUpti_ActivityInstructionClass\n Valid for CUpti_ActivityInstructionExecution and\n CUpti_ActivityInstructionCorrelation"]
pub const CUPTI_ACTIVITY_FLAG_INSTRUCTION_CLASS_MASK: CUpti_ActivityFlag = 510;
#[doc = " When calling cuptiActivityFlushAll, this flag\n can be set to force CUPTI to flush all records in the buffer, whether\n finished or not"]
pub const CUPTI_ACTIVITY_FLAG_FLUSH_FORCED: CUpti_ActivityFlag = 1;
#[doc = " The number of bytes requested by each thread\n Valid for CUpti_ActivitySharedAccess."]
pub const CUPTI_ACTIVITY_FLAG_SHARED_ACCESS_KIND_SIZE_MASK: CUpti_ActivityFlag = 255;
#[doc = " If bit in this flag is set, the access was load, else it is a\n store access.  Valid for CUpti_ActivitySharedAccess."]
pub const CUPTI_ACTIVITY_FLAG_SHARED_ACCESS_KIND_LOAD: CUpti_ActivityFlag = 256;
#[doc = " Indicates the activity represents an asynchronous memset\n operation. Valid for CUPTI_ACTIVITY_KIND_MEMSET."]
pub const CUPTI_ACTIVITY_FLAG_MEMSET_ASYNC: CUpti_ActivityFlag = 1;
#[doc = " Indicates the activity represents thrashing in CPU.\n Valid for counter of kind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING in\n CUPTI_ACTIVITY_KIND_UNIFIED_MEMORY_COUNTER"]
pub const CUPTI_ACTIVITY_FLAG_THRASHING_IN_CPU: CUpti_ActivityFlag = 1;
#[doc = " Indicates the activity represents page throttling in CPU.\n Valid for counter of kind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING in\n CUPTI_ACTIVITY_KIND_UNIFIED_MEMORY_COUNTER"]
pub const CUPTI_ACTIVITY_FLAG_THROTTLING_IN_CPU: CUpti_ActivityFlag = 1;
#[doc = " Indicates the activity represents page throttling in CPU.\n Valid for counter of kind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING in\n CUPTI_ACTIVITY_KIND_UNIFIED_MEMORY_COUNTER"]
pub const CUPTI_ACTIVITY_FLAG_FORCE_INT: CUpti_ActivityFlag = 2147483647;
#[doc = " \\brief Flags associated with activity records.\n\n Activity record flags. Flags can be combined by bitwise OR to\n associated multiple flags with an activity record. Each flag is\n specific to a certain activity kind, as noted below."]
pub type CUpti_ActivityFlag = ::std::os::raw::c_uint;
#[doc = " Invalid reason"]
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_INVALID: CUpti_ActivityPCSamplingStallReason = 0;
#[doc = " No stall, instruction is selected for issue"]
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_NONE: CUpti_ActivityPCSamplingStallReason = 1;
#[doc = " Warp is blocked because next instruction is not yet available,\n because of instruction cache miss, or because of branching effects"]
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_INST_FETCH: CUpti_ActivityPCSamplingStallReason = 2;
#[doc = " Instruction is waiting on an arithmetic dependency"]
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_EXEC_DEPENDENCY: CUpti_ActivityPCSamplingStallReason = 3;
#[doc = " Warp is blocked because it is waiting for a memory access to complete."]
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_MEMORY_DEPENDENCY: CUpti_ActivityPCSamplingStallReason =
    4;
#[doc = " Texture sub-system is fully utilized or has too many outstanding requests."]
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_TEXTURE: CUpti_ActivityPCSamplingStallReason = 5;
#[doc = " Warp is blocked as it is waiting at __syncthreads() or at memory barrier."]
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_SYNC: CUpti_ActivityPCSamplingStallReason = 6;
#[doc = " Warp is blocked waiting for __constant__ memory and immediate memory access to complete."]
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_CONSTANT_MEMORY_DEPENDENCY:
    CUpti_ActivityPCSamplingStallReason = 7;
#[doc = " Compute operation cannot be performed due to the required resources not\n being available."]
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_PIPE_BUSY: CUpti_ActivityPCSamplingStallReason = 8;
#[doc = " Warp is blocked because there are too many pending memory operations."]
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_MEMORY_THROTTLE: CUpti_ActivityPCSamplingStallReason = 9;
#[doc = " Warp was ready to issue, but some other warp issued instead."]
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_NOT_SELECTED: CUpti_ActivityPCSamplingStallReason = 10;
#[doc = " Miscellaneous reasons"]
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_OTHER: CUpti_ActivityPCSamplingStallReason = 11;
#[doc = " Sleeping."]
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_SLEEPING: CUpti_ActivityPCSamplingStallReason = 12;
#[doc = " Sleeping."]
pub const CUPTI_ACTIVITY_PC_SAMPLING_STALL_FORCE_INT: CUpti_ActivityPCSamplingStallReason =
    2147483647;
#[doc = " \\brief The stall reason for PC sampling activity."]
pub type CUpti_ActivityPCSamplingStallReason = ::std::os::raw::c_uint;
#[doc = " The PC sampling period is not set."]
pub const CUPTI_ACTIVITY_PC_SAMPLING_PERIOD_INVALID: CUpti_ActivityPCSamplingPeriod = 0;
#[doc = " Minimum sampling period available on the device."]
pub const CUPTI_ACTIVITY_PC_SAMPLING_PERIOD_MIN: CUpti_ActivityPCSamplingPeriod = 1;
#[doc = " Sampling period in lower range."]
pub const CUPTI_ACTIVITY_PC_SAMPLING_PERIOD_LOW: CUpti_ActivityPCSamplingPeriod = 2;
#[doc = " Medium sampling period."]
pub const CUPTI_ACTIVITY_PC_SAMPLING_PERIOD_MID: CUpti_ActivityPCSamplingPeriod = 3;
#[doc = " Sampling period in higher range."]
pub const CUPTI_ACTIVITY_PC_SAMPLING_PERIOD_HIGH: CUpti_ActivityPCSamplingPeriod = 4;
#[doc = " Maximum sampling period available on the device."]
pub const CUPTI_ACTIVITY_PC_SAMPLING_PERIOD_MAX: CUpti_ActivityPCSamplingPeriod = 5;
#[doc = " Maximum sampling period available on the device."]
pub const CUPTI_ACTIVITY_PC_SAMPLING_PERIOD_FORCE_INT: CUpti_ActivityPCSamplingPeriod = 2147483647;
#[doc = " \\brief Sampling period for PC sampling method\n\n Sampling period can be set using \\ref cuptiActivityConfigurePCSampling"]
pub type CUpti_ActivityPCSamplingPeriod = ::std::os::raw::c_uint;
#[doc = " The memory copy kind is not known."]
pub const CUPTI_ACTIVITY_MEMCPY_KIND_UNKNOWN: CUpti_ActivityMemcpyKind = 0;
#[doc = " A host to device memory copy."]
pub const CUPTI_ACTIVITY_MEMCPY_KIND_HTOD: CUpti_ActivityMemcpyKind = 1;
#[doc = " A device to host memory copy."]
pub const CUPTI_ACTIVITY_MEMCPY_KIND_DTOH: CUpti_ActivityMemcpyKind = 2;
#[doc = " A host to device array memory copy."]
pub const CUPTI_ACTIVITY_MEMCPY_KIND_HTOA: CUpti_ActivityMemcpyKind = 3;
#[doc = " A device array to host memory copy."]
pub const CUPTI_ACTIVITY_MEMCPY_KIND_ATOH: CUpti_ActivityMemcpyKind = 4;
#[doc = " A device array to device array memory copy."]
pub const CUPTI_ACTIVITY_MEMCPY_KIND_ATOA: CUpti_ActivityMemcpyKind = 5;
#[doc = " A device array to device memory copy."]
pub const CUPTI_ACTIVITY_MEMCPY_KIND_ATOD: CUpti_ActivityMemcpyKind = 6;
#[doc = " A device to device array memory copy."]
pub const CUPTI_ACTIVITY_MEMCPY_KIND_DTOA: CUpti_ActivityMemcpyKind = 7;
#[doc = " A device to device memory copy on the same device."]
pub const CUPTI_ACTIVITY_MEMCPY_KIND_DTOD: CUpti_ActivityMemcpyKind = 8;
#[doc = " A host to host memory copy."]
pub const CUPTI_ACTIVITY_MEMCPY_KIND_HTOH: CUpti_ActivityMemcpyKind = 9;
#[doc = " A peer to peer memory copy across different devices."]
pub const CUPTI_ACTIVITY_MEMCPY_KIND_PTOP: CUpti_ActivityMemcpyKind = 10;
#[doc = " A peer to peer memory copy across different devices."]
pub const CUPTI_ACTIVITY_MEMCPY_KIND_FORCE_INT: CUpti_ActivityMemcpyKind = 2147483647;
#[doc = " \\brief The kind of a memory copy, indicating the source and\n destination targets of the copy.\n\n Each kind represents the source and destination targets of a memory\n copy. Targets are host, device, and array."]
pub type CUpti_ActivityMemcpyKind = ::std::os::raw::c_uint;
#[doc = " The memory kind is unknown."]
pub const CUPTI_ACTIVITY_MEMORY_KIND_UNKNOWN: CUpti_ActivityMemoryKind = 0;
#[doc = " The memory is pageable."]
pub const CUPTI_ACTIVITY_MEMORY_KIND_PAGEABLE: CUpti_ActivityMemoryKind = 1;
#[doc = " The memory is pinned."]
pub const CUPTI_ACTIVITY_MEMORY_KIND_PINNED: CUpti_ActivityMemoryKind = 2;
#[doc = " The memory is on the device."]
pub const CUPTI_ACTIVITY_MEMORY_KIND_DEVICE: CUpti_ActivityMemoryKind = 3;
#[doc = " The memory is an array."]
pub const CUPTI_ACTIVITY_MEMORY_KIND_ARRAY: CUpti_ActivityMemoryKind = 4;
#[doc = " The memory is managed"]
pub const CUPTI_ACTIVITY_MEMORY_KIND_MANAGED: CUpti_ActivityMemoryKind = 5;
#[doc = " The memory is device static"]
pub const CUPTI_ACTIVITY_MEMORY_KIND_DEVICE_STATIC: CUpti_ActivityMemoryKind = 6;
#[doc = " The memory is managed static"]
pub const CUPTI_ACTIVITY_MEMORY_KIND_MANAGED_STATIC: CUpti_ActivityMemoryKind = 7;
#[doc = " The memory is managed static"]
pub const CUPTI_ACTIVITY_MEMORY_KIND_FORCE_INT: CUpti_ActivityMemoryKind = 2147483647;
#[doc = " \\brief The kinds of memory accessed by a memory operation/copy.\n\n Each kind represents the type of the memory\n accessed by a memory operation/copy."]
pub type CUpti_ActivityMemoryKind = ::std::os::raw::c_uint;
#[doc = " The preemption kind is not known."]
pub const CUPTI_ACTIVITY_PREEMPTION_KIND_UNKNOWN: CUpti_ActivityPreemptionKind = 0;
#[doc = " Preemption to save CDP block."]
pub const CUPTI_ACTIVITY_PREEMPTION_KIND_SAVE: CUpti_ActivityPreemptionKind = 1;
#[doc = " Preemption to restore CDP block."]
pub const CUPTI_ACTIVITY_PREEMPTION_KIND_RESTORE: CUpti_ActivityPreemptionKind = 2;
#[doc = " Preemption to restore CDP block."]
pub const CUPTI_ACTIVITY_PREEMPTION_KIND_FORCE_INT: CUpti_ActivityPreemptionKind = 2147483647;
#[doc = " \\brief The kind of a preemption activity."]
pub type CUpti_ActivityPreemptionKind = ::std::os::raw::c_uint;
#[doc = " Unknown data."]
pub const CUPTI_ACTIVITY_ENVIRONMENT_UNKNOWN: CUpti_ActivityEnvironmentKind = 0;
#[doc = " The environment data is related to speed."]
pub const CUPTI_ACTIVITY_ENVIRONMENT_SPEED: CUpti_ActivityEnvironmentKind = 1;
#[doc = " The environment data is related to temperature."]
pub const CUPTI_ACTIVITY_ENVIRONMENT_TEMPERATURE: CUpti_ActivityEnvironmentKind = 2;
#[doc = " The environment data is related to power."]
pub const CUPTI_ACTIVITY_ENVIRONMENT_POWER: CUpti_ActivityEnvironmentKind = 3;
#[doc = " The environment data is related to cooling."]
pub const CUPTI_ACTIVITY_ENVIRONMENT_COOLING: CUpti_ActivityEnvironmentKind = 4;
#[doc = " The environment data is related to cooling."]
pub const CUPTI_ACTIVITY_ENVIRONMENT_COUNT: CUpti_ActivityEnvironmentKind = 5;
#[doc = " The environment data is related to cooling."]
pub const CUPTI_ACTIVITY_ENVIRONMENT_KIND_FORCE_INT: CUpti_ActivityEnvironmentKind = 2147483647;
#[doc = " \\brief The kind of environment data. Used to indicate what type of\n data is being reported by an environment activity record."]
pub type CUpti_ActivityEnvironmentKind = ::std::os::raw::c_uint;
#[doc = " Nothing is running on the GPU and the clocks are dropping to idle\n state."]
pub const CUPTI_CLOCKS_THROTTLE_REASON_GPU_IDLE: CUpti_EnvironmentClocksThrottleReason = 1;
#[doc = " The GPU clocks are limited by a user specified limit."]
pub const CUPTI_CLOCKS_THROTTLE_REASON_USER_DEFINED_CLOCKS: CUpti_EnvironmentClocksThrottleReason =
    2;
#[doc = " A software power scaling algorithm is reducing the clocks below\n requested clocks."]
pub const CUPTI_CLOCKS_THROTTLE_REASON_SW_POWER_CAP: CUpti_EnvironmentClocksThrottleReason = 4;
#[doc = " Hardware slowdown to reduce the clock by a factor of two or more\n is engaged.  This is an indicator of one of the following: 1)\n Temperature is too high, 2) External power brake assertion is\n being triggered (e.g. by the system power supply), 3) Change in\n power state."]
pub const CUPTI_CLOCKS_THROTTLE_REASON_HW_SLOWDOWN: CUpti_EnvironmentClocksThrottleReason = 8;
#[doc = " Some unspecified factor is reducing the clocks."]
pub const CUPTI_CLOCKS_THROTTLE_REASON_UNKNOWN: CUpti_EnvironmentClocksThrottleReason = 2147483648;
#[doc = " Throttle reason is not supported for this GPU."]
pub const CUPTI_CLOCKS_THROTTLE_REASON_UNSUPPORTED: CUpti_EnvironmentClocksThrottleReason =
    1073741824;
#[doc = " No clock throttling."]
pub const CUPTI_CLOCKS_THROTTLE_REASON_NONE: CUpti_EnvironmentClocksThrottleReason = 0;
#[doc = " No clock throttling."]
pub const CUPTI_CLOCKS_THROTTLE_REASON_FORCE_INT: CUpti_EnvironmentClocksThrottleReason =
    2147483647;
#[doc = " \\brief Reasons for clock throttling.\n\n The possible reasons that a clock can be throttled. There can be\n more than one reason that a clock is being throttled so these types\n can be combined by bitwise OR.  These are used in the\n clocksThrottleReason field in the Environment Activity Record."]
pub type CUpti_EnvironmentClocksThrottleReason = ::std::os::raw::c_uint;
#[doc = " The unified memory counter scope is not known."]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_SCOPE_UNKNOWN:
    CUpti_ActivityUnifiedMemoryCounterScope = 0;
#[doc = " Collect unified memory counter for single process on one device"]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_SCOPE_PROCESS_SINGLE_DEVICE:
    CUpti_ActivityUnifiedMemoryCounterScope = 1;
#[doc = " Collect unified memory counter for single process across all devices"]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_SCOPE_PROCESS_ALL_DEVICES:
    CUpti_ActivityUnifiedMemoryCounterScope = 2;
#[doc = " Collect unified memory counter for single process across all devices"]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_SCOPE_COUNT:
    CUpti_ActivityUnifiedMemoryCounterScope = 3;
#[doc = " Collect unified memory counter for single process across all devices"]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_SCOPE_FORCE_INT:
    CUpti_ActivityUnifiedMemoryCounterScope = 2147483647;
#[doc = " \\brief Scope of the unified memory counter (deprecated in CUDA 7.0)"]
pub type CUpti_ActivityUnifiedMemoryCounterScope = ::std::os::raw::c_uint;
#[doc = " The unified memory counter kind is not known."]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_UNKNOWN:
    CUpti_ActivityUnifiedMemoryCounterKind = 0;
#[doc = " Number of bytes transferred from host to device"]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD:
    CUpti_ActivityUnifiedMemoryCounterKind = 1;
#[doc = " Number of bytes transferred from device to host"]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_DTOH:
    CUpti_ActivityUnifiedMemoryCounterKind = 2;
#[doc = " Number of CPU page faults, this is only supported on 64 bit\n Linux and Mac platforms"]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT:
    CUpti_ActivityUnifiedMemoryCounterKind = 3;
#[doc = " Number of GPU page faults, this is only supported on devices with\n compute capability 6.0 and higher and 64 bit Linux platforms"]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT:
    CUpti_ActivityUnifiedMemoryCounterKind = 4;
#[doc = " Thrashing occurs when data is frequently accessed by\n multiple processors and has to be constantly migrated around\n to achieve data locality. In this case the overhead of migration\n may exceed the benefits of locality.\n This is only supported on 64 bit Linux platforms."]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING:
    CUpti_ActivityUnifiedMemoryCounterKind = 5;
#[doc = " Throttling is a prevention technique used by the driver to avoid\n further thrashing. Here, the driver doesn't service the fault for\n one of the contending processors for a specific period of time,\n so that the other processor can run at full-speed.\n This is only supported on 64 bit Linux platforms."]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING:
    CUpti_ActivityUnifiedMemoryCounterKind = 6;
#[doc = " In case throttling does not help, the driver tries to pin the memory\n to a processor for a specific period of time. One of the contending\n processors will have slow  access to the memory, while the other will\n have fast access.\n This is only supported on 64 bit Linux platforms."]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_REMOTE_MAP:
    CUpti_ActivityUnifiedMemoryCounterKind = 7;
#[doc = " Number of bytes transferred from one device to another device.\n This is only supported on 64 bit Linux platforms."]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_DTOD:
    CUpti_ActivityUnifiedMemoryCounterKind = 8;
#[doc = " Number of bytes transferred from one device to another device.\n This is only supported on 64 bit Linux platforms."]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_COUNT: CUpti_ActivityUnifiedMemoryCounterKind =
    9;
#[doc = " Number of bytes transferred from one device to another device.\n This is only supported on 64 bit Linux platforms."]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_FORCE_INT:
    CUpti_ActivityUnifiedMemoryCounterKind = 2147483647;
#[doc = " \\brief Kind of the Unified Memory counter\n\n Many activities are associated with Unified Memory mechanism; among them\n are transfers from host to device, device to host, page fault at\n host side."]
pub type CUpti_ActivityUnifiedMemoryCounterKind = ::std::os::raw::c_uint;
#[doc = " The unified memory access type is not known"]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_ACCESS_TYPE_UNKNOWN: CUpti_ActivityUnifiedMemoryAccessType =
    0;
#[doc = " The page fault was triggered by read memory instruction"]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_ACCESS_TYPE_READ: CUpti_ActivityUnifiedMemoryAccessType = 1;
#[doc = " The page fault was triggered by write memory instruction"]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_ACCESS_TYPE_WRITE: CUpti_ActivityUnifiedMemoryAccessType =
    2;
#[doc = " The page fault was triggered by atomic memory instruction"]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_ACCESS_TYPE_ATOMIC: CUpti_ActivityUnifiedMemoryAccessType =
    3;
#[doc = " The page fault was triggered by memory prefetch operation"]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_ACCESS_TYPE_PREFETCH:
    CUpti_ActivityUnifiedMemoryAccessType = 4;
#[doc = " \\brief Memory access type for unified memory page faults\n\n This is valid for \\ref CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT\n and \\ref CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT"]
pub type CUpti_ActivityUnifiedMemoryAccessType = ::std::os::raw::c_uint;
#[doc = " The unified memory migration cause is not known"]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_MIGRATION_CAUSE_UNKNOWN:
    CUpti_ActivityUnifiedMemoryMigrationCause = 0;
#[doc = " The unified memory migrated due to an explicit call from\n the user e.g. cudaMemPrefetchAsync"]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_MIGRATION_CAUSE_USER:
    CUpti_ActivityUnifiedMemoryMigrationCause = 1;
#[doc = " The unified memory migrated to guarantee data coherence\n e.g. CPU/GPU faults on Pascal+ and kernel launch on pre-Pascal GPUs"]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_MIGRATION_CAUSE_COHERENCE:
    CUpti_ActivityUnifiedMemoryMigrationCause = 2;
#[doc = " The unified memory was speculatively migrated by the UVM driver\n before being accessed by the destination processor to improve\n performance"]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_MIGRATION_CAUSE_PREFETCH:
    CUpti_ActivityUnifiedMemoryMigrationCause = 3;
#[doc = " The unified memory migrated to the CPU because it was evicted to make\n room for another block of memory on the GPU"]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_MIGRATION_CAUSE_EVICTION:
    CUpti_ActivityUnifiedMemoryMigrationCause = 4;
#[doc = " The unified memory migrated to another processor because of access counter\n notifications. Only frequently accessed pages are migrated between CPU and GPU, or\n between peer GPUs."]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_MIGRATION_CAUSE_ACCESS_COUNTERS:
    CUpti_ActivityUnifiedMemoryMigrationCause = 5;
#[doc = " \\brief Migration cause of the Unified Memory counter\n\n This is valid for \\ref CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD and\n \\ref CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_DTOH"]
pub type CUpti_ActivityUnifiedMemoryMigrationCause = ::std::os::raw::c_uint;
#[doc = " The cause of mapping to remote memory was unknown"]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_REMOTE_MAP_CAUSE_UNKNOWN:
    CUpti_ActivityUnifiedMemoryRemoteMapCause = 0;
#[doc = " Mapping to remote memory was added to maintain data coherence."]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_REMOTE_MAP_CAUSE_COHERENCE:
    CUpti_ActivityUnifiedMemoryRemoteMapCause = 1;
#[doc = " Mapping to remote memory was added to prevent further thrashing"]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_REMOTE_MAP_CAUSE_THRASHING:
    CUpti_ActivityUnifiedMemoryRemoteMapCause = 2;
#[doc = " Mapping to remote memory was added to enforce the hints\n specified by the programmer or by performance heuristics of the\n UVM driver"]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_REMOTE_MAP_CAUSE_POLICY:
    CUpti_ActivityUnifiedMemoryRemoteMapCause = 3;
#[doc = " Mapping to remote memory was added because there is no more\n memory available on the processor and eviction was not\n possible"]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_REMOTE_MAP_CAUSE_OUT_OF_MEMORY:
    CUpti_ActivityUnifiedMemoryRemoteMapCause = 4;
#[doc = " Mapping to remote memory was added after the memory was\n evicted to make room for another block of memory on the GPU"]
pub const CUPTI_ACTIVITY_UNIFIED_MEMORY_REMOTE_MAP_CAUSE_EVICTION:
    CUpti_ActivityUnifiedMemoryRemoteMapCause = 5;
#[doc = " \\brief Remote memory map cause of the Unified Memory counter\n\n This is valid for \\ref CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_REMOTE_MAP"]
pub type CUpti_ActivityUnifiedMemoryRemoteMapCause = ::std::os::raw::c_uint;
#[doc = " The instruction class is not known."]
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_UNKNOWN: CUpti_ActivityInstructionClass = 0;
#[doc = " Represents a 32 bit floating point operation."]
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_FP_32: CUpti_ActivityInstructionClass = 1;
#[doc = " Represents a 64 bit floating point operation."]
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_FP_64: CUpti_ActivityInstructionClass = 2;
#[doc = " Represents an integer operation."]
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_INTEGER: CUpti_ActivityInstructionClass = 3;
#[doc = " Represents a bit conversion operation."]
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_BIT_CONVERSION: CUpti_ActivityInstructionClass = 4;
#[doc = " Represents a control flow instruction."]
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_CONTROL_FLOW: CUpti_ActivityInstructionClass = 5;
#[doc = " Represents a global load-store instruction."]
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_GLOBAL: CUpti_ActivityInstructionClass = 6;
#[doc = " Represents a shared load-store instruction."]
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_SHARED: CUpti_ActivityInstructionClass = 7;
#[doc = " Represents a local load-store instruction."]
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_LOCAL: CUpti_ActivityInstructionClass = 8;
#[doc = " Represents a generic load-store instruction."]
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_GENERIC: CUpti_ActivityInstructionClass = 9;
#[doc = " Represents a surface load-store instruction."]
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_SURFACE: CUpti_ActivityInstructionClass = 10;
#[doc = " Represents a constant load instruction."]
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_CONSTANT: CUpti_ActivityInstructionClass = 11;
#[doc = " Represents a texture load-store instruction."]
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_TEXTURE: CUpti_ActivityInstructionClass = 12;
#[doc = " Represents a global atomic instruction."]
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_GLOBAL_ATOMIC: CUpti_ActivityInstructionClass = 13;
#[doc = " Represents a shared atomic instruction."]
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_SHARED_ATOMIC: CUpti_ActivityInstructionClass = 14;
#[doc = " Represents a surface atomic instruction."]
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_SURFACE_ATOMIC: CUpti_ActivityInstructionClass = 15;
#[doc = " Represents a inter-thread communication instruction."]
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_INTER_THREAD_COMMUNICATION:
    CUpti_ActivityInstructionClass = 16;
#[doc = " Represents a barrier instruction."]
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_BARRIER: CUpti_ActivityInstructionClass = 17;
#[doc = " Represents some miscellaneous instructions which do not fit in the above classification."]
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_MISCELLANEOUS: CUpti_ActivityInstructionClass = 18;
#[doc = " Represents a 16 bit floating point operation."]
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_FP_16: CUpti_ActivityInstructionClass = 19;
#[doc = " Represents uniform instruction."]
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_UNIFORM: CUpti_ActivityInstructionClass = 20;
#[doc = " Represents uniform instruction."]
pub const CUPTI_ACTIVITY_INSTRUCTION_CLASS_KIND_FORCE_INT: CUpti_ActivityInstructionClass =
    2147483647;
#[doc = " \\brief SASS instruction classification.\n\n The sass instruction are broadly divided into different class. Each enum represents a classification."]
pub type CUpti_ActivityInstructionClass = ::std::os::raw::c_uint;
#[doc = " Partitioned global cache config unknown."]
pub const CUPTI_ACTIVITY_PARTITIONED_GLOBAL_CACHE_CONFIG_UNKNOWN:
    CUpti_ActivityPartitionedGlobalCacheConfig = 0;
#[doc = " Partitioned global cache not supported."]
pub const CUPTI_ACTIVITY_PARTITIONED_GLOBAL_CACHE_CONFIG_NOT_SUPPORTED:
    CUpti_ActivityPartitionedGlobalCacheConfig = 1;
#[doc = " Partitioned global cache config off."]
pub const CUPTI_ACTIVITY_PARTITIONED_GLOBAL_CACHE_CONFIG_OFF:
    CUpti_ActivityPartitionedGlobalCacheConfig = 2;
#[doc = " Partitioned global cache config on."]
pub const CUPTI_ACTIVITY_PARTITIONED_GLOBAL_CACHE_CONFIG_ON:
    CUpti_ActivityPartitionedGlobalCacheConfig = 3;
#[doc = " Partitioned global cache config on."]
pub const CUPTI_ACTIVITY_PARTITIONED_GLOBAL_CACHE_CONFIG_FORCE_INT:
    CUpti_ActivityPartitionedGlobalCacheConfig = 2147483647;
#[doc = " \\brief Partitioned global caching option"]
pub type CUpti_ActivityPartitionedGlobalCacheConfig = ::std::os::raw::c_uint;
#[doc = " Unknown data."]
pub const CUPTI_ACTIVITY_SYNCHRONIZATION_TYPE_UNKNOWN: CUpti_ActivitySynchronizationType = 0;
#[doc = " Event synchronize API."]
pub const CUPTI_ACTIVITY_SYNCHRONIZATION_TYPE_EVENT_SYNCHRONIZE: CUpti_ActivitySynchronizationType =
    1;
#[doc = " Stream wait event API."]
pub const CUPTI_ACTIVITY_SYNCHRONIZATION_TYPE_STREAM_WAIT_EVENT: CUpti_ActivitySynchronizationType =
    2;
#[doc = " Stream synchronize API."]
pub const CUPTI_ACTIVITY_SYNCHRONIZATION_TYPE_STREAM_SYNCHRONIZE:
    CUpti_ActivitySynchronizationType = 3;
#[doc = " Context synchronize API."]
pub const CUPTI_ACTIVITY_SYNCHRONIZATION_TYPE_CONTEXT_SYNCHRONIZE:
    CUpti_ActivitySynchronizationType = 4;
#[doc = " Context synchronize API."]
pub const CUPTI_ACTIVITY_SYNCHRONIZATION_TYPE_FORCE_INT: CUpti_ActivitySynchronizationType =
    2147483647;
#[doc = " \\brief Synchronization type.\n\n The types of synchronization to be used with\n CUpti_ActivitySynchronization2."]
pub type CUpti_ActivitySynchronizationType = ::std::os::raw::c_uint;
#[doc = " Unknown data."]
pub const CUPTI_ACTIVITY_STREAM_CREATE_FLAG_UNKNOWN: CUpti_ActivityStreamFlag = 0;
#[doc = " Default stream."]
pub const CUPTI_ACTIVITY_STREAM_CREATE_FLAG_DEFAULT: CUpti_ActivityStreamFlag = 1;
#[doc = " Non-blocking stream."]
pub const CUPTI_ACTIVITY_STREAM_CREATE_FLAG_NON_BLOCKING: CUpti_ActivityStreamFlag = 2;
#[doc = " Null stream."]
pub const CUPTI_ACTIVITY_STREAM_CREATE_FLAG_NULL: CUpti_ActivityStreamFlag = 3;
#[doc = " Stream create Mask"]
pub const CUPTI_ACTIVITY_STREAM_CREATE_MASK: CUpti_ActivityStreamFlag = 65535;
#[doc = " Stream create Mask"]
pub const CUPTI_ACTIVITY_STREAM_CREATE_FLAG_FORCE_INT: CUpti_ActivityStreamFlag = 2147483647;
#[doc = " \\brief stream type.\n\n The types of stream to be used with CUpti_ActivityStream."]
pub type CUpti_ActivityStreamFlag = ::std::os::raw::c_uint;
#[doc = " The flag is invalid."]
pub const CUPTI_LINK_FLAG_INVALID: CUpti_LinkFlag = 0;
#[doc = " Is peer to peer access supported by this link."]
pub const CUPTI_LINK_FLAG_PEER_ACCESS: CUpti_LinkFlag = 2;
#[doc = " Is system memory access supported by this link."]
pub const CUPTI_LINK_FLAG_SYSMEM_ACCESS: CUpti_LinkFlag = 4;
#[doc = " Is peer atomic access supported by this link."]
pub const CUPTI_LINK_FLAG_PEER_ATOMICS: CUpti_LinkFlag = 8;
#[doc = " Is system memory atomic access supported by this link."]
pub const CUPTI_LINK_FLAG_SYSMEM_ATOMICS: CUpti_LinkFlag = 16;
#[doc = " Is system memory atomic access supported by this link."]
pub const CUPTI_LINK_FLAG_FORCE_INT: CUpti_LinkFlag = 2147483647;
#[doc = " \\brief Link flags.\n\n Describes link properties, to be used with CUpti_ActivityNvLink."]
pub type CUpti_LinkFlag = ::std::os::raw::c_uint;
#[doc = " The operation is invalid."]
pub const CUPTI_ACTIVITY_MEMORY_OPERATION_TYPE_INVALID: CUpti_ActivityMemoryOperationType = 0;
#[doc = " Memory is allocated."]
pub const CUPTI_ACTIVITY_MEMORY_OPERATION_TYPE_ALLOCATION: CUpti_ActivityMemoryOperationType = 1;
#[doc = " Memory is released."]
pub const CUPTI_ACTIVITY_MEMORY_OPERATION_TYPE_RELEASE: CUpti_ActivityMemoryOperationType = 2;
#[doc = " Memory is released."]
pub const CUPTI_ACTIVITY_MEMORY_OPERATION_TYPE_FORCE_INT: CUpti_ActivityMemoryOperationType =
    2147483647;
#[doc = " \\brief Memory operation types.\n\n Describes the type of memory operation, to be used with CUpti_ActivityMemory4."]
pub type CUpti_ActivityMemoryOperationType = ::std::os::raw::c_uint;
#[doc = " The operation is invalid."]
pub const CUPTI_ACTIVITY_MEMORY_POOL_TYPE_INVALID: CUpti_ActivityMemoryPoolType = 0;
#[doc = " Memory pool is local to the process."]
pub const CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL: CUpti_ActivityMemoryPoolType = 1;
#[doc = " Memory pool is imported by the process."]
pub const CUPTI_ACTIVITY_MEMORY_POOL_TYPE_IMPORTED: CUpti_ActivityMemoryPoolType = 2;
#[doc = " Memory pool is imported by the process."]
pub const CUPTI_ACTIVITY_MEMORY_POOL_TYPE_FORCE_INT: CUpti_ActivityMemoryPoolType = 2147483647;
#[doc = " \\brief Memory pool types.\n\n Describes the type of memory pool, to be used with CUpti_ActivityMemory4."]
pub type CUpti_ActivityMemoryPoolType = ::std::os::raw::c_uint;
#[doc = " The operation is invalid."]
pub const CUPTI_ACTIVITY_MEMORY_POOL_OPERATION_TYPE_INVALID: CUpti_ActivityMemoryPoolOperationType =
    0;
#[doc = " Memory pool is created."]
pub const CUPTI_ACTIVITY_MEMORY_POOL_OPERATION_TYPE_CREATED: CUpti_ActivityMemoryPoolOperationType =
    1;
#[doc = " Memory pool is destroyed."]
pub const CUPTI_ACTIVITY_MEMORY_POOL_OPERATION_TYPE_DESTROYED:
    CUpti_ActivityMemoryPoolOperationType = 2;
#[doc = " Memory pool is trimmed."]
pub const CUPTI_ACTIVITY_MEMORY_POOL_OPERATION_TYPE_TRIMMED: CUpti_ActivityMemoryPoolOperationType =
    3;
#[doc = " Memory pool is trimmed."]
pub const CUPTI_ACTIVITY_MEMORY_POOL_OPERATION_TYPE_FORCE_INT:
    CUpti_ActivityMemoryPoolOperationType = 2147483647;
#[doc = " \\brief Memory pool operation types.\n\n Describes the type of memory pool operation, to be used with CUpti_ActivityMemoryPool2."]
pub type CUpti_ActivityMemoryPoolOperationType = ::std::os::raw::c_uint;
pub const CUPTI_CHANNEL_TYPE_INVALID: CUpti_ChannelType = 0;
#[doc = " Channel is used for standard work launch and tracking"]
pub const CUPTI_CHANNEL_TYPE_COMPUTE: CUpti_ChannelType = 1;
#[doc = " Channel is used by an asynchronous copy engine\n For confidential compute configurations, work launch and\n completion are done using the copy engines."]
pub const CUPTI_CHANNEL_TYPE_ASYNC_MEMCPY: CUpti_ChannelType = 2;
#[doc = " Channel is used for memory decompression operations"]
pub const CUPTI_CHANNEL_TYPE_DECOMP: CUpti_ChannelType = 3;
#[doc = " Channel is used for memory decompression operations"]
pub const CUPTI_CHANNEL_TYPE_FORCE_INT: CUpti_ChannelType = 2147483647;
pub type CUpti_ChannelType = ::std::os::raw::c_uint;
#[doc = " Regular (non-CIG) mode"]
pub const CUPTI_CONTEXT_CIG_MODE_NONE: CUpti_ContextCigMode = 0;
#[doc = " CIG mode"]
pub const CUPTI_CONTEXT_CIG_MODE_CIG: CUpti_ContextCigMode = 1;
#[doc = " CIG fallback mode"]
pub const CUPTI_CONTEXT_CIG_MODE_CIG_FALLBACK: CUpti_ContextCigMode = 2;
#[doc = " CIG fallback mode"]
pub const CUPTI_CONTEXT_CIG_MODE_FORCE_INT: CUpti_ContextCigMode = 2147483647;
#[doc = " \\brief CIG (CUDA in Graphics) Modes.\n\n Describes the CIG modes associated with the CUDA context."]
pub type CUpti_ContextCigMode = ::std::os::raw::c_uint;
#[doc = " The payload type is not known."]
pub const CUPTI_NVTX_EXT_PAYLOAD_TYPE_UNKNOWN: CUpti_NvtxExtPayloadType = 0;
#[doc = " The payload type is a schema."]
pub const CUPTI_NVTX_EXT_PAYLOAD_TYPE_SCHEMA: CUpti_NvtxExtPayloadType = 1;
#[doc = " The payload type is an enum."]
pub const CUPTI_NVTX_EXT_PAYLOAD_TYPE_ENUM: CUpti_NvtxExtPayloadType = 2;
#[doc = " The payload type is an enum."]
pub const CUPTI_NVTX_EXT_PAYLOAD_TYPE_FORCE_INT: CUpti_NvtxExtPayloadType = 2147483647;
pub type CUpti_NvtxExtPayloadType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_NvtxExtPayloadAttr {
    #[doc = " Size of the struct in bytes."]
    pub structSize: u32,
    #[doc = " The payload type. \\ref CUpti_NvtxExtPayloadType"]
    pub type_: u32,
    #[doc = " The attributes of the payload.\n Depending on the type, typecast the pointer:\n CUPTI_NVTX_EXT_PAYLOAD_TYPE_SCHEMA: nvtxPayloadSchemaAttr_t\n CUPTI_NVTX_EXT_PAYLOAD_TYPE_ENUM: nvtxPayloadEnumAttr_t"]
    pub attributes: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_NvtxExtPayloadAttr"]
        [::std::mem::size_of::<CUpti_NvtxExtPayloadAttr>() - 16usize];
    ["Alignment of CUpti_NvtxExtPayloadAttr"]
        [::std::mem::align_of::<CUpti_NvtxExtPayloadAttr>() - 8usize];
    ["Offset of field: CUpti_NvtxExtPayloadAttr::structSize"]
        [::std::mem::offset_of!(CUpti_NvtxExtPayloadAttr, structSize) - 0usize];
    ["Offset of field: CUpti_NvtxExtPayloadAttr::type_"]
        [::std::mem::offset_of!(CUpti_NvtxExtPayloadAttr, type_) - 4usize];
    ["Offset of field: CUpti_NvtxExtPayloadAttr::attributes"]
        [::std::mem::offset_of!(CUpti_NvtxExtPayloadAttr, attributes) - 8usize];
};
impl Default for CUpti_NvtxExtPayloadAttr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Unified Memory counters configuration structure\n\n This structure controls the enable/disable of the various\n Unified Memory counters consisting of scope, kind and other parameters.\n See function \\ref cuptiActivityConfigureUnifiedMemoryCounter"]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityUnifiedMemoryCounterConfig {
    #[doc = " Unified Memory counter Counter scope. (deprecated in CUDA 7.0)"]
    pub scope: CUpti_ActivityUnifiedMemoryCounterScope,
    #[doc = " Unified Memory counter Counter kind"]
    pub kind: CUpti_ActivityUnifiedMemoryCounterKind,
    #[doc = " Device id of the target device. This is relevant only\n for single device scopes. (deprecated in CUDA 7.0)"]
    pub deviceId: u32,
    #[doc = " Control to enable/disable the counter. To enable the counter\n set it to non-zero value while disable is indicated by zero."]
    pub enable: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityUnifiedMemoryCounterConfig"]
        [::std::mem::size_of::<CUpti_ActivityUnifiedMemoryCounterConfig>() - 16usize];
    ["Alignment of CUpti_ActivityUnifiedMemoryCounterConfig"]
        [::std::mem::align_of::<CUpti_ActivityUnifiedMemoryCounterConfig>() - 8usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounterConfig::scope"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounterConfig, scope) - 0usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounterConfig::kind"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounterConfig, kind) - 4usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounterConfig::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounterConfig, deviceId) - 8usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounterConfig::enable"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounterConfig, enable) - 12usize];
};
impl Default for CUpti_ActivityUnifiedMemoryCounterConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Device auto boost state structure\n\n This structure defines auto boost state for a device.\n See function \\ref cuptiGetAutoBoostState"]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityAutoBoostState {
    #[doc = " Returned auto boost state. 1 is returned in case auto boost is enabled, 0\n otherwise"]
    pub enabled: u32,
    #[doc = " Id of process that has set the current boost state. The value will be\n CUPTI_AUTO_BOOST_INVALID_CLIENT_PID if the user does not have the\n permission to query process ids or there is an error in querying the\n process id."]
    pub pid: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityAutoBoostState"]
        [::std::mem::size_of::<CUpti_ActivityAutoBoostState>() - 8usize];
    ["Alignment of CUpti_ActivityAutoBoostState"]
        [::std::mem::align_of::<CUpti_ActivityAutoBoostState>() - 8usize];
    ["Offset of field: CUpti_ActivityAutoBoostState::enabled"]
        [::std::mem::offset_of!(CUpti_ActivityAutoBoostState, enabled) - 0usize];
    ["Offset of field: CUpti_ActivityAutoBoostState::pid"]
        [::std::mem::offset_of!(CUpti_ActivityAutoBoostState, pid) - 4usize];
};
#[doc = " \\brief PC sampling configuration structure\n\n This structure defines the pc sampling configuration.\n\n See function \\ref cuptiActivityConfigurePCSampling"]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityPCSamplingConfig {
    #[doc = " Size of configuration structure.\n CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are\n available in the structure. Used to preserve backward compatibility."]
    pub size: u32,
    #[doc = " There are 5 level provided for sampling period. The level\n internally maps to a period in terms of cycles. Same level can\n map to different number of cycles on different gpus. No of\n cycles will be chosen to minimize information loss. The period\n chosen will be given by samplingPeriodInCycles in\n \\ref CUpti_ActivityPCSamplingRecordInfo for each kernel instance."]
    pub samplingPeriod: CUpti_ActivityPCSamplingPeriod,
    #[doc = " This will override the period set by samplingPeriod. Value 0 in samplingPeriod2 will be\n considered as samplingPeriod2 should not be used and samplingPeriod should be used.\n Valid values for samplingPeriod2 are between 5 to 31 both inclusive.\n This will set the sampling period to (2^samplingPeriod2) cycles."]
    pub samplingPeriod2: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityPCSamplingConfig"]
        [::std::mem::size_of::<CUpti_ActivityPCSamplingConfig>() - 16usize];
    ["Alignment of CUpti_ActivityPCSamplingConfig"]
        [::std::mem::align_of::<CUpti_ActivityPCSamplingConfig>() - 8usize];
    ["Offset of field: CUpti_ActivityPCSamplingConfig::size"]
        [::std::mem::offset_of!(CUpti_ActivityPCSamplingConfig, size) - 0usize];
    ["Offset of field: CUpti_ActivityPCSamplingConfig::samplingPeriod"]
        [::std::mem::offset_of!(CUpti_ActivityPCSamplingConfig, samplingPeriod) - 4usize];
    ["Offset of field: CUpti_ActivityPCSamplingConfig::samplingPeriod2"]
        [::std::mem::offset_of!(CUpti_ActivityPCSamplingConfig, samplingPeriod2) - 8usize];
};
impl Default for CUpti_ActivityPCSamplingConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The base activity record.\n\n The activity API uses a CUpti_Activity as a generic representation\n for any activity. The 'kind' field is used to determine the\n specific activity kind, and from that the CUpti_Activity object can\n be cast to the specific activity record type appropriate for that kind.\n\n Note that all activity record types are padded and aligned to\n ensure that each member of the record is naturally aligned.\n\n \\see CUpti_ActivityKind"]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Activity {
    #[doc = " The kind of this activity."]
    pub kind: CUpti_ActivityKind,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Activity"][::std::mem::size_of::<CUpti_Activity>() - 8usize];
    ["Alignment of CUpti_Activity"][::std::mem::align_of::<CUpti_Activity>() - 8usize];
    ["Offset of field: CUpti_Activity::kind"]
        [::std::mem::offset_of!(CUpti_Activity, kind) - 0usize];
};
impl Default for CUpti_Activity {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for memory copies.\n\n This activity record represents a memory copy\n (CUPTI_ACTIVITY_KIND_MEMCPY)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemcpy6 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMCPY."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The kind of the memory copy, stored as a byte to reduce record\n size. \\see CUpti_ActivityMemcpyKind"]
    pub copyKind: u8,
    #[doc = " The source memory kind read by the memory copy, stored as a byte\n to reduce record size. \\see CUpti_ActivityMemoryKind"]
    pub srcKind: u8,
    #[doc = " The destination memory kind read by the memory copy, stored as a\n byte to reduce record size. \\see CUpti_ActivityMemoryKind"]
    pub dstKind: u8,
    #[doc = " The flags associated with the memory copy. \\see CUpti_ActivityFlag"]
    pub flags: u8,
    #[doc = " The number of bytes transferred by the memory copy."]
    pub bytes: u64,
    #[doc = " The start timestamp for the memory copy, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory copy."]
    pub start: u64,
    #[doc = " The end timestamp for the memory copy, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory copy."]
    pub end: u64,
    #[doc = " The ID of the device where the memory copy is occurring."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the memory copy is occurring."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the memory copy is occurring."]
    pub streamId: u32,
    #[doc = " The correlation ID of the memory copy. Each memory copy is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver API activity record that launched\n the memory copy."]
    pub correlationId: u32,
    #[doc = " The runtime correlation ID of the memory copy. Each memory copy\n is assigned a unique runtime correlation ID that is identical to\n the correlation ID in the runtime API activity record that\n launched the memory copy."]
    pub runtimeCorrelationId: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
    #[doc = " The unique ID of the graph node that executed this memcpy through graph launch.\n This field will be 0 if the memcpy is not done through graph launch."]
    pub graphNodeId: u64,
    #[doc = " The unique ID of the graph that executed this memcpy through graph launch.\n This field will be 0 if the memcpy is not done through graph launch."]
    pub graphId: u32,
    #[doc = " The ID of the HW channel on which the memory copy is occurring."]
    pub channelID: u32,
    #[doc = " The type of the channel"]
    pub channelType: CUpti_ChannelType,
    #[doc = " This field is used to indicate if the memcpy operation is part of a device graph launch."]
    pub isDeviceLaunched: u8,
    #[doc = "  Reserved for internal use."]
    pub pad2: [u8; 3usize],
    #[doc = " The total number of memcopy operations traced in this record.\n This field is valid for memcpy operations happening using\n MemcpyBatchAsync APIs in CUDA.\n In MemcpyBatchAsync APIs, multiple memcpy operations are batched\n together for optimization purposes based on certain heuristics.\n For other memcpy operations, this field will be 1."]
    pub copyCount: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemcpy6"][::std::mem::size_of::<CUpti_ActivityMemcpy6>() - 96usize];
    ["Alignment of CUpti_ActivityMemcpy6"]
        [::std::mem::align_of::<CUpti_ActivityMemcpy6>() - 8usize];
    ["Offset of field: CUpti_ActivityMemcpy6::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy6, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMemcpy6::copyKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy6, copyKind) - 4usize];
    ["Offset of field: CUpti_ActivityMemcpy6::srcKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy6, srcKind) - 5usize];
    ["Offset of field: CUpti_ActivityMemcpy6::dstKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy6, dstKind) - 6usize];
    ["Offset of field: CUpti_ActivityMemcpy6::flags"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy6, flags) - 7usize];
    ["Offset of field: CUpti_ActivityMemcpy6::bytes"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy6, bytes) - 8usize];
    ["Offset of field: CUpti_ActivityMemcpy6::start"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy6, start) - 16usize];
    ["Offset of field: CUpti_ActivityMemcpy6::end"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy6, end) - 24usize];
    ["Offset of field: CUpti_ActivityMemcpy6::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy6, deviceId) - 32usize];
    ["Offset of field: CUpti_ActivityMemcpy6::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy6, contextId) - 36usize];
    ["Offset of field: CUpti_ActivityMemcpy6::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy6, streamId) - 40usize];
    ["Offset of field: CUpti_ActivityMemcpy6::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy6, correlationId) - 44usize];
    ["Offset of field: CUpti_ActivityMemcpy6::runtimeCorrelationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy6, runtimeCorrelationId) - 48usize];
    ["Offset of field: CUpti_ActivityMemcpy6::pad"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy6, pad) - 52usize];
    ["Offset of field: CUpti_ActivityMemcpy6::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy6, reserved0) - 56usize];
    ["Offset of field: CUpti_ActivityMemcpy6::graphNodeId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy6, graphNodeId) - 64usize];
    ["Offset of field: CUpti_ActivityMemcpy6::graphId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy6, graphId) - 72usize];
    ["Offset of field: CUpti_ActivityMemcpy6::channelID"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy6, channelID) - 76usize];
    ["Offset of field: CUpti_ActivityMemcpy6::channelType"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy6, channelType) - 80usize];
    ["Offset of field: CUpti_ActivityMemcpy6::isDeviceLaunched"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy6, isDeviceLaunched) - 84usize];
    ["Offset of field: CUpti_ActivityMemcpy6::pad2"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy6, pad2) - 85usize];
    ["Offset of field: CUpti_ActivityMemcpy6::copyCount"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy6, copyCount) - 88usize];
};
impl Default for CUpti_ActivityMemcpy6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for peer-to-peer memory copies.\n\n This activity record represents a peer-to-peer memory copy\n (CUPTI_ACTIVITY_KIND_MEMCPY2)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemcpyPtoP4 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMCPY2."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The kind of the memory copy, stored as a byte to reduce record\n size.  \\see CUpti_ActivityMemcpyKind"]
    pub copyKind: u8,
    #[doc = " The source memory kind read by the memory copy, stored as a byte\n to reduce record size.  \\see CUpti_ActivityMemoryKind"]
    pub srcKind: u8,
    #[doc = " The destination memory kind read by the memory copy, stored as a\n byte to reduce record size.  \\see CUpti_ActivityMemoryKind"]
    pub dstKind: u8,
    #[doc = " The flags associated with the memory copy. \\see\n CUpti_ActivityFlag"]
    pub flags: u8,
    #[doc = " The number of bytes transferred by the memory copy."]
    pub bytes: u64,
    #[doc = " The start timestamp for the memory copy, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory copy."]
    pub start: u64,
    #[doc = " The end timestamp for the memory copy, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory copy."]
    pub end: u64,
    #[doc = " The ID of the device where the memory copy is occurring."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the memory copy is occurring."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the memory copy is occurring."]
    pub streamId: u32,
    #[doc = " The ID of the device where memory is being copied from."]
    pub srcDeviceId: u32,
    #[doc = " The ID of the context owning the memory being copied from."]
    pub srcContextId: u32,
    #[doc = " The ID of the device where memory is being copied to."]
    pub dstDeviceId: u32,
    #[doc = " The ID of the context owning the memory being copied to."]
    pub dstContextId: u32,
    #[doc = " The correlation ID of the memory copy. Each memory copy is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver and runtime API activity record that\n launched the memory copy."]
    pub correlationId: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
    #[doc = " The unique ID of the graph node that executed the memcpy through graph launch.\n This field will be 0 if memcpy is not done using graph launch."]
    pub graphNodeId: u64,
    #[doc = " The unique ID of the graph that executed this memcpy through graph launch.\n This field will be 0 if the memcpy is not done through graph launch."]
    pub graphId: u32,
    #[doc = " The ID of the HW channel on which the memory copy is occurring."]
    pub channelID: u32,
    #[doc = " The type of the channel"]
    pub channelType: CUpti_ChannelType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemcpyPtoP4"]
        [::std::mem::size_of::<CUpti_ActivityMemcpyPtoP4>() - 96usize];
    ["Alignment of CUpti_ActivityMemcpyPtoP4"]
        [::std::mem::align_of::<CUpti_ActivityMemcpyPtoP4>() - 8usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP4::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP4::copyKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, copyKind) - 4usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP4::srcKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, srcKind) - 5usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP4::dstKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, dstKind) - 6usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP4::flags"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, flags) - 7usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP4::bytes"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, bytes) - 8usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP4::start"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, start) - 16usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP4::end"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, end) - 24usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP4::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, deviceId) - 32usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP4::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, contextId) - 36usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP4::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, streamId) - 40usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP4::srcDeviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, srcDeviceId) - 44usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP4::srcContextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, srcContextId) - 48usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP4::dstDeviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, dstDeviceId) - 52usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP4::dstContextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, dstContextId) - 56usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP4::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, correlationId) - 60usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP4::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, reserved0) - 64usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP4::graphNodeId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, graphNodeId) - 72usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP4::graphId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, graphId) - 80usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP4::channelID"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, channelID) - 84usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP4::channelType"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP4, channelType) - 88usize];
};
impl Default for CUpti_ActivityMemcpyPtoP4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for memset.\n\n This activity record represents a memory set operation\n (CUPTI_ACTIVITY_KIND_MEMSET)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemset4 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMSET."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The value being assigned to memory by the memory set."]
    pub value: u32,
    #[doc = " The number of bytes being set by the memory set."]
    pub bytes: u64,
    #[doc = " The start timestamp for the memory set, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory set."]
    pub start: u64,
    #[doc = " The end timestamp for the memory set, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory set."]
    pub end: u64,
    #[doc = " The ID of the device where the memory set is occurring."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the memory set is occurring."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the memory set is occurring."]
    pub streamId: u32,
    #[doc = " The correlation ID of the memory set. Each memory set is assigned\n a unique correlation ID that is identical to the correlation ID\n in the driver API activity record that launched the memory set."]
    pub correlationId: u32,
    #[doc = " The flags associated with the memset. \\see CUpti_ActivityFlag"]
    pub flags: u16,
    #[doc = " The memory kind of the memory set \\see CUpti_ActivityMemoryKind"]
    pub memoryKind: u16,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
    #[doc = " The unique ID of the graph node that executed this memset through graph launch.\n This field will be 0 if the memset is not executed through graph launch."]
    pub graphNodeId: u64,
    #[doc = " The unique ID of the graph that executed this memset through graph launch.\n This field will be 0 if the memset is not executed through graph launch."]
    pub graphId: u32,
    #[doc = " The ID of the HW channel on which the memory set is occurring."]
    pub channelID: u32,
    #[doc = " The type of the channel"]
    pub channelType: CUpti_ChannelType,
    #[doc = " This field is used to indicate if the memset operation is part of a device graph launch."]
    pub isDeviceLaunched: u8,
    #[doc = "  Undefined. Reserved for internal use"]
    pub pad2: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemset4"][::std::mem::size_of::<CUpti_ActivityMemset4>() - 88usize];
    ["Alignment of CUpti_ActivityMemset4"]
        [::std::mem::align_of::<CUpti_ActivityMemset4>() - 8usize];
    ["Offset of field: CUpti_ActivityMemset4::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMemset4, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMemset4::value"]
        [::std::mem::offset_of!(CUpti_ActivityMemset4, value) - 4usize];
    ["Offset of field: CUpti_ActivityMemset4::bytes"]
        [::std::mem::offset_of!(CUpti_ActivityMemset4, bytes) - 8usize];
    ["Offset of field: CUpti_ActivityMemset4::start"]
        [::std::mem::offset_of!(CUpti_ActivityMemset4, start) - 16usize];
    ["Offset of field: CUpti_ActivityMemset4::end"]
        [::std::mem::offset_of!(CUpti_ActivityMemset4, end) - 24usize];
    ["Offset of field: CUpti_ActivityMemset4::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemset4, deviceId) - 32usize];
    ["Offset of field: CUpti_ActivityMemset4::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemset4, contextId) - 36usize];
    ["Offset of field: CUpti_ActivityMemset4::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityMemset4, streamId) - 40usize];
    ["Offset of field: CUpti_ActivityMemset4::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemset4, correlationId) - 44usize];
    ["Offset of field: CUpti_ActivityMemset4::flags"]
        [::std::mem::offset_of!(CUpti_ActivityMemset4, flags) - 48usize];
    ["Offset of field: CUpti_ActivityMemset4::memoryKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemset4, memoryKind) - 50usize];
    ["Offset of field: CUpti_ActivityMemset4::pad"]
        [::std::mem::offset_of!(CUpti_ActivityMemset4, pad) - 52usize];
    ["Offset of field: CUpti_ActivityMemset4::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityMemset4, reserved0) - 56usize];
    ["Offset of field: CUpti_ActivityMemset4::graphNodeId"]
        [::std::mem::offset_of!(CUpti_ActivityMemset4, graphNodeId) - 64usize];
    ["Offset of field: CUpti_ActivityMemset4::graphId"]
        [::std::mem::offset_of!(CUpti_ActivityMemset4, graphId) - 72usize];
    ["Offset of field: CUpti_ActivityMemset4::channelID"]
        [::std::mem::offset_of!(CUpti_ActivityMemset4, channelID) - 76usize];
    ["Offset of field: CUpti_ActivityMemset4::channelType"]
        [::std::mem::offset_of!(CUpti_ActivityMemset4, channelType) - 80usize];
    ["Offset of field: CUpti_ActivityMemset4::isDeviceLaunched"]
        [::std::mem::offset_of!(CUpti_ActivityMemset4, isDeviceLaunched) - 84usize];
    ["Offset of field: CUpti_ActivityMemset4::pad2"]
        [::std::mem::offset_of!(CUpti_ActivityMemset4, pad2) - 85usize];
};
impl Default for CUpti_ActivityMemset4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for memory.\n\n This activity record represents a memory allocation and free operation\n (CUPTI_ACTIVITY_KIND_MEMORY).\n This activity record provides a single record for the memory\n allocation and memory release operations.\n\n Note: It is recommended to move to the new activity record \\ref CUpti_ActivityMemory4\n enabled using the kind \\ref CUPTI_ACTIVITY_KIND_MEMORY2.\n \\ref CUpti_ActivityMemory4 provides separate records for memory\n allocation and memory release operations. This allows to correlate the\n corresponding driver and runtime API activity record with the memory operation."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemory {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMORY"]
    pub kind: CUpti_ActivityKind,
    #[doc = " The memory kind requested by the user"]
    pub memoryKind: CUpti_ActivityMemoryKind,
    #[doc = " The virtual address of the allocation"]
    pub address: u64,
    #[doc = " The number of bytes of memory allocated."]
    pub bytes: u64,
    #[doc = " The start timestamp for the memory operation, i.e.\n the time when memory was allocated, in ns."]
    pub start: u64,
    #[doc = " The end timestamp for the memory operation, i.e.\n the time when memory was freed, in ns.\n This will be 0 if memory is not freed in the application"]
    pub end: u64,
    #[doc = " The program counter of the allocation of memory"]
    pub allocPC: u64,
    #[doc = " The program counter of the freeing of memory. This will\n be 0 if memory is not freed in the application"]
    pub freePC: u64,
    #[doc = " The ID of the process to which this record belongs to."]
    pub processId: u32,
    #[doc = " The ID of the device where the memory allocation is taking place."]
    pub deviceId: u32,
    #[doc = " The ID of the context. If context is NULL, \\p contextId is set to CUPTI_INVALID_CONTEXT_ID."]
    pub contextId: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
    #[doc = " Variable name. This name is shared across all activity\n records representing the same symbol, and so should not be\n modified."]
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemory"][::std::mem::size_of::<CUpti_ActivityMemory>() - 80usize];
    ["Alignment of CUpti_ActivityMemory"][::std::mem::align_of::<CUpti_ActivityMemory>() - 8usize];
    ["Offset of field: CUpti_ActivityMemory::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMemory, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMemory::memoryKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemory, memoryKind) - 4usize];
    ["Offset of field: CUpti_ActivityMemory::address"]
        [::std::mem::offset_of!(CUpti_ActivityMemory, address) - 8usize];
    ["Offset of field: CUpti_ActivityMemory::bytes"]
        [::std::mem::offset_of!(CUpti_ActivityMemory, bytes) - 16usize];
    ["Offset of field: CUpti_ActivityMemory::start"]
        [::std::mem::offset_of!(CUpti_ActivityMemory, start) - 24usize];
    ["Offset of field: CUpti_ActivityMemory::end"]
        [::std::mem::offset_of!(CUpti_ActivityMemory, end) - 32usize];
    ["Offset of field: CUpti_ActivityMemory::allocPC"]
        [::std::mem::offset_of!(CUpti_ActivityMemory, allocPC) - 40usize];
    ["Offset of field: CUpti_ActivityMemory::freePC"]
        [::std::mem::offset_of!(CUpti_ActivityMemory, freePC) - 48usize];
    ["Offset of field: CUpti_ActivityMemory::processId"]
        [::std::mem::offset_of!(CUpti_ActivityMemory, processId) - 56usize];
    ["Offset of field: CUpti_ActivityMemory::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemory, deviceId) - 60usize];
    ["Offset of field: CUpti_ActivityMemory::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemory, contextId) - 64usize];
    ["Offset of field: CUpti_ActivityMemory::pad"]
        [::std::mem::offset_of!(CUpti_ActivityMemory, pad) - 68usize];
    ["Offset of field: CUpti_ActivityMemory::name"]
        [::std::mem::offset_of!(CUpti_ActivityMemory, name) - 72usize];
};
impl Default for CUpti_ActivityMemory {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for memory.\n\n This activity record represents a memory allocation and free operation\n (CUPTI_ACTIVITY_KIND_MEMORY2).\n This activity record provides separate records for memory allocation and\n memory release operations.\n This allows to correlate the corresponding driver and runtime API\n activity record with the memory operation.\n\n Note: This activity record is an upgrade over \\ref CUpti_ActivityMemory\n enabled using the kind \\ref CUPTI_ACTIVITY_KIND_MEMORY.\n \\ref CUpti_ActivityMemory provides a single record for the memory\n allocation and memory release operations."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMemory4 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMORY2"]
    pub kind: CUpti_ActivityKind,
    #[doc = " The memory operation requested by the user, \\ref CUpti_ActivityMemoryOperationType."]
    pub memoryOperationType: CUpti_ActivityMemoryOperationType,
    #[doc = " The memory kind requested by the user, \\ref CUpti_ActivityMemoryKind."]
    pub memoryKind: CUpti_ActivityMemoryKind,
    #[doc = " The correlation ID of the memory operation. Each memory operation is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver and runtime API activity record that\n launched the memory operation."]
    pub correlationId: u32,
    #[doc = " The virtual address of the allocation."]
    pub address: u64,
    #[doc = " The number of bytes of memory allocated."]
    pub bytes: u64,
    #[doc = " The start timestamp for the memory operation, in ns."]
    pub timestamp: u64,
    #[doc = " The program counter of the memory operation."]
    pub PC: u64,
    #[doc = " The ID of the process to which this record belongs to."]
    pub processId: u32,
    #[doc = " The ID of the device where the memory operation is taking place."]
    pub deviceId: u32,
    #[doc = " The ID of the context. If context is NULL, \\p contextId is set to CUPTI_INVALID_CONTEXT_ID."]
    pub contextId: u32,
    #[doc = " The ID of the stream. If memory operation is not async, \\p streamId is set to CUPTI_INVALID_STREAM_ID."]
    pub streamId: u32,
    #[doc = " Variable name. This name is shared across all activity\n records representing the same symbol, and so should not be\n modified."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " \\p isAsync is set if memory operation happens through async memory APIs."]
    pub isAsync: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad1: u32,
    pub memoryPoolConfig: CUpti_ActivityMemory4__bindgen_ty_1,
    #[doc = " The shared object or binary that the memory allocation request comes from."]
    pub source: *const ::std::os::raw::c_char,
}
#[doc = " The memory pool configuration used for the memory operations."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMemory4__bindgen_ty_1 {
    #[doc = " The type of the memory pool, \\ref CUpti_ActivityMemoryPoolType"]
    pub memoryPoolType: CUpti_ActivityMemoryPoolType,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad2: u32,
    #[doc = " The base address of the memory pool."]
    pub address: u64,
    #[doc = " The release threshold of the memory pool in bytes. \\p releaseThreshold is\n valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \\ref CUpti_ActivityMemoryPoolType."]
    pub releaseThreshold: u64,
    pub pool: CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1,
    #[doc = " The utilized size of the memory pool. \\p utilizedSize is\n valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \\ref CUpti_ActivityMemoryPoolType."]
    pub utilizedSize: u64,
}
#[doc = " The size of memory pool in bytes and the processId of the memory pools\n \\p size is valid if \\p memoryPoolType is\n CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \\ref CUpti_ActivityMemoryPoolType.\n \\p processId is valid if \\p memoryPoolType is\n CUPTI_ACTIVITY_MEMORY_POOL_TYPE_IMPORTED, \\ref CUpti_ActivityMemoryPoolType"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1 {
    pub size: u64,
    pub processId: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1::size"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1, size) - 0usize];
    ["Offset of field: CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1::processId"][::std::mem::offset_of!(
        CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1,
        processId
    ) - 0usize];
};
impl Default for CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMemory4__bindgen_ty_1__bindgen_ty_1 {{ union }}"
        )
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemory4__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityMemory4__bindgen_ty_1>() - 40usize];
    ["Alignment of CUpti_ActivityMemory4__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityMemory4__bindgen_ty_1>() - 8usize];
    ["Offset of field: CUpti_ActivityMemory4__bindgen_ty_1::memoryPoolType"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4__bindgen_ty_1, memoryPoolType) - 0usize];
    ["Offset of field: CUpti_ActivityMemory4__bindgen_ty_1::pad2"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4__bindgen_ty_1, pad2) - 4usize];
    ["Offset of field: CUpti_ActivityMemory4__bindgen_ty_1::address"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4__bindgen_ty_1, address) - 8usize];
    ["Offset of field: CUpti_ActivityMemory4__bindgen_ty_1::releaseThreshold"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4__bindgen_ty_1, releaseThreshold) - 16usize];
    ["Offset of field: CUpti_ActivityMemory4__bindgen_ty_1::pool"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4__bindgen_ty_1, pool) - 24usize];
    ["Offset of field: CUpti_ActivityMemory4__bindgen_ty_1::utilizedSize"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4__bindgen_ty_1, utilizedSize) - 32usize];
};
impl Default for CUpti_ActivityMemory4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMemory4__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMemory4__bindgen_ty_1 {{ memoryPoolType: {:?}, pool: {:?} }}",
            self.memoryPoolType, self.pool
        )
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemory4"][::std::mem::size_of::<CUpti_ActivityMemory4>() - 128usize];
    ["Alignment of CUpti_ActivityMemory4"]
        [::std::mem::align_of::<CUpti_ActivityMemory4>() - 8usize];
    ["Offset of field: CUpti_ActivityMemory4::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMemory4::memoryOperationType"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4, memoryOperationType) - 4usize];
    ["Offset of field: CUpti_ActivityMemory4::memoryKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4, memoryKind) - 8usize];
    ["Offset of field: CUpti_ActivityMemory4::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4, correlationId) - 12usize];
    ["Offset of field: CUpti_ActivityMemory4::address"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4, address) - 16usize];
    ["Offset of field: CUpti_ActivityMemory4::bytes"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4, bytes) - 24usize];
    ["Offset of field: CUpti_ActivityMemory4::timestamp"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4, timestamp) - 32usize];
    ["Offset of field: CUpti_ActivityMemory4::PC"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4, PC) - 40usize];
    ["Offset of field: CUpti_ActivityMemory4::processId"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4, processId) - 48usize];
    ["Offset of field: CUpti_ActivityMemory4::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4, deviceId) - 52usize];
    ["Offset of field: CUpti_ActivityMemory4::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4, contextId) - 56usize];
    ["Offset of field: CUpti_ActivityMemory4::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4, streamId) - 60usize];
    ["Offset of field: CUpti_ActivityMemory4::name"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4, name) - 64usize];
    ["Offset of field: CUpti_ActivityMemory4::isAsync"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4, isAsync) - 72usize];
    ["Offset of field: CUpti_ActivityMemory4::pad1"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4, pad1) - 76usize];
    ["Offset of field: CUpti_ActivityMemory4::memoryPoolConfig"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4, memoryPoolConfig) - 80usize];
    ["Offset of field: CUpti_ActivityMemory4::source"]
        [::std::mem::offset_of!(CUpti_ActivityMemory4, source) - 120usize];
};
impl Default for CUpti_ActivityMemory4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMemory4 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMemory4 {{ kind: {:?}, memoryOperationType: {:?}, memoryKind: {:?}, name: {:?}, memoryPoolConfig: {:?}, source: {:?} }}",
            self.kind,
            self.memoryOperationType,
            self.memoryKind,
            self.name,
            self.memoryPoolConfig,
            self.source
        )
    }
}
#[doc = " \\brief The activity record for memory pool.\n\n This activity record represents a memory pool creation, destruction and\n trimming (CUPTI_ACTIVITY_KIND_MEMORY_POOL).\n This activity record provides separate records for memory pool creation,\n destruction and trimming operations.\n This allows to correlate the corresponding driver and runtime API\n activity record with the memory pool operation.\n"]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemoryPool3 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMORY_POOL"]
    pub kind: CUpti_ActivityKind,
    #[doc = " The memory operation requested by the user, \\ref CUpti_ActivityMemoryPoolOperationType."]
    pub memoryPoolOperationType: CUpti_ActivityMemoryPoolOperationType,
    #[doc = " The type of the memory pool, \\ref CUpti_ActivityMemoryPoolType"]
    pub memoryPoolType: CUpti_ActivityMemoryPoolType,
    #[doc = " The correlation ID of the memory pool operation. Each memory pool\n operation is assigned a unique correlation ID that is identical to the\n correlation ID in the driver and runtime API activity record that\n launched the memory operation."]
    pub correlationId: u32,
    #[doc = " The ID of the process to which this record belongs to."]
    pub processId: u32,
    #[doc = " The ID of the device where the memory pool is created."]
    pub deviceId: u32,
    #[doc = " The minimum bytes to keep of the memory pool. \\p minBytesToKeep is\n valid for CUPTI_ACTIVITY_MEMORY_POOL_OPERATION_TYPE_TRIMMED,\n \\ref CUpti_ActivityMemoryPoolOperationType"]
    pub minBytesToKeep: usize,
    #[doc = " The virtual address of the allocation."]
    pub address: u64,
    #[doc = " The size of the memory pool operation in bytes. \\p size is\n valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \\ref CUpti_ActivityMemoryPoolType."]
    pub size: u64,
    #[doc = " The release threshold of the memory pool. \\p releaseThreshold is\n valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \\ref CUpti_ActivityMemoryPoolType."]
    pub releaseThreshold: u64,
    #[doc = " The start timestamp for the memory operation, in ns."]
    pub timestamp: u64,
    #[doc = " The utilized size of the memory pool. \\p utilizedSize is\n valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \\ref CUpti_ActivityMemoryPoolType."]
    pub utilizedSize: u64,
    #[doc = " Whether the pool is of managed memory allocation or pinned memory allocation.\n If it is 0, it is pinned and if it is 1, the memory pool allocation is of managed memory type."]
    pub isManagedPool: u8,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad2: [u8; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemoryPool3"]
        [::std::mem::size_of::<CUpti_ActivityMemoryPool3>() - 80usize];
    ["Alignment of CUpti_ActivityMemoryPool3"]
        [::std::mem::align_of::<CUpti_ActivityMemoryPool3>() - 8usize];
    ["Offset of field: CUpti_ActivityMemoryPool3::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool3, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMemoryPool3::memoryPoolOperationType"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool3, memoryPoolOperationType) - 4usize];
    ["Offset of field: CUpti_ActivityMemoryPool3::memoryPoolType"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool3, memoryPoolType) - 8usize];
    ["Offset of field: CUpti_ActivityMemoryPool3::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool3, correlationId) - 12usize];
    ["Offset of field: CUpti_ActivityMemoryPool3::processId"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool3, processId) - 16usize];
    ["Offset of field: CUpti_ActivityMemoryPool3::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool3, deviceId) - 20usize];
    ["Offset of field: CUpti_ActivityMemoryPool3::minBytesToKeep"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool3, minBytesToKeep) - 24usize];
    ["Offset of field: CUpti_ActivityMemoryPool3::address"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool3, address) - 32usize];
    ["Offset of field: CUpti_ActivityMemoryPool3::size"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool3, size) - 40usize];
    ["Offset of field: CUpti_ActivityMemoryPool3::releaseThreshold"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool3, releaseThreshold) - 48usize];
    ["Offset of field: CUpti_ActivityMemoryPool3::timestamp"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool3, timestamp) - 56usize];
    ["Offset of field: CUpti_ActivityMemoryPool3::utilizedSize"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool3, utilizedSize) - 64usize];
    ["Offset of field: CUpti_ActivityMemoryPool3::isManagedPool"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool3, isManagedPool) - 72usize];
    ["Offset of field: CUpti_ActivityMemoryPool3::pad2"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool3, pad2) - 73usize];
};
impl Default for CUpti_ActivityMemoryPool3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The kernel was launched via a regular kernel call"]
pub const CUPTI_ACTIVITY_LAUNCH_TYPE_REGULAR: CUpti_ActivityLaunchType = 0;
#[doc = " The kernel was launched via API \\ref cudaLaunchCooperativeKernel() or\n \\ref cuLaunchCooperativeKernel()"]
pub const CUPTI_ACTIVITY_LAUNCH_TYPE_COOPERATIVE_SINGLE_DEVICE: CUpti_ActivityLaunchType = 1;
#[doc = " The kernel was launched via API \\ref cudaLaunchCooperativeKernelMultiDevice() or\n \\ref cuLaunchCooperativeKernelMultiDevice()"]
pub const CUPTI_ACTIVITY_LAUNCH_TYPE_COOPERATIVE_MULTI_DEVICE: CUpti_ActivityLaunchType = 2;
#[doc = " The kernel was launched as a CBL commandlist"]
pub const CUPTI_ACTIVITY_LAUNCH_TYPE_CBL_COMMANDLIST: CUpti_ActivityLaunchType = 3;
#[doc = " \\brief The type of the CUDA kernel launch."]
pub type CUpti_ActivityLaunchType = ::std::os::raw::c_uint;
#[doc = " The shared memory limit config is default"]
pub const CUPTI_FUNC_SHMEM_LIMIT_DEFAULT: CUpti_FuncShmemLimitConfig = 0;
#[doc = " User has opted for a higher dynamic shared memory limit using function attribute\n 'cudaFuncAttributeMaxDynamicSharedMemorySize' for runtime API or\n CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES for driver API"]
pub const CUPTI_FUNC_SHMEM_LIMIT_OPTIN: CUpti_FuncShmemLimitConfig = 1;
#[doc = " User has opted for a higher dynamic shared memory limit using function attribute\n 'cudaFuncAttributeMaxDynamicSharedMemorySize' for runtime API or\n CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES for driver API"]
pub const CUPTI_FUNC_SHMEM_LIMIT_FORCE_INT: CUpti_FuncShmemLimitConfig = 2147483647;
#[doc = " \\brief The shared memory limit per block config for a kernel\n This should be used to set 'cudaOccFuncShmemConfig' field in occupancy calculator API"]
pub type CUpti_FuncShmemLimitConfig = ::std::os::raw::c_uint;
#[doc = " \\brief The activity record for kernel.\n\n This activity record represents a kernel execution\n (CUPTI_ACTIVITY_KIND_KERNEL and\n CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL)"]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityKernel10 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_KERNEL or\n CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL."]
    pub kind: CUpti_ActivityKind,
    pub cacheConfig: CUpti_ActivityKernel10__bindgen_ty_1,
    #[doc = " The shared memory configuration used for the kernel. The value is one of\n the CUsharedconfig enumeration values from cuda.h."]
    pub sharedMemoryConfig: u8,
    #[doc = " The number of registers required for each thread executing the\n kernel."]
    pub registersPerThread: u16,
    #[doc = " The partitioned global caching requested for the kernel. Partitioned\n global caching is required to enable caching on certain chips, such as\n devices with compute capability 5.2."]
    pub partitionedGlobalCacheRequested: CUpti_ActivityPartitionedGlobalCacheConfig,
    #[doc = " The partitioned global caching executed for the kernel. Partitioned\n global caching is required to enable caching on certain chips, such as\n devices with compute capability 5.2. Partitioned global caching can be\n automatically disabled if the occupancy requirement of the launch cannot\n support caching."]
    pub partitionedGlobalCacheExecuted: CUpti_ActivityPartitionedGlobalCacheConfig,
    #[doc = " The start timestamp for the kernel execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the kernel."]
    pub start: u64,
    #[doc = " The end timestamp for the kernel execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the kernel."]
    pub end: u64,
    #[doc = " The completed timestamp for the kernel execution, in ns.  It\n represents the completion of all it's child kernels and the\n kernel itself. A value of CUPTI_TIMESTAMP_UNKNOWN indicates that\n the completion time is unknown."]
    pub completed: u64,
    #[doc = " The ID of the device where the kernel is executing."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the kernel is executing."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the kernel is executing."]
    pub streamId: u32,
    #[doc = " The X-dimension grid size for the kernel."]
    pub gridX: i32,
    #[doc = " The Y-dimension grid size for the kernel."]
    pub gridY: i32,
    #[doc = " The Z-dimension grid size for the kernel."]
    pub gridZ: i32,
    #[doc = " The X-dimension block size for the kernel."]
    pub blockX: i32,
    #[doc = " The Y-dimension block size for the kernel."]
    pub blockY: i32,
    #[doc = " The Z-dimension grid size for the kernel."]
    pub blockZ: i32,
    #[doc = " The static shared memory allocated for the kernel, in bytes."]
    pub staticSharedMemory: i32,
    #[doc = " The dynamic shared memory reserved for the kernel, in bytes."]
    pub dynamicSharedMemory: i32,
    #[doc = " The amount of local memory reserved for each thread, in bytes."]
    pub localMemoryPerThread: u32,
    #[doc = " The total amount of local memory reserved for the kernel, in\n bytes (deprecated in CUDA 11.8).\n Refer field localMemoryTotal_v2"]
    pub localMemoryTotal: u32,
    #[doc = " The correlation ID of the kernel. Each kernel execution is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver or runtime API activity record that\n launched the kernel."]
    pub correlationId: u32,
    #[doc = " The grid ID of the kernel. Each kernel is assigned a unique\n grid ID at runtime."]
    pub gridId: i64,
    #[doc = " The name of the kernel. This name is shared across all activity\n records representing the same kernel, and so should not be\n modified."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
    #[doc = " The timestamp when the kernel is queued up in the command buffer, in ns.\n A value of CUPTI_TIMESTAMP_UNKNOWN indicates that the queued time\n could not be collected for the kernel. This timestamp is not collected\n by default. Use API \\ref cuptiActivityEnableLatencyTimestamps() to\n enable collection.\n\n Command buffer is a buffer written by CUDA driver to send commands\n like kernel launch, memory copy etc to the GPU. All launches of CUDA\n kernels are asynchronous with respect to the host, the host requests\n the launch by writing commands into the command buffer, then returns\n without checking the GPU's progress."]
    pub queued: u64,
    #[doc = " The timestamp when the command buffer containing the kernel launch\n is submitted to the GPU, in ns. A value of CUPTI_TIMESTAMP_UNKNOWN\n indicates that the submitted time could not be collected for the kernel.\n This timestamp is not collected by default. Use API \\ref\n cuptiActivityEnableLatencyTimestamps() to enable collection."]
    pub submitted: u64,
    #[doc = " The indicates if the kernel was executed via a regular launch or via a\n single/multi device cooperative launch. \\see CUpti_ActivityLaunchType"]
    pub launchType: u8,
    #[doc = " This indicates if CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT was\n updated for the kernel launch"]
    pub isSharedMemoryCarveoutRequested: u8,
    #[doc = " Shared memory carveout value requested for the function in percentage of\n the total resource. The value will be updated only if field\n isSharedMemoryCarveoutRequested is set."]
    pub sharedMemoryCarveoutRequested: u8,
    #[doc = " Undefined. Reserved for internal use."]
    pub padding: u8,
    #[doc = " Shared memory size set by the driver."]
    pub sharedMemoryExecuted: u32,
    #[doc = " The unique ID of the graph node that launched this kernel through graph launch APIs.\n This field will be 0 if the kernel is not launched through graph launch APIs."]
    pub graphNodeId: u64,
    #[doc = " The shared memory limit config for the kernel. This field shows whether user has opted for a\n higher per block limit of dynamic shared memory."]
    pub shmemLimitConfig: CUpti_FuncShmemLimitConfig,
    #[doc = " The unique ID of the graph that launched this kernel through graph launch APIs.\n This field will be 0 if the kernel is not launched through graph launch APIs."]
    pub graphId: u32,
    #[doc = " The pointer to the access policy window. The structure CUaccessPolicyWindow is\n defined in cuda.h."]
    pub pAccessPolicyWindow: *mut CUaccessPolicyWindow,
    #[doc = " The ID of the HW channel on which the kernel is launched."]
    pub channelID: u32,
    #[doc = " The type of the channel"]
    pub channelType: CUpti_ChannelType,
    #[doc = " The X-dimension cluster size for the kernel.\n Field is valid for devices with compute capability 9.0 and higher"]
    pub clusterX: u32,
    #[doc = " The Y-dimension cluster size for the kernel.\n Field is valid for devices with compute capability 9.0 and higher"]
    pub clusterY: u32,
    #[doc = " The Z-dimension cluster size for the kernel.\n Field is valid for devices with compute capability 9.0 and higher"]
    pub clusterZ: u32,
    #[doc = " The cluster scheduling policy for the kernel. Refer CUclusterSchedulingPolicy\n Field is valid for devices with compute capability 9.0 and higher"]
    pub clusterSchedulingPolicy: u32,
    #[doc = " The total amount of local memory reserved for the kernel, in\n bytes."]
    pub localMemoryTotal_v2: u64,
    #[doc = " The maximum cluster size for the kernel"]
    pub maxPotentialClusterSize: u32,
    #[doc = " The maximum clusters that could co-exist on the target device for the kernel"]
    pub maxActiveClusters: u32,
    #[doc = " This field is set to 1 if the kernel is part of a device launched graph."]
    pub isDeviceLaunched: u8,
    pub padding3: [u8; 7usize],
}
#[doc = " For devices with compute capability 7.5+ cacheConfig values are not updated\n in case field isSharedMemoryCarveoutRequested is set"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityKernel10__bindgen_ty_1 {
    pub both: u8,
    pub config: CUpti_ActivityKernel10__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityKernel10__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel10__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityKernel10__bindgen_ty_1__bindgen_ty_1>() - 1usize];
    ["Alignment of CUpti_ActivityKernel10__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityKernel10__bindgen_ty_1__bindgen_ty_1>() - 1usize];
};
impl CUpti_ActivityKernel10__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn requested(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_requested(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn requested_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_requested_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn executed(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_executed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn executed_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_executed_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(requested: u8, executed: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let requested: u8 = unsafe { ::std::mem::transmute(requested) };
            requested as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let executed: u8 = unsafe { ::std::mem::transmute(executed) };
            executed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel10__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityKernel10__bindgen_ty_1>() - 1usize];
    ["Alignment of CUpti_ActivityKernel10__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityKernel10__bindgen_ty_1>() - 1usize];
    ["Offset of field: CUpti_ActivityKernel10__bindgen_ty_1::both"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10__bindgen_ty_1, both) - 0usize];
    ["Offset of field: CUpti_ActivityKernel10__bindgen_ty_1::config"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10__bindgen_ty_1, config) - 0usize];
};
impl Default for CUpti_ActivityKernel10__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel10__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityKernel10__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel10"][::std::mem::size_of::<CUpti_ActivityKernel10>() - 216usize];
    ["Alignment of CUpti_ActivityKernel10"]
        [::std::mem::align_of::<CUpti_ActivityKernel10>() - 8usize];
    ["Offset of field: CUpti_ActivityKernel10::kind"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, kind) - 0usize];
    ["Offset of field: CUpti_ActivityKernel10::cacheConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, cacheConfig) - 4usize];
    ["Offset of field: CUpti_ActivityKernel10::sharedMemoryConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, sharedMemoryConfig) - 5usize];
    ["Offset of field: CUpti_ActivityKernel10::registersPerThread"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, registersPerThread) - 6usize];
    ["Offset of field: CUpti_ActivityKernel10::partitionedGlobalCacheRequested"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, partitionedGlobalCacheRequested) - 8usize];
    ["Offset of field: CUpti_ActivityKernel10::partitionedGlobalCacheExecuted"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, partitionedGlobalCacheExecuted) - 12usize];
    ["Offset of field: CUpti_ActivityKernel10::start"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, start) - 16usize];
    ["Offset of field: CUpti_ActivityKernel10::end"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, end) - 24usize];
    ["Offset of field: CUpti_ActivityKernel10::completed"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, completed) - 32usize];
    ["Offset of field: CUpti_ActivityKernel10::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, deviceId) - 40usize];
    ["Offset of field: CUpti_ActivityKernel10::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, contextId) - 44usize];
    ["Offset of field: CUpti_ActivityKernel10::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, streamId) - 48usize];
    ["Offset of field: CUpti_ActivityKernel10::gridX"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, gridX) - 52usize];
    ["Offset of field: CUpti_ActivityKernel10::gridY"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, gridY) - 56usize];
    ["Offset of field: CUpti_ActivityKernel10::gridZ"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, gridZ) - 60usize];
    ["Offset of field: CUpti_ActivityKernel10::blockX"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, blockX) - 64usize];
    ["Offset of field: CUpti_ActivityKernel10::blockY"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, blockY) - 68usize];
    ["Offset of field: CUpti_ActivityKernel10::blockZ"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, blockZ) - 72usize];
    ["Offset of field: CUpti_ActivityKernel10::staticSharedMemory"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, staticSharedMemory) - 76usize];
    ["Offset of field: CUpti_ActivityKernel10::dynamicSharedMemory"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, dynamicSharedMemory) - 80usize];
    ["Offset of field: CUpti_ActivityKernel10::localMemoryPerThread"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, localMemoryPerThread) - 84usize];
    ["Offset of field: CUpti_ActivityKernel10::localMemoryTotal"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, localMemoryTotal) - 88usize];
    ["Offset of field: CUpti_ActivityKernel10::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, correlationId) - 92usize];
    ["Offset of field: CUpti_ActivityKernel10::gridId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, gridId) - 96usize];
    ["Offset of field: CUpti_ActivityKernel10::name"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, name) - 104usize];
    ["Offset of field: CUpti_ActivityKernel10::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, reserved0) - 112usize];
    ["Offset of field: CUpti_ActivityKernel10::queued"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, queued) - 120usize];
    ["Offset of field: CUpti_ActivityKernel10::submitted"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, submitted) - 128usize];
    ["Offset of field: CUpti_ActivityKernel10::launchType"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, launchType) - 136usize];
    ["Offset of field: CUpti_ActivityKernel10::isSharedMemoryCarveoutRequested"][::std::mem::offset_of!(
        CUpti_ActivityKernel10,
        isSharedMemoryCarveoutRequested
    ) - 137usize];
    ["Offset of field: CUpti_ActivityKernel10::sharedMemoryCarveoutRequested"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, sharedMemoryCarveoutRequested) - 138usize];
    ["Offset of field: CUpti_ActivityKernel10::padding"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, padding) - 139usize];
    ["Offset of field: CUpti_ActivityKernel10::sharedMemoryExecuted"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, sharedMemoryExecuted) - 140usize];
    ["Offset of field: CUpti_ActivityKernel10::graphNodeId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, graphNodeId) - 144usize];
    ["Offset of field: CUpti_ActivityKernel10::shmemLimitConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, shmemLimitConfig) - 152usize];
    ["Offset of field: CUpti_ActivityKernel10::graphId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, graphId) - 156usize];
    ["Offset of field: CUpti_ActivityKernel10::pAccessPolicyWindow"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, pAccessPolicyWindow) - 160usize];
    ["Offset of field: CUpti_ActivityKernel10::channelID"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, channelID) - 168usize];
    ["Offset of field: CUpti_ActivityKernel10::channelType"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, channelType) - 172usize];
    ["Offset of field: CUpti_ActivityKernel10::clusterX"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, clusterX) - 176usize];
    ["Offset of field: CUpti_ActivityKernel10::clusterY"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, clusterY) - 180usize];
    ["Offset of field: CUpti_ActivityKernel10::clusterZ"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, clusterZ) - 184usize];
    ["Offset of field: CUpti_ActivityKernel10::clusterSchedulingPolicy"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, clusterSchedulingPolicy) - 188usize];
    ["Offset of field: CUpti_ActivityKernel10::localMemoryTotal_v2"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, localMemoryTotal_v2) - 192usize];
    ["Offset of field: CUpti_ActivityKernel10::maxPotentialClusterSize"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, maxPotentialClusterSize) - 200usize];
    ["Offset of field: CUpti_ActivityKernel10::maxActiveClusters"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, maxActiveClusters) - 204usize];
    ["Offset of field: CUpti_ActivityKernel10::isDeviceLaunched"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, isDeviceLaunched) - 208usize];
    ["Offset of field: CUpti_ActivityKernel10::padding3"]
        [::std::mem::offset_of!(CUpti_ActivityKernel10, padding3) - 209usize];
};
impl Default for CUpti_ActivityKernel10 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel10 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityKernel10 {{ kind: {:?}, cacheConfig: {:?}, partitionedGlobalCacheRequested: {:?}, partitionedGlobalCacheExecuted: {:?}, name: {:?}, reserved0: {:?}, shmemLimitConfig: {:?}, pAccessPolicyWindow: {:?}, channelType: {:?}, padding3: {:?} }}",
            self.kind,
            self.cacheConfig,
            self.partitionedGlobalCacheRequested,
            self.partitionedGlobalCacheExecuted,
            self.name,
            self.reserved0,
            self.shmemLimitConfig,
            self.pAccessPolicyWindow,
            self.channelType,
            self.padding3
        )
    }
}
#[doc = " \\brief The activity record for CDP (CUDA Dynamic Parallelism)\n kernel.\n\n This activity record represents a CDP kernel execution."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityCdpKernel {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_CDP_KERNEL"]
    pub kind: CUpti_ActivityKind,
    pub cacheConfig: CUpti_ActivityCdpKernel__bindgen_ty_1,
    #[doc = " The shared memory configuration used for the kernel. The value is one of\n the CUsharedconfig enumeration values from cuda.h."]
    pub sharedMemoryConfig: u8,
    #[doc = " The number of registers required for each thread executing the\n kernel."]
    pub registersPerThread: u16,
    #[doc = " The start timestamp for the kernel execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the kernel."]
    pub start: u64,
    #[doc = " The end timestamp for the kernel execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the kernel."]
    pub end: u64,
    #[doc = " The ID of the device where the kernel is executing."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the kernel is executing."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the kernel is executing."]
    pub streamId: u32,
    #[doc = " The X-dimension grid size for the kernel."]
    pub gridX: i32,
    #[doc = " The Y-dimension grid size for the kernel."]
    pub gridY: i32,
    #[doc = " The Z-dimension grid size for the kernel."]
    pub gridZ: i32,
    #[doc = " The X-dimension block size for the kernel."]
    pub blockX: i32,
    #[doc = " The Y-dimension block size for the kernel."]
    pub blockY: i32,
    #[doc = " The Z-dimension grid size for the kernel."]
    pub blockZ: i32,
    #[doc = " The static shared memory allocated for the kernel, in bytes."]
    pub staticSharedMemory: i32,
    #[doc = " The dynamic shared memory reserved for the kernel, in bytes."]
    pub dynamicSharedMemory: i32,
    #[doc = " The amount of local memory reserved for each thread, in bytes."]
    pub localMemoryPerThread: u32,
    #[doc = " The total amount of local memory reserved for the kernel, in\n bytes."]
    pub localMemoryTotal: u32,
    #[doc = " The correlation ID of the kernel. Each kernel execution is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver API activity record that launched\n the kernel."]
    pub correlationId: u32,
    #[doc = " The grid ID of the kernel. Each kernel execution\n is assigned a unique grid ID."]
    pub gridId: i64,
    #[doc = " The grid ID of the parent kernel."]
    pub parentGridId: i64,
    #[doc = " The timestamp when kernel is queued up, in ns. A value of\n CUPTI_TIMESTAMP_UNKNOWN indicates that the queued time is\n unknown."]
    pub queued: u64,
    #[doc = " The timestamp when kernel is submitted to the gpu, in ns. A value\n of CUPTI_TIMESTAMP_UNKNOWN indicates that the submission time is\n unknown."]
    pub submitted: u64,
    #[doc = " The timestamp when kernel is marked as completed, in ns. A value\n of CUPTI_TIMESTAMP_UNKNOWN indicates that the completion time is\n unknown."]
    pub completed: u64,
    #[doc = " The X-dimension of the parent block."]
    pub parentBlockX: u32,
    #[doc = " The Y-dimension of the parent block."]
    pub parentBlockY: u32,
    #[doc = " The Z-dimension of the parent block."]
    pub parentBlockZ: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
    #[doc = " The name of the kernel. This name is shared across all activity\n records representing the same kernel, and so should not be\n modified."]
    pub name: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityCdpKernel__bindgen_ty_1 {
    pub both: u8,
    pub config: CUpti_ActivityCdpKernel__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityCdpKernel__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityCdpKernel__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityCdpKernel__bindgen_ty_1__bindgen_ty_1>() - 1usize];
    ["Alignment of CUpti_ActivityCdpKernel__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityCdpKernel__bindgen_ty_1__bindgen_ty_1>() - 1usize];
};
impl CUpti_ActivityCdpKernel__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn requested(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_requested(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn requested_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_requested_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn executed(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_executed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn executed_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_executed_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(requested: u8, executed: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let requested: u8 = unsafe { ::std::mem::transmute(requested) };
            requested as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let executed: u8 = unsafe { ::std::mem::transmute(executed) };
            executed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityCdpKernel__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityCdpKernel__bindgen_ty_1>() - 1usize];
    ["Alignment of CUpti_ActivityCdpKernel__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityCdpKernel__bindgen_ty_1>() - 1usize];
    ["Offset of field: CUpti_ActivityCdpKernel__bindgen_ty_1::both"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel__bindgen_ty_1, both) - 0usize];
    ["Offset of field: CUpti_ActivityCdpKernel__bindgen_ty_1::config"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel__bindgen_ty_1, config) - 0usize];
};
impl Default for CUpti_ActivityCdpKernel__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityCdpKernel__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityCdpKernel__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityCdpKernel"]
        [::std::mem::size_of::<CUpti_ActivityCdpKernel>() - 144usize];
    ["Alignment of CUpti_ActivityCdpKernel"]
        [::std::mem::align_of::<CUpti_ActivityCdpKernel>() - 8usize];
    ["Offset of field: CUpti_ActivityCdpKernel::kind"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, kind) - 0usize];
    ["Offset of field: CUpti_ActivityCdpKernel::cacheConfig"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, cacheConfig) - 4usize];
    ["Offset of field: CUpti_ActivityCdpKernel::sharedMemoryConfig"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, sharedMemoryConfig) - 5usize];
    ["Offset of field: CUpti_ActivityCdpKernel::registersPerThread"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, registersPerThread) - 6usize];
    ["Offset of field: CUpti_ActivityCdpKernel::start"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, start) - 8usize];
    ["Offset of field: CUpti_ActivityCdpKernel::end"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, end) - 16usize];
    ["Offset of field: CUpti_ActivityCdpKernel::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, deviceId) - 24usize];
    ["Offset of field: CUpti_ActivityCdpKernel::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, contextId) - 28usize];
    ["Offset of field: CUpti_ActivityCdpKernel::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, streamId) - 32usize];
    ["Offset of field: CUpti_ActivityCdpKernel::gridX"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, gridX) - 36usize];
    ["Offset of field: CUpti_ActivityCdpKernel::gridY"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, gridY) - 40usize];
    ["Offset of field: CUpti_ActivityCdpKernel::gridZ"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, gridZ) - 44usize];
    ["Offset of field: CUpti_ActivityCdpKernel::blockX"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, blockX) - 48usize];
    ["Offset of field: CUpti_ActivityCdpKernel::blockY"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, blockY) - 52usize];
    ["Offset of field: CUpti_ActivityCdpKernel::blockZ"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, blockZ) - 56usize];
    ["Offset of field: CUpti_ActivityCdpKernel::staticSharedMemory"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, staticSharedMemory) - 60usize];
    ["Offset of field: CUpti_ActivityCdpKernel::dynamicSharedMemory"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, dynamicSharedMemory) - 64usize];
    ["Offset of field: CUpti_ActivityCdpKernel::localMemoryPerThread"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, localMemoryPerThread) - 68usize];
    ["Offset of field: CUpti_ActivityCdpKernel::localMemoryTotal"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, localMemoryTotal) - 72usize];
    ["Offset of field: CUpti_ActivityCdpKernel::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, correlationId) - 76usize];
    ["Offset of field: CUpti_ActivityCdpKernel::gridId"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, gridId) - 80usize];
    ["Offset of field: CUpti_ActivityCdpKernel::parentGridId"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, parentGridId) - 88usize];
    ["Offset of field: CUpti_ActivityCdpKernel::queued"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, queued) - 96usize];
    ["Offset of field: CUpti_ActivityCdpKernel::submitted"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, submitted) - 104usize];
    ["Offset of field: CUpti_ActivityCdpKernel::completed"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, completed) - 112usize];
    ["Offset of field: CUpti_ActivityCdpKernel::parentBlockX"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, parentBlockX) - 120usize];
    ["Offset of field: CUpti_ActivityCdpKernel::parentBlockY"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, parentBlockY) - 124usize];
    ["Offset of field: CUpti_ActivityCdpKernel::parentBlockZ"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, parentBlockZ) - 128usize];
    ["Offset of field: CUpti_ActivityCdpKernel::pad"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, pad) - 132usize];
    ["Offset of field: CUpti_ActivityCdpKernel::name"]
        [::std::mem::offset_of!(CUpti_ActivityCdpKernel, name) - 136usize];
};
impl Default for CUpti_ActivityCdpKernel {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityCdpKernel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityCdpKernel {{ kind: {:?}, cacheConfig: {:?}, name: {:?} }}",
            self.kind, self.cacheConfig, self.name
        )
    }
}
#[doc = " \\brief The activity record for a preemption of a CDP kernel.\n\n This activity record represents a preemption of a CDP kernel."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityPreemption {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_PREEMPTION"]
    pub kind: CUpti_ActivityKind,
    #[doc = " kind of the preemption"]
    pub preemptionKind: CUpti_ActivityPreemptionKind,
    #[doc = " The timestamp of the preemption, in ns. A value of 0 indicates\n that timestamp information could not be collected for the\n preemption."]
    pub timestamp: u64,
    #[doc = " The grid-id of the block that is preempted"]
    pub gridId: i64,
    #[doc = " The X-dimension of the block that is preempted"]
    pub blockX: u32,
    #[doc = " The Y-dimension of the block that is preempted"]
    pub blockY: u32,
    #[doc = " The Z-dimension of the block that is preempted"]
    pub blockZ: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityPreemption"]
        [::std::mem::size_of::<CUpti_ActivityPreemption>() - 40usize];
    ["Alignment of CUpti_ActivityPreemption"]
        [::std::mem::align_of::<CUpti_ActivityPreemption>() - 8usize];
    ["Offset of field: CUpti_ActivityPreemption::kind"]
        [::std::mem::offset_of!(CUpti_ActivityPreemption, kind) - 0usize];
    ["Offset of field: CUpti_ActivityPreemption::preemptionKind"]
        [::std::mem::offset_of!(CUpti_ActivityPreemption, preemptionKind) - 4usize];
    ["Offset of field: CUpti_ActivityPreemption::timestamp"]
        [::std::mem::offset_of!(CUpti_ActivityPreemption, timestamp) - 8usize];
    ["Offset of field: CUpti_ActivityPreemption::gridId"]
        [::std::mem::offset_of!(CUpti_ActivityPreemption, gridId) - 16usize];
    ["Offset of field: CUpti_ActivityPreemption::blockX"]
        [::std::mem::offset_of!(CUpti_ActivityPreemption, blockX) - 24usize];
    ["Offset of field: CUpti_ActivityPreemption::blockY"]
        [::std::mem::offset_of!(CUpti_ActivityPreemption, blockY) - 28usize];
    ["Offset of field: CUpti_ActivityPreemption::blockZ"]
        [::std::mem::offset_of!(CUpti_ActivityPreemption, blockZ) - 32usize];
    ["Offset of field: CUpti_ActivityPreemption::pad"]
        [::std::mem::offset_of!(CUpti_ActivityPreemption, pad) - 36usize];
};
impl Default for CUpti_ActivityPreemption {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for a driver or runtime API invocation.\n\n This activity record represents an invocation of a driver or\n runtime API (CUPTI_ACTIVITY_KIND_DRIVER and\n CUPTI_ACTIVITY_KIND_RUNTIME)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityAPI {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_DRIVER,\n CUPTI_ACTIVITY_KIND_RUNTIME, or CUPTI_ACTIVITY_KIND_INTERNAL_LAUNCH_API."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The ID of the driver or runtime function."]
    pub cbid: CUpti_CallbackId,
    #[doc = " The start timestamp for the function, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the function."]
    pub start: u64,
    #[doc = " The end timestamp for the function, in ns. A value of 0 for both\n the start and end timestamps indicates that timestamp information\n could not be collected for the function."]
    pub end: u64,
    #[doc = " The ID of the process where the driver or runtime CUDA function\n is executing."]
    pub processId: u32,
    #[doc = " The ID of the thread where the driver or runtime CUDA function is\n executing."]
    pub threadId: u32,
    #[doc = " The correlation ID of the driver or runtime CUDA function. Each\n function invocation is assigned a unique correlation ID that is\n identical to the correlation ID in the memcpy, memset, or kernel\n activity record that is associated with this function."]
    pub correlationId: u32,
    #[doc = " The return value for the function. For a CUDA driver function\n with will be a CUresult value, and for a CUDA runtime function\n this will be a cudaError_t value."]
    pub returnValue: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityAPI"][::std::mem::size_of::<CUpti_ActivityAPI>() - 40usize];
    ["Alignment of CUpti_ActivityAPI"][::std::mem::align_of::<CUpti_ActivityAPI>() - 8usize];
    ["Offset of field: CUpti_ActivityAPI::kind"]
        [::std::mem::offset_of!(CUpti_ActivityAPI, kind) - 0usize];
    ["Offset of field: CUpti_ActivityAPI::cbid"]
        [::std::mem::offset_of!(CUpti_ActivityAPI, cbid) - 4usize];
    ["Offset of field: CUpti_ActivityAPI::start"]
        [::std::mem::offset_of!(CUpti_ActivityAPI, start) - 8usize];
    ["Offset of field: CUpti_ActivityAPI::end"]
        [::std::mem::offset_of!(CUpti_ActivityAPI, end) - 16usize];
    ["Offset of field: CUpti_ActivityAPI::processId"]
        [::std::mem::offset_of!(CUpti_ActivityAPI, processId) - 24usize];
    ["Offset of field: CUpti_ActivityAPI::threadId"]
        [::std::mem::offset_of!(CUpti_ActivityAPI, threadId) - 28usize];
    ["Offset of field: CUpti_ActivityAPI::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityAPI, correlationId) - 32usize];
    ["Offset of field: CUpti_ActivityAPI::returnValue"]
        [::std::mem::offset_of!(CUpti_ActivityAPI, returnValue) - 36usize];
};
impl Default for CUpti_ActivityAPI {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for a CUPTI event.\n\n This activity record represents a CUPTI event value\n (CUPTI_ACTIVITY_KIND_EVENT). This activity record kind is not\n produced by the activity API but is included for completeness and\n ease-of-use. Profile frameworks built on top of CUPTI that collect\n event data may choose to use this type to store the collected event\n data."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityEvent {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_EVENT."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The event ID."]
    pub id: CUpti_EventID,
    #[doc = " The event value."]
    pub value: u64,
    #[doc = " The event domain ID."]
    pub domain: CUpti_EventDomainID,
    #[doc = " The correlation ID of the event. Use of this ID is user-defined,\n but typically this ID value will equal the correlation ID of the\n kernel for which the event was gathered."]
    pub correlationId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityEvent"][::std::mem::size_of::<CUpti_ActivityEvent>() - 24usize];
    ["Alignment of CUpti_ActivityEvent"][::std::mem::align_of::<CUpti_ActivityEvent>() - 8usize];
    ["Offset of field: CUpti_ActivityEvent::kind"]
        [::std::mem::offset_of!(CUpti_ActivityEvent, kind) - 0usize];
    ["Offset of field: CUpti_ActivityEvent::id"]
        [::std::mem::offset_of!(CUpti_ActivityEvent, id) - 4usize];
    ["Offset of field: CUpti_ActivityEvent::value"]
        [::std::mem::offset_of!(CUpti_ActivityEvent, value) - 8usize];
    ["Offset of field: CUpti_ActivityEvent::domain"]
        [::std::mem::offset_of!(CUpti_ActivityEvent, domain) - 16usize];
    ["Offset of field: CUpti_ActivityEvent::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityEvent, correlationId) - 20usize];
};
impl Default for CUpti_ActivityEvent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for a CUPTI event with instance\n information.\n\n This activity record represents the a CUPTI event value for a\n specific event domain instance\n (CUPTI_ACTIVITY_KIND_EVENT_INSTANCE). This activity record kind is\n not produced by the activity API but is included for completeness\n and ease-of-use. Profile frameworks built on top of CUPTI that\n collect event data may choose to use this type to store the\n collected event data. This activity record should be used when\n event domain instance information needs to be associated with the\n event."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityEventInstance {
    #[doc = " The activity record kind, must be\n CUPTI_ACTIVITY_KIND_EVENT_INSTANCE."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The event ID."]
    pub id: CUpti_EventID,
    #[doc = " The event domain ID."]
    pub domain: CUpti_EventDomainID,
    #[doc = " The event domain instance."]
    pub instance: u32,
    #[doc = " The event value."]
    pub value: u64,
    #[doc = " The correlation ID of the event. Use of this ID is user-defined,\n but typically this ID value will equal the correlation ID of the\n kernel for which the event was gathered."]
    pub correlationId: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityEventInstance"]
        [::std::mem::size_of::<CUpti_ActivityEventInstance>() - 32usize];
    ["Alignment of CUpti_ActivityEventInstance"]
        [::std::mem::align_of::<CUpti_ActivityEventInstance>() - 8usize];
    ["Offset of field: CUpti_ActivityEventInstance::kind"]
        [::std::mem::offset_of!(CUpti_ActivityEventInstance, kind) - 0usize];
    ["Offset of field: CUpti_ActivityEventInstance::id"]
        [::std::mem::offset_of!(CUpti_ActivityEventInstance, id) - 4usize];
    ["Offset of field: CUpti_ActivityEventInstance::domain"]
        [::std::mem::offset_of!(CUpti_ActivityEventInstance, domain) - 8usize];
    ["Offset of field: CUpti_ActivityEventInstance::instance"]
        [::std::mem::offset_of!(CUpti_ActivityEventInstance, instance) - 12usize];
    ["Offset of field: CUpti_ActivityEventInstance::value"]
        [::std::mem::offset_of!(CUpti_ActivityEventInstance, value) - 16usize];
    ["Offset of field: CUpti_ActivityEventInstance::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityEventInstance, correlationId) - 24usize];
    ["Offset of field: CUpti_ActivityEventInstance::pad"]
        [::std::mem::offset_of!(CUpti_ActivityEventInstance, pad) - 28usize];
};
impl Default for CUpti_ActivityEventInstance {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for a CUPTI metric.\n\n This activity record represents the collection of a CUPTI metric\n value (CUPTI_ACTIVITY_KIND_METRIC). This activity record kind is not\n produced by the activity API but is included for completeness and\n ease-of-use. Profile frameworks built on top of CUPTI that collect\n metric data may choose to use this type to store the collected metric\n data."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMetric {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_METRIC."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The metric ID."]
    pub id: CUpti_MetricID,
    #[doc = " The metric value."]
    pub value: CUpti_MetricValue,
    #[doc = " The correlation ID of the metric. Use of this ID is user-defined,\n but typically this ID value will equal the correlation ID of the\n kernel for which the metric was gathered."]
    pub correlationId: u32,
    #[doc = " The properties of this metric. \\see CUpti_ActivityFlag"]
    pub flags: u8,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMetric"][::std::mem::size_of::<CUpti_ActivityMetric>() - 24usize];
    ["Alignment of CUpti_ActivityMetric"][::std::mem::align_of::<CUpti_ActivityMetric>() - 8usize];
    ["Offset of field: CUpti_ActivityMetric::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMetric, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMetric::id"]
        [::std::mem::offset_of!(CUpti_ActivityMetric, id) - 4usize];
    ["Offset of field: CUpti_ActivityMetric::value"]
        [::std::mem::offset_of!(CUpti_ActivityMetric, value) - 8usize];
    ["Offset of field: CUpti_ActivityMetric::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityMetric, correlationId) - 16usize];
    ["Offset of field: CUpti_ActivityMetric::flags"]
        [::std::mem::offset_of!(CUpti_ActivityMetric, flags) - 20usize];
    ["Offset of field: CUpti_ActivityMetric::pad"]
        [::std::mem::offset_of!(CUpti_ActivityMetric, pad) - 21usize];
};
impl Default for CUpti_ActivityMetric {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMetric {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMetric {{ kind: {:?}, value: {:?}, pad: {:?} }}",
            self.kind, self.value, self.pad
        )
    }
}
#[doc = " \\brief The activity record for a CUPTI metric with instance\n information.\n\n This activity record represents a CUPTI metric value\n for a specific metric domain instance\n (CUPTI_ACTIVITY_KIND_METRIC_INSTANCE).  This activity record kind\n is not produced by the activity API but is included for\n completeness and ease-of-use. Profile frameworks built on top of\n CUPTI that collect metric data may choose to use this type to store\n the collected metric data. This activity record should be used when\n metric domain instance information needs to be associated with the\n metric."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMetricInstance {
    #[doc = " The activity record kind, must be\n CUPTI_ACTIVITY_KIND_METRIC_INSTANCE."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The metric ID."]
    pub id: CUpti_MetricID,
    #[doc = " The metric value."]
    pub value: CUpti_MetricValue,
    #[doc = " The metric domain instance."]
    pub instance: u32,
    #[doc = " The correlation ID of the metric. Use of this ID is user-defined,\n but typically this ID value will equal the correlation ID of the\n kernel for which the metric was gathered."]
    pub correlationId: u32,
    #[doc = " The properties of this metric. \\see CUpti_ActivityFlag"]
    pub flags: u8,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: [u8; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMetricInstance"]
        [::std::mem::size_of::<CUpti_ActivityMetricInstance>() - 32usize];
    ["Alignment of CUpti_ActivityMetricInstance"]
        [::std::mem::align_of::<CUpti_ActivityMetricInstance>() - 8usize];
    ["Offset of field: CUpti_ActivityMetricInstance::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMetricInstance, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMetricInstance::id"]
        [::std::mem::offset_of!(CUpti_ActivityMetricInstance, id) - 4usize];
    ["Offset of field: CUpti_ActivityMetricInstance::value"]
        [::std::mem::offset_of!(CUpti_ActivityMetricInstance, value) - 8usize];
    ["Offset of field: CUpti_ActivityMetricInstance::instance"]
        [::std::mem::offset_of!(CUpti_ActivityMetricInstance, instance) - 16usize];
    ["Offset of field: CUpti_ActivityMetricInstance::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityMetricInstance, correlationId) - 20usize];
    ["Offset of field: CUpti_ActivityMetricInstance::flags"]
        [::std::mem::offset_of!(CUpti_ActivityMetricInstance, flags) - 24usize];
    ["Offset of field: CUpti_ActivityMetricInstance::pad"]
        [::std::mem::offset_of!(CUpti_ActivityMetricInstance, pad) - 25usize];
};
impl Default for CUpti_ActivityMetricInstance {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMetricInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMetricInstance {{ kind: {:?}, value: {:?}, pad: {:?} }}",
            self.kind, self.value, self.pad
        )
    }
}
#[doc = " \\brief The activity record for source locator.\n\n This activity record represents a source locator\n (CUPTI_ACTIVITY_KIND_SOURCE_LOCATOR)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivitySourceLocator {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_SOURCE_LOCATOR."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The ID for the source path, will be used in all the source level\n results."]
    pub id: u32,
    #[doc = " The line number in the source ."]
    pub lineNumber: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
    #[doc = " The path for the file."]
    pub fileName: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivitySourceLocator"]
        [::std::mem::size_of::<CUpti_ActivitySourceLocator>() - 24usize];
    ["Alignment of CUpti_ActivitySourceLocator"]
        [::std::mem::align_of::<CUpti_ActivitySourceLocator>() - 8usize];
    ["Offset of field: CUpti_ActivitySourceLocator::kind"]
        [::std::mem::offset_of!(CUpti_ActivitySourceLocator, kind) - 0usize];
    ["Offset of field: CUpti_ActivitySourceLocator::id"]
        [::std::mem::offset_of!(CUpti_ActivitySourceLocator, id) - 4usize];
    ["Offset of field: CUpti_ActivitySourceLocator::lineNumber"]
        [::std::mem::offset_of!(CUpti_ActivitySourceLocator, lineNumber) - 8usize];
    ["Offset of field: CUpti_ActivitySourceLocator::pad"]
        [::std::mem::offset_of!(CUpti_ActivitySourceLocator, pad) - 12usize];
    ["Offset of field: CUpti_ActivitySourceLocator::fileName"]
        [::std::mem::offset_of!(CUpti_ActivitySourceLocator, fileName) - 16usize];
};
impl Default for CUpti_ActivitySourceLocator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for source-level global\n access.\n\n This activity records the locations of the global\n accesses in the source (CUPTI_ACTIVITY_KIND_GLOBAL_ACCESS)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityGlobalAccess3 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_GLOBAL_ACCESS."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The properties of this global access."]
    pub flags: CUpti_ActivityFlag,
    #[doc = " The ID for source locator."]
    pub sourceLocatorId: u32,
    #[doc = " The correlation ID of the kernel to which this result is associated."]
    pub correlationId: u32,
    #[doc = " Correlation ID with global/device function name"]
    pub functionId: u32,
    #[doc = " The number of times this instruction was executed per warp. It will be incremented\n when at least one of thread among warp is active with predicate and condition code\n evaluating to true."]
    pub executed: u32,
    #[doc = " The pc offset for the access."]
    pub pcOffset: u64,
    #[doc = " This increments each time when this instruction is executed by number of\n threads that executed this instruction with predicate and condition code\n evaluating to true."]
    pub threadsExecuted: u64,
    #[doc = " The total number of 32 bytes transactions to L2 cache generated by this\naccess"]
    pub l2_transactions: u64,
    #[doc = " The minimum number of L2 transactions possible based on the access pattern."]
    pub theoreticalL2Transactions: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityGlobalAccess3"]
        [::std::mem::size_of::<CUpti_ActivityGlobalAccess3>() - 56usize];
    ["Alignment of CUpti_ActivityGlobalAccess3"]
        [::std::mem::align_of::<CUpti_ActivityGlobalAccess3>() - 8usize];
    ["Offset of field: CUpti_ActivityGlobalAccess3::kind"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess3, kind) - 0usize];
    ["Offset of field: CUpti_ActivityGlobalAccess3::flags"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess3, flags) - 4usize];
    ["Offset of field: CUpti_ActivityGlobalAccess3::sourceLocatorId"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess3, sourceLocatorId) - 8usize];
    ["Offset of field: CUpti_ActivityGlobalAccess3::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess3, correlationId) - 12usize];
    ["Offset of field: CUpti_ActivityGlobalAccess3::functionId"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess3, functionId) - 16usize];
    ["Offset of field: CUpti_ActivityGlobalAccess3::executed"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess3, executed) - 20usize];
    ["Offset of field: CUpti_ActivityGlobalAccess3::pcOffset"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess3, pcOffset) - 24usize];
    ["Offset of field: CUpti_ActivityGlobalAccess3::threadsExecuted"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess3, threadsExecuted) - 32usize];
    ["Offset of field: CUpti_ActivityGlobalAccess3::l2_transactions"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess3, l2_transactions) - 40usize];
    ["Offset of field: CUpti_ActivityGlobalAccess3::theoreticalL2Transactions"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess3, theoreticalL2Transactions) - 48usize];
};
impl Default for CUpti_ActivityGlobalAccess3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for source level result\n branch.\n\n This activity record the locations of the branches in the\n source (CUPTI_ACTIVITY_KIND_BRANCH)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityBranch2 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_BRANCH."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The ID for source locator."]
    pub sourceLocatorId: u32,
    #[doc = " The correlation ID of the kernel to which this result is associated."]
    pub correlationId: u32,
    #[doc = " Correlation ID with global/device function name"]
    pub functionId: u32,
    #[doc = " The pc offset for the branch."]
    pub pcOffset: u32,
    #[doc = " Number of times this branch diverged"]
    pub diverged: u32,
    #[doc = " This increments each time when this instruction is executed by number\n of threads that executed this instruction"]
    pub threadsExecuted: u64,
    #[doc = " The number of times this instruction was executed per warp. It will be incremented\n regardless of predicate or condition code."]
    pub executed: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityBranch2"][::std::mem::size_of::<CUpti_ActivityBranch2>() - 40usize];
    ["Alignment of CUpti_ActivityBranch2"]
        [::std::mem::align_of::<CUpti_ActivityBranch2>() - 8usize];
    ["Offset of field: CUpti_ActivityBranch2::kind"]
        [::std::mem::offset_of!(CUpti_ActivityBranch2, kind) - 0usize];
    ["Offset of field: CUpti_ActivityBranch2::sourceLocatorId"]
        [::std::mem::offset_of!(CUpti_ActivityBranch2, sourceLocatorId) - 4usize];
    ["Offset of field: CUpti_ActivityBranch2::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityBranch2, correlationId) - 8usize];
    ["Offset of field: CUpti_ActivityBranch2::functionId"]
        [::std::mem::offset_of!(CUpti_ActivityBranch2, functionId) - 12usize];
    ["Offset of field: CUpti_ActivityBranch2::pcOffset"]
        [::std::mem::offset_of!(CUpti_ActivityBranch2, pcOffset) - 16usize];
    ["Offset of field: CUpti_ActivityBranch2::diverged"]
        [::std::mem::offset_of!(CUpti_ActivityBranch2, diverged) - 20usize];
    ["Offset of field: CUpti_ActivityBranch2::threadsExecuted"]
        [::std::mem::offset_of!(CUpti_ActivityBranch2, threadsExecuted) - 24usize];
    ["Offset of field: CUpti_ActivityBranch2::executed"]
        [::std::mem::offset_of!(CUpti_ActivityBranch2, executed) - 32usize];
    ["Offset of field: CUpti_ActivityBranch2::pad"]
        [::std::mem::offset_of!(CUpti_ActivityBranch2, pad) - 36usize];
};
impl Default for CUpti_ActivityBranch2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for a device. (CUDA 11.6 onwards)\n\n This activity record represents information about a GPU device\n (CUPTI_ACTIVITY_KIND_DEVICE)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityDevice5 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_DEVICE."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The flags associated with the device. \\see CUpti_ActivityFlag"]
    pub flags: CUpti_ActivityFlag,
    #[doc = " The global memory bandwidth available on the device, in\n kBytes/sec."]
    pub globalMemoryBandwidth: u64,
    #[doc = " The amount of global memory on the device, in bytes."]
    pub globalMemorySize: u64,
    #[doc = " The amount of constant memory on the device, in bytes."]
    pub constantMemorySize: u32,
    #[doc = " The size of the L2 cache on the device, in bytes."]
    pub l2CacheSize: u32,
    #[doc = " The number of threads per warp on the device."]
    pub numThreadsPerWarp: u32,
    #[doc = " The core clock rate of the device, in kHz."]
    pub coreClockRate: u32,
    #[doc = " Number of memory copy engines on the device."]
    pub numMemcpyEngines: u32,
    #[doc = " Number of multiprocessors on the device."]
    pub numMultiprocessors: u32,
    #[doc = " The maximum \"instructions per cycle\" possible on each device\n multiprocessor."]
    pub maxIPC: u32,
    #[doc = " Maximum number of warps that can be present on a multiprocessor\n at any given time."]
    pub maxWarpsPerMultiprocessor: u32,
    #[doc = " Maximum number of blocks that can be present on a multiprocessor\n at any given time."]
    pub maxBlocksPerMultiprocessor: u32,
    #[doc = " Maximum amount of shared memory available per multiprocessor, in bytes."]
    pub maxSharedMemoryPerMultiprocessor: u32,
    #[doc = " Maximum number of 32-bit registers available per multiprocessor."]
    pub maxRegistersPerMultiprocessor: u32,
    #[doc = " Maximum number of registers that can be allocated to a block."]
    pub maxRegistersPerBlock: u32,
    #[doc = " Maximum amount of shared memory that can be assigned to a block,\n in bytes."]
    pub maxSharedMemoryPerBlock: u32,
    #[doc = " Maximum number of threads allowed in a block."]
    pub maxThreadsPerBlock: u32,
    #[doc = " Maximum allowed X dimension for a block."]
    pub maxBlockDimX: u32,
    #[doc = " Maximum allowed Y dimension for a block."]
    pub maxBlockDimY: u32,
    #[doc = " Maximum allowed Z dimension for a block."]
    pub maxBlockDimZ: u32,
    #[doc = " Maximum allowed X dimension for a grid."]
    pub maxGridDimX: u32,
    #[doc = " Maximum allowed Y dimension for a grid."]
    pub maxGridDimY: u32,
    #[doc = " Maximum allowed Z dimension for a grid."]
    pub maxGridDimZ: u32,
    #[doc = " Compute capability for the device, major number."]
    pub computeCapabilityMajor: u32,
    #[doc = " Compute capability for the device, minor number."]
    pub computeCapabilityMinor: u32,
    #[doc = " The device ID."]
    pub id: u32,
    #[doc = " ECC enabled flag for device"]
    pub eccEnabled: u32,
    #[doc = " The device UUID. This value is the globally unique immutable\n alphanumeric identifier of the device."]
    pub uuid: CUuuid,
    #[doc = " The device name. Client is responsible for freeing this memory using the free function when done."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Flag to indicate whether the device is visible to CUDA. Users can\n set the device visibility using CUDA_VISIBLE_DEVICES environment"]
    pub isCudaVisible: u8,
    #[doc = " MIG enabled flag for device"]
    pub isMigEnabled: u8,
    pub reserved: [u8; 6usize],
    #[doc = " GPU Instance id for MIG enabled devices.\n If mig mode is disabled value is set to UINT32_MAX"]
    pub gpuInstanceId: u32,
    #[doc = " Compute Instance id for MIG enabled devices.\n If mig mode is disabled value is set to UINT32_MAX"]
    pub computeInstanceId: u32,
    #[doc = " The MIG UUID. This value is the globally unique immutable\n alphanumeric identifier of the device."]
    pub migUuid: CUuuid,
    #[doc = " Numa (Non-uniform memory access) information for device\n GPU is a NUMA node or not"]
    pub isNumaNode: u32,
    #[doc = " Numa (Non-uniform memory access) information for device\n NUMA node ID of the GPU memory\n if GPU is not a NUMA node, it returns invalidNumaId"]
    pub numaId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityDevice5"][::std::mem::size_of::<CUpti_ActivityDevice5>() - 184usize];
    ["Alignment of CUpti_ActivityDevice5"]
        [::std::mem::align_of::<CUpti_ActivityDevice5>() - 8usize];
    ["Offset of field: CUpti_ActivityDevice5::kind"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, kind) - 0usize];
    ["Offset of field: CUpti_ActivityDevice5::flags"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, flags) - 4usize];
    ["Offset of field: CUpti_ActivityDevice5::globalMemoryBandwidth"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, globalMemoryBandwidth) - 8usize];
    ["Offset of field: CUpti_ActivityDevice5::globalMemorySize"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, globalMemorySize) - 16usize];
    ["Offset of field: CUpti_ActivityDevice5::constantMemorySize"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, constantMemorySize) - 24usize];
    ["Offset of field: CUpti_ActivityDevice5::l2CacheSize"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, l2CacheSize) - 28usize];
    ["Offset of field: CUpti_ActivityDevice5::numThreadsPerWarp"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, numThreadsPerWarp) - 32usize];
    ["Offset of field: CUpti_ActivityDevice5::coreClockRate"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, coreClockRate) - 36usize];
    ["Offset of field: CUpti_ActivityDevice5::numMemcpyEngines"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, numMemcpyEngines) - 40usize];
    ["Offset of field: CUpti_ActivityDevice5::numMultiprocessors"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, numMultiprocessors) - 44usize];
    ["Offset of field: CUpti_ActivityDevice5::maxIPC"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, maxIPC) - 48usize];
    ["Offset of field: CUpti_ActivityDevice5::maxWarpsPerMultiprocessor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, maxWarpsPerMultiprocessor) - 52usize];
    ["Offset of field: CUpti_ActivityDevice5::maxBlocksPerMultiprocessor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, maxBlocksPerMultiprocessor) - 56usize];
    ["Offset of field: CUpti_ActivityDevice5::maxSharedMemoryPerMultiprocessor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, maxSharedMemoryPerMultiprocessor) - 60usize];
    ["Offset of field: CUpti_ActivityDevice5::maxRegistersPerMultiprocessor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, maxRegistersPerMultiprocessor) - 64usize];
    ["Offset of field: CUpti_ActivityDevice5::maxRegistersPerBlock"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, maxRegistersPerBlock) - 68usize];
    ["Offset of field: CUpti_ActivityDevice5::maxSharedMemoryPerBlock"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, maxSharedMemoryPerBlock) - 72usize];
    ["Offset of field: CUpti_ActivityDevice5::maxThreadsPerBlock"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, maxThreadsPerBlock) - 76usize];
    ["Offset of field: CUpti_ActivityDevice5::maxBlockDimX"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, maxBlockDimX) - 80usize];
    ["Offset of field: CUpti_ActivityDevice5::maxBlockDimY"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, maxBlockDimY) - 84usize];
    ["Offset of field: CUpti_ActivityDevice5::maxBlockDimZ"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, maxBlockDimZ) - 88usize];
    ["Offset of field: CUpti_ActivityDevice5::maxGridDimX"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, maxGridDimX) - 92usize];
    ["Offset of field: CUpti_ActivityDevice5::maxGridDimY"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, maxGridDimY) - 96usize];
    ["Offset of field: CUpti_ActivityDevice5::maxGridDimZ"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, maxGridDimZ) - 100usize];
    ["Offset of field: CUpti_ActivityDevice5::computeCapabilityMajor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, computeCapabilityMajor) - 104usize];
    ["Offset of field: CUpti_ActivityDevice5::computeCapabilityMinor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, computeCapabilityMinor) - 108usize];
    ["Offset of field: CUpti_ActivityDevice5::id"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, id) - 112usize];
    ["Offset of field: CUpti_ActivityDevice5::eccEnabled"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, eccEnabled) - 116usize];
    ["Offset of field: CUpti_ActivityDevice5::uuid"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, uuid) - 120usize];
    ["Offset of field: CUpti_ActivityDevice5::name"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, name) - 136usize];
    ["Offset of field: CUpti_ActivityDevice5::isCudaVisible"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, isCudaVisible) - 144usize];
    ["Offset of field: CUpti_ActivityDevice5::isMigEnabled"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, isMigEnabled) - 145usize];
    ["Offset of field: CUpti_ActivityDevice5::reserved"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, reserved) - 146usize];
    ["Offset of field: CUpti_ActivityDevice5::gpuInstanceId"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, gpuInstanceId) - 152usize];
    ["Offset of field: CUpti_ActivityDevice5::computeInstanceId"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, computeInstanceId) - 156usize];
    ["Offset of field: CUpti_ActivityDevice5::migUuid"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, migUuid) - 160usize];
    ["Offset of field: CUpti_ActivityDevice5::isNumaNode"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, isNumaNode) - 176usize];
    ["Offset of field: CUpti_ActivityDevice5::numaId"]
        [::std::mem::offset_of!(CUpti_ActivityDevice5, numaId) - 180usize];
};
impl Default for CUpti_ActivityDevice5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for a device attribute.\n\n This activity record represents information about a GPU device:\n either a CUpti_DeviceAttribute or CUdevice_attribute value\n (CUPTI_ACTIVITY_KIND_DEVICE_ATTRIBUTE)."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityDeviceAttribute {
    #[doc = " The activity record kind, must be\n CUPTI_ACTIVITY_KIND_DEVICE_ATTRIBUTE."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The flags associated with the device. \\see CUpti_ActivityFlag"]
    pub flags: CUpti_ActivityFlag,
    #[doc = " The ID of the device that this attribute applies to."]
    pub deviceId: u32,
    pub attribute: CUpti_ActivityDeviceAttribute__bindgen_ty_1,
    pub value: CUpti_ActivityDeviceAttribute__bindgen_ty_2,
}
#[doc = " The attribute, either a CUpti_DeviceAttribute or\n CUdevice_attribute. Flag\n CUPTI_ACTIVITY_FLAG_DEVICE_ATTRIBUTE_CUDEVICE is used to indicate\n what kind of attribute this is. If\n CUPTI_ACTIVITY_FLAG_DEVICE_ATTRIBUTE_CUDEVICE is 1 then\n CUdevice_attribute field is value, otherwise\n CUpti_DeviceAttribute field is valid."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityDeviceAttribute__bindgen_ty_1 {
    pub cu: CUdevice_attribute,
    pub cupti: CUpti_DeviceAttribute,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityDeviceAttribute__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityDeviceAttribute__bindgen_ty_1>() - 4usize];
    ["Alignment of CUpti_ActivityDeviceAttribute__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityDeviceAttribute__bindgen_ty_1>() - 4usize];
    ["Offset of field: CUpti_ActivityDeviceAttribute__bindgen_ty_1::cu"]
        [::std::mem::offset_of!(CUpti_ActivityDeviceAttribute__bindgen_ty_1, cu) - 0usize];
    ["Offset of field: CUpti_ActivityDeviceAttribute__bindgen_ty_1::cupti"]
        [::std::mem::offset_of!(CUpti_ActivityDeviceAttribute__bindgen_ty_1, cupti) - 0usize];
};
impl Default for CUpti_ActivityDeviceAttribute__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityDeviceAttribute__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityDeviceAttribute__bindgen_ty_1 {{ union }}")
    }
}
#[doc = " The value for the attribute. See CUpti_DeviceAttribute and\n CUdevice_attribute for the type of the value for a given\n attribute."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityDeviceAttribute__bindgen_ty_2 {
    pub vDouble: f64,
    pub vUint32: u32,
    pub vUint64: u64,
    pub vInt32: i32,
    pub vInt64: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityDeviceAttribute__bindgen_ty_2"]
        [::std::mem::size_of::<CUpti_ActivityDeviceAttribute__bindgen_ty_2>() - 8usize];
    ["Alignment of CUpti_ActivityDeviceAttribute__bindgen_ty_2"]
        [::std::mem::align_of::<CUpti_ActivityDeviceAttribute__bindgen_ty_2>() - 8usize];
    ["Offset of field: CUpti_ActivityDeviceAttribute__bindgen_ty_2::vDouble"]
        [::std::mem::offset_of!(CUpti_ActivityDeviceAttribute__bindgen_ty_2, vDouble) - 0usize];
    ["Offset of field: CUpti_ActivityDeviceAttribute__bindgen_ty_2::vUint32"]
        [::std::mem::offset_of!(CUpti_ActivityDeviceAttribute__bindgen_ty_2, vUint32) - 0usize];
    ["Offset of field: CUpti_ActivityDeviceAttribute__bindgen_ty_2::vUint64"]
        [::std::mem::offset_of!(CUpti_ActivityDeviceAttribute__bindgen_ty_2, vUint64) - 0usize];
    ["Offset of field: CUpti_ActivityDeviceAttribute__bindgen_ty_2::vInt32"]
        [::std::mem::offset_of!(CUpti_ActivityDeviceAttribute__bindgen_ty_2, vInt32) - 0usize];
    ["Offset of field: CUpti_ActivityDeviceAttribute__bindgen_ty_2::vInt64"]
        [::std::mem::offset_of!(CUpti_ActivityDeviceAttribute__bindgen_ty_2, vInt64) - 0usize];
};
impl Default for CUpti_ActivityDeviceAttribute__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityDeviceAttribute__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityDeviceAttribute__bindgen_ty_2 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityDeviceAttribute"]
        [::std::mem::size_of::<CUpti_ActivityDeviceAttribute>() - 24usize];
    ["Alignment of CUpti_ActivityDeviceAttribute"]
        [::std::mem::align_of::<CUpti_ActivityDeviceAttribute>() - 8usize];
    ["Offset of field: CUpti_ActivityDeviceAttribute::kind"]
        [::std::mem::offset_of!(CUpti_ActivityDeviceAttribute, kind) - 0usize];
    ["Offset of field: CUpti_ActivityDeviceAttribute::flags"]
        [::std::mem::offset_of!(CUpti_ActivityDeviceAttribute, flags) - 4usize];
    ["Offset of field: CUpti_ActivityDeviceAttribute::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityDeviceAttribute, deviceId) - 8usize];
    ["Offset of field: CUpti_ActivityDeviceAttribute::attribute"]
        [::std::mem::offset_of!(CUpti_ActivityDeviceAttribute, attribute) - 12usize];
    ["Offset of field: CUpti_ActivityDeviceAttribute::value"]
        [::std::mem::offset_of!(CUpti_ActivityDeviceAttribute, value) - 16usize];
};
impl Default for CUpti_ActivityDeviceAttribute {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityDeviceAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityDeviceAttribute {{ kind: {:?}, flags: {:?}, attribute: {:?}, value: {:?} }}",
            self.kind, self.flags, self.attribute, self.value
        )
    }
}
#[doc = " \\brief The activity record for a context.\n\n This activity record represents information about a context\n (CUPTI_ACTIVITY_KIND_CONTEXT)."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityContext3 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_CONTEXT."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The context ID."]
    pub contextId: u32,
    #[doc = " The device ID."]
    pub deviceId: u32,
    #[doc = " The compute API kind. \\see CUpti_ActivityComputeApiKind"]
    pub computeApiKind: u16,
    #[doc = " The ID for the NULL stream in this context"]
    pub nullStreamId: u16,
    #[doc = " The ID of the parent context. It would be 0 if\n context does not have parent"]
    pub parentContextId: u32,
    #[doc = " This field indicates whether the context is a green context"]
    pub isGreenContext: u8,
    pub padding: u8,
    #[doc = " Number of multiprocessors assigned to the green context\n Invalid if the field 'isGreenContext' is 0"]
    pub numMultiprocessors: u16,
    #[doc = " This field indicates the CIG mode"]
    pub cigMode: CUpti_ContextCigMode,
    pub padding2: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityContext3"][::std::mem::size_of::<CUpti_ActivityContext3>() - 32usize];
    ["Alignment of CUpti_ActivityContext3"]
        [::std::mem::align_of::<CUpti_ActivityContext3>() - 8usize];
    ["Offset of field: CUpti_ActivityContext3::kind"]
        [::std::mem::offset_of!(CUpti_ActivityContext3, kind) - 0usize];
    ["Offset of field: CUpti_ActivityContext3::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityContext3, contextId) - 4usize];
    ["Offset of field: CUpti_ActivityContext3::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityContext3, deviceId) - 8usize];
    ["Offset of field: CUpti_ActivityContext3::computeApiKind"]
        [::std::mem::offset_of!(CUpti_ActivityContext3, computeApiKind) - 12usize];
    ["Offset of field: CUpti_ActivityContext3::nullStreamId"]
        [::std::mem::offset_of!(CUpti_ActivityContext3, nullStreamId) - 14usize];
    ["Offset of field: CUpti_ActivityContext3::parentContextId"]
        [::std::mem::offset_of!(CUpti_ActivityContext3, parentContextId) - 16usize];
    ["Offset of field: CUpti_ActivityContext3::isGreenContext"]
        [::std::mem::offset_of!(CUpti_ActivityContext3, isGreenContext) - 20usize];
    ["Offset of field: CUpti_ActivityContext3::padding"]
        [::std::mem::offset_of!(CUpti_ActivityContext3, padding) - 21usize];
    ["Offset of field: CUpti_ActivityContext3::numMultiprocessors"]
        [::std::mem::offset_of!(CUpti_ActivityContext3, numMultiprocessors) - 22usize];
    ["Offset of field: CUpti_ActivityContext3::cigMode"]
        [::std::mem::offset_of!(CUpti_ActivityContext3, cigMode) - 24usize];
    ["Offset of field: CUpti_ActivityContext3::padding2"]
        [::std::mem::offset_of!(CUpti_ActivityContext3, padding2) - 28usize];
};
impl Default for CUpti_ActivityContext3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record providing a name.\n\n This activity record provides a name for a device, context, thread,\n etc. and other resource naming done via NVTX APIs\n (CUPTI_ACTIVITY_KIND_NAME)."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityName {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_NAME."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The kind of activity object being named."]
    pub objectKind: CUpti_ActivityObjectKind,
    #[doc = " The identifier for the activity object. 'objectKind' indicates\n which ID is valid for this record."]
    pub objectId: CUpti_ActivityObjectKindId,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
    #[doc = " The name."]
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityName"][::std::mem::size_of::<CUpti_ActivityName>() - 32usize];
    ["Alignment of CUpti_ActivityName"][::std::mem::align_of::<CUpti_ActivityName>() - 8usize];
    ["Offset of field: CUpti_ActivityName::kind"]
        [::std::mem::offset_of!(CUpti_ActivityName, kind) - 0usize];
    ["Offset of field: CUpti_ActivityName::objectKind"]
        [::std::mem::offset_of!(CUpti_ActivityName, objectKind) - 4usize];
    ["Offset of field: CUpti_ActivityName::objectId"]
        [::std::mem::offset_of!(CUpti_ActivityName, objectId) - 8usize];
    ["Offset of field: CUpti_ActivityName::pad"]
        [::std::mem::offset_of!(CUpti_ActivityName, pad) - 20usize];
    ["Offset of field: CUpti_ActivityName::name"]
        [::std::mem::offset_of!(CUpti_ActivityName, name) - 24usize];
};
impl Default for CUpti_ActivityName {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityName {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityName {{ kind: {:?}, objectKind: {:?}, objectId: {:?}, name: {:?} }}",
            self.kind, self.objectKind, self.objectId, self.name
        )
    }
}
#[doc = " \\brief The activity record providing a marker which is an\n instantaneous point in time.\n\n The marker is specified with a descriptive name and unique id\n (CUPTI_ACTIVITY_KIND_MARKER)."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMarker2 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MARKER."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The flags associated with the marker. \\see CUpti_ActivityFlag"]
    pub flags: CUpti_ActivityFlag,
    #[doc = " The timestamp for the marker, in ns. A value of 0 indicates that\n timestamp information could not be collected for the marker."]
    pub timestamp: u64,
    #[doc = " The marker ID."]
    pub id: u32,
    #[doc = " The kind of activity object associated with this marker."]
    pub objectKind: CUpti_ActivityObjectKind,
    #[doc = " The identifier for the activity object associated with this\n marker. 'objectKind' indicates which ID is valid for this record."]
    pub objectId: CUpti_ActivityObjectKindId,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
    #[doc = " The marker name for an instantaneous or start marker. This will\n be NULL for an end marker."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " The name of the domain to which this marker belongs to.\n This will be NULL for default domain."]
    pub domain: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMarker2"][::std::mem::size_of::<CUpti_ActivityMarker2>() - 56usize];
    ["Alignment of CUpti_ActivityMarker2"]
        [::std::mem::align_of::<CUpti_ActivityMarker2>() - 8usize];
    ["Offset of field: CUpti_ActivityMarker2::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMarker2, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMarker2::flags"]
        [::std::mem::offset_of!(CUpti_ActivityMarker2, flags) - 4usize];
    ["Offset of field: CUpti_ActivityMarker2::timestamp"]
        [::std::mem::offset_of!(CUpti_ActivityMarker2, timestamp) - 8usize];
    ["Offset of field: CUpti_ActivityMarker2::id"]
        [::std::mem::offset_of!(CUpti_ActivityMarker2, id) - 16usize];
    ["Offset of field: CUpti_ActivityMarker2::objectKind"]
        [::std::mem::offset_of!(CUpti_ActivityMarker2, objectKind) - 20usize];
    ["Offset of field: CUpti_ActivityMarker2::objectId"]
        [::std::mem::offset_of!(CUpti_ActivityMarker2, objectId) - 24usize];
    ["Offset of field: CUpti_ActivityMarker2::pad"]
        [::std::mem::offset_of!(CUpti_ActivityMarker2, pad) - 36usize];
    ["Offset of field: CUpti_ActivityMarker2::name"]
        [::std::mem::offset_of!(CUpti_ActivityMarker2, name) - 40usize];
    ["Offset of field: CUpti_ActivityMarker2::domain"]
        [::std::mem::offset_of!(CUpti_ActivityMarker2, domain) - 48usize];
};
impl Default for CUpti_ActivityMarker2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMarker2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMarker2 {{ kind: {:?}, flags: {:?}, objectKind: {:?}, objectId: {:?}, name: {:?}, domain: {:?} }}",
            self.kind, self.flags, self.objectKind, self.objectId, self.name, self.domain
        )
    }
}
#[doc = " \\brief The activity record providing detailed information for a marker.\n\n User must enable CUPTI_ACTIVITY_KIND_MARKER as well\n to get records for marker data.\n The marker data contains color, payload, and category.\n (CUPTI_ACTIVITY_KIND_MARKER_DATA)."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMarkerData2 {
    #[doc = " The activity record kind, must be\n CUPTI_ACTIVITY_KIND_MARKER_DATA."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The flags associated with the marker. \\see CUpti_ActivityFlag"]
    pub flags: CUpti_ActivityFlag,
    #[doc = " The marker ID."]
    pub id: u32,
    #[doc = " Defines the payload format for the value associated with the marker."]
    pub payloadKind: CUpti_MetricValueKind,
    #[doc = " The payload value."]
    pub payload: CUpti_MetricValue,
    #[doc = " The color for the marker."]
    pub color: u32,
    #[doc = " The category for the marker."]
    pub category: u32,
    #[doc = " CUPTI maintained domain id required for NVTX extended payloads.\n To parse the payload correctly, the domain id must be used to\n identify the payload attributes as they are domain specific."]
    pub cuptiDomainId: u32,
    #[doc = " Reserved for internal use."]
    pub padding: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMarkerData2"]
        [::std::mem::size_of::<CUpti_ActivityMarkerData2>() - 40usize];
    ["Alignment of CUpti_ActivityMarkerData2"]
        [::std::mem::align_of::<CUpti_ActivityMarkerData2>() - 8usize];
    ["Offset of field: CUpti_ActivityMarkerData2::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMarkerData2, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMarkerData2::flags"]
        [::std::mem::offset_of!(CUpti_ActivityMarkerData2, flags) - 4usize];
    ["Offset of field: CUpti_ActivityMarkerData2::id"]
        [::std::mem::offset_of!(CUpti_ActivityMarkerData2, id) - 8usize];
    ["Offset of field: CUpti_ActivityMarkerData2::payloadKind"]
        [::std::mem::offset_of!(CUpti_ActivityMarkerData2, payloadKind) - 12usize];
    ["Offset of field: CUpti_ActivityMarkerData2::payload"]
        [::std::mem::offset_of!(CUpti_ActivityMarkerData2, payload) - 16usize];
    ["Offset of field: CUpti_ActivityMarkerData2::color"]
        [::std::mem::offset_of!(CUpti_ActivityMarkerData2, color) - 24usize];
    ["Offset of field: CUpti_ActivityMarkerData2::category"]
        [::std::mem::offset_of!(CUpti_ActivityMarkerData2, category) - 28usize];
    ["Offset of field: CUpti_ActivityMarkerData2::cuptiDomainId"]
        [::std::mem::offset_of!(CUpti_ActivityMarkerData2, cuptiDomainId) - 32usize];
    ["Offset of field: CUpti_ActivityMarkerData2::padding"]
        [::std::mem::offset_of!(CUpti_ActivityMarkerData2, padding) - 36usize];
};
impl Default for CUpti_ActivityMarkerData2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMarkerData2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMarkerData2 {{ kind: {:?}, flags: {:?}, payloadKind: {:?}, payload: {:?} }}",
            self.kind, self.flags, self.payloadKind, self.payload
        )
    }
}
#[doc = " \\brief The activity record for CUPTI and driver overheads.\n\n This activity record provides CUPTI and driver overhead information\n (CUPTI_ACTIVITY_KIND_OVERHEAD)."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityOverhead3 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_OVERHEAD."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The kind of overhead, CUPTI, DRIVER, COMPILER etc."]
    pub overheadKind: CUpti_ActivityOverheadKind,
    #[doc = " The kind of activity object that the overhead is associated with."]
    pub objectKind: CUpti_ActivityObjectKind,
    #[doc = " The identifier for the activity object. 'objectKind' indicates\n which ID is valid for this record."]
    pub objectId: CUpti_ActivityObjectKindId,
    #[doc = " The start timestamp for the overhead, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the overhead."]
    pub start: u64,
    #[doc = " The end timestamp for the overhead, in ns. A value of 0 for both\n the start and end timestamps indicates that timestamp information\n could not be collected for the overhead."]
    pub end: u64,
    #[doc = " The correlation ID of the overhead operation to which\n records belong to. This ID is identical to the\n correlation ID in the driver or runtime API activity record that\n launched the overhead operation.\n In some cases, it can be zero, such as for CUPTI_ACTIVITY_OVERHEAD_CUPTI_BUFFER_FLUSH records."]
    pub correlationId: u32,
    #[doc = " Reserved for internal use."]
    pub reserved0: u32,
    #[doc = " Pointer to the struct with additional details about the overhead.\n Refer CUpti_ActivityOverheadKind enum and the corresponding structure to typecast and access additional overhead data.\n Client is responsible for freeing this memory using the free function when done."]
    pub overheadData: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityOverhead3"][::std::mem::size_of::<CUpti_ActivityOverhead3>() - 56usize];
    ["Alignment of CUpti_ActivityOverhead3"]
        [::std::mem::align_of::<CUpti_ActivityOverhead3>() - 8usize];
    ["Offset of field: CUpti_ActivityOverhead3::kind"]
        [::std::mem::offset_of!(CUpti_ActivityOverhead3, kind) - 0usize];
    ["Offset of field: CUpti_ActivityOverhead3::overheadKind"]
        [::std::mem::offset_of!(CUpti_ActivityOverhead3, overheadKind) - 4usize];
    ["Offset of field: CUpti_ActivityOverhead3::objectKind"]
        [::std::mem::offset_of!(CUpti_ActivityOverhead3, objectKind) - 8usize];
    ["Offset of field: CUpti_ActivityOverhead3::objectId"]
        [::std::mem::offset_of!(CUpti_ActivityOverhead3, objectId) - 12usize];
    ["Offset of field: CUpti_ActivityOverhead3::start"]
        [::std::mem::offset_of!(CUpti_ActivityOverhead3, start) - 24usize];
    ["Offset of field: CUpti_ActivityOverhead3::end"]
        [::std::mem::offset_of!(CUpti_ActivityOverhead3, end) - 32usize];
    ["Offset of field: CUpti_ActivityOverhead3::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityOverhead3, correlationId) - 40usize];
    ["Offset of field: CUpti_ActivityOverhead3::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityOverhead3, reserved0) - 44usize];
    ["Offset of field: CUpti_ActivityOverhead3::overheadData"]
        [::std::mem::offset_of!(CUpti_ActivityOverhead3, overheadData) - 48usize];
};
impl Default for CUpti_ActivityOverhead3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityOverhead3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityOverhead3 {{ kind: {:?}, overheadKind: {:?}, objectKind: {:?}, objectId: {:?}, overheadData: {:?} }}",
            self.kind, self.overheadKind, self.objectKind, self.objectId, self.overheadData
        )
    }
}
#[doc = " \\brief The activity record for CUPTI environmental data.\n\n This activity record provides CUPTI environmental data, include\n power, clocks, and thermals.  This information is sampled at\n various rates and returned in this activity record.  The consumer\n of the record needs to check the environmentKind field to figure\n out what kind of environmental record this is."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityEnvironment {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_ENVIRONMENT."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The ID of the device"]
    pub deviceId: u32,
    #[doc = " The timestamp when this sample was retrieved, in ns. A value of 0\n indicates that timestamp information could not be collected for\n the marker."]
    pub timestamp: u64,
    #[doc = " The kind of data reported in this record."]
    pub environmentKind: CUpti_ActivityEnvironmentKind,
    pub data: CUpti_ActivityEnvironment__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityEnvironment__bindgen_ty_1 {
    pub speed: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1,
    pub temperature: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_2,
    pub power: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_3,
    pub cooling: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_4,
}
#[doc = " Data returned for CUPTI_ACTIVITY_ENVIRONMENT_SPEED environment\n kind."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " The SM frequency in MHz"]
    pub smClock: u32,
    #[doc = " The memory frequency in MHz"]
    pub memoryClock: u32,
    #[doc = " The PCIe link generation."]
    pub pcieLinkGen: u32,
    #[doc = " The PCIe link width."]
    pub pcieLinkWidth: u32,
    #[doc = " The clocks throttle reasons."]
    pub clocksThrottleReasons: CUpti_EnvironmentClocksThrottleReason,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1>() - 20usize];
    ["Alignment of CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1::smClock"][::std::mem::offset_of!(
        CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1,
        smClock
    ) - 0usize];
    ["Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1::memoryClock"][::std::mem::offset_of!(
        CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1,
        memoryClock
    )
        - 4usize];
    ["Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1::pcieLinkGen"][::std::mem::offset_of!(
        CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1,
        pcieLinkGen
    )
        - 8usize];
    ["Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1::pcieLinkWidth"][::std::mem::offset_of!(
        CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1,
        pcieLinkWidth
    )
        - 12usize];
    [
        "Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1::clocksThrottleReasons",
    ][::std::mem::offset_of!(
        CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1,
        clocksThrottleReasons
    ) - 16usize];
};
impl Default for CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Data returned for CUPTI_ACTIVITY_ENVIRONMENT_TEMPERATURE\n environment kind."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " The GPU temperature in degrees C."]
    pub gpuTemperature: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::size_of::<CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_2>() - 4usize];
    ["Alignment of CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::align_of::<CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_2>() - 4usize];
    ["Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_2::gpuTemperature"][::std::mem::offset_of!(
        CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_2,
        gpuTemperature
    )
        - 0usize];
};
#[doc = " Data returned for CUPTI_ACTIVITY_ENVIRONMENT_POWER environment kind.\n The power in milliwatts consumed by GPU and associated circuitry.\n The power in milliwatts that will trigger power management algorithm."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_3 {
    pub power: u32,
    pub powerLimit: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::size_of::<CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_3>() - 8usize];
    ["Alignment of CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::align_of::<CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_3>() - 4usize];
    ["Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_3::power"][::std::mem::offset_of!(
        CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_3,
        power
    ) - 0usize];
    ["Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_3::powerLimit"][::std::mem::offset_of!(
        CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_3,
        powerLimit
    )
        - 4usize];
};
#[doc = " Data returned for CUPTI_ACTIVITY_ENVIRONMENT_COOLING\n environment kind."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_4 {
    #[doc = " The fan speed as percentage of maximum."]
    pub fanSpeed: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::size_of::<CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_4>() - 4usize];
    ["Alignment of CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::align_of::<CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_4>() - 4usize];
    ["Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_4::fanSpeed"][::std::mem::offset_of!(
        CUpti_ActivityEnvironment__bindgen_ty_1__bindgen_ty_4,
        fanSpeed
    )
        - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityEnvironment__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityEnvironment__bindgen_ty_1>() - 20usize];
    ["Alignment of CUpti_ActivityEnvironment__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityEnvironment__bindgen_ty_1>() - 4usize];
    ["Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1::speed"]
        [::std::mem::offset_of!(CUpti_ActivityEnvironment__bindgen_ty_1, speed) - 0usize];
    ["Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1::temperature"]
        [::std::mem::offset_of!(CUpti_ActivityEnvironment__bindgen_ty_1, temperature) - 0usize];
    ["Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1::power"]
        [::std::mem::offset_of!(CUpti_ActivityEnvironment__bindgen_ty_1, power) - 0usize];
    ["Offset of field: CUpti_ActivityEnvironment__bindgen_ty_1::cooling"]
        [::std::mem::offset_of!(CUpti_ActivityEnvironment__bindgen_ty_1, cooling) - 0usize];
};
impl Default for CUpti_ActivityEnvironment__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityEnvironment__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityEnvironment__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityEnvironment"]
        [::std::mem::size_of::<CUpti_ActivityEnvironment>() - 40usize];
    ["Alignment of CUpti_ActivityEnvironment"]
        [::std::mem::align_of::<CUpti_ActivityEnvironment>() - 8usize];
    ["Offset of field: CUpti_ActivityEnvironment::kind"]
        [::std::mem::offset_of!(CUpti_ActivityEnvironment, kind) - 0usize];
    ["Offset of field: CUpti_ActivityEnvironment::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityEnvironment, deviceId) - 4usize];
    ["Offset of field: CUpti_ActivityEnvironment::timestamp"]
        [::std::mem::offset_of!(CUpti_ActivityEnvironment, timestamp) - 8usize];
    ["Offset of field: CUpti_ActivityEnvironment::environmentKind"]
        [::std::mem::offset_of!(CUpti_ActivityEnvironment, environmentKind) - 16usize];
    ["Offset of field: CUpti_ActivityEnvironment::data"]
        [::std::mem::offset_of!(CUpti_ActivityEnvironment, data) - 20usize];
};
impl Default for CUpti_ActivityEnvironment {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityEnvironment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityEnvironment {{ kind: {:?}, environmentKind: {:?}, data: {:?} }}",
            self.kind, self.environmentKind, self.data
        )
    }
}
#[doc = " \\brief The activity record for source-level instruction execution.\n\n This activity records result for source level instruction execution.\n (CUPTI_ACTIVITY_KIND_INSTRUCTION_EXECUTION)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityInstructionExecution {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_INSTRUCTION_EXECUTION."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The properties of this instruction execution."]
    pub flags: CUpti_ActivityFlag,
    #[doc = " The ID for source locator."]
    pub sourceLocatorId: u32,
    #[doc = " The correlation ID of the kernel to which this result is associated."]
    pub correlationId: u32,
    #[doc = " Correlation ID with global/device function name"]
    pub functionId: u32,
    #[doc = " The pc offset for the instruction."]
    pub pcOffset: u32,
    #[doc = " This increments each time when this instruction is executed by number\n of threads that executed this instruction, regardless of predicate or condition code."]
    pub threadsExecuted: u64,
    #[doc = " This increments each time when this instruction is executed by number\n of threads that executed this instruction with predicate and condition code evaluating to true."]
    pub notPredOffThreadsExecuted: u64,
    #[doc = " The number of times this instruction was executed per warp. It will be incremented\n regardless of predicate or condition code."]
    pub executed: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityInstructionExecution"]
        [::std::mem::size_of::<CUpti_ActivityInstructionExecution>() - 48usize];
    ["Alignment of CUpti_ActivityInstructionExecution"]
        [::std::mem::align_of::<CUpti_ActivityInstructionExecution>() - 8usize];
    ["Offset of field: CUpti_ActivityInstructionExecution::kind"]
        [::std::mem::offset_of!(CUpti_ActivityInstructionExecution, kind) - 0usize];
    ["Offset of field: CUpti_ActivityInstructionExecution::flags"]
        [::std::mem::offset_of!(CUpti_ActivityInstructionExecution, flags) - 4usize];
    ["Offset of field: CUpti_ActivityInstructionExecution::sourceLocatorId"]
        [::std::mem::offset_of!(CUpti_ActivityInstructionExecution, sourceLocatorId) - 8usize];
    ["Offset of field: CUpti_ActivityInstructionExecution::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityInstructionExecution, correlationId) - 12usize];
    ["Offset of field: CUpti_ActivityInstructionExecution::functionId"]
        [::std::mem::offset_of!(CUpti_ActivityInstructionExecution, functionId) - 16usize];
    ["Offset of field: CUpti_ActivityInstructionExecution::pcOffset"]
        [::std::mem::offset_of!(CUpti_ActivityInstructionExecution, pcOffset) - 20usize];
    ["Offset of field: CUpti_ActivityInstructionExecution::threadsExecuted"]
        [::std::mem::offset_of!(CUpti_ActivityInstructionExecution, threadsExecuted) - 24usize];
    ["Offset of field: CUpti_ActivityInstructionExecution::notPredOffThreadsExecuted"][::std::mem::offset_of!(
        CUpti_ActivityInstructionExecution,
        notPredOffThreadsExecuted
    ) - 32usize];
    ["Offset of field: CUpti_ActivityInstructionExecution::executed"]
        [::std::mem::offset_of!(CUpti_ActivityInstructionExecution, executed) - 40usize];
    ["Offset of field: CUpti_ActivityInstructionExecution::pad"]
        [::std::mem::offset_of!(CUpti_ActivityInstructionExecution, pad) - 44usize];
};
impl Default for CUpti_ActivityInstructionExecution {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for PC sampling.\n\n This activity records information obtained by sampling PC\n (CUPTI_ACTIVITY_KIND_PC_SAMPLING)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityPCSampling3 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_PC_SAMPLING."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The properties of this instruction."]
    pub flags: CUpti_ActivityFlag,
    #[doc = " The ID for source locator."]
    pub sourceLocatorId: u32,
    #[doc = " The correlation ID of the kernel to which this result is associated."]
    pub correlationId: u32,
    #[doc = " Correlation ID with global/device function name"]
    pub functionId: u32,
    #[doc = " Number of times the PC was sampled with the stallReason in the record.\n These samples indicate that no instruction was issued in that cycle from\n the warp scheduler from where the warp was sampled.\n Field is valid for devices with compute capability 6.0 and higher"]
    pub latencySamples: u32,
    #[doc = " Number of times the PC was sampled with the stallReason in the record.\n The same PC can be sampled with different stall reasons. The count includes\n latencySamples."]
    pub samples: u32,
    #[doc = " Current stall reason. Includes one of the reasons from\n \\ref CUpti_ActivityPCSamplingStallReason"]
    pub stallReason: CUpti_ActivityPCSamplingStallReason,
    #[doc = " The pc offset for the instruction."]
    pub pcOffset: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityPCSampling3"]
        [::std::mem::size_of::<CUpti_ActivityPCSampling3>() - 40usize];
    ["Alignment of CUpti_ActivityPCSampling3"]
        [::std::mem::align_of::<CUpti_ActivityPCSampling3>() - 8usize];
    ["Offset of field: CUpti_ActivityPCSampling3::kind"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling3, kind) - 0usize];
    ["Offset of field: CUpti_ActivityPCSampling3::flags"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling3, flags) - 4usize];
    ["Offset of field: CUpti_ActivityPCSampling3::sourceLocatorId"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling3, sourceLocatorId) - 8usize];
    ["Offset of field: CUpti_ActivityPCSampling3::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling3, correlationId) - 12usize];
    ["Offset of field: CUpti_ActivityPCSampling3::functionId"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling3, functionId) - 16usize];
    ["Offset of field: CUpti_ActivityPCSampling3::latencySamples"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling3, latencySamples) - 20usize];
    ["Offset of field: CUpti_ActivityPCSampling3::samples"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling3, samples) - 24usize];
    ["Offset of field: CUpti_ActivityPCSampling3::stallReason"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling3, stallReason) - 28usize];
    ["Offset of field: CUpti_ActivityPCSampling3::pcOffset"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling3, pcOffset) - 32usize];
};
impl Default for CUpti_ActivityPCSampling3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for record status for PC sampling.\n\n This activity records information obtained by sampling PC\n (CUPTI_ACTIVITY_KIND_PC_SAMPLING_RECORD_INFO)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityPCSamplingRecordInfo {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_PC_SAMPLING_RECORD_INFO."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The correlation ID of the kernel to which this result is associated."]
    pub correlationId: u32,
    #[doc = " Number of times the PC was sampled for this kernel instance including all\n dropped samples."]
    pub totalSamples: u64,
    #[doc = " Number of samples that were dropped by hardware due to backpressure/overflow."]
    pub droppedSamples: u64,
    #[doc = " Sampling period in terms of number of cycles ."]
    pub samplingPeriodInCycles: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityPCSamplingRecordInfo"]
        [::std::mem::size_of::<CUpti_ActivityPCSamplingRecordInfo>() - 32usize];
    ["Alignment of CUpti_ActivityPCSamplingRecordInfo"]
        [::std::mem::align_of::<CUpti_ActivityPCSamplingRecordInfo>() - 8usize];
    ["Offset of field: CUpti_ActivityPCSamplingRecordInfo::kind"]
        [::std::mem::offset_of!(CUpti_ActivityPCSamplingRecordInfo, kind) - 0usize];
    ["Offset of field: CUpti_ActivityPCSamplingRecordInfo::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityPCSamplingRecordInfo, correlationId) - 4usize];
    ["Offset of field: CUpti_ActivityPCSamplingRecordInfo::totalSamples"]
        [::std::mem::offset_of!(CUpti_ActivityPCSamplingRecordInfo, totalSamples) - 8usize];
    ["Offset of field: CUpti_ActivityPCSamplingRecordInfo::droppedSamples"]
        [::std::mem::offset_of!(CUpti_ActivityPCSamplingRecordInfo, droppedSamples) - 16usize];
    ["Offset of field: CUpti_ActivityPCSamplingRecordInfo::samplingPeriodInCycles"][::std::mem::offset_of!(
        CUpti_ActivityPCSamplingRecordInfo,
        samplingPeriodInCycles
    ) - 24usize];
};
impl Default for CUpti_ActivityPCSamplingRecordInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for Unified Memory counters (CUDA 7.0 and beyond)\n\n This activity record represents a Unified Memory counter\n (CUPTI_ACTIVITY_KIND_UNIFIED_MEMORY_COUNTER)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityUnifiedMemoryCounter3 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_UNIFIED_MEMORY_COUNTER"]
    pub kind: CUpti_ActivityKind,
    #[doc = " The Unified Memory counter kind"]
    pub counterKind: CUpti_ActivityUnifiedMemoryCounterKind,
    #[doc = " Value of the counter\n For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD,\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_DTOH,\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THREASHING and\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_REMOTE_MAP, it is the size of the\n memory region in bytes.\n For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT, it\n is the number of page fault groups for the same page.\n For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT,\n it is the program counter for the instruction that caused fault."]
    pub value: u64,
    #[doc = " The start timestamp of the counter, in ns.\n For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD and\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_DTOH, timestamp is\n captured when activity starts on GPU.\n For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT and\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT, timestamp is\n captured when CUDA driver started processing the fault.\n For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING, timestamp\n is captured when CUDA driver detected thrashing of memory region.\n For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING,\n timestamp is captured when throttling operation was started by CUDA driver.\n For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_REMOTE_MAP,\n timestamp is captured when CUDA driver has pushed all required operations\n to the processor specified by dstId."]
    pub start: u64,
    #[doc = " The end timestamp of the counter, in ns.\n Ignore this field if counterKind is\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT or\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING or\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_REMOTE_MAP.\n For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD and\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_DTOH, timestamp is\n captured when activity finishes on GPU.\n For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT, timestamp is\n captured when CUDA driver queues the replay of faulting memory accesses on the GPU\n For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING, timestamp\n is captured when throttling operation was finished by CUDA driver"]
    pub end: u64,
    #[doc = " This is the virtual base address of the page/s being transferred. For cpu and\n gpu faults, the virtual address for the page that faulted."]
    pub address: u64,
    #[doc = " The ID of the source CPU/device involved in the memory transfer, page fault, thrashing,\n throttling or remote map operation. For counterKind\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING, it is a bitwise ORing of the\n device IDs fighting for the memory region, ONLY if there are less than 32 devices. Ignore this field if counterKind is\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT"]
    pub srcId: u32,
    #[doc = " The ID of the destination CPU/device involved in the memory transfer or remote map\n operation. Ignore this field if counterKind is\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT or\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT or\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING or\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING"]
    pub dstId: u32,
    #[doc = " The ID of the stream causing the transfer.\n This value of this field is invalid."]
    pub streamId: u32,
    #[doc = " The ID of the process to which this record belongs to."]
    pub processId: u32,
    #[doc = " The flags associated with this record. See enums \\ref CUpti_ActivityUnifiedMemoryAccessType\n if counterKind is CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT\n and \\ref CUpti_ActivityUnifiedMemoryMigrationCause if counterKind is\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD or\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD\n and \\ref CUpti_ActivityUnifiedMemoryRemoteMapCause if counterKind is\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_REMOTE_MAP and \\ref CUpti_ActivityFlag\n if counterKind is CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING or\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING"]
    pub flags: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
    #[doc = " \\brief The bitmask of devices involved in the operation.\n\n For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING, it is a bitwise ORing of the\n device IDs fighting for the memory region. processors[0] represents the device ID of the device 0 to device 63,\n processors[1] represents device ID of device 64 to device 127 and so on.\n Ignore this field if counterKind is\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT or\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT or\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING or\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_REMOTE_MAP or\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD or\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_DTOH or\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_DTOD or\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_FAULT_REPLAY"]
    pub processors: [u64; 5usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityUnifiedMemoryCounter3"]
        [::std::mem::size_of::<CUpti_ActivityUnifiedMemoryCounter3>() - 104usize];
    ["Alignment of CUpti_ActivityUnifiedMemoryCounter3"]
        [::std::mem::align_of::<CUpti_ActivityUnifiedMemoryCounter3>() - 8usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter3::kind"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, kind) - 0usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter3::counterKind"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, counterKind) - 4usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter3::value"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, value) - 8usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter3::start"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, start) - 16usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter3::end"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, end) - 24usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter3::address"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, address) - 32usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter3::srcId"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, srcId) - 40usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter3::dstId"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, dstId) - 44usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter3::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, streamId) - 48usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter3::processId"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, processId) - 52usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter3::flags"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, flags) - 56usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter3::pad"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, pad) - 60usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter3::processors"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter3, processors) - 64usize];
};
impl Default for CUpti_ActivityUnifiedMemoryCounter3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for global/device functions.\n\n This activity records function name and corresponding module\n information.\n (CUPTI_ACTIVITY_KIND_FUNCTION)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityFunction {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_FUNCTION."]
    pub kind: CUpti_ActivityKind,
    #[doc = " ID to uniquely identify the record"]
    pub id: u32,
    #[doc = " The ID of the context where the function is launched."]
    pub contextId: u32,
    #[doc = " The module ID in which this global/device function is present."]
    pub moduleId: u32,
    #[doc = " The function's unique symbol index in the module."]
    pub functionIndex: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
    #[doc = " The name of the function. This name is shared across all activity\n records representing the same kernel, and so should not be\n modified."]
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityFunction"][::std::mem::size_of::<CUpti_ActivityFunction>() - 32usize];
    ["Alignment of CUpti_ActivityFunction"]
        [::std::mem::align_of::<CUpti_ActivityFunction>() - 8usize];
    ["Offset of field: CUpti_ActivityFunction::kind"]
        [::std::mem::offset_of!(CUpti_ActivityFunction, kind) - 0usize];
    ["Offset of field: CUpti_ActivityFunction::id"]
        [::std::mem::offset_of!(CUpti_ActivityFunction, id) - 4usize];
    ["Offset of field: CUpti_ActivityFunction::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityFunction, contextId) - 8usize];
    ["Offset of field: CUpti_ActivityFunction::moduleId"]
        [::std::mem::offset_of!(CUpti_ActivityFunction, moduleId) - 12usize];
    ["Offset of field: CUpti_ActivityFunction::functionIndex"]
        [::std::mem::offset_of!(CUpti_ActivityFunction, functionIndex) - 16usize];
    ["Offset of field: CUpti_ActivityFunction::pad"]
        [::std::mem::offset_of!(CUpti_ActivityFunction, pad) - 20usize];
    ["Offset of field: CUpti_ActivityFunction::name"]
        [::std::mem::offset_of!(CUpti_ActivityFunction, name) - 24usize];
};
impl Default for CUpti_ActivityFunction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for a CUDA module.\n\n This activity record represents a CUDA module\n (CUPTI_ACTIVITY_KIND_MODULE). This activity record kind is not\n produced by the activity API but is included for completeness and\n ease-of-use. Profile frameworks built on top of CUPTI that collect\n module data from the module callback may choose to use this type to\n store the collected module data."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityModule {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MODULE."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The ID of the context where the module is loaded."]
    pub contextId: u32,
    #[doc = " The module ID."]
    pub id: u32,
    #[doc = " The cubin size."]
    pub cubinSize: u32,
    #[doc = " The pointer to cubin."]
    pub cubin: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityModule"][::std::mem::size_of::<CUpti_ActivityModule>() - 24usize];
    ["Alignment of CUpti_ActivityModule"][::std::mem::align_of::<CUpti_ActivityModule>() - 8usize];
    ["Offset of field: CUpti_ActivityModule::kind"]
        [::std::mem::offset_of!(CUpti_ActivityModule, kind) - 0usize];
    ["Offset of field: CUpti_ActivityModule::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityModule, contextId) - 4usize];
    ["Offset of field: CUpti_ActivityModule::id"]
        [::std::mem::offset_of!(CUpti_ActivityModule, id) - 8usize];
    ["Offset of field: CUpti_ActivityModule::cubinSize"]
        [::std::mem::offset_of!(CUpti_ActivityModule, cubinSize) - 12usize];
    ["Offset of field: CUpti_ActivityModule::cubin"]
        [::std::mem::offset_of!(CUpti_ActivityModule, cubin) - 16usize];
};
impl Default for CUpti_ActivityModule {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for source-level shared\n access.\n\n This activity records the locations of the shared\n accesses in the source\n (CUPTI_ACTIVITY_KIND_SHARED_ACCESS)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivitySharedAccess {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_SHARED_ACCESS."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The properties of this shared access."]
    pub flags: CUpti_ActivityFlag,
    #[doc = " The ID for source locator."]
    pub sourceLocatorId: u32,
    #[doc = " The correlation ID of the kernel to which this result is associated."]
    pub correlationId: u32,
    #[doc = " Correlation ID with global/device function name"]
    pub functionId: u32,
    #[doc = " The pc offset for the access."]
    pub pcOffset: u32,
    #[doc = " This increments each time when this instruction is executed by number\n of threads that executed this instruction with predicate and condition code evaluating to true."]
    pub threadsExecuted: u64,
    #[doc = " The total number of shared memory transactions generated by this access"]
    pub sharedTransactions: u64,
    #[doc = " The minimum number of shared memory transactions possible based on the access pattern."]
    pub theoreticalSharedTransactions: u64,
    #[doc = " The number of times this instruction was executed per warp. It will be incremented\n when at least one of thread among warp is active with predicate and condition code\n evaluating to true."]
    pub executed: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivitySharedAccess"]
        [::std::mem::size_of::<CUpti_ActivitySharedAccess>() - 56usize];
    ["Alignment of CUpti_ActivitySharedAccess"]
        [::std::mem::align_of::<CUpti_ActivitySharedAccess>() - 8usize];
    ["Offset of field: CUpti_ActivitySharedAccess::kind"]
        [::std::mem::offset_of!(CUpti_ActivitySharedAccess, kind) - 0usize];
    ["Offset of field: CUpti_ActivitySharedAccess::flags"]
        [::std::mem::offset_of!(CUpti_ActivitySharedAccess, flags) - 4usize];
    ["Offset of field: CUpti_ActivitySharedAccess::sourceLocatorId"]
        [::std::mem::offset_of!(CUpti_ActivitySharedAccess, sourceLocatorId) - 8usize];
    ["Offset of field: CUpti_ActivitySharedAccess::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivitySharedAccess, correlationId) - 12usize];
    ["Offset of field: CUpti_ActivitySharedAccess::functionId"]
        [::std::mem::offset_of!(CUpti_ActivitySharedAccess, functionId) - 16usize];
    ["Offset of field: CUpti_ActivitySharedAccess::pcOffset"]
        [::std::mem::offset_of!(CUpti_ActivitySharedAccess, pcOffset) - 20usize];
    ["Offset of field: CUpti_ActivitySharedAccess::threadsExecuted"]
        [::std::mem::offset_of!(CUpti_ActivitySharedAccess, threadsExecuted) - 24usize];
    ["Offset of field: CUpti_ActivitySharedAccess::sharedTransactions"]
        [::std::mem::offset_of!(CUpti_ActivitySharedAccess, sharedTransactions) - 32usize];
    ["Offset of field: CUpti_ActivitySharedAccess::theoreticalSharedTransactions"][::std::mem::offset_of!(
        CUpti_ActivitySharedAccess,
        theoreticalSharedTransactions
    ) - 40usize];
    ["Offset of field: CUpti_ActivitySharedAccess::executed"]
        [::std::mem::offset_of!(CUpti_ActivitySharedAccess, executed) - 48usize];
    ["Offset of field: CUpti_ActivitySharedAccess::pad"]
        [::std::mem::offset_of!(CUpti_ActivitySharedAccess, pad) - 52usize];
};
impl Default for CUpti_ActivitySharedAccess {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for CUDA event.\n\n This activity is used to track recorded events.\n (CUPTI_ACTIVITY_KIND_CUDA_EVENT)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityCudaEvent2 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_CUDA_EVENT."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The correlation ID of the API to which this result is associated."]
    pub correlationId: u32,
    #[doc = " The ID of the context where the event was recorded."]
    pub contextId: u32,
    #[doc = " The compute stream where the event was recorded."]
    pub streamId: u32,
    #[doc = " A unique event ID to identify the event record."]
    pub eventId: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
    #[doc = " The ID of the device where the event was recorded."]
    pub deviceId: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad2: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
    #[doc = " The device-side timestamp on CUDA event record.\n Timestamp is in nanoseconds. Collection of this field is disabled by default.\n It can be enabled by calling CUPTI API \\ref cuptiActivityEnableCudaEventDeviceTimestamps"]
    pub deviceTimestamp: u64,
    #[doc = " A unique ID to associate event synchronization records\n with the latest CUDA Event record. Similar field is added\n in CUpti_ActivitySynchronization2 to associate CUDA Event\n record to the synchronization record.\n\n The same CUDA event can be used multiple times, so the\n event id will not be unique to correlate the synchronization\n record with the latest CUDA Event record.\n This field will be unique and can be used to do the required\n correlation."]
    pub cudaEventSyncId: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityCudaEvent2"]
        [::std::mem::size_of::<CUpti_ActivityCudaEvent2>() - 56usize];
    ["Alignment of CUpti_ActivityCudaEvent2"]
        [::std::mem::align_of::<CUpti_ActivityCudaEvent2>() - 8usize];
    ["Offset of field: CUpti_ActivityCudaEvent2::kind"]
        [::std::mem::offset_of!(CUpti_ActivityCudaEvent2, kind) - 0usize];
    ["Offset of field: CUpti_ActivityCudaEvent2::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityCudaEvent2, correlationId) - 4usize];
    ["Offset of field: CUpti_ActivityCudaEvent2::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityCudaEvent2, contextId) - 8usize];
    ["Offset of field: CUpti_ActivityCudaEvent2::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityCudaEvent2, streamId) - 12usize];
    ["Offset of field: CUpti_ActivityCudaEvent2::eventId"]
        [::std::mem::offset_of!(CUpti_ActivityCudaEvent2, eventId) - 16usize];
    ["Offset of field: CUpti_ActivityCudaEvent2::pad"]
        [::std::mem::offset_of!(CUpti_ActivityCudaEvent2, pad) - 20usize];
    ["Offset of field: CUpti_ActivityCudaEvent2::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityCudaEvent2, deviceId) - 24usize];
    ["Offset of field: CUpti_ActivityCudaEvent2::pad2"]
        [::std::mem::offset_of!(CUpti_ActivityCudaEvent2, pad2) - 28usize];
    ["Offset of field: CUpti_ActivityCudaEvent2::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityCudaEvent2, reserved0) - 32usize];
    ["Offset of field: CUpti_ActivityCudaEvent2::deviceTimestamp"]
        [::std::mem::offset_of!(CUpti_ActivityCudaEvent2, deviceTimestamp) - 40usize];
    ["Offset of field: CUpti_ActivityCudaEvent2::cudaEventSyncId"]
        [::std::mem::offset_of!(CUpti_ActivityCudaEvent2, cudaEventSyncId) - 48usize];
};
impl Default for CUpti_ActivityCudaEvent2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for CUDA stream.\n\n This activity is used to track created streams.\n (CUPTI_ACTIVITY_KIND_STREAM)."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityStream {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_STREAM."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The ID of the context where the stream was created."]
    pub contextId: u32,
    #[doc = " A unique stream ID to identify the stream."]
    pub streamId: u32,
    #[doc = " The clamped priority for the stream."]
    pub priority: u32,
    #[doc = " Flags associated with the stream."]
    pub flag: CUpti_ActivityStreamFlag,
    #[doc = " The correlation ID of the API to which this result is associated."]
    pub correlationId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityStream"][::std::mem::size_of::<CUpti_ActivityStream>() - 24usize];
    ["Alignment of CUpti_ActivityStream"][::std::mem::align_of::<CUpti_ActivityStream>() - 8usize];
    ["Offset of field: CUpti_ActivityStream::kind"]
        [::std::mem::offset_of!(CUpti_ActivityStream, kind) - 0usize];
    ["Offset of field: CUpti_ActivityStream::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityStream, contextId) - 4usize];
    ["Offset of field: CUpti_ActivityStream::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityStream, streamId) - 8usize];
    ["Offset of field: CUpti_ActivityStream::priority"]
        [::std::mem::offset_of!(CUpti_ActivityStream, priority) - 12usize];
    ["Offset of field: CUpti_ActivityStream::flag"]
        [::std::mem::offset_of!(CUpti_ActivityStream, flag) - 16usize];
    ["Offset of field: CUpti_ActivityStream::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityStream, correlationId) - 20usize];
};
impl Default for CUpti_ActivityStream {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for synchronization management.\n\n This activity is used to track various CUDA synchronization APIs.\n (CUPTI_ACTIVITY_KIND_SYNCHRONIZATION)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivitySynchronization2 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_SYNCHRONIZATION."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The type of record."]
    pub type_: CUpti_ActivitySynchronizationType,
    #[doc = " The start timestamp for the function, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the function."]
    pub start: u64,
    #[doc = " The end timestamp for the function, in ns. A value of 0 for both\n the start and end timestamps indicates that timestamp information\n could not be collected for the function."]
    pub end: u64,
    #[doc = " The correlation ID of the API to which this result is associated."]
    pub correlationId: u32,
    #[doc = " The ID of the context for which the synchronization API is called.\n In case of context synchronization API it is the context id for which the API is called.\n In case of stream/event synchronization it is the ID of the context where the stream/event was created."]
    pub contextId: u32,
    #[doc = " The compute stream for which the synchronization API is called.\n A CUPTI_SYNCHRONIZATION_INVALID_VALUE value indicate the field is not applicable for this record.\n Not valid for cuCtxSynchronize, cuEventSynchronize."]
    pub streamId: u32,
    #[doc = " The event ID for which the synchronization API is called.\n A CUPTI_SYNCHRONIZATION_INVALID_VALUE value indicate the field is not applicable for this record.\n Not valid for cuCtxSynchronize, cuStreamSynchronize."]
    pub cudaEventId: u32,
    #[doc = " A unique ID to associate event synchronization records\n with the latest CUDA Event record. Similar field is added\n in CUpti_ActivityCudaEvent2 to associate synchronization\n record to the CUDA Event record.\n\n The same CUDA event can be used multiple times, so the\n event id will not be unique to correlate the synchronization\n record with the latest CUDA Event record.\n This field will be unique and can be used to do the required\n correlation.\n\n A CUPTI_SYNCHRONIZATION_INVALID_VALUE value indicates that\n the field is not applicable for this record.\n Valid only for synchronization records related to CUDA Events."]
    pub cudaEventSyncId: u64,
    #[doc = " The return value for the synchronization record.\n Use cuptiActivityEnableAllSyncRecords API to enable/disable\n collection of synchronization records with return value being\n non-zero. This will be a CUresult value."]
    pub returnValue: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivitySynchronization2"]
        [::std::mem::size_of::<CUpti_ActivitySynchronization2>() - 56usize];
    ["Alignment of CUpti_ActivitySynchronization2"]
        [::std::mem::align_of::<CUpti_ActivitySynchronization2>() - 8usize];
    ["Offset of field: CUpti_ActivitySynchronization2::kind"]
        [::std::mem::offset_of!(CUpti_ActivitySynchronization2, kind) - 0usize];
    ["Offset of field: CUpti_ActivitySynchronization2::type_"]
        [::std::mem::offset_of!(CUpti_ActivitySynchronization2, type_) - 4usize];
    ["Offset of field: CUpti_ActivitySynchronization2::start"]
        [::std::mem::offset_of!(CUpti_ActivitySynchronization2, start) - 8usize];
    ["Offset of field: CUpti_ActivitySynchronization2::end"]
        [::std::mem::offset_of!(CUpti_ActivitySynchronization2, end) - 16usize];
    ["Offset of field: CUpti_ActivitySynchronization2::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivitySynchronization2, correlationId) - 24usize];
    ["Offset of field: CUpti_ActivitySynchronization2::contextId"]
        [::std::mem::offset_of!(CUpti_ActivitySynchronization2, contextId) - 28usize];
    ["Offset of field: CUpti_ActivitySynchronization2::streamId"]
        [::std::mem::offset_of!(CUpti_ActivitySynchronization2, streamId) - 32usize];
    ["Offset of field: CUpti_ActivitySynchronization2::cudaEventId"]
        [::std::mem::offset_of!(CUpti_ActivitySynchronization2, cudaEventId) - 36usize];
    ["Offset of field: CUpti_ActivitySynchronization2::cudaEventSyncId"]
        [::std::mem::offset_of!(CUpti_ActivitySynchronization2, cudaEventSyncId) - 40usize];
    ["Offset of field: CUpti_ActivitySynchronization2::returnValue"]
        [::std::mem::offset_of!(CUpti_ActivitySynchronization2, returnValue) - 48usize];
    ["Offset of field: CUpti_ActivitySynchronization2::pad"]
        [::std::mem::offset_of!(CUpti_ActivitySynchronization2, pad) - 52usize];
};
impl Default for CUpti_ActivitySynchronization2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for source-level sass/source\n line-by-line correlation.\n\n This activity records source level sass/source correlation\n information.\n (CUPTI_ACTIVITY_KIND_INSTRUCTION_CORRELATION)."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityInstructionCorrelation {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_INSTRUCTION_CORRELATION."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The properties of this instruction."]
    pub flags: CUpti_ActivityFlag,
    #[doc = " The ID for source locator."]
    pub sourceLocatorId: u32,
    #[doc = " Correlation ID with global/device function name"]
    pub functionId: u32,
    #[doc = " The pc offset for the instruction."]
    pub pcOffset: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityInstructionCorrelation"]
        [::std::mem::size_of::<CUpti_ActivityInstructionCorrelation>() - 24usize];
    ["Alignment of CUpti_ActivityInstructionCorrelation"]
        [::std::mem::align_of::<CUpti_ActivityInstructionCorrelation>() - 8usize];
    ["Offset of field: CUpti_ActivityInstructionCorrelation::kind"]
        [::std::mem::offset_of!(CUpti_ActivityInstructionCorrelation, kind) - 0usize];
    ["Offset of field: CUpti_ActivityInstructionCorrelation::flags"]
        [::std::mem::offset_of!(CUpti_ActivityInstructionCorrelation, flags) - 4usize];
    ["Offset of field: CUpti_ActivityInstructionCorrelation::sourceLocatorId"]
        [::std::mem::offset_of!(CUpti_ActivityInstructionCorrelation, sourceLocatorId) - 8usize];
    ["Offset of field: CUpti_ActivityInstructionCorrelation::functionId"]
        [::std::mem::offset_of!(CUpti_ActivityInstructionCorrelation, functionId) - 12usize];
    ["Offset of field: CUpti_ActivityInstructionCorrelation::pcOffset"]
        [::std::mem::offset_of!(CUpti_ActivityInstructionCorrelation, pcOffset) - 16usize];
    ["Offset of field: CUpti_ActivityInstructionCorrelation::pad"]
        [::std::mem::offset_of!(CUpti_ActivityInstructionCorrelation, pad) - 20usize];
};
impl Default for CUpti_ActivityInstructionCorrelation {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CUPTI_OPENACC_EVENT_KIND_INVALID: CUpti_OpenAccEventKind = 0;
pub const CUPTI_OPENACC_EVENT_KIND_DEVICE_INIT: CUpti_OpenAccEventKind = 1;
pub const CUPTI_OPENACC_EVENT_KIND_DEVICE_SHUTDOWN: CUpti_OpenAccEventKind = 2;
pub const CUPTI_OPENACC_EVENT_KIND_RUNTIME_SHUTDOWN: CUpti_OpenAccEventKind = 3;
pub const CUPTI_OPENACC_EVENT_KIND_ENQUEUE_LAUNCH: CUpti_OpenAccEventKind = 4;
pub const CUPTI_OPENACC_EVENT_KIND_ENQUEUE_UPLOAD: CUpti_OpenAccEventKind = 5;
pub const CUPTI_OPENACC_EVENT_KIND_ENQUEUE_DOWNLOAD: CUpti_OpenAccEventKind = 6;
pub const CUPTI_OPENACC_EVENT_KIND_WAIT: CUpti_OpenAccEventKind = 7;
pub const CUPTI_OPENACC_EVENT_KIND_IMPLICIT_WAIT: CUpti_OpenAccEventKind = 8;
pub const CUPTI_OPENACC_EVENT_KIND_COMPUTE_CONSTRUCT: CUpti_OpenAccEventKind = 9;
pub const CUPTI_OPENACC_EVENT_KIND_UPDATE: CUpti_OpenAccEventKind = 10;
pub const CUPTI_OPENACC_EVENT_KIND_ENTER_DATA: CUpti_OpenAccEventKind = 11;
pub const CUPTI_OPENACC_EVENT_KIND_EXIT_DATA: CUpti_OpenAccEventKind = 12;
pub const CUPTI_OPENACC_EVENT_KIND_CREATE: CUpti_OpenAccEventKind = 13;
pub const CUPTI_OPENACC_EVENT_KIND_DELETE: CUpti_OpenAccEventKind = 14;
pub const CUPTI_OPENACC_EVENT_KIND_ALLOC: CUpti_OpenAccEventKind = 15;
pub const CUPTI_OPENACC_EVENT_KIND_FREE: CUpti_OpenAccEventKind = 16;
pub const CUPTI_OPENACC_EVENT_KIND_FORCE_INT: CUpti_OpenAccEventKind = 2147483647;
#[doc = " \\brief The OpenAcc event kind for OpenAcc activity records.\n\n \\see CUpti_ActivityKindOpenAcc"]
pub type CUpti_OpenAccEventKind = ::std::os::raw::c_uint;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_UNKNOWN: CUpti_OpenAccConstructKind = 0;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_PARALLEL: CUpti_OpenAccConstructKind = 1;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_KERNELS: CUpti_OpenAccConstructKind = 2;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_LOOP: CUpti_OpenAccConstructKind = 3;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_DATA: CUpti_OpenAccConstructKind = 4;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_ENTER_DATA: CUpti_OpenAccConstructKind = 5;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_EXIT_DATA: CUpti_OpenAccConstructKind = 6;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_HOST_DATA: CUpti_OpenAccConstructKind = 7;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_ATOMIC: CUpti_OpenAccConstructKind = 8;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_DECLARE: CUpti_OpenAccConstructKind = 9;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_INIT: CUpti_OpenAccConstructKind = 10;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_SHUTDOWN: CUpti_OpenAccConstructKind = 11;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_SET: CUpti_OpenAccConstructKind = 12;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_UPDATE: CUpti_OpenAccConstructKind = 13;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_ROUTINE: CUpti_OpenAccConstructKind = 14;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_WAIT: CUpti_OpenAccConstructKind = 15;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_RUNTIME_API: CUpti_OpenAccConstructKind = 16;
pub const CUPTI_OPENACC_CONSTRUCT_KIND_FORCE_INT: CUpti_OpenAccConstructKind = 2147483647;
#[doc = " \\brief The OpenAcc parent construct kind for OpenAcc activity records."]
pub type CUpti_OpenAccConstructKind = ::std::os::raw::c_uint;
pub const CUPTI_OPENMP_EVENT_KIND_INVALID: CUpti_OpenMpEventKind = 0;
pub const CUPTI_OPENMP_EVENT_KIND_PARALLEL: CUpti_OpenMpEventKind = 1;
pub const CUPTI_OPENMP_EVENT_KIND_TASK: CUpti_OpenMpEventKind = 2;
pub const CUPTI_OPENMP_EVENT_KIND_THREAD: CUpti_OpenMpEventKind = 3;
pub const CUPTI_OPENMP_EVENT_KIND_IDLE: CUpti_OpenMpEventKind = 4;
pub const CUPTI_OPENMP_EVENT_KIND_WAIT_BARRIER: CUpti_OpenMpEventKind = 5;
pub const CUPTI_OPENMP_EVENT_KIND_WAIT_TASKWAIT: CUpti_OpenMpEventKind = 6;
pub const CUPTI_OPENMP_EVENT_KIND_FORCE_INT: CUpti_OpenMpEventKind = 2147483647;
pub type CUpti_OpenMpEventKind = ::std::os::raw::c_uint;
#[doc = " \\brief The base activity record for OpenAcc records.\n\n The OpenACC activity API part uses a CUpti_ActivityOpenAcc as a generic\n representation for any OpenACC activity. The 'kind' field is used to determine the\n specific activity kind, and from that the CUpti_ActivityOpenAcc object can\n be cast to the specific OpenACC activity record type appropriate for that kind.\n\n Note that all OpenACC activity record types are padded and aligned to\n ensure that each member of the record is naturally aligned.\n\n \\see CUpti_ActivityKind"]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityOpenAcc {
    #[doc = " The kind of this activity."]
    pub kind: CUpti_ActivityKind,
    #[doc = " CUPTI OpenACC event kind (\\see CUpti_OpenAccEventKind)"]
    pub eventKind: CUpti_OpenAccEventKind,
    #[doc = " CUPTI OpenACC parent construct kind (\\see CUpti_OpenAccConstructKind)\n\n Note that for applications using PGI OpenACC runtime < 16.1, this\n will always be CUPTI_OPENACC_CONSTRUCT_KIND_UNKNOWN."]
    pub parentConstruct: CUpti_OpenAccConstructKind,
    #[doc = " Version number"]
    pub version: u32,
    #[doc = " 1 for any implicit event, such as an implicit wait at a synchronous data construct\n 0 otherwise"]
    pub implicit: u32,
    #[doc = " Device type"]
    pub deviceType: u32,
    #[doc = " Device number"]
    pub deviceNumber: u32,
    #[doc = " ThreadId"]
    pub threadId: u32,
    #[doc = " Value of async() clause of the corresponding directive"]
    pub async_: u64,
    #[doc = " Internal asynchronous queue number used"]
    pub asyncMap: u64,
    #[doc = " The line number of the directive or program construct or the starting line\n number of the OpenACC construct corresponding to the event.\n A zero value means the line number is not known."]
    pub lineNo: u32,
    #[doc = " For an OpenACC construct, this contains the line number of the end\n of the construct. A zero value means the line number is not known."]
    pub endLineNo: u32,
    #[doc = " The line number of the first line of the function named in funcName.\n A zero value means the line number is not known."]
    pub funcLineNo: u32,
    #[doc = " The last line number of the function named in funcName.\n A zero value means the line number is not known."]
    pub funcEndLineNo: u32,
    #[doc = " CUPTI start timestamp"]
    pub start: u64,
    #[doc = " CUPTI end timestamp"]
    pub end: u64,
    #[doc = " CUDA device id\n Valid only if deviceType is acc_device_nvidia."]
    pub cuDeviceId: u32,
    #[doc = " CUDA context id\n Valid only if deviceType is acc_device_nvidia."]
    pub cuContextId: u32,
    #[doc = " CUDA stream id\n Valid only if deviceType is acc_device_nvidia."]
    pub cuStreamId: u32,
    #[doc = " The ID of the process where the OpenACC activity is executing."]
    pub cuProcessId: u32,
    #[doc = " The ID of the thread where the OpenACC activity is executing."]
    pub cuThreadId: u32,
    #[doc = " The OpenACC correlation ID.\n Valid only if deviceType is acc_device_nvidia.\n If not 0, it uniquely identifies this record. It is identical to the\n externalId in the preceding external correlation record of type\n CUPTI_EXTERNAL_CORRELATION_KIND_OPENACC."]
    pub externalId: u32,
    pub srcFile: *const ::std::os::raw::c_char,
    pub funcName: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityOpenAcc"][::std::mem::size_of::<CUpti_ActivityOpenAcc>() - 120usize];
    ["Alignment of CUpti_ActivityOpenAcc"]
        [::std::mem::align_of::<CUpti_ActivityOpenAcc>() - 8usize];
    ["Offset of field: CUpti_ActivityOpenAcc::kind"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, kind) - 0usize];
    ["Offset of field: CUpti_ActivityOpenAcc::eventKind"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, eventKind) - 4usize];
    ["Offset of field: CUpti_ActivityOpenAcc::parentConstruct"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, parentConstruct) - 8usize];
    ["Offset of field: CUpti_ActivityOpenAcc::version"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, version) - 12usize];
    ["Offset of field: CUpti_ActivityOpenAcc::implicit"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, implicit) - 16usize];
    ["Offset of field: CUpti_ActivityOpenAcc::deviceType"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, deviceType) - 20usize];
    ["Offset of field: CUpti_ActivityOpenAcc::deviceNumber"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, deviceNumber) - 24usize];
    ["Offset of field: CUpti_ActivityOpenAcc::threadId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, threadId) - 28usize];
    ["Offset of field: CUpti_ActivityOpenAcc::async_"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, async_) - 32usize];
    ["Offset of field: CUpti_ActivityOpenAcc::asyncMap"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, asyncMap) - 40usize];
    ["Offset of field: CUpti_ActivityOpenAcc::lineNo"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, lineNo) - 48usize];
    ["Offset of field: CUpti_ActivityOpenAcc::endLineNo"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, endLineNo) - 52usize];
    ["Offset of field: CUpti_ActivityOpenAcc::funcLineNo"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, funcLineNo) - 56usize];
    ["Offset of field: CUpti_ActivityOpenAcc::funcEndLineNo"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, funcEndLineNo) - 60usize];
    ["Offset of field: CUpti_ActivityOpenAcc::start"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, start) - 64usize];
    ["Offset of field: CUpti_ActivityOpenAcc::end"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, end) - 72usize];
    ["Offset of field: CUpti_ActivityOpenAcc::cuDeviceId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, cuDeviceId) - 80usize];
    ["Offset of field: CUpti_ActivityOpenAcc::cuContextId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, cuContextId) - 84usize];
    ["Offset of field: CUpti_ActivityOpenAcc::cuStreamId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, cuStreamId) - 88usize];
    ["Offset of field: CUpti_ActivityOpenAcc::cuProcessId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, cuProcessId) - 92usize];
    ["Offset of field: CUpti_ActivityOpenAcc::cuThreadId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, cuThreadId) - 96usize];
    ["Offset of field: CUpti_ActivityOpenAcc::externalId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, externalId) - 100usize];
    ["Offset of field: CUpti_ActivityOpenAcc::srcFile"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, srcFile) - 104usize];
    ["Offset of field: CUpti_ActivityOpenAcc::funcName"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAcc, funcName) - 112usize];
};
impl Default for CUpti_ActivityOpenAcc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for OpenACC data.\n\n (CUPTI_ACTIVITY_KIND_OPENACC_DATA)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityOpenAccData {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_OPENACC_DATA."]
    pub kind: CUpti_ActivityKind,
    #[doc = " CUPTI OpenACC event kind (\\see CUpti_OpenAccEventKind)"]
    pub eventKind: CUpti_OpenAccEventKind,
    pub parentConstruct: CUpti_OpenAccConstructKind,
    pub version: u32,
    pub implicit: u32,
    pub deviceType: u32,
    pub deviceNumber: u32,
    #[doc = " ThreadId"]
    pub threadId: u32,
    pub async_: u64,
    pub asyncMap: u64,
    pub lineNo: u32,
    pub endLineNo: u32,
    pub funcLineNo: u32,
    pub funcEndLineNo: u32,
    #[doc = " CUPTI start timestamp"]
    pub start: u64,
    #[doc = " CUPTI end timestamp"]
    pub end: u64,
    #[doc = " CUDA device id\n Valid only if deviceType is acc_device_nvidia."]
    pub cuDeviceId: u32,
    #[doc = " CUDA context id\n Valid only if deviceType is acc_device_nvidia."]
    pub cuContextId: u32,
    #[doc = " CUDA stream id\n Valid only if deviceType is acc_device_nvidia."]
    pub cuStreamId: u32,
    #[doc = " The ID of the process where the OpenACC activity is executing."]
    pub cuProcessId: u32,
    #[doc = " The ID of the thread where the OpenACC activity is executing."]
    pub cuThreadId: u32,
    #[doc = " The OpenACC correlation ID.\n Valid only if deviceType is acc_device_nvidia.\n If not 0, it uniquely identifies this record. It is identical to the\n externalId in the preceding external correlation record of type\n CUPTI_EXTERNAL_CORRELATION_KIND_OPENACC."]
    pub externalId: u32,
    pub srcFile: *const ::std::os::raw::c_char,
    pub funcName: *const ::std::os::raw::c_char,
    #[doc = " Number of bytes"]
    pub bytes: u64,
    #[doc = " Host pointer if available"]
    pub hostPtr: u64,
    #[doc = " Device pointer if available"]
    pub devicePtr: u64,
    pub varName: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityOpenAccData"]
        [::std::mem::size_of::<CUpti_ActivityOpenAccData>() - 152usize];
    ["Alignment of CUpti_ActivityOpenAccData"]
        [::std::mem::align_of::<CUpti_ActivityOpenAccData>() - 8usize];
    ["Offset of field: CUpti_ActivityOpenAccData::kind"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, kind) - 0usize];
    ["Offset of field: CUpti_ActivityOpenAccData::eventKind"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, eventKind) - 4usize];
    ["Offset of field: CUpti_ActivityOpenAccData::parentConstruct"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, parentConstruct) - 8usize];
    ["Offset of field: CUpti_ActivityOpenAccData::version"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, version) - 12usize];
    ["Offset of field: CUpti_ActivityOpenAccData::implicit"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, implicit) - 16usize];
    ["Offset of field: CUpti_ActivityOpenAccData::deviceType"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, deviceType) - 20usize];
    ["Offset of field: CUpti_ActivityOpenAccData::deviceNumber"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, deviceNumber) - 24usize];
    ["Offset of field: CUpti_ActivityOpenAccData::threadId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, threadId) - 28usize];
    ["Offset of field: CUpti_ActivityOpenAccData::async_"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, async_) - 32usize];
    ["Offset of field: CUpti_ActivityOpenAccData::asyncMap"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, asyncMap) - 40usize];
    ["Offset of field: CUpti_ActivityOpenAccData::lineNo"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, lineNo) - 48usize];
    ["Offset of field: CUpti_ActivityOpenAccData::endLineNo"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, endLineNo) - 52usize];
    ["Offset of field: CUpti_ActivityOpenAccData::funcLineNo"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, funcLineNo) - 56usize];
    ["Offset of field: CUpti_ActivityOpenAccData::funcEndLineNo"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, funcEndLineNo) - 60usize];
    ["Offset of field: CUpti_ActivityOpenAccData::start"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, start) - 64usize];
    ["Offset of field: CUpti_ActivityOpenAccData::end"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, end) - 72usize];
    ["Offset of field: CUpti_ActivityOpenAccData::cuDeviceId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, cuDeviceId) - 80usize];
    ["Offset of field: CUpti_ActivityOpenAccData::cuContextId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, cuContextId) - 84usize];
    ["Offset of field: CUpti_ActivityOpenAccData::cuStreamId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, cuStreamId) - 88usize];
    ["Offset of field: CUpti_ActivityOpenAccData::cuProcessId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, cuProcessId) - 92usize];
    ["Offset of field: CUpti_ActivityOpenAccData::cuThreadId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, cuThreadId) - 96usize];
    ["Offset of field: CUpti_ActivityOpenAccData::externalId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, externalId) - 100usize];
    ["Offset of field: CUpti_ActivityOpenAccData::srcFile"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, srcFile) - 104usize];
    ["Offset of field: CUpti_ActivityOpenAccData::funcName"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, funcName) - 112usize];
    ["Offset of field: CUpti_ActivityOpenAccData::bytes"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, bytes) - 120usize];
    ["Offset of field: CUpti_ActivityOpenAccData::hostPtr"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, hostPtr) - 128usize];
    ["Offset of field: CUpti_ActivityOpenAccData::devicePtr"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, devicePtr) - 136usize];
    ["Offset of field: CUpti_ActivityOpenAccData::varName"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccData, varName) - 144usize];
};
impl Default for CUpti_ActivityOpenAccData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for OpenACC launch.\n\n (CUPTI_ACTIVITY_KIND_OPENACC_LAUNCH)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityOpenAccLaunch {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_OPENACC_LAUNCH."]
    pub kind: CUpti_ActivityKind,
    #[doc = " CUPTI OpenACC event kind (\\see CUpti_OpenAccEventKind)"]
    pub eventKind: CUpti_OpenAccEventKind,
    #[doc = " CUPTI OpenACC parent construct kind (\\see CUpti_OpenAccConstructKind)\n\n Note that for applications using PGI OpenACC runtime < 16.1, this\n will always be CUPTI_OPENACC_CONSTRUCT_KIND_UNKNOWN."]
    pub parentConstruct: CUpti_OpenAccConstructKind,
    #[doc = " Version number"]
    pub version: u32,
    #[doc = " 1 for any implicit event, such as an implicit wait at a synchronous data construct\n 0 otherwise"]
    pub implicit: u32,
    #[doc = " Device type"]
    pub deviceType: u32,
    #[doc = " Device number"]
    pub deviceNumber: u32,
    #[doc = " ThreadId"]
    pub threadId: u32,
    #[doc = " Value of async() clause of the corresponding directive"]
    pub async_: u64,
    #[doc = " Internal asynchronous queue number used"]
    pub asyncMap: u64,
    #[doc = " The line number of the directive or program construct or the starting line\n number of the OpenACC construct corresponding to the event.\n A negative or zero value means the line number is not known."]
    pub lineNo: u32,
    #[doc = " For an OpenACC construct, this contains the line number of the end\n of the construct. A negative or zero value means the line number is not known."]
    pub endLineNo: u32,
    #[doc = " The line number of the first line of the function named in func_name.\n A negative or zero value means the line number is not known."]
    pub funcLineNo: u32,
    #[doc = " The last line number of the function named in func_name.\n A negative or zero value means the line number is not known."]
    pub funcEndLineNo: u32,
    #[doc = " CUPTI start timestamp"]
    pub start: u64,
    #[doc = " CUPTI end timestamp"]
    pub end: u64,
    #[doc = " CUDA device id\n Valid only if deviceType is acc_device_nvidia."]
    pub cuDeviceId: u32,
    #[doc = " CUDA context id\n Valid only if deviceType is acc_device_nvidia."]
    pub cuContextId: u32,
    #[doc = " CUDA stream id\n Valid only if deviceType is acc_device_nvidia."]
    pub cuStreamId: u32,
    #[doc = " The ID of the process where the OpenACC activity is executing."]
    pub cuProcessId: u32,
    #[doc = " The ID of the thread where the OpenACC activity is executing."]
    pub cuThreadId: u32,
    #[doc = " The OpenACC correlation ID.\n Valid only if deviceType is acc_device_nvidia.\n If not 0, it uniquely identifies this record. It is identical to the\n externalId in the preceding external correlation record of type\n CUPTI_EXTERNAL_CORRELATION_KIND_OPENACC."]
    pub externalId: u32,
    #[doc = " A pointer to null-terminated string containing the name of or path to\n the source file, if known, or a null pointer if not."]
    pub srcFile: *const ::std::os::raw::c_char,
    #[doc = " A pointer to a null-terminated string containing the name of the\n function in which the event occurred."]
    pub funcName: *const ::std::os::raw::c_char,
    #[doc = " The number of gangs created for this kernel launch"]
    pub numGangs: u64,
    #[doc = " The number of workers created for this kernel launch"]
    pub numWorkers: u64,
    #[doc = " The number of vector lanes created for this kernel launch"]
    pub vectorLength: u64,
    #[doc = " A pointer to null-terminated string containing the name of the\n kernel being launched, if known, or a null pointer if not."]
    pub kernelName: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityOpenAccLaunch"]
        [::std::mem::size_of::<CUpti_ActivityOpenAccLaunch>() - 152usize];
    ["Alignment of CUpti_ActivityOpenAccLaunch"]
        [::std::mem::align_of::<CUpti_ActivityOpenAccLaunch>() - 8usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::kind"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, kind) - 0usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::eventKind"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, eventKind) - 4usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::parentConstruct"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, parentConstruct) - 8usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::version"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, version) - 12usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::implicit"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, implicit) - 16usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::deviceType"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, deviceType) - 20usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::deviceNumber"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, deviceNumber) - 24usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::threadId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, threadId) - 28usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::async_"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, async_) - 32usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::asyncMap"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, asyncMap) - 40usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::lineNo"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, lineNo) - 48usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::endLineNo"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, endLineNo) - 52usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::funcLineNo"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, funcLineNo) - 56usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::funcEndLineNo"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, funcEndLineNo) - 60usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::start"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, start) - 64usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::end"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, end) - 72usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::cuDeviceId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, cuDeviceId) - 80usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::cuContextId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, cuContextId) - 84usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::cuStreamId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, cuStreamId) - 88usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::cuProcessId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, cuProcessId) - 92usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::cuThreadId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, cuThreadId) - 96usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::externalId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, externalId) - 100usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::srcFile"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, srcFile) - 104usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::funcName"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, funcName) - 112usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::numGangs"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, numGangs) - 120usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::numWorkers"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, numWorkers) - 128usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::vectorLength"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, vectorLength) - 136usize];
    ["Offset of field: CUpti_ActivityOpenAccLaunch::kernelName"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccLaunch, kernelName) - 144usize];
};
impl Default for CUpti_ActivityOpenAccLaunch {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for OpenACC other.\n\n (CUPTI_ACTIVITY_KIND_OPENACC_OTHER)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityOpenAccOther {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_OPENACC_OTHER."]
    pub kind: CUpti_ActivityKind,
    #[doc = " CUPTI OpenACC event kind (\\see CUpti_OpenAccEventKind)"]
    pub eventKind: CUpti_OpenAccEventKind,
    #[doc = " CUPTI OpenACC parent construct kind (\\see CUpti_OpenAccConstructKind)\n\n Note that for applications using PGI OpenACC runtime < 16.1, this\n will always be CUPTI_OPENACC_CONSTRUCT_KIND_UNKNOWN."]
    pub parentConstruct: CUpti_OpenAccConstructKind,
    #[doc = " Version number"]
    pub version: u32,
    #[doc = " 1 for any implicit event, such as an implicit wait at a synchronous data construct\n 0 otherwise"]
    pub implicit: u32,
    #[doc = " Device type"]
    pub deviceType: u32,
    #[doc = " Device number"]
    pub deviceNumber: u32,
    #[doc = " ThreadId"]
    pub threadId: u32,
    #[doc = " Value of async() clause of the corresponding directive"]
    pub async_: u64,
    #[doc = " Internal asynchronous queue number used"]
    pub asyncMap: u64,
    #[doc = " The line number of the directive or program construct or the starting line\n number of the OpenACC construct corresponding to the event.\n A negative or zero value means the line number is not known."]
    pub lineNo: u32,
    #[doc = " For an OpenACC construct, this contains the line number of the end\n of the construct. A negative or zero value means the line number is not known."]
    pub endLineNo: u32,
    #[doc = " The line number of the first line of the function named in func_name.\n A negative or zero value means the line number is not known."]
    pub funcLineNo: u32,
    #[doc = " The last line number of the function named in func_name.\n A negative or zero value means the line number is not known."]
    pub funcEndLineNo: u32,
    #[doc = " CUPTI start timestamp"]
    pub start: u64,
    #[doc = " CUPTI end timestamp"]
    pub end: u64,
    #[doc = " CUDA device id\n Valid only if deviceType is acc_device_nvidia."]
    pub cuDeviceId: u32,
    #[doc = " CUDA context id\n Valid only if deviceType is acc_device_nvidia."]
    pub cuContextId: u32,
    #[doc = " CUDA stream id\n Valid only if deviceType is acc_device_nvidia."]
    pub cuStreamId: u32,
    #[doc = " The ID of the process where the OpenACC activity is executing."]
    pub cuProcessId: u32,
    #[doc = " The ID of the thread where the OpenACC activity is executing."]
    pub cuThreadId: u32,
    #[doc = " The OpenACC correlation ID.\n Valid only if deviceType is acc_device_nvidia.\n If not 0, it uniquely identifies this record. It is identical to the\n externalId in the preceding external correlation record of type\n CUPTI_EXTERNAL_CORRELATION_KIND_OPENACC."]
    pub externalId: u32,
    #[doc = " A pointer to null-terminated string containing the name of or path to\n the source file, if known, or a null pointer if not."]
    pub srcFile: *const ::std::os::raw::c_char,
    #[doc = " A pointer to a null-terminated string containing the name of the\n function in which the event occurred."]
    pub funcName: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityOpenAccOther"]
        [::std::mem::size_of::<CUpti_ActivityOpenAccOther>() - 120usize];
    ["Alignment of CUpti_ActivityOpenAccOther"]
        [::std::mem::align_of::<CUpti_ActivityOpenAccOther>() - 8usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::kind"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, kind) - 0usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::eventKind"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, eventKind) - 4usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::parentConstruct"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, parentConstruct) - 8usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::version"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, version) - 12usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::implicit"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, implicit) - 16usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::deviceType"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, deviceType) - 20usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::deviceNumber"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, deviceNumber) - 24usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::threadId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, threadId) - 28usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::async_"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, async_) - 32usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::asyncMap"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, asyncMap) - 40usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::lineNo"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, lineNo) - 48usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::endLineNo"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, endLineNo) - 52usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::funcLineNo"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, funcLineNo) - 56usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::funcEndLineNo"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, funcEndLineNo) - 60usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::start"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, start) - 64usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::end"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, end) - 72usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::cuDeviceId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, cuDeviceId) - 80usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::cuContextId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, cuContextId) - 84usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::cuStreamId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, cuStreamId) - 88usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::cuProcessId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, cuProcessId) - 92usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::cuThreadId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, cuThreadId) - 96usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::externalId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, externalId) - 100usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::srcFile"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, srcFile) - 104usize];
    ["Offset of field: CUpti_ActivityOpenAccOther::funcName"]
        [::std::mem::offset_of!(CUpti_ActivityOpenAccOther, funcName) - 112usize];
};
impl Default for CUpti_ActivityOpenAccOther {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The base activity record for OpenMp records.\n\n \\see CUpti_ActivityKind"]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityOpenMp {
    #[doc = " The kind of this activity."]
    pub kind: CUpti_ActivityKind,
    #[doc = " CUPTI OpenMP event kind (\\see CUpti_OpenMpEventKind)"]
    pub eventKind: CUpti_OpenMpEventKind,
    #[doc = " Version number"]
    pub version: u32,
    #[doc = " ThreadId"]
    pub threadId: u32,
    #[doc = " CUPTI start timestamp"]
    pub start: u64,
    #[doc = " CUPTI end timestamp"]
    pub end: u64,
    #[doc = " The ID of the process where the OpenMP activity is executing."]
    pub cuProcessId: u32,
    #[doc = " The ID of the thread where the OpenMP activity is executing."]
    pub cuThreadId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityOpenMp"][::std::mem::size_of::<CUpti_ActivityOpenMp>() - 40usize];
    ["Alignment of CUpti_ActivityOpenMp"][::std::mem::align_of::<CUpti_ActivityOpenMp>() - 8usize];
    ["Offset of field: CUpti_ActivityOpenMp::kind"]
        [::std::mem::offset_of!(CUpti_ActivityOpenMp, kind) - 0usize];
    ["Offset of field: CUpti_ActivityOpenMp::eventKind"]
        [::std::mem::offset_of!(CUpti_ActivityOpenMp, eventKind) - 4usize];
    ["Offset of field: CUpti_ActivityOpenMp::version"]
        [::std::mem::offset_of!(CUpti_ActivityOpenMp, version) - 8usize];
    ["Offset of field: CUpti_ActivityOpenMp::threadId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenMp, threadId) - 12usize];
    ["Offset of field: CUpti_ActivityOpenMp::start"]
        [::std::mem::offset_of!(CUpti_ActivityOpenMp, start) - 16usize];
    ["Offset of field: CUpti_ActivityOpenMp::end"]
        [::std::mem::offset_of!(CUpti_ActivityOpenMp, end) - 24usize];
    ["Offset of field: CUpti_ActivityOpenMp::cuProcessId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenMp, cuProcessId) - 32usize];
    ["Offset of field: CUpti_ActivityOpenMp::cuThreadId"]
        [::std::mem::offset_of!(CUpti_ActivityOpenMp, cuThreadId) - 36usize];
};
impl Default for CUpti_ActivityOpenMp {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CUPTI_EXTERNAL_CORRELATION_KIND_INVALID: CUpti_ExternalCorrelationKind = 0;
#[doc = " The external API is unknown to CUPTI"]
pub const CUPTI_EXTERNAL_CORRELATION_KIND_UNKNOWN: CUpti_ExternalCorrelationKind = 1;
#[doc = " The external API is OpenACC"]
pub const CUPTI_EXTERNAL_CORRELATION_KIND_OPENACC: CUpti_ExternalCorrelationKind = 2;
#[doc = " The external API is custom0"]
pub const CUPTI_EXTERNAL_CORRELATION_KIND_CUSTOM0: CUpti_ExternalCorrelationKind = 3;
#[doc = " The external API is custom1"]
pub const CUPTI_EXTERNAL_CORRELATION_KIND_CUSTOM1: CUpti_ExternalCorrelationKind = 4;
#[doc = " The external API is custom2"]
pub const CUPTI_EXTERNAL_CORRELATION_KIND_CUSTOM2: CUpti_ExternalCorrelationKind = 5;
#[doc = " Add new kinds before this line"]
pub const CUPTI_EXTERNAL_CORRELATION_KIND_SIZE: CUpti_ExternalCorrelationKind = 6;
#[doc = " Add new kinds before this line"]
pub const CUPTI_EXTERNAL_CORRELATION_KIND_FORCE_INT: CUpti_ExternalCorrelationKind = 2147483647;
#[doc = " \\brief The kind of external APIs supported for correlation.\n\n Custom correlation kinds are reserved for usage in external tools.\n\n \\see CUpti_ActivityExternalCorrelation"]
pub type CUpti_ExternalCorrelationKind = ::std::os::raw::c_uint;
#[doc = " \\brief The activity record for correlation with external records\n\n This activity record correlates native CUDA records (e.g. CUDA Driver API,\n kernels, memcpys, ...) with records from external APIs such as OpenACC.\n (CUPTI_ACTIVITY_KIND_EXTERNAL_CORRELATION).\n\n \\see CUpti_ActivityKind"]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityExternalCorrelation {
    #[doc = " The kind of this activity."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The kind of external API this record correlated to."]
    pub externalKind: CUpti_ExternalCorrelationKind,
    #[doc = " The correlation ID of the associated non-CUDA API record.\n The exact field in the associated external record depends\n on that record's activity kind (\\see externalKind)."]
    pub externalId: u64,
    #[doc = " The correlation ID of the associated CUDA driver or runtime API record."]
    pub correlationId: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityExternalCorrelation"]
        [::std::mem::size_of::<CUpti_ActivityExternalCorrelation>() - 24usize];
    ["Alignment of CUpti_ActivityExternalCorrelation"]
        [::std::mem::align_of::<CUpti_ActivityExternalCorrelation>() - 8usize];
    ["Offset of field: CUpti_ActivityExternalCorrelation::kind"]
        [::std::mem::offset_of!(CUpti_ActivityExternalCorrelation, kind) - 0usize];
    ["Offset of field: CUpti_ActivityExternalCorrelation::externalKind"]
        [::std::mem::offset_of!(CUpti_ActivityExternalCorrelation, externalKind) - 4usize];
    ["Offset of field: CUpti_ActivityExternalCorrelation::externalId"]
        [::std::mem::offset_of!(CUpti_ActivityExternalCorrelation, externalId) - 8usize];
    ["Offset of field: CUpti_ActivityExternalCorrelation::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityExternalCorrelation, correlationId) - 16usize];
    ["Offset of field: CUpti_ActivityExternalCorrelation::reserved"]
        [::std::mem::offset_of!(CUpti_ActivityExternalCorrelation, reserved) - 20usize];
};
impl Default for CUpti_ActivityExternalCorrelation {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CUPTI_DEV_TYPE_INVALID: CUpti_DevType = 0;
#[doc = " The device type is GPU."]
pub const CUPTI_DEV_TYPE_GPU: CUpti_DevType = 1;
#[doc = " The device type is NVLink processing unit in CPU."]
pub const CUPTI_DEV_TYPE_NPU: CUpti_DevType = 2;
#[doc = " The device type is NVLink processing unit in CPU."]
pub const CUPTI_DEV_TYPE_FORCE_INT: CUpti_DevType = 2147483647;
#[doc = " \\brief The device type for device connected to NVLink."]
pub type CUpti_DevType = ::std::os::raw::c_uint;
#[doc = " \\brief NVLink information.\n\n This structure gives capabilities of each logical NVLink connection between two devices,\n gpu<->gpu or gpu<->CPU which can be used to understand the topology."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityNvLink4 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_NVLINK."]
    pub kind: CUpti_ActivityKind,
    #[doc = " NvLink version."]
    pub nvlinkVersion: u32,
    #[doc = " Type of device 0 \\ref CUpti_DevType"]
    pub typeDev0: CUpti_DevType,
    #[doc = " Type of device 1 \\ref CUpti_DevType"]
    pub typeDev1: CUpti_DevType,
    pub idDev0: CUpti_ActivityNvLink4__bindgen_ty_1,
    pub idDev1: CUpti_ActivityNvLink4__bindgen_ty_2,
    #[doc = " Flag gives capabilities of the link \\see CUpti_LinkFlag"]
    pub flag: u32,
    #[doc = " Number of physical NVLinks present between two devices."]
    pub physicalNvLinkCount: u32,
    #[doc = " Port numbers for maximum 32 NVLinks connected to device 0.\n If typeDev0 is CUPTI_DEV_TYPE_NPU, ignore this field.\n In case of invalid/unknown port number, this field will be set\n to value CUPTI_NVLINK_INVALID_PORT.\n This will be used to correlate the metric values to individual\n physical link and attribute traffic to the logical NVLink in\n the topology."]
    pub portDev0: [i8; 32usize],
    #[doc = " Port numbers for maximum 32 NVLinks connected to device 1.\n If typeDev1 is CUPTI_DEV_TYPE_NPU, ignore this field.\n In case of invalid/unknown port number, this field will be set\n to value CUPTI_NVLINK_INVALID_PORT.\n This will be used to correlate the metric values to individual\n physical link and attribute traffic to the logical NVLink in\n the topology."]
    pub portDev1: [i8; 32usize],
    #[doc = " Bandwidth of NVLink in kbytes/sec"]
    pub bandwidth: u64,
    #[doc = " NVSwitch is connected as an intermediate node."]
    pub nvswitchConnected: u8,
    #[doc = " Undefined. reserved for internal use"]
    pub pad: [u8; 7usize],
}
#[doc = " If typeDev0 is CUPTI_DEV_TYPE_GPU, UUID for device 0. \\ref CUpti_ActivityDevice5.\n If typeDev0 is CUPTI_DEV_TYPE_NPU, struct npu for NPU."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityNvLink4__bindgen_ty_1 {
    pub uuidDev: CUuuid,
    pub npu: CUpti_ActivityNvLink4__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityNvLink4__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Index of the NPU. First index will always be zero."]
    pub index: u32,
    #[doc = " Domain ID of NPU. On Linux, this can be queried using lspci."]
    pub domainId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityNvLink4__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityNvLink4__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of CUpti_ActivityNvLink4__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityNvLink4__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: CUpti_ActivityNvLink4__bindgen_ty_1__bindgen_ty_1::index"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink4__bindgen_ty_1__bindgen_ty_1, index) - 0usize];
    ["Offset of field: CUpti_ActivityNvLink4__bindgen_ty_1__bindgen_ty_1::domainId"][::std::mem::offset_of!(
        CUpti_ActivityNvLink4__bindgen_ty_1__bindgen_ty_1,
        domainId
    ) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityNvLink4__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityNvLink4__bindgen_ty_1>() - 16usize];
    ["Alignment of CUpti_ActivityNvLink4__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityNvLink4__bindgen_ty_1>() - 4usize];
    ["Offset of field: CUpti_ActivityNvLink4__bindgen_ty_1::uuidDev"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink4__bindgen_ty_1, uuidDev) - 0usize];
    ["Offset of field: CUpti_ActivityNvLink4__bindgen_ty_1::npu"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink4__bindgen_ty_1, npu) - 0usize];
};
impl Default for CUpti_ActivityNvLink4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink4__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityNvLink4__bindgen_ty_1 {{ union }}")
    }
}
#[doc = " If typeDev1 is CUPTI_DEV_TYPE_GPU, UUID for device 1. \\ref CUpti_ActivityDevice5.\n If typeDev1 is CUPTI_DEV_TYPE_NPU, struct npu for NPU."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityNvLink4__bindgen_ty_2 {
    pub uuidDev: CUuuid,
    pub npu: CUpti_ActivityNvLink4__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityNvLink4__bindgen_ty_2__bindgen_ty_1 {
    #[doc = " Index of the NPU. First index will always be zero."]
    pub index: u32,
    #[doc = " Domain ID of NPU. On Linux, this can be queried using lspci."]
    pub domainId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityNvLink4__bindgen_ty_2__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityNvLink4__bindgen_ty_2__bindgen_ty_1>() - 8usize];
    ["Alignment of CUpti_ActivityNvLink4__bindgen_ty_2__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityNvLink4__bindgen_ty_2__bindgen_ty_1>() - 4usize];
    ["Offset of field: CUpti_ActivityNvLink4__bindgen_ty_2__bindgen_ty_1::index"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink4__bindgen_ty_2__bindgen_ty_1, index) - 0usize];
    ["Offset of field: CUpti_ActivityNvLink4__bindgen_ty_2__bindgen_ty_1::domainId"][::std::mem::offset_of!(
        CUpti_ActivityNvLink4__bindgen_ty_2__bindgen_ty_1,
        domainId
    ) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityNvLink4__bindgen_ty_2"]
        [::std::mem::size_of::<CUpti_ActivityNvLink4__bindgen_ty_2>() - 16usize];
    ["Alignment of CUpti_ActivityNvLink4__bindgen_ty_2"]
        [::std::mem::align_of::<CUpti_ActivityNvLink4__bindgen_ty_2>() - 4usize];
    ["Offset of field: CUpti_ActivityNvLink4__bindgen_ty_2::uuidDev"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink4__bindgen_ty_2, uuidDev) - 0usize];
    ["Offset of field: CUpti_ActivityNvLink4__bindgen_ty_2::npu"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink4__bindgen_ty_2, npu) - 0usize];
};
impl Default for CUpti_ActivityNvLink4__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink4__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityNvLink4__bindgen_ty_2 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityNvLink4"][::std::mem::size_of::<CUpti_ActivityNvLink4>() - 136usize];
    ["Alignment of CUpti_ActivityNvLink4"]
        [::std::mem::align_of::<CUpti_ActivityNvLink4>() - 8usize];
    ["Offset of field: CUpti_ActivityNvLink4::kind"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink4, kind) - 0usize];
    ["Offset of field: CUpti_ActivityNvLink4::nvlinkVersion"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink4, nvlinkVersion) - 4usize];
    ["Offset of field: CUpti_ActivityNvLink4::typeDev0"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink4, typeDev0) - 8usize];
    ["Offset of field: CUpti_ActivityNvLink4::typeDev1"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink4, typeDev1) - 12usize];
    ["Offset of field: CUpti_ActivityNvLink4::idDev0"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink4, idDev0) - 16usize];
    ["Offset of field: CUpti_ActivityNvLink4::idDev1"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink4, idDev1) - 32usize];
    ["Offset of field: CUpti_ActivityNvLink4::flag"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink4, flag) - 48usize];
    ["Offset of field: CUpti_ActivityNvLink4::physicalNvLinkCount"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink4, physicalNvLinkCount) - 52usize];
    ["Offset of field: CUpti_ActivityNvLink4::portDev0"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink4, portDev0) - 56usize];
    ["Offset of field: CUpti_ActivityNvLink4::portDev1"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink4, portDev1) - 88usize];
    ["Offset of field: CUpti_ActivityNvLink4::bandwidth"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink4, bandwidth) - 120usize];
    ["Offset of field: CUpti_ActivityNvLink4::nvswitchConnected"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink4, nvswitchConnected) - 128usize];
    ["Offset of field: CUpti_ActivityNvLink4::pad"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink4, pad) - 129usize];
};
impl Default for CUpti_ActivityNvLink4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink4 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityNvLink4 {{ kind: {:?}, typeDev0: {:?}, typeDev1: {:?}, idDev0: {:?}, idDev1: {:?}, portDev0: {:?}, portDev1: {:?}, pad: {:?} }}",
            self.kind,
            self.typeDev0,
            self.typeDev1,
            self.idDev0,
            self.idDev1,
            self.portDev0,
            self.portDev1,
            self.pad
        )
    }
}
#[doc = " PCIE GPU record"]
pub const CUPTI_PCIE_DEVICE_TYPE_GPU: CUpti_PcieDeviceType = 0;
#[doc = " PCIE Bridge record"]
pub const CUPTI_PCIE_DEVICE_TYPE_BRIDGE: CUpti_PcieDeviceType = 1;
#[doc = " PCIE Bridge record"]
pub const CUPTI_PCIE_DEVICE_TYPE_FORCE_INT: CUpti_PcieDeviceType = 2147483647;
#[doc = " Field to differentiate whether PCIE Activity record\n is of a GPU or a PCI Bridge"]
pub type CUpti_PcieDeviceType = ::std::os::raw::c_uint;
#[doc = " \\brief PCI devices information required to construct topology\n\n This structure gives capabilities of GPU and PCI bridge connected to the PCIE bus\n which can be used to understand the topology."]
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityPcie {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_PCIE."]
    pub kind: CUpti_ActivityKind,
    #[doc = " Type of device in topology, \\ref CUpti_PcieDeviceType. If type is\n CUPTI_PCIE_DEVICE_TYPE_GPU use devId for id and gpuAttr and if type is\n CUPTI_PCIE_DEVICE_TYPE_BRIDGE use bridgeId for id and bridgeAttr."]
    pub type_: CUpti_PcieDeviceType,
    pub id: CUpti_ActivityPcie__bindgen_ty_1,
    #[doc = " Domain for the GPU or Bridge, required to identify which PCIE bus it belongs to in\n multiple NUMA systems."]
    pub domain: u32,
    #[doc = " PCIE Generation of GPU or Bridge."]
    pub pcieGeneration: u16,
    #[doc = " Link rate of the GPU or bridge in gigatransfers per second (GT/s)"]
    pub linkRate: u16,
    #[doc = " Link width of the GPU or bridge"]
    pub linkWidth: u16,
    #[doc = " Upstream bus ID for the GPU or PCI bridge. Required to identify which bus it is\n connected to in the topology."]
    pub upstreamBus: u16,
    pub attr: CUpti_ActivityPcie__bindgen_ty_2,
}
#[doc = " A unique identifier for GPU or Bridge in Topology"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityPcie__bindgen_ty_1 {
    #[doc = " GPU device ID"]
    pub devId: CUdevice,
    #[doc = " A unique identifier for Bridge in the Topology"]
    pub bridgeId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityPcie__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityPcie__bindgen_ty_1>() - 4usize];
    ["Alignment of CUpti_ActivityPcie__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityPcie__bindgen_ty_1>() - 4usize];
    ["Offset of field: CUpti_ActivityPcie__bindgen_ty_1::devId"]
        [::std::mem::offset_of!(CUpti_ActivityPcie__bindgen_ty_1, devId) - 0usize];
    ["Offset of field: CUpti_ActivityPcie__bindgen_ty_1::bridgeId"]
        [::std::mem::offset_of!(CUpti_ActivityPcie__bindgen_ty_1, bridgeId) - 0usize];
};
impl Default for CUpti_ActivityPcie__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityPcie__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityPcie__bindgen_ty_1 {{ union }}")
    }
}
#[doc = " Attributes for more information about GPU (gpuAttr) or PCI Bridge (bridgeAttr)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityPcie__bindgen_ty_2 {
    pub gpuAttr: CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_1,
    pub bridgeAttr: CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_1 {
    #[doc = " UUID for the device. \\ref CUpti_ActivityDevice5."]
    pub uuidDev: CUuuid,
    #[doc = " CUdevice with which this device has P2P capability.\n This can also be obtained by querying cuDeviceCanAccessPeer or\n cudaDeviceCanAccessPeer APIs"]
    pub peerDev: [CUdevice; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_1>() - 144usize];
    ["Alignment of CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_1>() - 4usize];
    ["Offset of field: CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_1::uuidDev"]
        [::std::mem::offset_of!(CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_1, uuidDev) - 0usize];
    ["Offset of field: CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_1::peerDev"]
        [::std::mem::offset_of!(CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_1, peerDev) - 16usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2 {
    #[doc = " The downstream bus number, used to search downstream devices/bridges connected\n to this bridge."]
    pub secondaryBus: u16,
    #[doc = " Device ID of the bridge"]
    pub deviceId: u16,
    #[doc = " Vendor ID of the bridge"]
    pub vendorId: u16,
    #[doc = " Padding for alignment"]
    pub pad0: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2"]
        [::std::mem::size_of::<CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2>() - 8usize];
    ["Alignment of CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2"]
        [::std::mem::align_of::<CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2>() - 2usize];
    ["Offset of field: CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2::secondaryBus"][::std::mem::offset_of!(
        CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2,
        secondaryBus
    ) - 0usize];
    ["Offset of field: CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2, deviceId) - 2usize];
    ["Offset of field: CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2::vendorId"]
        [::std::mem::offset_of!(CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2, vendorId) - 4usize];
    ["Offset of field: CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2::pad0"]
        [::std::mem::offset_of!(CUpti_ActivityPcie__bindgen_ty_2__bindgen_ty_2, pad0) - 6usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityPcie__bindgen_ty_2"]
        [::std::mem::size_of::<CUpti_ActivityPcie__bindgen_ty_2>() - 144usize];
    ["Alignment of CUpti_ActivityPcie__bindgen_ty_2"]
        [::std::mem::align_of::<CUpti_ActivityPcie__bindgen_ty_2>() - 4usize];
    ["Offset of field: CUpti_ActivityPcie__bindgen_ty_2::gpuAttr"]
        [::std::mem::offset_of!(CUpti_ActivityPcie__bindgen_ty_2, gpuAttr) - 0usize];
    ["Offset of field: CUpti_ActivityPcie__bindgen_ty_2::bridgeAttr"]
        [::std::mem::offset_of!(CUpti_ActivityPcie__bindgen_ty_2, bridgeAttr) - 0usize];
};
impl Default for CUpti_ActivityPcie__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityPcie__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityPcie__bindgen_ty_2 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityPcie"][::std::mem::size_of::<CUpti_ActivityPcie>() - 168usize];
    ["Alignment of CUpti_ActivityPcie"][::std::mem::align_of::<CUpti_ActivityPcie>() - 8usize];
    ["Offset of field: CUpti_ActivityPcie::kind"]
        [::std::mem::offset_of!(CUpti_ActivityPcie, kind) - 0usize];
    ["Offset of field: CUpti_ActivityPcie::type_"]
        [::std::mem::offset_of!(CUpti_ActivityPcie, type_) - 4usize];
    ["Offset of field: CUpti_ActivityPcie::id"]
        [::std::mem::offset_of!(CUpti_ActivityPcie, id) - 8usize];
    ["Offset of field: CUpti_ActivityPcie::domain"]
        [::std::mem::offset_of!(CUpti_ActivityPcie, domain) - 12usize];
    ["Offset of field: CUpti_ActivityPcie::pcieGeneration"]
        [::std::mem::offset_of!(CUpti_ActivityPcie, pcieGeneration) - 16usize];
    ["Offset of field: CUpti_ActivityPcie::linkRate"]
        [::std::mem::offset_of!(CUpti_ActivityPcie, linkRate) - 18usize];
    ["Offset of field: CUpti_ActivityPcie::linkWidth"]
        [::std::mem::offset_of!(CUpti_ActivityPcie, linkWidth) - 20usize];
    ["Offset of field: CUpti_ActivityPcie::upstreamBus"]
        [::std::mem::offset_of!(CUpti_ActivityPcie, upstreamBus) - 22usize];
    ["Offset of field: CUpti_ActivityPcie::attr"]
        [::std::mem::offset_of!(CUpti_ActivityPcie, attr) - 24usize];
};
impl Default for CUpti_ActivityPcie {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityPcie {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityPcie {{ kind: {:?}, type: {:?}, id: {:?}, attr: {:?} }}",
            self.kind, self.type_, self.id, self.attr
        )
    }
}
#[doc = " PCIE Generation 1"]
pub const CUPTI_PCIE_GEN_GEN1: CUpti_PcieGen = 1;
#[doc = " PCIE Generation 2"]
pub const CUPTI_PCIE_GEN_GEN2: CUpti_PcieGen = 2;
#[doc = " PCIE Generation 3"]
pub const CUPTI_PCIE_GEN_GEN3: CUpti_PcieGen = 3;
#[doc = " PCIE Generation 4"]
pub const CUPTI_PCIE_GEN_GEN4: CUpti_PcieGen = 4;
#[doc = " PCIE Generation 5"]
pub const CUPTI_PCIE_GEN_GEN5: CUpti_PcieGen = 5;
#[doc = " PCIE Generation 6"]
pub const CUPTI_PCIE_GEN_GEN6: CUpti_PcieGen = 6;
#[doc = " PCIE Generation 6"]
pub const CUPTI_PCIE_GEN_FORCE_INT: CUpti_PcieGen = 2147483647;
#[doc = " \\brief PCIE Generation.\n\n Enumeration of PCIE Generation for\n pcie activity attribute pcieGeneration"]
pub type CUpti_PcieGen = ::std::os::raw::c_uint;
pub const CUPTI_CONFIDENTIAL_COMPUTE_INVALID_ROTATION_EVENT:
    CUpti_ConfidentialComputeRotationEventType = 0;
#[doc = " This channel has been blocked from accepting new CUDA work so a key rotation can be done."]
pub const CUPTI_CONFIDENTIAL_COMPUTE_KEY_ROTATION_CHANNEL_BLOCKED:
    CUpti_ConfidentialComputeRotationEventType = 1;
#[doc = " This channel remains blocked and all queued CUDA work has completed.\n Other clients or channels may cause delays in starting the key rotation."]
pub const CUPTI_CONFIDENTIAL_COMPUTE_KEY_ROTATION_CHANNEL_DRAINED:
    CUpti_ConfidentialComputeRotationEventType = 2;
#[doc = " Key rotations have completed and this channel is unblocked."]
pub const CUPTI_CONFIDENTIAL_COMPUTE_KEY_ROTATION_CHANNEL_UNBLOCKED:
    CUpti_ConfidentialComputeRotationEventType = 3;
#[doc = " Key rotations have completed and this channel is unblocked."]
pub const CUPTI_CONFIDENTIAL_COMPUTE_EVENT_TYPE_FORCE_INT:
    CUpti_ConfidentialComputeRotationEventType = 2147483647;
pub type CUpti_ConfidentialComputeRotationEventType = ::std::os::raw::c_uint;
#[doc = " \\brief Event related to confidential compute encryption rotation\n\n This structure gives timestamps for stages of encryption rotation"]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityConfidentialComputeRotation {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_CONFIDENTIAL_COMPUTE_ROTATION."]
    pub kind: CUpti_ActivityKind,
    #[doc = " Type of event \\ref CUpti_ConfidentialComputeRotationEventType"]
    pub eventType: CUpti_ConfidentialComputeRotationEventType,
    #[doc = " Device ID"]
    pub deviceId: u32,
    #[doc = " Context ID"]
    pub contextId: u32,
    #[doc = " Channel ID"]
    pub channelId: u32,
    #[doc = " Channel Type \\ref CUpti_ChannelType"]
    pub channelType: CUpti_ChannelType,
    #[doc = " Timestamp in ns"]
    pub timestamp: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityConfidentialComputeRotation"]
        [::std::mem::size_of::<CUpti_ActivityConfidentialComputeRotation>() - 32usize];
    ["Alignment of CUpti_ActivityConfidentialComputeRotation"]
        [::std::mem::align_of::<CUpti_ActivityConfidentialComputeRotation>() - 8usize];
    ["Offset of field: CUpti_ActivityConfidentialComputeRotation::kind"]
        [::std::mem::offset_of!(CUpti_ActivityConfidentialComputeRotation, kind) - 0usize];
    ["Offset of field: CUpti_ActivityConfidentialComputeRotation::eventType"]
        [::std::mem::offset_of!(CUpti_ActivityConfidentialComputeRotation, eventType) - 4usize];
    ["Offset of field: CUpti_ActivityConfidentialComputeRotation::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityConfidentialComputeRotation, deviceId) - 8usize];
    ["Offset of field: CUpti_ActivityConfidentialComputeRotation::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityConfidentialComputeRotation, contextId) - 12usize];
    ["Offset of field: CUpti_ActivityConfidentialComputeRotation::channelId"]
        [::std::mem::offset_of!(CUpti_ActivityConfidentialComputeRotation, channelId) - 16usize];
    ["Offset of field: CUpti_ActivityConfidentialComputeRotation::channelType"]
        [::std::mem::offset_of!(CUpti_ActivityConfidentialComputeRotation, channelType) - 20usize];
    ["Offset of field: CUpti_ActivityConfidentialComputeRotation::timestamp"]
        [::std::mem::offset_of!(CUpti_ActivityConfidentialComputeRotation, timestamp) - 24usize];
};
impl Default for CUpti_ActivityConfidentialComputeRotation {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for an instantaneous CUPTI event.\n\n This activity record represents a CUPTI event value\n (CUPTI_ACTIVITY_KIND_EVENT) sampled at a particular instant.\n This activity record kind is not produced by the activity API but is\n included for completeness and ease-of-use. Profiler frameworks built on\n top of CUPTI that collect event data at a particular time may choose to\n use this type to store the collected event data."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityInstantaneousEvent {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_INSTANTANEOUS_EVENT."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The event ID."]
    pub id: CUpti_EventID,
    #[doc = " The event value."]
    pub value: u64,
    #[doc = " The timestamp at which event is sampled"]
    pub timestamp: u64,
    #[doc = " The device id"]
    pub deviceId: u32,
    #[doc = " Undefined. reserved for internal use"]
    pub reserved: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityInstantaneousEvent"]
        [::std::mem::size_of::<CUpti_ActivityInstantaneousEvent>() - 32usize];
    ["Alignment of CUpti_ActivityInstantaneousEvent"]
        [::std::mem::align_of::<CUpti_ActivityInstantaneousEvent>() - 8usize];
    ["Offset of field: CUpti_ActivityInstantaneousEvent::kind"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousEvent, kind) - 0usize];
    ["Offset of field: CUpti_ActivityInstantaneousEvent::id"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousEvent, id) - 4usize];
    ["Offset of field: CUpti_ActivityInstantaneousEvent::value"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousEvent, value) - 8usize];
    ["Offset of field: CUpti_ActivityInstantaneousEvent::timestamp"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousEvent, timestamp) - 16usize];
    ["Offset of field: CUpti_ActivityInstantaneousEvent::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousEvent, deviceId) - 24usize];
    ["Offset of field: CUpti_ActivityInstantaneousEvent::reserved"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousEvent, reserved) - 28usize];
};
impl Default for CUpti_ActivityInstantaneousEvent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for an instantaneous CUPTI event\n with event domain instance information.\n\n This activity record represents the a CUPTI event value for a\n specific event domain instance\n (CUPTI_ACTIVITY_KIND_EVENT_INSTANCE) sampled at a particular instant.\n This activity record kind is not produced by the activity API but is\n included for completeness and ease-of-use. Profiler frameworks built on\n top of CUPTI that collect event data may choose to use this type to store the\n collected event data. This activity record should be used when\n event domain instance information needs to be associated with the\n event."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityInstantaneousEventInstance {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_INSTANTANEOUS_EVENT_INSTANCE."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The event ID."]
    pub id: CUpti_EventID,
    #[doc = " The event value."]
    pub value: u64,
    #[doc = " The timestamp at which event is sampled"]
    pub timestamp: u64,
    #[doc = " The device id"]
    pub deviceId: u32,
    #[doc = " The event domain instance"]
    pub instance: u8,
    #[doc = " Undefined. reserved for internal use"]
    pub pad: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityInstantaneousEventInstance"]
        [::std::mem::size_of::<CUpti_ActivityInstantaneousEventInstance>() - 32usize];
    ["Alignment of CUpti_ActivityInstantaneousEventInstance"]
        [::std::mem::align_of::<CUpti_ActivityInstantaneousEventInstance>() - 8usize];
    ["Offset of field: CUpti_ActivityInstantaneousEventInstance::kind"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousEventInstance, kind) - 0usize];
    ["Offset of field: CUpti_ActivityInstantaneousEventInstance::id"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousEventInstance, id) - 4usize];
    ["Offset of field: CUpti_ActivityInstantaneousEventInstance::value"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousEventInstance, value) - 8usize];
    ["Offset of field: CUpti_ActivityInstantaneousEventInstance::timestamp"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousEventInstance, timestamp) - 16usize];
    ["Offset of field: CUpti_ActivityInstantaneousEventInstance::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousEventInstance, deviceId) - 24usize];
    ["Offset of field: CUpti_ActivityInstantaneousEventInstance::instance"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousEventInstance, instance) - 28usize];
    ["Offset of field: CUpti_ActivityInstantaneousEventInstance::pad"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousEventInstance, pad) - 29usize];
};
impl Default for CUpti_ActivityInstantaneousEventInstance {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for an instantaneous CUPTI metric.\n\n This activity record represents the collection of a CUPTI metric\n value (CUPTI_ACTIVITY_KIND_METRIC) at a particular instance.\n This activity record kind is not produced by the activity API but\n is included for completeness and ease-of-use. Profiler frameworks built\n on top of CUPTI that collect metric data may choose to use this type to\n store the collected metric data."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityInstantaneousMetric {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_INSTANTANEOUS_METRIC."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The metric ID."]
    pub id: CUpti_MetricID,
    #[doc = " The metric value."]
    pub value: CUpti_MetricValue,
    #[doc = " The timestamp at which metric is sampled"]
    pub timestamp: u64,
    #[doc = " The device id"]
    pub deviceId: u32,
    #[doc = " The properties of this metric. \\see CUpti_ActivityFlag"]
    pub flags: u8,
    #[doc = " Undefined. reserved for internal use"]
    pub pad: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityInstantaneousMetric"]
        [::std::mem::size_of::<CUpti_ActivityInstantaneousMetric>() - 32usize];
    ["Alignment of CUpti_ActivityInstantaneousMetric"]
        [::std::mem::align_of::<CUpti_ActivityInstantaneousMetric>() - 8usize];
    ["Offset of field: CUpti_ActivityInstantaneousMetric::kind"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousMetric, kind) - 0usize];
    ["Offset of field: CUpti_ActivityInstantaneousMetric::id"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousMetric, id) - 4usize];
    ["Offset of field: CUpti_ActivityInstantaneousMetric::value"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousMetric, value) - 8usize];
    ["Offset of field: CUpti_ActivityInstantaneousMetric::timestamp"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousMetric, timestamp) - 16usize];
    ["Offset of field: CUpti_ActivityInstantaneousMetric::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousMetric, deviceId) - 24usize];
    ["Offset of field: CUpti_ActivityInstantaneousMetric::flags"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousMetric, flags) - 28usize];
    ["Offset of field: CUpti_ActivityInstantaneousMetric::pad"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousMetric, pad) - 29usize];
};
impl Default for CUpti_ActivityInstantaneousMetric {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityInstantaneousMetric {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityInstantaneousMetric {{ kind: {:?}, value: {:?}, pad: {:?} }}",
            self.kind, self.value, self.pad
        )
    }
}
#[doc = " \\brief The instantaneous activity record for a CUPTI metric with instance\n information.\n\n This activity record represents a CUPTI metric value\n for a specific metric domain instance\n (CUPTI_ACTIVITY_KIND_METRIC_INSTANCE) sampled at a particular time. This\n activity record kind is not produced by the activity API but is included for\n completeness and ease-of-use. Profiler frameworks built on top of\n CUPTI that collect metric data may choose to use this type to store\n the collected metric data. This activity record should be used when\n metric domain instance information needs to be associated with the\n metric."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityInstantaneousMetricInstance {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_INSTANTANEOUS_METRIC_INSTANCE."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The metric ID."]
    pub id: CUpti_MetricID,
    #[doc = " The metric value."]
    pub value: CUpti_MetricValue,
    #[doc = " The timestamp at which metric is sampled"]
    pub timestamp: u64,
    #[doc = " The device id"]
    pub deviceId: u32,
    #[doc = " The properties of this metric. \\see CUpti_ActivityFlag"]
    pub flags: u8,
    #[doc = " The metric domain instance"]
    pub instance: u8,
    #[doc = " Undefined. reserved for internal use"]
    pub pad: [u8; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityInstantaneousMetricInstance"]
        [::std::mem::size_of::<CUpti_ActivityInstantaneousMetricInstance>() - 32usize];
    ["Alignment of CUpti_ActivityInstantaneousMetricInstance"]
        [::std::mem::align_of::<CUpti_ActivityInstantaneousMetricInstance>() - 8usize];
    ["Offset of field: CUpti_ActivityInstantaneousMetricInstance::kind"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousMetricInstance, kind) - 0usize];
    ["Offset of field: CUpti_ActivityInstantaneousMetricInstance::id"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousMetricInstance, id) - 4usize];
    ["Offset of field: CUpti_ActivityInstantaneousMetricInstance::value"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousMetricInstance, value) - 8usize];
    ["Offset of field: CUpti_ActivityInstantaneousMetricInstance::timestamp"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousMetricInstance, timestamp) - 16usize];
    ["Offset of field: CUpti_ActivityInstantaneousMetricInstance::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousMetricInstance, deviceId) - 24usize];
    ["Offset of field: CUpti_ActivityInstantaneousMetricInstance::flags"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousMetricInstance, flags) - 28usize];
    ["Offset of field: CUpti_ActivityInstantaneousMetricInstance::instance"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousMetricInstance, instance) - 29usize];
    ["Offset of field: CUpti_ActivityInstantaneousMetricInstance::pad"]
        [::std::mem::offset_of!(CUpti_ActivityInstantaneousMetricInstance, pad) - 30usize];
};
impl Default for CUpti_ActivityInstantaneousMetricInstance {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityInstantaneousMetricInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityInstantaneousMetricInstance {{ kind: {:?}, value: {:?}, pad: {:?} }}",
            self.kind, self.value, self.pad
        )
    }
}
pub const CUPTI_ACTIVITY_JIT_ENTRY_INVALID: CUpti_ActivityJitEntryType = 0;
#[doc = " PTX to CUBIN."]
pub const CUPTI_ACTIVITY_JIT_ENTRY_PTX_TO_CUBIN: CUpti_ActivityJitEntryType = 1;
#[doc = " NVVM-IR to PTX"]
pub const CUPTI_ACTIVITY_JIT_ENTRY_NVVM_IR_TO_PTX: CUpti_ActivityJitEntryType = 2;
#[doc = " NVVM-IR to PTX"]
pub const CUPTI_ACTIVITY_JIT_ENTRY_TYPE_FORCE_INT: CUpti_ActivityJitEntryType = 2147483647;
#[doc = " \\brief The types of JIT entry.\n\n To be used in CUpti_ActivityJit."]
pub type CUpti_ActivityJitEntryType = ::std::os::raw::c_uint;
pub const CUPTI_ACTIVITY_JIT_OPERATION_INVALID: CUpti_ActivityJitOperationType = 0;
#[doc = " Loaded from the compute cache."]
pub const CUPTI_ACTIVITY_JIT_OPERATION_CACHE_LOAD: CUpti_ActivityJitOperationType = 1;
#[doc = " Stored in the compute cache."]
pub const CUPTI_ACTIVITY_JIT_OPERATION_CACHE_STORE: CUpti_ActivityJitOperationType = 2;
#[doc = " JIT compilation."]
pub const CUPTI_ACTIVITY_JIT_OPERATION_COMPILE: CUpti_ActivityJitOperationType = 3;
#[doc = " JIT compilation."]
pub const CUPTI_ACTIVITY_JIT_OPERATION_TYPE_FORCE_INT: CUpti_ActivityJitOperationType = 2147483647;
#[doc = " \\brief The types of JIT compilation operations.\n\n To be used in CUpti_ActivityJit."]
pub type CUpti_ActivityJitOperationType = ::std::os::raw::c_uint;
#[doc = " \\brief The activity record for JIT operations.\n This activity represents the JIT operations (compile, load, store) of a CUmodule\n from the Compute Cache.\n Gives the exact hashed path of where the cached module is loaded from,\n or where the module will be stored after Just-In-Time (JIT) compilation."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityJit2 {
    #[doc = " The activity record kind must be CUPTI_ACTIVITY_KIND_JIT."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The JIT entry type."]
    pub jitEntryType: CUpti_ActivityJitEntryType,
    #[doc = " The JIT operation type."]
    pub jitOperationType: CUpti_ActivityJitOperationType,
    #[doc = " The device ID."]
    pub deviceId: u32,
    #[doc = " The start timestamp for the JIT operation, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the JIT operation."]
    pub start: u64,
    #[doc = " The end timestamp for the JIT operation, in ns. A value of 0 for both\n the start and end timestamps indicates that timestamp information\n could not be collected for the JIT operation."]
    pub end: u64,
    #[doc = " The correlation ID of the JIT operation to which\n records belong to. Each JIT operation is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver or runtime API activity record that\n launched the JIT operation."]
    pub correlationId: u32,
    #[doc = " Internal use."]
    pub padding: u32,
    #[doc = " The correlation ID to correlate JIT compilation, load and store operations.\n Each JIT compilation unit is assigned a unique correlation ID\n at the time of the JIT compilation. This correlation id can be used\n to find the matching JIT cache load/store records."]
    pub jitOperationCorrelationId: u64,
    #[doc = " The size of compute cache."]
    pub cacheSize: u64,
    #[doc = " The path where the fat binary is cached."]
    pub cachePath: *const ::std::os::raw::c_char,
    #[doc = " The ID of the process where the JIT operation is executing."]
    pub processId: u32,
    #[doc = " The ID of the thread where the JIT operation is executing."]
    pub threadId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityJit2"][::std::mem::size_of::<CUpti_ActivityJit2>() - 72usize];
    ["Alignment of CUpti_ActivityJit2"][::std::mem::align_of::<CUpti_ActivityJit2>() - 8usize];
    ["Offset of field: CUpti_ActivityJit2::kind"]
        [::std::mem::offset_of!(CUpti_ActivityJit2, kind) - 0usize];
    ["Offset of field: CUpti_ActivityJit2::jitEntryType"]
        [::std::mem::offset_of!(CUpti_ActivityJit2, jitEntryType) - 4usize];
    ["Offset of field: CUpti_ActivityJit2::jitOperationType"]
        [::std::mem::offset_of!(CUpti_ActivityJit2, jitOperationType) - 8usize];
    ["Offset of field: CUpti_ActivityJit2::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityJit2, deviceId) - 12usize];
    ["Offset of field: CUpti_ActivityJit2::start"]
        [::std::mem::offset_of!(CUpti_ActivityJit2, start) - 16usize];
    ["Offset of field: CUpti_ActivityJit2::end"]
        [::std::mem::offset_of!(CUpti_ActivityJit2, end) - 24usize];
    ["Offset of field: CUpti_ActivityJit2::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityJit2, correlationId) - 32usize];
    ["Offset of field: CUpti_ActivityJit2::padding"]
        [::std::mem::offset_of!(CUpti_ActivityJit2, padding) - 36usize];
    ["Offset of field: CUpti_ActivityJit2::jitOperationCorrelationId"]
        [::std::mem::offset_of!(CUpti_ActivityJit2, jitOperationCorrelationId) - 40usize];
    ["Offset of field: CUpti_ActivityJit2::cacheSize"]
        [::std::mem::offset_of!(CUpti_ActivityJit2, cacheSize) - 48usize];
    ["Offset of field: CUpti_ActivityJit2::cachePath"]
        [::std::mem::offset_of!(CUpti_ActivityJit2, cachePath) - 56usize];
    ["Offset of field: CUpti_ActivityJit2::processId"]
        [::std::mem::offset_of!(CUpti_ActivityJit2, processId) - 64usize];
    ["Offset of field: CUpti_ActivityJit2::threadId"]
        [::std::mem::offset_of!(CUpti_ActivityJit2, threadId) - 68usize];
};
impl Default for CUpti_ActivityJit2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for trace of graph execution.\n\n This activity record represents execution for a graph without giving visibility\n about the execution of its nodes. This is intended to reduce overheads in tracing\n each node. The activity kind is CUPTI_ACTIVITY_KIND_GRAPH_TRACE"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityGraphTrace2 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_GRAPH_TRACE"]
    pub kind: CUpti_ActivityKind,
    #[doc = " The correlation ID of the graph launch. Each graph launch is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver API activity record that launched\n the graph."]
    pub correlationId: u32,
    #[doc = " The start timestamp for the graph execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the graph."]
    pub start: u64,
    #[doc = " The end timestamp for the graph execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the graph."]
    pub end: u64,
    #[doc = " The ID of the device where the first node of the graph is executed.\n If this is INT_MAX, then the start is on the host."]
    pub deviceId: u32,
    #[doc = " The unique ID of the graph that is launched."]
    pub graphId: u32,
    #[doc = " The ID of the context where the first node of the graph is executed.\n If this is INT_MAX, then the start is on the host."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the graph is being launched."]
    pub streamId: u32,
    #[doc = " This field is reserved for internal use"]
    pub reserved: *mut ::std::os::raw::c_void,
    #[doc = " The ID of the device where last node of the graph is executed"]
    pub endDeviceId: u32,
    #[doc = " The ID of the context where the last node of the graph is executed."]
    pub endContextId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityGraphTrace2"]
        [::std::mem::size_of::<CUpti_ActivityGraphTrace2>() - 56usize];
    ["Alignment of CUpti_ActivityGraphTrace2"]
        [::std::mem::align_of::<CUpti_ActivityGraphTrace2>() - 8usize];
    ["Offset of field: CUpti_ActivityGraphTrace2::kind"]
        [::std::mem::offset_of!(CUpti_ActivityGraphTrace2, kind) - 0usize];
    ["Offset of field: CUpti_ActivityGraphTrace2::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityGraphTrace2, correlationId) - 4usize];
    ["Offset of field: CUpti_ActivityGraphTrace2::start"]
        [::std::mem::offset_of!(CUpti_ActivityGraphTrace2, start) - 8usize];
    ["Offset of field: CUpti_ActivityGraphTrace2::end"]
        [::std::mem::offset_of!(CUpti_ActivityGraphTrace2, end) - 16usize];
    ["Offset of field: CUpti_ActivityGraphTrace2::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityGraphTrace2, deviceId) - 24usize];
    ["Offset of field: CUpti_ActivityGraphTrace2::graphId"]
        [::std::mem::offset_of!(CUpti_ActivityGraphTrace2, graphId) - 28usize];
    ["Offset of field: CUpti_ActivityGraphTrace2::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityGraphTrace2, contextId) - 32usize];
    ["Offset of field: CUpti_ActivityGraphTrace2::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityGraphTrace2, streamId) - 36usize];
    ["Offset of field: CUpti_ActivityGraphTrace2::reserved"]
        [::std::mem::offset_of!(CUpti_ActivityGraphTrace2, reserved) - 40usize];
    ["Offset of field: CUpti_ActivityGraphTrace2::endDeviceId"]
        [::std::mem::offset_of!(CUpti_ActivityGraphTrace2, endDeviceId) - 48usize];
    ["Offset of field: CUpti_ActivityGraphTrace2::endContextId"]
        [::std::mem::offset_of!(CUpti_ActivityGraphTrace2, endContextId) - 52usize];
};
impl Default for CUpti_ActivityGraphTrace2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CUPTI_DEVICE_GRAPH_LAUNCH_MODE_INVALID: CUpti_DeviceGraphLaunchMode = 0;
pub const CUPTI_DEVICE_GRAPH_LAUNCH_MODE_FIRE_AND_FORGET: CUpti_DeviceGraphLaunchMode = 1;
pub const CUPTI_DEVICE_GRAPH_LAUNCH_MODE_TAIL: CUpti_DeviceGraphLaunchMode = 2;
pub const CUPTI_DEVICE_GRAPH_LAUNCH_MODE_FIRE_AND_FORGET_AS_SIBLING: CUpti_DeviceGraphLaunchMode =
    3;
#[doc = " \\brief The launch mode for device graph execution."]
pub type CUpti_DeviceGraphLaunchMode = ::std::os::raw::c_uint;
#[doc = " \\brief The activity record for trace of device graph execution.\n\n This activity record represents execution for a device launched graph without giving visibility\n about the execution of its nodes. This is intended to reduce overheads in tracing\n each node. The activity kind is CUPTI_ACTIVITY_KIND_DEVICE_GRAPH_TRACE"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityDeviceGraphTrace {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_DEVICE_GRAPH_TRACE"]
    pub kind: CUpti_ActivityKind,
    #[doc = " The ID of the device where the first node of the graph is executed."]
    pub deviceId: u32,
    #[doc = " The start timestamp for the graph execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the graph."]
    pub start: u64,
    #[doc = " The end timestamp for the graph execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the graph."]
    pub end: u64,
    #[doc = " The unique ID of the graph that is launched."]
    pub graphId: u32,
    #[doc = " The unique ID of the graph that has launched this graph."]
    pub launcherGraphId: u32,
    #[doc = " The type of launch. See \\ref CUpti_DeviceGraphLaunchMode"]
    pub deviceLaunchMode: u32,
    #[doc = " The ID of the context where the first node of the graph is executed."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the graph is being launched."]
    pub streamId: u64,
    #[doc = " This field is reserved for internal use"]
    pub reserved: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityDeviceGraphTrace"]
        [::std::mem::size_of::<CUpti_ActivityDeviceGraphTrace>() - 56usize];
    ["Alignment of CUpti_ActivityDeviceGraphTrace"]
        [::std::mem::align_of::<CUpti_ActivityDeviceGraphTrace>() - 8usize];
    ["Offset of field: CUpti_ActivityDeviceGraphTrace::kind"]
        [::std::mem::offset_of!(CUpti_ActivityDeviceGraphTrace, kind) - 0usize];
    ["Offset of field: CUpti_ActivityDeviceGraphTrace::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityDeviceGraphTrace, deviceId) - 4usize];
    ["Offset of field: CUpti_ActivityDeviceGraphTrace::start"]
        [::std::mem::offset_of!(CUpti_ActivityDeviceGraphTrace, start) - 8usize];
    ["Offset of field: CUpti_ActivityDeviceGraphTrace::end"]
        [::std::mem::offset_of!(CUpti_ActivityDeviceGraphTrace, end) - 16usize];
    ["Offset of field: CUpti_ActivityDeviceGraphTrace::graphId"]
        [::std::mem::offset_of!(CUpti_ActivityDeviceGraphTrace, graphId) - 24usize];
    ["Offset of field: CUpti_ActivityDeviceGraphTrace::launcherGraphId"]
        [::std::mem::offset_of!(CUpti_ActivityDeviceGraphTrace, launcherGraphId) - 28usize];
    ["Offset of field: CUpti_ActivityDeviceGraphTrace::deviceLaunchMode"]
        [::std::mem::offset_of!(CUpti_ActivityDeviceGraphTrace, deviceLaunchMode) - 32usize];
    ["Offset of field: CUpti_ActivityDeviceGraphTrace::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityDeviceGraphTrace, contextId) - 36usize];
    ["Offset of field: CUpti_ActivityDeviceGraphTrace::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityDeviceGraphTrace, streamId) - 40usize];
    ["Offset of field: CUpti_ActivityDeviceGraphTrace::reserved"]
        [::std::mem::offset_of!(CUpti_ActivityDeviceGraphTrace, reserved) - 48usize];
};
impl Default for CUpti_ActivityDeviceGraphTrace {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for trace of decompression operations.\n\n This activity record represents execution for a batch of decompression operatios.\n The activity kind is CUPTI_ACTIVITY_KIND_MEM_DECOMPRESS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemDecompress {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MEM_DECOMPRESS"]
    pub kind: CUpti_ActivityKind,
    #[doc = " The ID of the device."]
    pub deviceId: u32,
    #[doc = " The ID of the context."]
    pub contextId: u32,
    #[doc = " The ID of the stream."]
    pub streamId: u32,
    #[doc = " The ID of the HW channel on which the memory copy is occurring."]
    pub channelID: u32,
    #[doc = " The type of the channel"]
    pub channelType: CUpti_ChannelType,
    #[doc = " The correlation ID of the decompression operations. Each operation is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver API activity record that launched\n the operation."]
    pub correlationId: u32,
    #[doc = " The number of operations in the batch."]
    pub numberOfOperations: u32,
    #[doc = " The number of bytes to be read and decompressed in the\n batch operation."]
    pub sourceBytes: u64,
    #[doc = " This field is reserved for internal use"]
    pub reserved0: *mut ::std::os::raw::c_void,
    #[doc = " The start timestamp.\n A value of CUPTI_TIMESTAMP_UNKNOWN indicates that\n the start time is unknown."]
    pub start: u64,
    #[doc = " The end timestamp.\n A value of CUPTI_TIMESTAMP_UNKNOWN indicates that\n the start time is unknown."]
    pub end: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemDecompress"]
        [::std::mem::size_of::<CUpti_ActivityMemDecompress>() - 64usize];
    ["Alignment of CUpti_ActivityMemDecompress"]
        [::std::mem::align_of::<CUpti_ActivityMemDecompress>() - 8usize];
    ["Offset of field: CUpti_ActivityMemDecompress::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMemDecompress, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMemDecompress::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemDecompress, deviceId) - 4usize];
    ["Offset of field: CUpti_ActivityMemDecompress::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemDecompress, contextId) - 8usize];
    ["Offset of field: CUpti_ActivityMemDecompress::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityMemDecompress, streamId) - 12usize];
    ["Offset of field: CUpti_ActivityMemDecompress::channelID"]
        [::std::mem::offset_of!(CUpti_ActivityMemDecompress, channelID) - 16usize];
    ["Offset of field: CUpti_ActivityMemDecompress::channelType"]
        [::std::mem::offset_of!(CUpti_ActivityMemDecompress, channelType) - 20usize];
    ["Offset of field: CUpti_ActivityMemDecompress::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemDecompress, correlationId) - 24usize];
    ["Offset of field: CUpti_ActivityMemDecompress::numberOfOperations"]
        [::std::mem::offset_of!(CUpti_ActivityMemDecompress, numberOfOperations) - 28usize];
    ["Offset of field: CUpti_ActivityMemDecompress::sourceBytes"]
        [::std::mem::offset_of!(CUpti_ActivityMemDecompress, sourceBytes) - 32usize];
    ["Offset of field: CUpti_ActivityMemDecompress::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityMemDecompress, reserved0) - 40usize];
    ["Offset of field: CUpti_ActivityMemDecompress::start"]
        [::std::mem::offset_of!(CUpti_ActivityMemDecompress, start) - 48usize];
    ["Offset of field: CUpti_ActivityMemDecompress::end"]
        [::std::mem::offset_of!(CUpti_ActivityMemDecompress, end) - 56usize];
};
impl Default for CUpti_ActivityMemDecompress {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The device memory size (in bytes) reserved for storing profiling data for concurrent\n kernels (activity kind \\ref CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL), memcopies and memsets\n for each buffer on a context. The value is a size_t.\n\n There is a limit on how many device buffers can be allocated per context. User\n can query and set this limit using the attribute\n \\ref CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_POOL_LIMIT.\n CUPTI doesn't pre-allocate all the buffers, it pre-allocates only those many\n buffers as set by the attribute \\ref CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_PRE_ALLOCATE_VALUE.\n When all of the data in a buffer is consumed, it is added in the reuse pool, and\n CUPTI picks a buffer from this pool when a new buffer is needed. Thus memory\n footprint does not scale with the kernel count. Applications with the high density\n of kernels, memcopies and memsets might result in having CUPTI to allocate more device buffers.\n CUPTI allocates another buffer only when it runs out of the buffers in the\n reuse pool.\n\n Since buffer allocation happens in the main application thread, this might result\n in stalls in the critical path. CUPTI pre-allocates 3 buffers of the same size to\n mitigate this issue. User can query and set the pre-allocation limit using the\n attribute \\ref CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_PRE_ALLOCATE_VALUE.\n\n Having larger buffer size leaves less device memory for the application.\n Having smaller buffer size increases the risk of dropping timestamps for\n records if too many kernels or memcopies or memsets are launched at one time.\n\n This value only applies to new buffer allocations. Set this value before initializing\n CUDA or before creating a context to ensure it is considered for the following allocations.\n\n The default value is 3200000 (~3MB) which can accommodate profiling data\n up to 100,000 kernels, memcopies and memsets combined.\n\n Note: Starting with the CUDA 12.0 Update 1 release, CUPTI allocates the profiling buffer\n in the device memory by default, which may improve the performance of the tracing run.\n To change the preferred location to page-locked host memory, refer to the attribute\n \\ref CUPTI_ACTIVITY_ATTR_MEM_ALLOCATION_TYPE_HOST_PINNED.\n The size of the memory and maximum number of pools are still controlled by the attributes\n \\ref CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_SIZE and \\ref CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_POOL_LIMIT.\n\n Note: The actual amount of device memory per buffer reserved by CUPTI might be larger."]
pub const CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_SIZE: CUpti_ActivityAttribute = 0;
#[doc = " The device memory size (in bytes) reserved for storing profiling\n data for CDP operations for each buffer on a context. The\n value is a size_t.\n\n Having larger buffer size means less flush operations but\n consumes more device memory. This value only applies to new\n allocations.\n\n Set this value before initializing CUDA or before creating a\n context to ensure it is considered for the following allocations.\n\n The default value is 8388608 (8MB).\n\n Note: The actual amount of device memory per context reserved by\n CUPTI might be larger."]
pub const CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_SIZE_CDP: CUpti_ActivityAttribute = 1;
#[doc = " The maximum number of device memory buffers per context. The value is a size_t.\n\n For an application with high rate of kernel launches, memcopies and memsets having a bigger pool\n limit helps in timestamp collection for all these activities at the expense of a larger memory footprint.\n Refer to the description of the attribute \\ref CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_SIZE\n for more details.\n\n Setting this value will not modify the number of memory buffers\n currently stored.\n\n Set this value before initializing CUDA to ensure the limit is\n not exceeded.\n\n The default value is 250."]
pub const CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_POOL_LIMIT: CUpti_ActivityAttribute = 2;
#[doc = " This attribute is not supported starting with CUDA 12.3\n CUPTI no longer uses profiling semaphore pool to store profiling data.\n\n There is a limit on how many semaphore pools can be allocated per context. User\n can query and set this limit using the attribute\n \\ref CUPTI_ACTIVITY_ATTR_PROFILING_SEMAPHORE_POOL_LIMIT.\n CUPTI doesn't pre-allocate all the semaphore pools, it pre-allocates only those many\n semaphore pools as set by the attribute \\ref CUPTI_ACTIVITY_ATTR_PROFILING_SEMAPHORE_PRE_ALLOCATE_VALUE.\n When all of the data in a semaphore pool is consumed, it is added in the reuse pool, and\n CUPTI picks a semaphore pool from the reuse pool when a new semaphore pool is needed. Thus memory\n footprint does not scale with the kernel count. Applications with the high density\n of kernels might result in having CUPTI to allocate more semaphore pools.\n CUPTI allocates another semaphore pool only when it runs out of the semaphore pools in the\n reuse pool.\n\n Since semaphore pool allocation happens in the main application thread, this might result\n in stalls in the critical path. CUPTI pre-allocates 3 semaphore pools of the same size to\n mitigate this issue. User can query and set the pre-allocation limit using the\n attribute \\ref CUPTI_ACTIVITY_ATTR_PROFILING_SEMAPHORE_PRE_ALLOCATE_VALUE.\n\n Having larger semaphore pool size leaves less device memory for the application.\n Having smaller semaphore pool size increases the risk of dropping timestamps for\n kernel records if too many kernels are issued/launched at one time.\n\n This value only applies to new semaphore pool allocations. Set this value before initializing\n CUDA or before creating a context to ensure it is considered for the following allocations.\n\n The default value is 25000 which can accommodate profiling data for upto 25,000 kernels.\n"]
pub const CUPTI_ACTIVITY_ATTR_PROFILING_SEMAPHORE_POOL_SIZE: CUpti_ActivityAttribute = 3;
#[doc = " This attribute is not supported starting with CUDA 12.3\n CUPTI no longer uses profiling semaphore pool to store profiling data.\n\n The maximum number of profiling semaphore pools per context. The value is a size_t.\n\n Refer to the description of the attribute \\ref CUPTI_ACTIVITY_ATTR_PROFILING_SEMAPHORE_POOL_SIZE\n for more details.\n\n Set this value before initializing CUDA to ensure the limit is not exceeded.\n\n The default value is 250."]
pub const CUPTI_ACTIVITY_ATTR_PROFILING_SEMAPHORE_POOL_LIMIT: CUpti_ActivityAttribute = 4;
#[doc = " The flag to indicate whether user should provide activity buffer of zero value.\n The value is a uint8_t.\n\n If the value of this attribute is non-zero, user should provide\n a zero value buffer in the \\ref CUpti_BuffersCallbackRequestFunc.\n If the user does not provide a zero value buffer after setting this to non-zero,\n the activity buffer may contain some uninitialized values when CUPTI returns it in\n \\ref CUpti_BuffersCallbackCompleteFunc\n\n If the value of this attribute is zero, CUPTI will initialize the user buffer\n received in the \\ref CUpti_BuffersCallbackRequestFunc to zero before filling it.\n If the user sets this to zero, a few stalls may appear in critical path because CUPTI\n will zero out the buffer in the main thread.\n Set this value before returning from \\ref CUpti_BuffersCallbackRequestFunc to\n ensure it is considered for all the subsequent user buffers.\n\n The default value is 0."]
pub const CUPTI_ACTIVITY_ATTR_ZEROED_OUT_ACTIVITY_BUFFER: CUpti_ActivityAttribute = 5;
#[doc = " Number of device buffers to pre-allocate for a context during the initialization phase.\n The value is a size_t.\n\n Refer to the description of the attribute \\ref CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_SIZE\n for details.\n\n This value must be less than the maximum number of device buffers set using\n the attribute \\ref CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_POOL_LIMIT\n\n Set this value before initializing CUDA or before creating a context to ensure it\n is considered by the CUPTI.\n\n The default value is set to 3 to ping pong between these buffers (if possible)."]
pub const CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_PRE_ALLOCATE_VALUE: CUpti_ActivityAttribute = 6;
#[doc = " This attribute is not supported starting with CUDA 12.3\n CUPTI no longer uses profiling semaphore pool to store profiling data.\n\n Number of profiling semaphore pools to pre-allocate for a context during the\n initialization phase. The value is a size_t.\n\n Refer to the description of the attribute \\ref CUPTI_ACTIVITY_ATTR_PROFILING_SEMAPHORE_POOL_SIZE\n for details.\n\n This value must be less than the maximum number of profiling semaphore pools set\n using the attribute \\ref CUPTI_ACTIVITY_ATTR_PROFILING_SEMAPHORE_POOL_LIMIT\n\n Set this value before initializing CUDA or before creating a context to ensure it\n is considered by the CUPTI.\n\n The default value is set to 3 to ping pong between these pools (if possible)."]
pub const CUPTI_ACTIVITY_ATTR_PROFILING_SEMAPHORE_PRE_ALLOCATE_VALUE: CUpti_ActivityAttribute = 7;
#[doc = " Allocate page-locked (pinned) host memory for storing profiling data for concurrent\n kernels, memcopies and memsets for each buffer on a context. The value is a uint8_t.\n\n From CUDA 11.2 through CUDA 12.0 GA releases, CUPTI allocated the profiling buffer\n in pinned host memory by default.\n Allocating excessive amounts of pinned memory may degrade system performance, as it\n reduces the amount of memory available to the system for paging. For this reason user\n might want to change the location from pinned host memory to device memory by setting\n value of this attribute to 0.\n\n Using page-locked (pinned) host memory buffers is not supported on confidential computing\n devices. If this attribute is set to 1, CUPTI will return error CUPTI_ERROR_NOT_SUPPORTED.\n\n The default value is 0."]
pub const CUPTI_ACTIVITY_ATTR_MEM_ALLOCATION_TYPE_HOST_PINNED: CUpti_ActivityAttribute = 8;
#[doc = " Request activity buffers per-thread to store CUPTI activity records\n in the activity buffer on per-thread basis. The value is a uint8_t.\n\n The attribute should be set before registering the buffer callbacks using\n cuptiActivityRegisterCallbacks API and before any of the CUPTI activity kinds are enabled.\n This makes sure that all the records are stored in activity buffers allocated per-thread.\n Changing this attribute in the middle of the profiling session will result in undefined behavior.\n\n The default value is 1."]
pub const CUPTI_ACTIVITY_ATTR_PER_THREAD_ACTIVITY_BUFFER: CUpti_ActivityAttribute = 9;
#[doc = " The device memory size (in bytes) reserved for storing profiling\n data for device graph operations for each buffer on a context. The\n value is a size_t.\n\n Having larger buffer size means less flush operations but\n consumes more device memory. This value only applies to new\n allocations.\n\n Set this value before initializing CUDA or before creating a\n context to ensure it is considered for the following allocations.\n\n The default value is 16777216 (16MB).\n\n Note: The actual amount of device memory per context reserved by\n CUPTI might be larger."]
pub const CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_SIZE_DEVICE_GRAPHS: CUpti_ActivityAttribute = 10;
#[doc = " The device memory size (in bytes) reserved for storing profiling\n data for device graph operations for each buffer on a context. The\n value is a size_t.\n\n Having larger buffer size means less flush operations but\n consumes more device memory. This value only applies to new\n allocations.\n\n Set this value before initializing CUDA or before creating a\n context to ensure it is considered for the following allocations.\n\n The default value is 16777216 (16MB).\n\n Note: The actual amount of device memory per context reserved by\n CUPTI might be larger."]
pub const CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_FORCE_INT: CUpti_ActivityAttribute = 2147483647;
#[doc = " \\brief Activity attributes.\n\n These attributes are used to control the behavior of the activity\n API."]
pub type CUpti_ActivityAttribute = ::std::os::raw::c_uint;
#[doc = " Default type\n Windows uses API GetCurrentThreadId()\n Linux/Mac/Android/QNX use POSIX pthread API pthread_self()"]
pub const CUPTI_ACTIVITY_THREAD_ID_TYPE_DEFAULT: CUpti_ActivityThreadIdType = 0;
#[doc = " This type is based on the system API available on the underlying platform\n and thread-id obtained is supposed to be unique for the process lifetime.\n Windows uses API GetCurrentThreadId()\n Linux uses syscall SYS_gettid\n Mac uses syscall SYS_thread_selfid\n Android/QNX use gettid()"]
pub const CUPTI_ACTIVITY_THREAD_ID_TYPE_SYSTEM: CUpti_ActivityThreadIdType = 1;
#[doc = " Add new enums before this field."]
pub const CUPTI_ACTIVITY_THREAD_ID_TYPE_SIZE: CUpti_ActivityThreadIdType = 2;
#[doc = " Add new enums before this field."]
pub const CUPTI_ACTIVITY_THREAD_ID_TYPE_FORCE_INT: CUpti_ActivityThreadIdType = 2147483647;
#[doc = " \\brief Thread-Id types.\n\n CUPTI uses different methods to obtain the thread-id depending on the\n support and the underlying platform. This enum documents these methods\n for each type. APIs \\ref cuptiSetThreadIdType and \\ref cuptiGetThreadIdType\n can be used to set and get the thread-id type."]
pub type CUpti_ActivityThreadIdType = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " \\brief Get the CUPTI timestamp.\n\n Returns a timestamp normalized to correspond with the start and end\n timestamps reported in the CUPTI activity records. The timestamp is\n reported in nanoseconds.\n\n \\param timestamp Returns the CUPTI timestamp\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p timestamp is NULL"]
    pub fn cuptiGetTimestamp(timestamp: *mut u64) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get the ID of a context.\n\n Get the ID of a context.\n\n \\param context The context\n \\param contextId Returns a process-unique ID for the context\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_CONTEXT The context is NULL or not valid.\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p contextId is NULL"]
    pub fn cuptiGetContextId(context: CUcontext, contextId: *mut u32) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get the ID of a stream.\n\n Get the ID of a stream. The stream ID is unique within a context\n (i.e. all streams within a context will have unique stream\n IDs).\n\n \\param context If non-NULL then the stream is checked to ensure\n that it belongs to this context. Typically this parameter should be\n null.\n \\param stream The stream\n \\param streamId Returns a context-unique ID for the stream\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_STREAM if unable to get stream ID, or\n if \\p context is non-NULL and \\p stream does not belong to the\n context\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p streamId is NULL\n\n **DEPRECATED** This method is deprecated as of CUDA 8.0.\n Use method cuptiGetStreamIdEx instead."]
    pub fn cuptiGetStreamId(
        context: CUcontext,
        stream: CUstream,
        streamId: *mut u32,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get the ID of a stream.\n\n Get the ID of a stream. The stream ID is unique within a context\n (i.e. all streams within a context will have unique stream\n IDs).\n\n \\param context If non-NULL then the stream is checked to ensure\n that it belongs to this context. Typically this parameter should be\n null.\n \\param stream The stream\n \\param perThreadStream Flag to indicate if program is compiled for per-thread streams\n \\param streamId Returns a context-unique ID for the stream\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_STREAM if unable to get stream ID, or\n if \\p context is non-NULL and \\p stream does not belong to the\n context\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p streamId is NULL"]
    pub fn cuptiGetStreamIdEx(
        context: CUcontext,
        stream: CUstream,
        perThreadStream: u8,
        streamId: *mut u32,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get the ID of a device\n\n If \\p context is NULL, returns the ID of the device that contains\n the currently active context. If \\p context is non-NULL, returns\n the ID of the device which contains that context. Operates in a\n similar manner to cudaGetDevice() or cuCtxGetDevice() but may be\n called from within callback functions.\n\n \\param context The context, or NULL to indicate the current context.\n \\param deviceId Returns the ID of the device that is current for\n the calling thread.\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_DEVICE if unable to get device ID\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p deviceId is NULL"]
    pub fn cuptiGetDeviceId(context: CUcontext, deviceId: *mut u32) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get the unique ID of a graph node\n\n Returns the unique ID of the CUDA graph node.\n\n \\param node The graph node.\n \\param nodeId Returns the unique ID of the node\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p node is NULL"]
    pub fn cuptiGetGraphNodeId(node: CUgraphNode, nodeId: *mut u64) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get the unique ID of graph\n\n Returns the unique ID of CUDA graph.\n\n \\param graph The graph.\n \\param pId Returns the unique ID of the graph\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p graph is NULL"]
    pub fn cuptiGetGraphId(graph: CUgraph, pId: *mut u32) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get the unique ID of executable graph\n\n Returns the unique ID of executable CUDA graph.\n\n \\param graphExec The executable graph.\n \\param pId Returns the unique ID of the executable graph\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p graph is NULL"]
    pub fn cuptiGetGraphExecId(graphExec: CUgraphExec, pId: *mut u32) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Enable collection of a specific kind of activity record.\n\n Enable collection of a specific kind of activity record. Multiple\n kinds can be enabled by calling this function multiple times. By\n default all activity kinds are disabled for collection.\n\n \\param kind The kind of activity record to collect\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_NOT_COMPATIBLE if the activity kind cannot be enabled\n \\retval CUPTI_ERROR_INVALID_KIND if the activity kind is not supported"]
    pub fn cuptiActivityEnable(kind: CUpti_ActivityKind) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Enable collection of a specific kind of activity record. For certain activity kinds\n it dumps existing records.\n\n In general, the behavior of this API is similar to the API \\ref cuptiActivityEnable i.e. it\n enables the collection of a specific kind of activity record.\n Additionally, this API can help in dumping the records for activities which happened in\n the past before enabling the corresponding activity kind.\n The API allows to get records for the current resource allocations done in CUDA\n For CUPTI_ACTIVITY_KIND_DEVICE, existing device records are dumped\n For CUPTI_ACTIVITY_KIND_CONTEXT, existing context records are dumped\n For CUPTI_ACTIVITY_KIND_STREAM, existing stream records are dumped\n For CUPTI_ACTIVITY_KIND_ NVLINK, existing NVLINK records are dumped\n For CUPTI_ACTIVITY_KIND_PCIE, existing PCIE records are dumped\n For other activities, the behavior is similar to the API \\ref cuptiActivityEnable\n\n Device records are emitted in CUPTI on CUDA driver initialization. Those records\n can only be retrieved by the user if CUPTI is attached before CUDA initialization.\n Context and stream records are emitted on context and stream creation.\n The use case of the API is to provide the records for CUDA resources\n (contexts/streams/devices) that are currently active if user late attaches CUPTI.\n\n Before calling this function, the user must register buffer callbacks\n to get the activity records by calling \\ref cuptiActivityRegisterCallbacks.\n If the user does not register the buffers and calls API \\ref cuptiActivityEnableAndDump,\n then CUPTI will enable the activity kind but not provide any records for that\n activity kind.\n\n \\param kind The kind of activity record to collect\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_UNKNOWN if buffer is not initialized.\n \\retval CUPTI_ERROR_NOT_COMPATIBLE if the activity kind cannot be enabled\n \\retval CUPTI_ERROR_INVALID_KIND if the activity kind is not supported"]
    pub fn cuptiActivityEnableAndDump(kind: CUpti_ActivityKind) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Disable collection of a specific kind of activity record.\n\n Disable collection of a specific kind of activity record. Multiple\n kinds can be disabled by calling this function multiple times. By\n default all activity kinds are disabled for collection.\n\n \\param kind The kind of activity record to stop collecting\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_KIND if the activity kind is not supported"]
    pub fn cuptiActivityDisable(kind: CUpti_ActivityKind) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Enable collection of a specific kind of activity record for\n a context.\n\n Enable collection of a specific kind of activity record for a\n context.  This setting done by this API will supersede the global\n settings for activity records enabled by \\ref cuptiActivityEnable.\n Multiple kinds can be enabled by calling this function multiple\n times.\n\n \\param context The context for which activity is to be enabled\n \\param kind The kind of activity record to collect\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_NOT_COMPATIBLE if the activity kind cannot be enabled\n \\retval CUPTI_ERROR_INVALID_KIND if the activity kind is not supported"]
    pub fn cuptiActivityEnableContext(context: CUcontext, kind: CUpti_ActivityKind) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Disable collection of a specific kind of activity record for\n a context.\n\n Disable collection of a specific kind of activity record for a context.\n This setting done by this API will supersede the global settings\n for activity records.\n Multiple kinds can be enabled by calling this function multiple times.\n\n \\param context The context for which activity is to be disabled\n \\param kind The kind of activity record to stop collecting\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_KIND if the activity kind is not supported"]
    pub fn cuptiActivityDisableContext(context: CUcontext, kind: CUpti_ActivityKind)
    -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get the number of activity records that were dropped of\n insufficient buffer space.\n\n Get the number of records that were dropped because of insufficient\n buffer space.  The dropped count includes records that could not be\n recorded because CUPTI did not have activity buffer space available\n for the record (because the CUpti_BuffersCallbackRequestFunc\n callback did not return an empty buffer of sufficient size) and\n also CDP records that could not be record because the device-size\n buffer was full (size is controlled by the\n CUPTI_ACTIVITY_ATTR_DEVICE_BUFFER_SIZE_CDP attribute). The dropped\n count maintained for the queue is reset to zero when this function\n is called.\n\n \\param context The context, or NULL to get dropped count from global queue\n \\param streamId The stream ID\n \\param dropped The number of records that were dropped since the last call\n to this function.\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p dropped is NULL"]
    pub fn cuptiActivityGetNumDroppedRecords(
        context: CUcontext,
        streamId: u32,
        dropped: *mut usize,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Iterate over the activity records in a buffer.\n\n This is a helper function to iterate over the activity records in a\n buffer. A buffer of activity records is typically obtained by\n receiving a CUpti_BuffersCallbackCompleteFunc callback. Stop iterating\n the buffer when an error occurs.\n\n An example of typical usage:\n \\code\n CUpti_Activity *record = NULL;\n CUptiResult status = CUPTI_SUCCESS;\n   do {\n      status = cuptiActivityGetNextRecord(buffer, validSize, &record);\n      if(status == CUPTI_SUCCESS) {\n           // Use record here...\n      }\n      else if (status == CUPTI_ERROR_MAX_LIMIT_REACHED)\n          break;\n      else if (status == CUPTI_ERROR_INVALID_KIND)\n          break;\n      else {\n          goto Error;\n      }\n    } while (1);\n \\endcode\n\n \\param buffer The buffer containing activity records\n \\param record Inputs the previous record returned by\n cuptiActivityGetNextRecord and returns the next activity record\n from the buffer. If input value is NULL, returns the first activity\n record in the buffer. Records of certain kinds like CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL\n may contain invalid (0) timestamps, indicating that no timing information could\n be collected for lack of device memory.\n \\param validBufferSizeBytes The number of valid bytes in the buffer.\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_MAX_LIMIT_REACHED if no more records in the buffer\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p buffer is NULL.\n \\retval CUPTI_ERROR_INVALID_KIND if activity record is either incomplete or invalid"]
    pub fn cuptiActivityGetNextRecord(
        buffer: *mut u8,
        validBufferSizeBytes: usize,
        record: *mut *mut CUpti_Activity,
    ) -> CUptiResult;
}
#[doc = " \\brief Function type for callback used by CUPTI to request an empty\n buffer for storing activity records.\n\n This callback function signals the CUPTI client that an activity\n buffer is needed by CUPTI. The activity buffer is used by CUPTI to\n store activity records. The callback function can decline the\n request by setting \\p *buffer to NULL. In this case CUPTI may drop\n activity records.\n\n \\param buffer Returns the new buffer. If set to NULL then no buffer\n is returned.\n \\param size Returns the size of the returned buffer.\n \\param maxNumRecords Returns the maximum number of records that\n should be placed in the buffer. If 0 then the buffer is filled with\n as many records as possible. If > 0 the buffer is filled with at\n most that many records before it is returned."]
pub type CUpti_BuffersCallbackRequestFunc = ::std::option::Option<
    unsafe extern "C" fn(buffer: *mut *mut u8, size: *mut usize, maxNumRecords: *mut usize),
>;
#[doc = " \\brief Function type for callback used by CUPTI to return a buffer\n of activity records.\n\n This callback function returns to the CUPTI client a buffer\n containing activity records.  The buffer contains \\p validSize\n bytes of activity records which should be read using\n cuptiActivityGetNextRecord. The number of dropped records can be\n read using cuptiActivityGetNumDroppedRecords. After this call CUPTI\n relinquished ownership of the buffer and will not use it\n anymore. The client may return the buffer to CUPTI using the\n CUpti_BuffersCallbackRequestFunc callback.\n Note: CUDA 6.0 onwards, all buffers returned by this callback are\n global buffers i.e. there is no context/stream specific buffer.\n User needs to parse the global buffer to extract the context/stream\n specific activity records.\n\n \\param context The context this buffer is associated with. If NULL, the\n buffer is associated with the global activities. This field is deprecated\n as of CUDA 6.0 and will always be NULL.\n \\param streamId The stream id this buffer is associated with.\n This field is deprecated as of CUDA 6.0 and will always be NULL.\n \\param buffer The activity record buffer.\n \\param size The total size of the buffer in bytes as set in\n CUpti_BuffersCallbackRequestFunc.\n \\param validSize The number of valid bytes in the buffer."]
pub type CUpti_BuffersCallbackCompleteFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: CUcontext,
        streamId: u32,
        buffer: *mut u8,
        size: usize,
        validSize: usize,
    ),
>;
unsafe extern "C" {
    #[doc = " \\brief Registers callback functions with CUPTI for activity buffer\n handling.\n\n This function registers two callback functions to be used in asynchronous\n buffer handling. If registered, activity record buffers are handled using\n asynchronous requested/completed callbacks from CUPTI.\n\n Registering these callbacks prevents the client from using CUPTI's\n blocking enqueue/dequeue functions.\n\n \\param funcBufferRequested callback which is invoked when an empty\n buffer is requested by CUPTI\n \\param funcBufferCompleted callback which is invoked when a buffer\n containing activity records is available from CUPTI\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if either \\p\n funcBufferRequested or \\p funcBufferCompleted is NULL"]
    pub fn cuptiActivityRegisterCallbacks(
        funcBufferRequested: CUpti_BuffersCallbackRequestFunc,
        funcBufferCompleted: CUpti_BuffersCallbackCompleteFunc,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Wait for all activity records to be delivered via the\n completion callback.\n\n This function does not return until all activity records associated\n with the specified context/stream are returned to the CUPTI client\n using the callback registered in cuptiActivityRegisterCallbacks. To\n ensure that all activity records are complete, the requested\n stream(s), if any, are synchronized.\n\n If \\p context is NULL, the global activity records (i.e. those not\n associated with a particular stream) are flushed (in this case no\n streams are synchronized).  If \\p context is a valid CUcontext and\n \\p streamId is 0, the buffers of all streams of this context are\n flushed.  Otherwise, the buffers of the specified stream in this\n context is flushed.\n\n Before calling this function, the buffer handling callback api\n must be activated by calling cuptiActivityRegisterCallbacks.\n\n \\param context A valid CUcontext or NULL.\n \\param streamId The stream ID.\n \\param flag The flag can be set to indicate a forced flush. See CUpti_ActivityFlag\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_CUPTI_ERROR_INVALID_OPERATION if not preceded\n by a successful call to cuptiActivityRegisterCallbacks\n \\retval CUPTI_ERROR_UNKNOWN an internal error occurred\n\n **DEPRECATED** This method is deprecated\n CONTEXT and STREAMID will be ignored. Use cuptiActivityFlushAll\n to flush all data."]
    pub fn cuptiActivityFlush(context: CUcontext, streamId: u32, flag: u32) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Request to deliver activity records via the buffer completion callback.\n\n This function returns the activity records associated with all contexts/streams\n (and the global buffers not associated with any stream) to the CUPTI client\n using the callback registered in cuptiActivityRegisterCallbacks.\n\n This is a blocking call but it doesn't issue any CUDA synchronization calls\n implicitly thus it's not guaranteed that all activities are completed on the\n underlying devices. Activity record is considered as completed if it has all\n the information filled up including the timestamps if any. It is the client's\n responsibility to issue necessary CUDA synchronization calls before calling\n this function if all activity records with complete information are expected\n to be delivered.\n\n Behavior of the function based on the input flag:\n (-) ::For default flush i.e. when flag is set as 0, it returns all the\n activity buffers which have all the activity records completed, buffers need not\n to be full though. It doesn't return buffers which have one or more incomplete\n records. Default flush can be done at a regular interval in a separate thread.\n (-) ::For forced flush i.e. when flag CUPTI_ACTIVITY_FLAG_FLUSH_FORCED is passed\n to the function, it returns all the activity buffers including the ones which have\n one or more incomplete activity records. It's suggested for clients to do the\n force flush before the termination of the profiling session to allow remaining\n buffers to be delivered. In general, it can be done in the at-exit handler.\n\n Before calling this function, the buffer handling callback api must be activated\n by calling cuptiActivityRegisterCallbacks.\n\n \\param flag The flag can be set to indicate a forced flush. See CUpti_ActivityFlag\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_OPERATION if not preceded by a\n successful call to cuptiActivityRegisterCallbacks\n \\retval CUPTI_ERROR_UNKNOWN an internal error occurred\n\n \\see cuptiActivityFlushPeriod"]
    pub fn cuptiActivityFlushAll(flag: u32) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Read an activity API attribute.\n\n Read an activity API attribute and return it in \\p *value.\n\n \\param attr The attribute to read\n \\param valueSize Size of buffer pointed by the value, and\n returns the number of bytes written to \\p value\n \\param value Returns the value of the attribute\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p valueSize or \\p value is NULL, or\n if \\p attr is not an activity attribute\n \\retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT Indicates that\n the \\p value buffer is too small to hold the attribute value."]
    pub fn cuptiActivityGetAttribute(
        attr: CUpti_ActivityAttribute,
        valueSize: *mut usize,
        value: *mut ::std::os::raw::c_void,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Write an activity API attribute.\n\n Write an activity API attribute.\n\n \\param attr The attribute to write\n \\param valueSize The size, in bytes, of the value\n \\param value The attribute value to write\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p valueSize or \\p value is NULL, or\n if \\p attr is not an activity attribute\n \\retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT Indicates that\n the \\p value buffer is too small to hold the attribute value."]
    pub fn cuptiActivitySetAttribute(
        attr: CUpti_ActivityAttribute,
        valueSize: *mut usize,
        value: *mut ::std::os::raw::c_void,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Set Unified Memory Counter configuration.\n\n Set the configuration before enabling the corresponding activity kind\n CUPTI_ACTIVITY_KIND_UNIFIED_MEMORY_COUNTER.\n The API should be called after CUDA driver initialization.\n\n \\param config A pointer to \\ref CUpti_ActivityUnifiedMemoryCounterConfig structures\n containing Unified Memory counter configuration.\n \\param count Number of Unified Memory counter configuration structures\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p config is NULL or\n any parameter in the \\p config structures is not a valid value\n \\retval CUPTI_ERROR_UM_PROFILING_NOT_SUPPORTED One potential reason is that\n platform (OS/arch) does not support the unified memory counters\n \\retval CUPTI_ERROR_UM_PROFILING_NOT_SUPPORTED_ON_DEVICE Indicates that the device\n does not support the unified memory counters\n \\retval CUPTI_ERROR_UM_PROFILING_NOT_SUPPORTED_ON_NON_P2P_DEVICES Indicates that\n multi-GPU configuration without P2P support between any pair of devices\n does not support the unified memory counters"]
    pub fn cuptiActivityConfigureUnifiedMemoryCounter(
        config: *mut CUpti_ActivityUnifiedMemoryCounterConfig,
        count: u32,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get auto boost state\n\n The profiling results can be inconsistent in case auto boost is enabled.\n CUPTI tries to disable auto boost while profiling. It can fail to disable in\n cases where user does not have the permissions or CUDA_AUTO_BOOST env\n variable is set. The function can be used to query whether auto boost is\n enabled.\n\n \\param context A valid CUcontext.\n \\param state A pointer to \\ref CUpti_ActivityAutoBoostState structure which\n contains the current state and the id of the process that has requested the\n current state\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p CUcontext or \\p state is NULL\n \\retval CUPTI_ERROR_NOT_SUPPORTED Indicates that the device does not support auto boost\n \\retval CUPTI_ERROR_UNKNOWN an internal error occurred"]
    pub fn cuptiGetAutoBoostState(
        context: CUcontext,
        state: *mut CUpti_ActivityAutoBoostState,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Set PC sampling configuration.\n\n For Pascal and older GPU architectures this API must be called before enabling\n activity kind CUPTI_ACTIVITY_KIND_PC_SAMPLING. There is no such requirement\n for Volta and newer GPU architectures.\n\n For Volta and newer GPU architectures if this API is called in the middle of\n execution, PC sampling configuration will be updated for subsequent kernel launches.\n\n Starting with CUDA 13.0, this function is unsupported and should not be used. It always returns the error code CUPTI_ERROR_LEGACY_PROFILER_NOT_SUPPORTED.\n\n \\param ctx The context\n \\param config A pointer to \\ref CUpti_ActivityPCSamplingConfig structure\n containing PC sampling configuration.\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_OPERATION if this api is called while\n some valid event collection method is set.\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p config is NULL or\n any parameter in the \\p config structures is not a valid value\n \\retval CUPTI_ERROR_NOT_SUPPORTED Indicates that the system/device\n does not support the unified memory counters"]
    pub fn cuptiActivityConfigurePCSampling(
        ctx: CUcontext,
        config: *mut CUpti_ActivityPCSamplingConfig,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Returns the last error from a cupti call or callback\n\n Returns the last error that has been produced by any of the cupti api calls\n or the callback in the same host thread and resets it to CUPTI_SUCCESS."]
    pub fn cuptiGetLastError() -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Set the thread-id type\n\n CUPTI uses the method corresponding to set type to generate the thread-id.\n See enum \\ref CUpti_ActivityThreadIdType for the list of methods.\n Activity records having thread-id field contain the same value.\n Thread id type must not be changed during the profiling session to\n avoid thread-id value mismatch across activity records.\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_SUPPORTED if \\p type is not supported on the platform"]
    pub fn cuptiSetThreadIdType(type_: CUpti_ActivityThreadIdType) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Get the thread-id type\n\n Returns the thread-id type used in CUPTI\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p type is NULL"]
    pub fn cuptiGetThreadIdType(type_: *mut CUpti_ActivityThreadIdType) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Check support for a compute capability\n\n This function is used to check the support for a device based on\n it's compute capability. It sets the \\p support when the compute\n capability is supported by the current version of CUPTI, and clears\n it otherwise. This version of CUPTI might not support all GPUs sharing\n the same compute capability. It is suggested to use API \\ref\n cuptiDeviceSupported which provides correct information.\n\n \\param major The major revision number of the compute capability\n \\param minor The minor revision number of the compute capability\n \\param support Pointer to an integer to return the support status\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p support is NULL\n\n \\sa ::cuptiDeviceSupported"]
    pub fn cuptiComputeCapabilitySupported(
        major: ::std::os::raw::c_int,
        minor: ::std::os::raw::c_int,
        support: *mut ::std::os::raw::c_int,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Check support for a compute device\n\n This function is used to check the support for a compute device.\n It sets the \\p support when the device is supported by the current\n version of CUPTI, and clears it otherwise.\n\n \\param dev The device handle returned by CUDA Driver API cuDeviceGet\n \\param support Pointer to an integer to return the support status\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p support is NULL\n \\retval CUPTI_ERROR_INVALID_DEVICE if \\p dev is not a valid device\n\n \\sa ::cuptiComputeCapabilitySupported"]
    pub fn cuptiDeviceSupported(dev: CUdevice, support: *mut ::std::os::raw::c_int) -> CUptiResult;
}
#[doc = " No virtualization mode is associated with the device\n i.e. it's a baremetal GPU"]
pub const CUPTI_DEVICE_VIRTUALIZATION_MODE_NONE: CUpti_DeviceVirtualizationMode = 0;
#[doc = " The device is associated with the pass-through GPU.\n In this mode, an entire physical GPU is directly assigned\n to one virtual machine (VM)."]
pub const CUPTI_DEVICE_VIRTUALIZATION_MODE_PASS_THROUGH: CUpti_DeviceVirtualizationMode = 1;
#[doc = " The device is associated with the virtual GPU (vGPU).\n In this mode multiple virtual machines (VMs) have simultaneous,\n direct access to a single physical GPU."]
pub const CUPTI_DEVICE_VIRTUALIZATION_MODE_VIRTUAL_GPU: CUpti_DeviceVirtualizationMode = 2;
#[doc = " The device is associated with the virtual GPU (vGPU).\n In this mode multiple virtual machines (VMs) have simultaneous,\n direct access to a single physical GPU."]
pub const CUPTI_DEVICE_VIRTUALIZATION_MODE_FORCE_INT: CUpti_DeviceVirtualizationMode = 2147483647;
#[doc = " This indicates the virtualization mode in which CUDA device is running"]
pub type CUpti_DeviceVirtualizationMode = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " \\brief Query the virtualization mode of the device\n\n This function is used to query the virtualization mode of the CUDA device.\n\n \\param dev The device handle returned by CUDA Driver API cuDeviceGet\n \\param mode Pointer to an CUpti_DeviceVirtualizationMode to return the virtualization mode\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_DEVICE if \\p dev is not a valid device\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p mode is NULL\n"]
    pub fn cuptiDeviceVirtualizationMode(
        dev: CUdevice,
        mode: *mut CUpti_DeviceVirtualizationMode,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Detach CUPTI from the running process\n\n This API detaches the CUPTI from the running process. It destroys and cleans up all the\n resources associated with CUPTI in the current process. After CUPTI detaches from the process,\n the process will keep on running with no CUPTI attached to it.\n For safe operation of the API, it is recommended this API is invoked from the exit callsite\n of any of the CUDA Driver or Runtime API. Otherwise CUPTI client needs to make sure that\n required CUDA synchronization and CUPTI activity buffer flush is done before calling the API.\n Sample code showing the usage of the API in the cupti callback handler code:\n \\code\nvoid CUPTIAPI\ncuptiCallbackHandler(void *userdata, CUpti_CallbackDomain domain,\nCUpti_CallbackId cbid, void *cbdata)\n{\nconst CUpti_CallbackData *cbInfo = (CUpti_CallbackData *)cbdata;\n\n// Take this code path when CUPTI detach is requested\nif (detachCupti) {\nswitch(domain)\n{\ncase CUPTI_CB_DOMAIN_RUNTIME_API:\ncase CUPTI_CB_DOMAIN_DRIVER_API:\nif (cbInfo->callbackSite == CUPTI_API_EXIT) {\n// call the CUPTI detach API\ncuptiFinalize();\n}\nbreak;\ndefault:\nbreak;\n}\n}\n}\n\\endcode"]
    pub fn cuptiFinalize() -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Push an external correlation id for the calling thread\n\n This function notifies CUPTI that the calling thread is entering an external API region.\n When a CUPTI activity API record is created while within an external API region and\n CUPTI_ACTIVITY_KIND_EXTERNAL_CORRELATION is enabled, the activity API record will\n be preceded by a CUpti_ActivityExternalCorrelation record for each \\ref CUpti_ExternalCorrelationKind.\n\n \\param kind The kind of external API activities should be correlated with.\n \\param id External correlation id.\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER The external API kind is invalid"]
    pub fn cuptiActivityPushExternalCorrelationId(
        kind: CUpti_ExternalCorrelationKind,
        id: u64,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Pop an external correlation id for the calling thread\n\n This function notifies CUPTI that the calling thread is leaving an external API region.\n\n \\param kind The kind of external API activities should be correlated with.\n \\param lastId If the function returns successful, contains the last external correlation id for this \\p kind, can be NULL.\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER The external API kind is invalid.\n \\retval CUPTI_ERROR_QUEUE_EMPTY No external id is currently associated with \\p kind."]
    pub fn cuptiActivityPopExternalCorrelationId(
        kind: CUpti_ExternalCorrelationKind,
        lastId: *mut u64,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Controls the collection of queued and submitted timestamps for kernels.\n\n This API is used to control the collection of queued and submitted timestamps\n for kernels whose records are provided through the struct \\ref CUpti_ActivityKernel10.\n Default value is 0, i.e. these timestamps are not collected. This API needs\n to be called before initialization of CUDA and this setting should not be\n changed during the profiling session.\n\n This API is not supported if the HW trace is enabled through the API \\ref cuptiActivityEnableHWTrace.\n \\param enable is a boolean, denoting whether these timestamps should be\n collected\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED"]
    pub fn cuptiActivityEnableLatencyTimestamps(enable: u8) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Sets the flush period for the worker thread\n\n CUPTI creates a worker thread to minimize the perturbance for the application created\n threads. CUPTI offloads certain operations from the application threads to the worker\n thread, this includes synchronization of profiling resources between host and device,\n delivery of the activity buffers to the client using the callback registered in\n cuptiActivityRegisterCallbacks. For performance reasons, CUPTI wakes up the worker\n thread based on certain heuristics.\n\n This API is used to control the flush period of the worker thread. This setting will\n override the CUPTI heuristics. Setting time to zero disables the periodic flush and\n restores the default behavior.\n\n Periodic flush can return only those activity buffers which are full and have all the\n activity records completed.\n\n It's allowed to use the API \\ref cuptiActivityFlushAll to flush the data on-demand, even\n when client sets the periodic flush.\n\n \\param time flush period in milliseconds (ms)\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED\n\n \\see cuptiActivityFlushAll"]
    pub fn cuptiActivityFlushPeriod(time: u32) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Controls the collection of launch attributes for kernels.\n\n This API is used to control the collection of launch attributes for kernels whose\n records are provided through the struct \\ref CUpti_ActivityKernel10.\n Default value is 0, i.e. these attributes are not collected.\n\n \\param enable is a boolean denoting whether these launch attributes should be collected"]
    pub fn cuptiActivityEnableLaunchAttributes(enable: u8) -> CUptiResult;
}
#[doc = " \\brief Function type for callback used by CUPTI to request a timestamp\n to be used in activity records.\n\n This callback function signals the CUPTI client that a timestamp needs\n to be returned. This timestamp would be treated as normalized timestamp\n to be used for various purposes in CUPTI. For example to store start and\n end timestamps reported in the CUPTI activity records.\n The returned timestamp must be in nanoseconds.\n\n \\sa ::cuptiActivityRegisterTimestampCallback"]
pub type CUpti_TimestampCallbackFunc = ::std::option::Option<unsafe extern "C" fn() -> u64>;
unsafe extern "C" {
    #[doc = " \\brief Registers callback function with CUPTI for providing timestamp.\n\n This function registers a callback function to obtain timestamp of user's\n choice instead of using CUPTI provided timestamp.\n By default CUPTI uses different methods, based on the underlying platform,\n to retrieve the timestamp\n Linux (x86_64, aarch64 sbsa, aarch64) uses clock_gettime(CLOCK_REALTIME)\n Windows uses QueryPerformanceCounter()\n WSL (Windows Subsystem for Linux) uses clock_gettime(CLOCK_MONOTONIC_RAW) as CLOCK_REALTIME can cause backward jumps.\n QNX uses ClockCycles()\n Timestamps retrieved using these methods are converted to nanosecond if needed\n before usage.\n\n Timestamps for GPU activities such as kernels, memory copies and memset operations are\n recorded directly on the GPU. To provide a unified and normalized view of these timestamps\n in relation to CPU time, CUPTI performs a linear interpolation to convert GPU timestamps\n into CPU timestamps during post-processing.\n For activities where timestamps are captured on the GPU, the timestamp callback is invoked\n during the post-processing phase, while converting GPU timestamps into CPU timestamps.\n For activities for which timestamps are captured directly on the CPU, the timestamp callback\n is invoked immediately at the time of the activity.\n\n The registration of timestamp callback should be done before any of the CUPTI\n activity kinds are enabled to make sure that all the records report the timestamp using\n the callback function registered through cuptiActivityRegisterTimestampCallback API.\n\n Changing the timestamp callback function in CUPTI through\n cuptiActivityRegisterTimestampCallback API in the middle of the profiling\n session can cause records generated prior to the change to report\n timestamps through previous timestamp method.\n\n \\param funcTimestamp callback which is invoked when a timestamp is\n needed by CUPTI\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p funcTimestamp is NULL\n \\retval CUPTI_ERROR_NOT_INITIALIZED"]
    pub fn cuptiActivityRegisterTimestampCallback(
        funcTimestamp: CUpti_TimestampCallbackFunc,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Controls the collection of records for device launched graphs.\n\n This API is used to control the collection of records for device launched graphs.\n Default value is 0, i.e. these records are not collected.\n Default value is 1 if HW trace is enabled using API cuptiActivityEnableHWTrace.\n This API needs to be called before initialization of CUDA and this setting should not be\n changed during the profiling session.\n\n \\param enable is a boolean, denoting whether these records should be\n collected\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED"]
    pub fn cuptiActivityEnableDeviceGraph(enable: u8) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Controls the collection of activity records for specific CUDA Driver APIs.\n\n Activity kind CUPTI_ACTIVITY_KIND_DRIVER controls the collection of either all\n CUDA Driver APIs or none. API cuptiActivityEnableDriverApi can be used for fine-grained\n control, it allows enabling/disabling tracing of a specific set of CUDA Driver APIs.\n To disable collection of a small set of CUDA Driver APIs, user can\n first enable the collection of all Driver APIs using the activity kind\n CUPTI_ACTIVITY_KIND_DRIVER and call this API to disable specific Driver APIs.\n And to enable the collection of a small set of CUDA Driver APIs, user can\n call this API without using the activity kind CUPTI_ACTIVITY_KIND_DRIVER.\n\n Note: Activity kind CUPTI_ACTIVITY_KIND_DRIVER overrides the settings done by this API\n if it is called after the API.\n\n \\param cbid callback id of the CUDA Driver API. This can be found in the header cupti_driver_cbid.h.\n \\param enable is a boolean, denoting whether to enable or disable the collection\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED"]
    pub fn cuptiActivityEnableDriverApi(cbid: CUpti_CallbackId, enable: u8) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Controls the collection of activity records for specific CUDA Runtime APIs.\n\n Activity kind CUPTI_ACTIVITY_KIND_RUNTIME controls the collection of either all\n CUDA Runtime APIs or none. API cuptiActivityEnableRuntimeApi can be used for fine-grained\n control, it allows enabling/disabling tracing of a specific set of CUDA Runtime APIs.\n To disable collection of a small set of CUDA Runtime APIs, user can\n first enable the collection of all Runtime APIs using the activity kind\n CUPTI_ACTIVITY_KIND_RUNTIME and call this API to disable specific Runtime APIs.\n And to enable the collection of a small set of CUDA Runtime APIs, user can\n call this API without using the activity kind CUPTI_ACTIVITY_KIND_RUNTIME.\n\n Note: Activity kind CUPTI_ACTIVITY_KIND_RUNTIME overrides the settings done by this API\n if it is called after the API.\n\n \\param cbid callback id of the CUDA Runtime API. This can be found in the header cupti_runtime_cbid.h.\n \\param enable is a boolean, denoting whether to enable or disable the collection\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED"]
    pub fn cuptiActivityEnableRuntimeApi(cbid: CUpti_CallbackId, enable: u8) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Enables the collection of CUDA kernel timestamps through Hardware Event System(HES).\n\n This API enables the collection of CUDA kernel timestamps through HW events instead\n of the traditional SW instrumentation and semaphore based approach.\n This option is only available on Blackwell architecture.\n This API should be called after driver is initialized.\n\n \\param enable is a boolean, denoting whether to enable or disable the collection through HW events\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED if CUPTI is not initialized or the CUDA driver is not initialized\n \\retval CUPTI_ERROR_NOT_SUPPORTED if HW trace cannot be enabled on the current platform\n \\retval CUPTI_ERROR_VIRTUALIZED_DEVICE_NOT_SUPPORTED\n \\retval CUPTI_ERROR_CONFIDENTIAL_COMPUTING_NOT_SUPPORTED\n \\retval CUPTI_ERROR_CMP_DEVICE_NOT_SUPPORTED\n \\retval CUPTI_ERROR_MIG_DEVICE_NOT_SUPPORTED\n \\retval CUPTI_ERROR_SLI_DEVICE_NOT_SUPPORTED\n \\retval CUPTI_ERROR_WSL_DEVICE_NOT_SUPPORTED"]
    pub fn cuptiActivityEnableHWTrace(enable: u8) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = "  \\brief Enables tracking the source library for memory allocation requests.\n\n This API is used to control whether or not we track the source library of\n memory allocation requests. Default value is 0, i.e. it is not tracked. The\n activity kind CUPTI_ACTIVITY_KIND_MEMORY2 needs to be enabled, and if this flag is\n set, we get the full path of the shared object responsible for the GPU memory allocation\n request in the member source in the CUpti_ActivityMemory4 records. Also note that this feature\n adds runtime overhead.\n\n \\param enable is a boolean, denoting whether the source library of the memory allocation\n request needs to be tracked\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED"]
    pub fn cuptiActivityEnableAllocationSource(enable: u8) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Enables collecting records for all synchronization operations.\n\n CUPTI provides CUDA event query and stream query records via CUPTI_ACTIVITY_KIND_SYNCHRONIZATION.\n Using this API, CUPTI client can disable to record CUDA event query and stream query records\n for queries for which the operations have not yet been completed on the CUDA event/stream.\n\n By default, the record is generated for all CUDA events and stream irrespective of whether the\n operations have been completed on the CUDA event/stream.\n\n \\param enable is a boolean, denoting whether to enable or disable the collection of all CUDA event query\n and stream query records\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED"]
    pub fn cuptiActivityEnableAllSyncRecords(enable: u8) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Enable/Disable collecting device timestamp for CUPTI_ACTIVITY_KIND_CUDA_EVENT record.\n\n CUPTI provides device timestamps via 'deviceTimestamp' field in CUPTI_ACTIVITY_KIND_CUDA_EVENT records.\n Using this API, CUPTI client can enable or disable the collection of CUDA event device timestamps.\n By default, the collection of CUDA event device timestamps is disabled.\n\n \\param enable is a boolean, denoting whether to enable or disable the collection of CUDA event device timestamps\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_NOT_INITIALIZED"]
    pub fn cuptiActivityEnableCudaEventDeviceTimestamps(enable: u8) -> CUptiResult;
}
#[doc = " \\brief The activity record for CUPTI and driver overheads.\n (Deprecated in CUDA 12.2)\n\n This activity record provides CUPTI and driver overhead information\n (CUPTI_ACTIVITY_OVERHEAD). These records are now reported using\n CUpti_ActivityOverhead3"]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityOverhead {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_OVERHEAD."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The kind of overhead, CUPTI, DRIVER, COMPILER etc."]
    pub overheadKind: CUpti_ActivityOverheadKind,
    #[doc = " The kind of activity object that the overhead is associated with."]
    pub objectKind: CUpti_ActivityObjectKind,
    #[doc = " The identifier for the activity object. 'objectKind' indicates\n which ID is valid for this record."]
    pub objectId: CUpti_ActivityObjectKindId,
    #[doc = " The start timestamp for the overhead, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the overhead."]
    pub start: u64,
    #[doc = " The end timestamp for the overhead, in ns. A value of 0 for both\n the start and end timestamps indicates that timestamp information\n could not be collected for the overhead."]
    pub end: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityOverhead"][::std::mem::size_of::<CUpti_ActivityOverhead>() - 40usize];
    ["Alignment of CUpti_ActivityOverhead"]
        [::std::mem::align_of::<CUpti_ActivityOverhead>() - 8usize];
    ["Offset of field: CUpti_ActivityOverhead::kind"]
        [::std::mem::offset_of!(CUpti_ActivityOverhead, kind) - 0usize];
    ["Offset of field: CUpti_ActivityOverhead::overheadKind"]
        [::std::mem::offset_of!(CUpti_ActivityOverhead, overheadKind) - 4usize];
    ["Offset of field: CUpti_ActivityOverhead::objectKind"]
        [::std::mem::offset_of!(CUpti_ActivityOverhead, objectKind) - 8usize];
    ["Offset of field: CUpti_ActivityOverhead::objectId"]
        [::std::mem::offset_of!(CUpti_ActivityOverhead, objectId) - 12usize];
    ["Offset of field: CUpti_ActivityOverhead::start"]
        [::std::mem::offset_of!(CUpti_ActivityOverhead, start) - 24usize];
    ["Offset of field: CUpti_ActivityOverhead::end"]
        [::std::mem::offset_of!(CUpti_ActivityOverhead, end) - 32usize];
};
impl Default for CUpti_ActivityOverhead {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityOverhead {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityOverhead {{ kind: {:?}, overheadKind: {:?}, objectKind: {:?}, objectId: {:?} }}",
            self.kind, self.overheadKind, self.objectKind, self.objectId
        )
    }
}
#[doc = " \\brief The activity record for CUPTI and driver overheads.\n\n This activity record provides CUPTI and driver overhead information\n (CUPTI_ACTIVITY_OVERHEAD)."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityOverhead2 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_OVERHEAD."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The kind of overhead, CUPTI, DRIVER, COMPILER etc."]
    pub overheadKind: CUpti_ActivityOverheadKind,
    #[doc = " The kind of activity object that the overhead is associated with."]
    pub objectKind: CUpti_ActivityObjectKind,
    #[doc = " The identifier for the activity object. 'objectKind' indicates\n which ID is valid for this record."]
    pub objectId: CUpti_ActivityObjectKindId,
    #[doc = " The start timestamp for the overhead, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the overhead."]
    pub start: u64,
    #[doc = " The end timestamp for the overhead, in ns. A value of 0 for both\n the start and end timestamps indicates that timestamp information\n could not be collected for the overhead."]
    pub end: u64,
    #[doc = " The correlation ID of the overhead operation to which\n records belong to. This ID is identical to the\n correlation ID in the driver or runtime API activity record that\n launched the overhead operation.\n In some cases, it can be zero, such as for CUPTI_ACTIVITY_OVERHEAD_CUPTI_BUFFER_FLUSH records."]
    pub correlationId: u32,
    #[doc = " Reserved for internal use."]
    pub reserved0: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityOverhead2"][::std::mem::size_of::<CUpti_ActivityOverhead2>() - 48usize];
    ["Alignment of CUpti_ActivityOverhead2"]
        [::std::mem::align_of::<CUpti_ActivityOverhead2>() - 8usize];
    ["Offset of field: CUpti_ActivityOverhead2::kind"]
        [::std::mem::offset_of!(CUpti_ActivityOverhead2, kind) - 0usize];
    ["Offset of field: CUpti_ActivityOverhead2::overheadKind"]
        [::std::mem::offset_of!(CUpti_ActivityOverhead2, overheadKind) - 4usize];
    ["Offset of field: CUpti_ActivityOverhead2::objectKind"]
        [::std::mem::offset_of!(CUpti_ActivityOverhead2, objectKind) - 8usize];
    ["Offset of field: CUpti_ActivityOverhead2::objectId"]
        [::std::mem::offset_of!(CUpti_ActivityOverhead2, objectId) - 12usize];
    ["Offset of field: CUpti_ActivityOverhead2::start"]
        [::std::mem::offset_of!(CUpti_ActivityOverhead2, start) - 24usize];
    ["Offset of field: CUpti_ActivityOverhead2::end"]
        [::std::mem::offset_of!(CUpti_ActivityOverhead2, end) - 32usize];
    ["Offset of field: CUpti_ActivityOverhead2::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityOverhead2, correlationId) - 40usize];
    ["Offset of field: CUpti_ActivityOverhead2::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityOverhead2, reserved0) - 44usize];
};
impl Default for CUpti_ActivityOverhead2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityOverhead2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityOverhead2 {{ kind: {:?}, overheadKind: {:?}, objectKind: {:?}, objectId: {:?} }}",
            self.kind, self.overheadKind, self.objectKind, self.objectId
        )
    }
}
#[doc = " \\brief The activity record for a device. (deprecated)\n\n This activity record represents information about a GPU device\n (CUPTI_ACTIVITY_KIND_DEVICE).\n Device activity is now reported using the\n CUpti_ActivityDevice5 activity record."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityDevice {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_DEVICE."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The flags associated with the device. \\see CUpti_ActivityFlag"]
    pub flags: CUpti_ActivityFlag,
    #[doc = " The global memory bandwidth available on the device, in\n kBytes/sec."]
    pub globalMemoryBandwidth: u64,
    #[doc = " The amount of global memory on the device, in bytes."]
    pub globalMemorySize: u64,
    #[doc = " The amount of constant memory on the device, in bytes."]
    pub constantMemorySize: u32,
    #[doc = " The size of the L2 cache on the device, in bytes."]
    pub l2CacheSize: u32,
    #[doc = " The number of threads per warp on the device."]
    pub numThreadsPerWarp: u32,
    #[doc = " The core clock rate of the device, in kHz."]
    pub coreClockRate: u32,
    #[doc = " Number of memory copy engines on the device."]
    pub numMemcpyEngines: u32,
    #[doc = " Number of multiprocessors on the device."]
    pub numMultiprocessors: u32,
    #[doc = " The maximum \"instructions per cycle\" possible on each device\n multiprocessor."]
    pub maxIPC: u32,
    #[doc = " Maximum number of warps that can be present on a multiprocessor\n at any given time."]
    pub maxWarpsPerMultiprocessor: u32,
    #[doc = " Maximum number of blocks that can be present on a multiprocessor\n at any given time."]
    pub maxBlocksPerMultiprocessor: u32,
    #[doc = " Maximum number of registers that can be allocated to a block."]
    pub maxRegistersPerBlock: u32,
    #[doc = " Maximum amount of shared memory that can be assigned to a block,\n in bytes."]
    pub maxSharedMemoryPerBlock: u32,
    #[doc = " Maximum number of threads allowed in a block."]
    pub maxThreadsPerBlock: u32,
    #[doc = " Maximum allowed X dimension for a block."]
    pub maxBlockDimX: u32,
    #[doc = " Maximum allowed Y dimension for a block."]
    pub maxBlockDimY: u32,
    #[doc = " Maximum allowed Z dimension for a block."]
    pub maxBlockDimZ: u32,
    #[doc = " Maximum allowed X dimension for a grid."]
    pub maxGridDimX: u32,
    #[doc = " Maximum allowed Y dimension for a grid."]
    pub maxGridDimY: u32,
    #[doc = " Maximum allowed Z dimension for a grid."]
    pub maxGridDimZ: u32,
    #[doc = " Compute capability for the device, major number."]
    pub computeCapabilityMajor: u32,
    #[doc = " Compute capability for the device, minor number."]
    pub computeCapabilityMinor: u32,
    #[doc = " The device ID."]
    pub id: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
    #[doc = " The device name. This name is shared across all activity records\n representing instances of the device, and so should not be\n modified."]
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityDevice"][::std::mem::size_of::<CUpti_ActivityDevice>() - 120usize];
    ["Alignment of CUpti_ActivityDevice"][::std::mem::align_of::<CUpti_ActivityDevice>() - 8usize];
    ["Offset of field: CUpti_ActivityDevice::kind"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, kind) - 0usize];
    ["Offset of field: CUpti_ActivityDevice::flags"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, flags) - 4usize];
    ["Offset of field: CUpti_ActivityDevice::globalMemoryBandwidth"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, globalMemoryBandwidth) - 8usize];
    ["Offset of field: CUpti_ActivityDevice::globalMemorySize"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, globalMemorySize) - 16usize];
    ["Offset of field: CUpti_ActivityDevice::constantMemorySize"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, constantMemorySize) - 24usize];
    ["Offset of field: CUpti_ActivityDevice::l2CacheSize"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, l2CacheSize) - 28usize];
    ["Offset of field: CUpti_ActivityDevice::numThreadsPerWarp"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, numThreadsPerWarp) - 32usize];
    ["Offset of field: CUpti_ActivityDevice::coreClockRate"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, coreClockRate) - 36usize];
    ["Offset of field: CUpti_ActivityDevice::numMemcpyEngines"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, numMemcpyEngines) - 40usize];
    ["Offset of field: CUpti_ActivityDevice::numMultiprocessors"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, numMultiprocessors) - 44usize];
    ["Offset of field: CUpti_ActivityDevice::maxIPC"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, maxIPC) - 48usize];
    ["Offset of field: CUpti_ActivityDevice::maxWarpsPerMultiprocessor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, maxWarpsPerMultiprocessor) - 52usize];
    ["Offset of field: CUpti_ActivityDevice::maxBlocksPerMultiprocessor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, maxBlocksPerMultiprocessor) - 56usize];
    ["Offset of field: CUpti_ActivityDevice::maxRegistersPerBlock"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, maxRegistersPerBlock) - 60usize];
    ["Offset of field: CUpti_ActivityDevice::maxSharedMemoryPerBlock"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, maxSharedMemoryPerBlock) - 64usize];
    ["Offset of field: CUpti_ActivityDevice::maxThreadsPerBlock"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, maxThreadsPerBlock) - 68usize];
    ["Offset of field: CUpti_ActivityDevice::maxBlockDimX"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, maxBlockDimX) - 72usize];
    ["Offset of field: CUpti_ActivityDevice::maxBlockDimY"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, maxBlockDimY) - 76usize];
    ["Offset of field: CUpti_ActivityDevice::maxBlockDimZ"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, maxBlockDimZ) - 80usize];
    ["Offset of field: CUpti_ActivityDevice::maxGridDimX"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, maxGridDimX) - 84usize];
    ["Offset of field: CUpti_ActivityDevice::maxGridDimY"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, maxGridDimY) - 88usize];
    ["Offset of field: CUpti_ActivityDevice::maxGridDimZ"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, maxGridDimZ) - 92usize];
    ["Offset of field: CUpti_ActivityDevice::computeCapabilityMajor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, computeCapabilityMajor) - 96usize];
    ["Offset of field: CUpti_ActivityDevice::computeCapabilityMinor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, computeCapabilityMinor) - 100usize];
    ["Offset of field: CUpti_ActivityDevice::id"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, id) - 104usize];
    ["Offset of field: CUpti_ActivityDevice::pad"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, pad) - 108usize];
    ["Offset of field: CUpti_ActivityDevice::name"]
        [::std::mem::offset_of!(CUpti_ActivityDevice, name) - 112usize];
};
impl Default for CUpti_ActivityDevice {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for a device. (deprecated)\n\n This activity record represents information about a GPU device\n (CUPTI_ACTIVITY_KIND_DEVICE).\n Device activity is now reported using the\n CUpti_ActivityDevice5 activity record."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityDevice2 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_DEVICE."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The flags associated with the device. \\see CUpti_ActivityFlag"]
    pub flags: CUpti_ActivityFlag,
    #[doc = " The global memory bandwidth available on the device, in\n kBytes/sec."]
    pub globalMemoryBandwidth: u64,
    #[doc = " The amount of global memory on the device, in bytes."]
    pub globalMemorySize: u64,
    #[doc = " The amount of constant memory on the device, in bytes."]
    pub constantMemorySize: u32,
    #[doc = " The size of the L2 cache on the device, in bytes."]
    pub l2CacheSize: u32,
    #[doc = " The number of threads per warp on the device."]
    pub numThreadsPerWarp: u32,
    #[doc = " The core clock rate of the device, in kHz."]
    pub coreClockRate: u32,
    #[doc = " Number of memory copy engines on the device."]
    pub numMemcpyEngines: u32,
    #[doc = " Number of multiprocessors on the device."]
    pub numMultiprocessors: u32,
    #[doc = " The maximum \"instructions per cycle\" possible on each device\n multiprocessor."]
    pub maxIPC: u32,
    #[doc = " Maximum number of warps that can be present on a multiprocessor\n at any given time."]
    pub maxWarpsPerMultiprocessor: u32,
    #[doc = " Maximum number of blocks that can be present on a multiprocessor\n at any given time."]
    pub maxBlocksPerMultiprocessor: u32,
    #[doc = " Maximum amount of shared memory available per multiprocessor, in bytes."]
    pub maxSharedMemoryPerMultiprocessor: u32,
    #[doc = " Maximum number of 32-bit registers available per multiprocessor."]
    pub maxRegistersPerMultiprocessor: u32,
    #[doc = " Maximum number of registers that can be allocated to a block."]
    pub maxRegistersPerBlock: u32,
    #[doc = " Maximum amount of shared memory that can be assigned to a block,\n in bytes."]
    pub maxSharedMemoryPerBlock: u32,
    #[doc = " Maximum number of threads allowed in a block."]
    pub maxThreadsPerBlock: u32,
    #[doc = " Maximum allowed X dimension for a block."]
    pub maxBlockDimX: u32,
    #[doc = " Maximum allowed Y dimension for a block."]
    pub maxBlockDimY: u32,
    #[doc = " Maximum allowed Z dimension for a block."]
    pub maxBlockDimZ: u32,
    #[doc = " Maximum allowed X dimension for a grid."]
    pub maxGridDimX: u32,
    #[doc = " Maximum allowed Y dimension for a grid."]
    pub maxGridDimY: u32,
    #[doc = " Maximum allowed Z dimension for a grid."]
    pub maxGridDimZ: u32,
    #[doc = " Compute capability for the device, major number."]
    pub computeCapabilityMajor: u32,
    #[doc = " Compute capability for the device, minor number."]
    pub computeCapabilityMinor: u32,
    #[doc = " The device ID."]
    pub id: u32,
    #[doc = " ECC enabled flag for device"]
    pub eccEnabled: u32,
    #[doc = " The device UUID. This value is the globally unique immutable\n alphanumeric identifier of the device."]
    pub uuid: CUuuid,
    #[doc = " The device name. This name is shared across all activity records\n representing instances of the device, and so should not be\n modified."]
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityDevice2"][::std::mem::size_of::<CUpti_ActivityDevice2>() - 144usize];
    ["Alignment of CUpti_ActivityDevice2"]
        [::std::mem::align_of::<CUpti_ActivityDevice2>() - 8usize];
    ["Offset of field: CUpti_ActivityDevice2::kind"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, kind) - 0usize];
    ["Offset of field: CUpti_ActivityDevice2::flags"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, flags) - 4usize];
    ["Offset of field: CUpti_ActivityDevice2::globalMemoryBandwidth"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, globalMemoryBandwidth) - 8usize];
    ["Offset of field: CUpti_ActivityDevice2::globalMemorySize"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, globalMemorySize) - 16usize];
    ["Offset of field: CUpti_ActivityDevice2::constantMemorySize"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, constantMemorySize) - 24usize];
    ["Offset of field: CUpti_ActivityDevice2::l2CacheSize"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, l2CacheSize) - 28usize];
    ["Offset of field: CUpti_ActivityDevice2::numThreadsPerWarp"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, numThreadsPerWarp) - 32usize];
    ["Offset of field: CUpti_ActivityDevice2::coreClockRate"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, coreClockRate) - 36usize];
    ["Offset of field: CUpti_ActivityDevice2::numMemcpyEngines"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, numMemcpyEngines) - 40usize];
    ["Offset of field: CUpti_ActivityDevice2::numMultiprocessors"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, numMultiprocessors) - 44usize];
    ["Offset of field: CUpti_ActivityDevice2::maxIPC"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, maxIPC) - 48usize];
    ["Offset of field: CUpti_ActivityDevice2::maxWarpsPerMultiprocessor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, maxWarpsPerMultiprocessor) - 52usize];
    ["Offset of field: CUpti_ActivityDevice2::maxBlocksPerMultiprocessor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, maxBlocksPerMultiprocessor) - 56usize];
    ["Offset of field: CUpti_ActivityDevice2::maxSharedMemoryPerMultiprocessor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, maxSharedMemoryPerMultiprocessor) - 60usize];
    ["Offset of field: CUpti_ActivityDevice2::maxRegistersPerMultiprocessor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, maxRegistersPerMultiprocessor) - 64usize];
    ["Offset of field: CUpti_ActivityDevice2::maxRegistersPerBlock"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, maxRegistersPerBlock) - 68usize];
    ["Offset of field: CUpti_ActivityDevice2::maxSharedMemoryPerBlock"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, maxSharedMemoryPerBlock) - 72usize];
    ["Offset of field: CUpti_ActivityDevice2::maxThreadsPerBlock"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, maxThreadsPerBlock) - 76usize];
    ["Offset of field: CUpti_ActivityDevice2::maxBlockDimX"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, maxBlockDimX) - 80usize];
    ["Offset of field: CUpti_ActivityDevice2::maxBlockDimY"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, maxBlockDimY) - 84usize];
    ["Offset of field: CUpti_ActivityDevice2::maxBlockDimZ"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, maxBlockDimZ) - 88usize];
    ["Offset of field: CUpti_ActivityDevice2::maxGridDimX"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, maxGridDimX) - 92usize];
    ["Offset of field: CUpti_ActivityDevice2::maxGridDimY"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, maxGridDimY) - 96usize];
    ["Offset of field: CUpti_ActivityDevice2::maxGridDimZ"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, maxGridDimZ) - 100usize];
    ["Offset of field: CUpti_ActivityDevice2::computeCapabilityMajor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, computeCapabilityMajor) - 104usize];
    ["Offset of field: CUpti_ActivityDevice2::computeCapabilityMinor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, computeCapabilityMinor) - 108usize];
    ["Offset of field: CUpti_ActivityDevice2::id"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, id) - 112usize];
    ["Offset of field: CUpti_ActivityDevice2::eccEnabled"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, eccEnabled) - 116usize];
    ["Offset of field: CUpti_ActivityDevice2::uuid"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, uuid) - 120usize];
    ["Offset of field: CUpti_ActivityDevice2::name"]
        [::std::mem::offset_of!(CUpti_ActivityDevice2, name) - 136usize];
};
impl Default for CUpti_ActivityDevice2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for a device. (CUDA 7.0 onwards)\n\n This activity record represents information about a GPU device\n (CUPTI_ACTIVITY_KIND_DEVICE).\n Device activity is now reported using the\n CUpti_ActivityDevice5 activity record."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityDevice3 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_DEVICE."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The flags associated with the device. \\see CUpti_ActivityFlag"]
    pub flags: CUpti_ActivityFlag,
    #[doc = " The global memory bandwidth available on the device, in\n kBytes/sec."]
    pub globalMemoryBandwidth: u64,
    #[doc = " The amount of global memory on the device, in bytes."]
    pub globalMemorySize: u64,
    #[doc = " The amount of constant memory on the device, in bytes."]
    pub constantMemorySize: u32,
    #[doc = " The size of the L2 cache on the device, in bytes."]
    pub l2CacheSize: u32,
    #[doc = " The number of threads per warp on the device."]
    pub numThreadsPerWarp: u32,
    #[doc = " The core clock rate of the device, in kHz."]
    pub coreClockRate: u32,
    #[doc = " Number of memory copy engines on the device."]
    pub numMemcpyEngines: u32,
    #[doc = " Number of multiprocessors on the device."]
    pub numMultiprocessors: u32,
    #[doc = " The maximum \"instructions per cycle\" possible on each device\n multiprocessor."]
    pub maxIPC: u32,
    #[doc = " Maximum number of warps that can be present on a multiprocessor\n at any given time."]
    pub maxWarpsPerMultiprocessor: u32,
    #[doc = " Maximum number of blocks that can be present on a multiprocessor\n at any given time."]
    pub maxBlocksPerMultiprocessor: u32,
    #[doc = " Maximum amount of shared memory available per multiprocessor, in bytes."]
    pub maxSharedMemoryPerMultiprocessor: u32,
    #[doc = " Maximum number of 32-bit registers available per multiprocessor."]
    pub maxRegistersPerMultiprocessor: u32,
    #[doc = " Maximum number of registers that can be allocated to a block."]
    pub maxRegistersPerBlock: u32,
    #[doc = " Maximum amount of shared memory that can be assigned to a block,\n in bytes."]
    pub maxSharedMemoryPerBlock: u32,
    #[doc = " Maximum number of threads allowed in a block."]
    pub maxThreadsPerBlock: u32,
    #[doc = " Maximum allowed X dimension for a block."]
    pub maxBlockDimX: u32,
    #[doc = " Maximum allowed Y dimension for a block."]
    pub maxBlockDimY: u32,
    #[doc = " Maximum allowed Z dimension for a block."]
    pub maxBlockDimZ: u32,
    #[doc = " Maximum allowed X dimension for a grid."]
    pub maxGridDimX: u32,
    #[doc = " Maximum allowed Y dimension for a grid."]
    pub maxGridDimY: u32,
    #[doc = " Maximum allowed Z dimension for a grid."]
    pub maxGridDimZ: u32,
    #[doc = " Compute capability for the device, major number."]
    pub computeCapabilityMajor: u32,
    #[doc = " Compute capability for the device, minor number."]
    pub computeCapabilityMinor: u32,
    #[doc = " The device ID."]
    pub id: u32,
    #[doc = " ECC enabled flag for device"]
    pub eccEnabled: u32,
    #[doc = " The device UUID. This value is the globally unique immutable\n alphanumeric identifier of the device."]
    pub uuid: CUuuid,
    #[doc = " The device name. This name is shared across all activity records\n representing instances of the device, and so should not be\n modified."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Flag to indicate whether the device is visible to CUDA. Users can\n set the device visibility using CUDA_VISIBLE_DEVICES environment"]
    pub isCudaVisible: u8,
    pub reserved: [u8; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityDevice3"][::std::mem::size_of::<CUpti_ActivityDevice3>() - 152usize];
    ["Alignment of CUpti_ActivityDevice3"]
        [::std::mem::align_of::<CUpti_ActivityDevice3>() - 8usize];
    ["Offset of field: CUpti_ActivityDevice3::kind"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, kind) - 0usize];
    ["Offset of field: CUpti_ActivityDevice3::flags"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, flags) - 4usize];
    ["Offset of field: CUpti_ActivityDevice3::globalMemoryBandwidth"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, globalMemoryBandwidth) - 8usize];
    ["Offset of field: CUpti_ActivityDevice3::globalMemorySize"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, globalMemorySize) - 16usize];
    ["Offset of field: CUpti_ActivityDevice3::constantMemorySize"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, constantMemorySize) - 24usize];
    ["Offset of field: CUpti_ActivityDevice3::l2CacheSize"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, l2CacheSize) - 28usize];
    ["Offset of field: CUpti_ActivityDevice3::numThreadsPerWarp"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, numThreadsPerWarp) - 32usize];
    ["Offset of field: CUpti_ActivityDevice3::coreClockRate"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, coreClockRate) - 36usize];
    ["Offset of field: CUpti_ActivityDevice3::numMemcpyEngines"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, numMemcpyEngines) - 40usize];
    ["Offset of field: CUpti_ActivityDevice3::numMultiprocessors"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, numMultiprocessors) - 44usize];
    ["Offset of field: CUpti_ActivityDevice3::maxIPC"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, maxIPC) - 48usize];
    ["Offset of field: CUpti_ActivityDevice3::maxWarpsPerMultiprocessor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, maxWarpsPerMultiprocessor) - 52usize];
    ["Offset of field: CUpti_ActivityDevice3::maxBlocksPerMultiprocessor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, maxBlocksPerMultiprocessor) - 56usize];
    ["Offset of field: CUpti_ActivityDevice3::maxSharedMemoryPerMultiprocessor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, maxSharedMemoryPerMultiprocessor) - 60usize];
    ["Offset of field: CUpti_ActivityDevice3::maxRegistersPerMultiprocessor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, maxRegistersPerMultiprocessor) - 64usize];
    ["Offset of field: CUpti_ActivityDevice3::maxRegistersPerBlock"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, maxRegistersPerBlock) - 68usize];
    ["Offset of field: CUpti_ActivityDevice3::maxSharedMemoryPerBlock"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, maxSharedMemoryPerBlock) - 72usize];
    ["Offset of field: CUpti_ActivityDevice3::maxThreadsPerBlock"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, maxThreadsPerBlock) - 76usize];
    ["Offset of field: CUpti_ActivityDevice3::maxBlockDimX"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, maxBlockDimX) - 80usize];
    ["Offset of field: CUpti_ActivityDevice3::maxBlockDimY"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, maxBlockDimY) - 84usize];
    ["Offset of field: CUpti_ActivityDevice3::maxBlockDimZ"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, maxBlockDimZ) - 88usize];
    ["Offset of field: CUpti_ActivityDevice3::maxGridDimX"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, maxGridDimX) - 92usize];
    ["Offset of field: CUpti_ActivityDevice3::maxGridDimY"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, maxGridDimY) - 96usize];
    ["Offset of field: CUpti_ActivityDevice3::maxGridDimZ"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, maxGridDimZ) - 100usize];
    ["Offset of field: CUpti_ActivityDevice3::computeCapabilityMajor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, computeCapabilityMajor) - 104usize];
    ["Offset of field: CUpti_ActivityDevice3::computeCapabilityMinor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, computeCapabilityMinor) - 108usize];
    ["Offset of field: CUpti_ActivityDevice3::id"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, id) - 112usize];
    ["Offset of field: CUpti_ActivityDevice3::eccEnabled"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, eccEnabled) - 116usize];
    ["Offset of field: CUpti_ActivityDevice3::uuid"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, uuid) - 120usize];
    ["Offset of field: CUpti_ActivityDevice3::name"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, name) - 136usize];
    ["Offset of field: CUpti_ActivityDevice3::isCudaVisible"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, isCudaVisible) - 144usize];
    ["Offset of field: CUpti_ActivityDevice3::reserved"]
        [::std::mem::offset_of!(CUpti_ActivityDevice3, reserved) - 145usize];
};
impl Default for CUpti_ActivityDevice3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for a device. (CUDA 11.6 onwards)\n\n This activity record represents information about a GPU device\n (CUPTI_ACTIVITY_KIND_DEVICE).\n Device activity is now reported using the\n CUpti_ActivityDevice5 activity record."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityDevice4 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_DEVICE."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The flags associated with the device. \\see CUpti_ActivityFlag"]
    pub flags: CUpti_ActivityFlag,
    #[doc = " The global memory bandwidth available on the device, in\n kBytes/sec."]
    pub globalMemoryBandwidth: u64,
    #[doc = " The amount of global memory on the device, in bytes."]
    pub globalMemorySize: u64,
    #[doc = " The amount of constant memory on the device, in bytes."]
    pub constantMemorySize: u32,
    #[doc = " The size of the L2 cache on the device, in bytes."]
    pub l2CacheSize: u32,
    #[doc = " The number of threads per warp on the device."]
    pub numThreadsPerWarp: u32,
    #[doc = " The core clock rate of the device, in kHz."]
    pub coreClockRate: u32,
    #[doc = " Number of memory copy engines on the device."]
    pub numMemcpyEngines: u32,
    #[doc = " Number of multiprocessors on the device."]
    pub numMultiprocessors: u32,
    #[doc = " The maximum \"instructions per cycle\" possible on each device\n multiprocessor."]
    pub maxIPC: u32,
    #[doc = " Maximum number of warps that can be present on a multiprocessor\n at any given time."]
    pub maxWarpsPerMultiprocessor: u32,
    #[doc = " Maximum number of blocks that can be present on a multiprocessor\n at any given time."]
    pub maxBlocksPerMultiprocessor: u32,
    #[doc = " Maximum amount of shared memory available per multiprocessor, in bytes."]
    pub maxSharedMemoryPerMultiprocessor: u32,
    #[doc = " Maximum number of 32-bit registers available per multiprocessor."]
    pub maxRegistersPerMultiprocessor: u32,
    #[doc = " Maximum number of registers that can be allocated to a block."]
    pub maxRegistersPerBlock: u32,
    #[doc = " Maximum amount of shared memory that can be assigned to a block,\n in bytes."]
    pub maxSharedMemoryPerBlock: u32,
    #[doc = " Maximum number of threads allowed in a block."]
    pub maxThreadsPerBlock: u32,
    #[doc = " Maximum allowed X dimension for a block."]
    pub maxBlockDimX: u32,
    #[doc = " Maximum allowed Y dimension for a block."]
    pub maxBlockDimY: u32,
    #[doc = " Maximum allowed Z dimension for a block."]
    pub maxBlockDimZ: u32,
    #[doc = " Maximum allowed X dimension for a grid."]
    pub maxGridDimX: u32,
    #[doc = " Maximum allowed Y dimension for a grid."]
    pub maxGridDimY: u32,
    #[doc = " Maximum allowed Z dimension for a grid."]
    pub maxGridDimZ: u32,
    #[doc = " Compute capability for the device, major number."]
    pub computeCapabilityMajor: u32,
    #[doc = " Compute capability for the device, minor number."]
    pub computeCapabilityMinor: u32,
    #[doc = " The device ID."]
    pub id: u32,
    #[doc = " ECC enabled flag for device"]
    pub eccEnabled: u32,
    #[doc = " The device UUID. This value is the globally unique immutable\n alphanumeric identifier of the device."]
    pub uuid: CUuuid,
    #[doc = " The device name. This name is shared across all activity records\n representing instances of the device, and so should not be\n modified."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Flag to indicate whether the device is visible to CUDA. Users can\n set the device visibility using CUDA_VISIBLE_DEVICES environment"]
    pub isCudaVisible: u8,
    #[doc = " MIG enabled flag for device"]
    pub isMigEnabled: u8,
    pub reserved: [u8; 6usize],
    #[doc = " GPU Instance id for MIG enabled devices.\n If mig mode is disabled value is set to UINT32_MAX"]
    pub gpuInstanceId: u32,
    #[doc = " Compute Instance id for MIG enabled devices.\n If mig mode is disabled value is set to UINT32_MAX"]
    pub computeInstanceId: u32,
    #[doc = " The MIG UUID. This value is the globally unique immutable\n alphanumeric identifier of the device."]
    pub migUuid: CUuuid,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityDevice4"][::std::mem::size_of::<CUpti_ActivityDevice4>() - 176usize];
    ["Alignment of CUpti_ActivityDevice4"]
        [::std::mem::align_of::<CUpti_ActivityDevice4>() - 8usize];
    ["Offset of field: CUpti_ActivityDevice4::kind"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, kind) - 0usize];
    ["Offset of field: CUpti_ActivityDevice4::flags"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, flags) - 4usize];
    ["Offset of field: CUpti_ActivityDevice4::globalMemoryBandwidth"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, globalMemoryBandwidth) - 8usize];
    ["Offset of field: CUpti_ActivityDevice4::globalMemorySize"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, globalMemorySize) - 16usize];
    ["Offset of field: CUpti_ActivityDevice4::constantMemorySize"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, constantMemorySize) - 24usize];
    ["Offset of field: CUpti_ActivityDevice4::l2CacheSize"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, l2CacheSize) - 28usize];
    ["Offset of field: CUpti_ActivityDevice4::numThreadsPerWarp"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, numThreadsPerWarp) - 32usize];
    ["Offset of field: CUpti_ActivityDevice4::coreClockRate"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, coreClockRate) - 36usize];
    ["Offset of field: CUpti_ActivityDevice4::numMemcpyEngines"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, numMemcpyEngines) - 40usize];
    ["Offset of field: CUpti_ActivityDevice4::numMultiprocessors"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, numMultiprocessors) - 44usize];
    ["Offset of field: CUpti_ActivityDevice4::maxIPC"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, maxIPC) - 48usize];
    ["Offset of field: CUpti_ActivityDevice4::maxWarpsPerMultiprocessor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, maxWarpsPerMultiprocessor) - 52usize];
    ["Offset of field: CUpti_ActivityDevice4::maxBlocksPerMultiprocessor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, maxBlocksPerMultiprocessor) - 56usize];
    ["Offset of field: CUpti_ActivityDevice4::maxSharedMemoryPerMultiprocessor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, maxSharedMemoryPerMultiprocessor) - 60usize];
    ["Offset of field: CUpti_ActivityDevice4::maxRegistersPerMultiprocessor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, maxRegistersPerMultiprocessor) - 64usize];
    ["Offset of field: CUpti_ActivityDevice4::maxRegistersPerBlock"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, maxRegistersPerBlock) - 68usize];
    ["Offset of field: CUpti_ActivityDevice4::maxSharedMemoryPerBlock"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, maxSharedMemoryPerBlock) - 72usize];
    ["Offset of field: CUpti_ActivityDevice4::maxThreadsPerBlock"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, maxThreadsPerBlock) - 76usize];
    ["Offset of field: CUpti_ActivityDevice4::maxBlockDimX"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, maxBlockDimX) - 80usize];
    ["Offset of field: CUpti_ActivityDevice4::maxBlockDimY"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, maxBlockDimY) - 84usize];
    ["Offset of field: CUpti_ActivityDevice4::maxBlockDimZ"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, maxBlockDimZ) - 88usize];
    ["Offset of field: CUpti_ActivityDevice4::maxGridDimX"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, maxGridDimX) - 92usize];
    ["Offset of field: CUpti_ActivityDevice4::maxGridDimY"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, maxGridDimY) - 96usize];
    ["Offset of field: CUpti_ActivityDevice4::maxGridDimZ"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, maxGridDimZ) - 100usize];
    ["Offset of field: CUpti_ActivityDevice4::computeCapabilityMajor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, computeCapabilityMajor) - 104usize];
    ["Offset of field: CUpti_ActivityDevice4::computeCapabilityMinor"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, computeCapabilityMinor) - 108usize];
    ["Offset of field: CUpti_ActivityDevice4::id"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, id) - 112usize];
    ["Offset of field: CUpti_ActivityDevice4::eccEnabled"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, eccEnabled) - 116usize];
    ["Offset of field: CUpti_ActivityDevice4::uuid"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, uuid) - 120usize];
    ["Offset of field: CUpti_ActivityDevice4::name"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, name) - 136usize];
    ["Offset of field: CUpti_ActivityDevice4::isCudaVisible"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, isCudaVisible) - 144usize];
    ["Offset of field: CUpti_ActivityDevice4::isMigEnabled"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, isMigEnabled) - 145usize];
    ["Offset of field: CUpti_ActivityDevice4::reserved"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, reserved) - 146usize];
    ["Offset of field: CUpti_ActivityDevice4::gpuInstanceId"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, gpuInstanceId) - 152usize];
    ["Offset of field: CUpti_ActivityDevice4::computeInstanceId"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, computeInstanceId) - 156usize];
    ["Offset of field: CUpti_ActivityDevice4::migUuid"]
        [::std::mem::offset_of!(CUpti_ActivityDevice4, migUuid) - 160usize];
};
impl Default for CUpti_ActivityDevice4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for kernel. (deprecated)\n\n This activity record represents a kernel execution\n (CUPTI_ACTIVITY_KIND_KERNEL and\n CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL) but is no longer generated\n by CUPTI. Kernel activities are now reported using the\n CUpti_ActivityKernel9 activity record."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityKernel {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_KERNEL\n or CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The cache configuration requested by the kernel. The value is one\n of the CUfunc_cache enumeration values from cuda.h."]
    pub cacheConfigRequested: u8,
    #[doc = " The cache configuration used for the kernel. The value is one of\n the CUfunc_cache enumeration values from cuda.h."]
    pub cacheConfigExecuted: u8,
    #[doc = " The number of registers required for each thread executing the\n kernel."]
    pub registersPerThread: u16,
    #[doc = " The start timestamp for the kernel execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the kernel."]
    pub start: u64,
    #[doc = " The end timestamp for the kernel execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the kernel."]
    pub end: u64,
    #[doc = " The ID of the device where the kernel is executing."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the kernel is executing."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the kernel is executing."]
    pub streamId: u32,
    #[doc = " The X-dimension grid size for the kernel."]
    pub gridX: i32,
    #[doc = " The Y-dimension grid size for the kernel."]
    pub gridY: i32,
    #[doc = " The Z-dimension grid size for the kernel."]
    pub gridZ: i32,
    #[doc = " The X-dimension block size for the kernel."]
    pub blockX: i32,
    #[doc = " The Y-dimension block size for the kernel."]
    pub blockY: i32,
    #[doc = " The Z-dimension grid size for the kernel."]
    pub blockZ: i32,
    #[doc = " The static shared memory allocated for the kernel, in bytes."]
    pub staticSharedMemory: i32,
    #[doc = " The dynamic shared memory reserved for the kernel, in bytes."]
    pub dynamicSharedMemory: i32,
    #[doc = " The amount of local memory reserved for each thread, in bytes."]
    pub localMemoryPerThread: u32,
    #[doc = " The total amount of local memory reserved for the kernel, in\n bytes."]
    pub localMemoryTotal: u32,
    #[doc = " The correlation ID of the kernel. Each kernel execution is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver API activity record that launched\n the kernel."]
    pub correlationId: u32,
    #[doc = " The runtime correlation ID of the kernel. Each kernel execution\n is assigned a unique runtime correlation ID that is identical to\n the correlation ID in the runtime API activity record that\n launched the kernel."]
    pub runtimeCorrelationId: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
    #[doc = " The name of the kernel. This name is shared across all activity\n records representing the same kernel, and so should not be\n modified."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel"][::std::mem::size_of::<CUpti_ActivityKernel>() - 104usize];
    ["Alignment of CUpti_ActivityKernel"][::std::mem::align_of::<CUpti_ActivityKernel>() - 8usize];
    ["Offset of field: CUpti_ActivityKernel::kind"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, kind) - 0usize];
    ["Offset of field: CUpti_ActivityKernel::cacheConfigRequested"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, cacheConfigRequested) - 4usize];
    ["Offset of field: CUpti_ActivityKernel::cacheConfigExecuted"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, cacheConfigExecuted) - 5usize];
    ["Offset of field: CUpti_ActivityKernel::registersPerThread"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, registersPerThread) - 6usize];
    ["Offset of field: CUpti_ActivityKernel::start"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, start) - 8usize];
    ["Offset of field: CUpti_ActivityKernel::end"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, end) - 16usize];
    ["Offset of field: CUpti_ActivityKernel::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, deviceId) - 24usize];
    ["Offset of field: CUpti_ActivityKernel::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, contextId) - 28usize];
    ["Offset of field: CUpti_ActivityKernel::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, streamId) - 32usize];
    ["Offset of field: CUpti_ActivityKernel::gridX"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, gridX) - 36usize];
    ["Offset of field: CUpti_ActivityKernel::gridY"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, gridY) - 40usize];
    ["Offset of field: CUpti_ActivityKernel::gridZ"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, gridZ) - 44usize];
    ["Offset of field: CUpti_ActivityKernel::blockX"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, blockX) - 48usize];
    ["Offset of field: CUpti_ActivityKernel::blockY"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, blockY) - 52usize];
    ["Offset of field: CUpti_ActivityKernel::blockZ"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, blockZ) - 56usize];
    ["Offset of field: CUpti_ActivityKernel::staticSharedMemory"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, staticSharedMemory) - 60usize];
    ["Offset of field: CUpti_ActivityKernel::dynamicSharedMemory"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, dynamicSharedMemory) - 64usize];
    ["Offset of field: CUpti_ActivityKernel::localMemoryPerThread"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, localMemoryPerThread) - 68usize];
    ["Offset of field: CUpti_ActivityKernel::localMemoryTotal"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, localMemoryTotal) - 72usize];
    ["Offset of field: CUpti_ActivityKernel::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, correlationId) - 76usize];
    ["Offset of field: CUpti_ActivityKernel::runtimeCorrelationId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, runtimeCorrelationId) - 80usize];
    ["Offset of field: CUpti_ActivityKernel::pad"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, pad) - 84usize];
    ["Offset of field: CUpti_ActivityKernel::name"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, name) - 88usize];
    ["Offset of field: CUpti_ActivityKernel::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityKernel, reserved0) - 96usize];
};
impl Default for CUpti_ActivityKernel {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for kernel. (deprecated)\n\n This activity record represents a kernel execution\n (CUPTI_ACTIVITY_KIND_KERNEL and\n CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL) but is no longer generated\n by CUPTI. Kernel activities are now reported using the\n CUpti_ActivityKernel9 activity record."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityKernel2 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_KERNEL or\n CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL."]
    pub kind: CUpti_ActivityKind,
    pub cacheConfig: CUpti_ActivityKernel2__bindgen_ty_1,
    #[doc = " The shared memory configuration used for the kernel. The value is one of\n the CUsharedconfig enumeration values from cuda.h."]
    pub sharedMemoryConfig: u8,
    #[doc = " The number of registers required for each thread executing the\n kernel."]
    pub registersPerThread: u16,
    #[doc = " The start timestamp for the kernel execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the kernel."]
    pub start: u64,
    #[doc = " The end timestamp for the kernel execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the kernel."]
    pub end: u64,
    #[doc = " The completed timestamp for the kernel execution, in ns.  It\n represents the completion of all it's child kernels and the\n kernel itself. A value of CUPTI_TIMESTAMP_UNKNOWN indicates that\n the completion time is unknown."]
    pub completed: u64,
    #[doc = " The ID of the device where the kernel is executing."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the kernel is executing."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the kernel is executing."]
    pub streamId: u32,
    #[doc = " The X-dimension grid size for the kernel."]
    pub gridX: i32,
    #[doc = " The Y-dimension grid size for the kernel."]
    pub gridY: i32,
    #[doc = " The Z-dimension grid size for the kernel."]
    pub gridZ: i32,
    #[doc = " The X-dimension block size for the kernel."]
    pub blockX: i32,
    #[doc = " The Y-dimension block size for the kernel."]
    pub blockY: i32,
    #[doc = " The Z-dimension grid size for the kernel."]
    pub blockZ: i32,
    #[doc = " The static shared memory allocated for the kernel, in bytes."]
    pub staticSharedMemory: i32,
    #[doc = " The dynamic shared memory reserved for the kernel, in bytes."]
    pub dynamicSharedMemory: i32,
    #[doc = " The amount of local memory reserved for each thread, in bytes."]
    pub localMemoryPerThread: u32,
    #[doc = " The total amount of local memory reserved for the kernel, in\n bytes."]
    pub localMemoryTotal: u32,
    #[doc = " The correlation ID of the kernel. Each kernel execution is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver or runtime API activity record that\n launched the kernel."]
    pub correlationId: u32,
    #[doc = " The grid ID of the kernel. Each kernel is assigned a unique\n grid ID at runtime."]
    pub gridId: i64,
    #[doc = " The name of the kernel. This name is shared across all activity\n records representing the same kernel, and so should not be\n modified."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityKernel2__bindgen_ty_1 {
    pub both: u8,
    pub config: CUpti_ActivityKernel2__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityKernel2__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel2__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityKernel2__bindgen_ty_1__bindgen_ty_1>() - 1usize];
    ["Alignment of CUpti_ActivityKernel2__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityKernel2__bindgen_ty_1__bindgen_ty_1>() - 1usize];
};
impl CUpti_ActivityKernel2__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn requested(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_requested(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn requested_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_requested_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn executed(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_executed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn executed_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_executed_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(requested: u8, executed: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let requested: u8 = unsafe { ::std::mem::transmute(requested) };
            requested as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let executed: u8 = unsafe { ::std::mem::transmute(executed) };
            executed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel2__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityKernel2__bindgen_ty_1>() - 1usize];
    ["Alignment of CUpti_ActivityKernel2__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityKernel2__bindgen_ty_1>() - 1usize];
    ["Offset of field: CUpti_ActivityKernel2__bindgen_ty_1::both"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2__bindgen_ty_1, both) - 0usize];
    ["Offset of field: CUpti_ActivityKernel2__bindgen_ty_1::config"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2__bindgen_ty_1, config) - 0usize];
};
impl Default for CUpti_ActivityKernel2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel2__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityKernel2__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel2"][::std::mem::size_of::<CUpti_ActivityKernel2>() - 112usize];
    ["Alignment of CUpti_ActivityKernel2"]
        [::std::mem::align_of::<CUpti_ActivityKernel2>() - 8usize];
    ["Offset of field: CUpti_ActivityKernel2::kind"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, kind) - 0usize];
    ["Offset of field: CUpti_ActivityKernel2::cacheConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, cacheConfig) - 4usize];
    ["Offset of field: CUpti_ActivityKernel2::sharedMemoryConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, sharedMemoryConfig) - 5usize];
    ["Offset of field: CUpti_ActivityKernel2::registersPerThread"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, registersPerThread) - 6usize];
    ["Offset of field: CUpti_ActivityKernel2::start"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, start) - 8usize];
    ["Offset of field: CUpti_ActivityKernel2::end"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, end) - 16usize];
    ["Offset of field: CUpti_ActivityKernel2::completed"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, completed) - 24usize];
    ["Offset of field: CUpti_ActivityKernel2::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, deviceId) - 32usize];
    ["Offset of field: CUpti_ActivityKernel2::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, contextId) - 36usize];
    ["Offset of field: CUpti_ActivityKernel2::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, streamId) - 40usize];
    ["Offset of field: CUpti_ActivityKernel2::gridX"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, gridX) - 44usize];
    ["Offset of field: CUpti_ActivityKernel2::gridY"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, gridY) - 48usize];
    ["Offset of field: CUpti_ActivityKernel2::gridZ"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, gridZ) - 52usize];
    ["Offset of field: CUpti_ActivityKernel2::blockX"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, blockX) - 56usize];
    ["Offset of field: CUpti_ActivityKernel2::blockY"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, blockY) - 60usize];
    ["Offset of field: CUpti_ActivityKernel2::blockZ"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, blockZ) - 64usize];
    ["Offset of field: CUpti_ActivityKernel2::staticSharedMemory"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, staticSharedMemory) - 68usize];
    ["Offset of field: CUpti_ActivityKernel2::dynamicSharedMemory"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, dynamicSharedMemory) - 72usize];
    ["Offset of field: CUpti_ActivityKernel2::localMemoryPerThread"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, localMemoryPerThread) - 76usize];
    ["Offset of field: CUpti_ActivityKernel2::localMemoryTotal"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, localMemoryTotal) - 80usize];
    ["Offset of field: CUpti_ActivityKernel2::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, correlationId) - 84usize];
    ["Offset of field: CUpti_ActivityKernel2::gridId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, gridId) - 88usize];
    ["Offset of field: CUpti_ActivityKernel2::name"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, name) - 96usize];
    ["Offset of field: CUpti_ActivityKernel2::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityKernel2, reserved0) - 104usize];
};
impl Default for CUpti_ActivityKernel2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityKernel2 {{ kind: {:?}, cacheConfig: {:?}, name: {:?}, reserved0: {:?} }}",
            self.kind, self.cacheConfig, self.name, self.reserved0
        )
    }
}
#[doc = " \\brief The activity record for a kernel (CUDA 6.5(with sm_52 support) onwards).\n (deprecated in CUDA 9.0)\n\n This activity record represents a kernel execution\n (CUPTI_ACTIVITY_KIND_KERNEL and\n CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL).\n Kernel activities are now reported using the CUpti_ActivityKernel9 activity\n record."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityKernel3 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_KERNEL or\n CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL."]
    pub kind: CUpti_ActivityKind,
    pub cacheConfig: CUpti_ActivityKernel3__bindgen_ty_1,
    #[doc = " The shared memory configuration used for the kernel. The value is one of\n the CUsharedconfig enumeration values from cuda.h."]
    pub sharedMemoryConfig: u8,
    #[doc = " The number of registers required for each thread executing the\n kernel."]
    pub registersPerThread: u16,
    #[doc = " The partitioned global caching requested for the kernel. Partitioned\n global caching is required to enable caching on certain chips, such as\n devices with compute capability 5.2."]
    pub partitionedGlobalCacheRequested: CUpti_ActivityPartitionedGlobalCacheConfig,
    #[doc = " The partitioned global caching executed for the kernel. Partitioned\n global caching is required to enable caching on certain chips, such as\n devices with compute capability 5.2. Partitioned global caching can be\n automatically disabled if the occupancy requirement of the launch cannot\n support caching."]
    pub partitionedGlobalCacheExecuted: CUpti_ActivityPartitionedGlobalCacheConfig,
    #[doc = " The start timestamp for the kernel execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the kernel."]
    pub start: u64,
    #[doc = " The end timestamp for the kernel execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the kernel."]
    pub end: u64,
    #[doc = " The completed timestamp for the kernel execution, in ns.  It\n represents the completion of all it's child kernels and the\n kernel itself. A value of CUPTI_TIMESTAMP_UNKNOWN indicates that\n the completion time is unknown."]
    pub completed: u64,
    #[doc = " The ID of the device where the kernel is executing."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the kernel is executing."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the kernel is executing."]
    pub streamId: u32,
    #[doc = " The X-dimension grid size for the kernel."]
    pub gridX: i32,
    #[doc = " The Y-dimension grid size for the kernel."]
    pub gridY: i32,
    #[doc = " The Z-dimension grid size for the kernel."]
    pub gridZ: i32,
    #[doc = " The X-dimension block size for the kernel."]
    pub blockX: i32,
    #[doc = " The Y-dimension block size for the kernel."]
    pub blockY: i32,
    #[doc = " The Z-dimension grid size for the kernel."]
    pub blockZ: i32,
    #[doc = " The static shared memory allocated for the kernel, in bytes."]
    pub staticSharedMemory: i32,
    #[doc = " The dynamic shared memory reserved for the kernel, in bytes."]
    pub dynamicSharedMemory: i32,
    #[doc = " The amount of local memory reserved for each thread, in bytes."]
    pub localMemoryPerThread: u32,
    #[doc = " The total amount of local memory reserved for the kernel, in\n bytes."]
    pub localMemoryTotal: u32,
    #[doc = " The correlation ID of the kernel. Each kernel execution is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver or runtime API activity record that\n launched the kernel."]
    pub correlationId: u32,
    #[doc = " The grid ID of the kernel. Each kernel is assigned a unique\n grid ID at runtime."]
    pub gridId: i64,
    #[doc = " The name of the kernel. This name is shared across all activity\n records representing the same kernel, and so should not be\n modified."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityKernel3__bindgen_ty_1 {
    pub both: u8,
    pub config: CUpti_ActivityKernel3__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityKernel3__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel3__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityKernel3__bindgen_ty_1__bindgen_ty_1>() - 1usize];
    ["Alignment of CUpti_ActivityKernel3__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityKernel3__bindgen_ty_1__bindgen_ty_1>() - 1usize];
};
impl CUpti_ActivityKernel3__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn requested(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_requested(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn requested_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_requested_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn executed(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_executed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn executed_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_executed_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(requested: u8, executed: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let requested: u8 = unsafe { ::std::mem::transmute(requested) };
            requested as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let executed: u8 = unsafe { ::std::mem::transmute(executed) };
            executed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel3__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityKernel3__bindgen_ty_1>() - 1usize];
    ["Alignment of CUpti_ActivityKernel3__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityKernel3__bindgen_ty_1>() - 1usize];
    ["Offset of field: CUpti_ActivityKernel3__bindgen_ty_1::both"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3__bindgen_ty_1, both) - 0usize];
    ["Offset of field: CUpti_ActivityKernel3__bindgen_ty_1::config"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3__bindgen_ty_1, config) - 0usize];
};
impl Default for CUpti_ActivityKernel3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel3__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityKernel3__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel3"][::std::mem::size_of::<CUpti_ActivityKernel3>() - 120usize];
    ["Alignment of CUpti_ActivityKernel3"]
        [::std::mem::align_of::<CUpti_ActivityKernel3>() - 8usize];
    ["Offset of field: CUpti_ActivityKernel3::kind"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, kind) - 0usize];
    ["Offset of field: CUpti_ActivityKernel3::cacheConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, cacheConfig) - 4usize];
    ["Offset of field: CUpti_ActivityKernel3::sharedMemoryConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, sharedMemoryConfig) - 5usize];
    ["Offset of field: CUpti_ActivityKernel3::registersPerThread"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, registersPerThread) - 6usize];
    ["Offset of field: CUpti_ActivityKernel3::partitionedGlobalCacheRequested"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, partitionedGlobalCacheRequested) - 8usize];
    ["Offset of field: CUpti_ActivityKernel3::partitionedGlobalCacheExecuted"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, partitionedGlobalCacheExecuted) - 12usize];
    ["Offset of field: CUpti_ActivityKernel3::start"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, start) - 16usize];
    ["Offset of field: CUpti_ActivityKernel3::end"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, end) - 24usize];
    ["Offset of field: CUpti_ActivityKernel3::completed"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, completed) - 32usize];
    ["Offset of field: CUpti_ActivityKernel3::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, deviceId) - 40usize];
    ["Offset of field: CUpti_ActivityKernel3::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, contextId) - 44usize];
    ["Offset of field: CUpti_ActivityKernel3::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, streamId) - 48usize];
    ["Offset of field: CUpti_ActivityKernel3::gridX"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, gridX) - 52usize];
    ["Offset of field: CUpti_ActivityKernel3::gridY"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, gridY) - 56usize];
    ["Offset of field: CUpti_ActivityKernel3::gridZ"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, gridZ) - 60usize];
    ["Offset of field: CUpti_ActivityKernel3::blockX"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, blockX) - 64usize];
    ["Offset of field: CUpti_ActivityKernel3::blockY"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, blockY) - 68usize];
    ["Offset of field: CUpti_ActivityKernel3::blockZ"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, blockZ) - 72usize];
    ["Offset of field: CUpti_ActivityKernel3::staticSharedMemory"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, staticSharedMemory) - 76usize];
    ["Offset of field: CUpti_ActivityKernel3::dynamicSharedMemory"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, dynamicSharedMemory) - 80usize];
    ["Offset of field: CUpti_ActivityKernel3::localMemoryPerThread"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, localMemoryPerThread) - 84usize];
    ["Offset of field: CUpti_ActivityKernel3::localMemoryTotal"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, localMemoryTotal) - 88usize];
    ["Offset of field: CUpti_ActivityKernel3::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, correlationId) - 92usize];
    ["Offset of field: CUpti_ActivityKernel3::gridId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, gridId) - 96usize];
    ["Offset of field: CUpti_ActivityKernel3::name"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, name) - 104usize];
    ["Offset of field: CUpti_ActivityKernel3::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityKernel3, reserved0) - 112usize];
};
impl Default for CUpti_ActivityKernel3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityKernel3 {{ kind: {:?}, cacheConfig: {:?}, partitionedGlobalCacheRequested: {:?}, partitionedGlobalCacheExecuted: {:?}, name: {:?}, reserved0: {:?} }}",
            self.kind,
            self.cacheConfig,
            self.partitionedGlobalCacheRequested,
            self.partitionedGlobalCacheExecuted,
            self.name,
            self.reserved0
        )
    }
}
#[doc = " \\brief The activity record for a kernel (CUDA 9.0(with sm_70 support) onwards).\n (deprecated in CUDA 11.0)\n\n This activity record represents a kernel execution\n (CUPTI_ACTIVITY_KIND_KERNEL and\n CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL).\n Kernel activities are now reported using the CUpti_ActivityKernel9 activity\n record."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityKernel4 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_KERNEL or\n CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL."]
    pub kind: CUpti_ActivityKind,
    pub cacheConfig: CUpti_ActivityKernel4__bindgen_ty_1,
    #[doc = " The shared memory configuration used for the kernel. The value is one of\n the CUsharedconfig enumeration values from cuda.h."]
    pub sharedMemoryConfig: u8,
    #[doc = " The number of registers required for each thread executing the\n kernel."]
    pub registersPerThread: u16,
    #[doc = " The partitioned global caching requested for the kernel. Partitioned\n global caching is required to enable caching on certain chips, such as\n devices with compute capability 5.2."]
    pub partitionedGlobalCacheRequested: CUpti_ActivityPartitionedGlobalCacheConfig,
    #[doc = " The partitioned global caching executed for the kernel. Partitioned\n global caching is required to enable caching on certain chips, such as\n devices with compute capability 5.2. Partitioned global caching can be\n automatically disabled if the occupancy requirement of the launch cannot\n support caching."]
    pub partitionedGlobalCacheExecuted: CUpti_ActivityPartitionedGlobalCacheConfig,
    #[doc = " The start timestamp for the kernel execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the kernel."]
    pub start: u64,
    #[doc = " The end timestamp for the kernel execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the kernel."]
    pub end: u64,
    #[doc = " The completed timestamp for the kernel execution, in ns.  It\n represents the completion of all it's child kernels and the\n kernel itself. A value of CUPTI_TIMESTAMP_UNKNOWN indicates that\n the completion time is unknown."]
    pub completed: u64,
    #[doc = " The ID of the device where the kernel is executing."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the kernel is executing."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the kernel is executing."]
    pub streamId: u32,
    #[doc = " The X-dimension grid size for the kernel."]
    pub gridX: i32,
    #[doc = " The Y-dimension grid size for the kernel."]
    pub gridY: i32,
    #[doc = " The Z-dimension grid size for the kernel."]
    pub gridZ: i32,
    #[doc = " The X-dimension block size for the kernel."]
    pub blockX: i32,
    #[doc = " The Y-dimension block size for the kernel."]
    pub blockY: i32,
    #[doc = " The Z-dimension grid size for the kernel."]
    pub blockZ: i32,
    #[doc = " The static shared memory allocated for the kernel, in bytes."]
    pub staticSharedMemory: i32,
    #[doc = " The dynamic shared memory reserved for the kernel, in bytes."]
    pub dynamicSharedMemory: i32,
    #[doc = " The amount of local memory reserved for each thread, in bytes."]
    pub localMemoryPerThread: u32,
    #[doc = " The total amount of local memory reserved for the kernel, in\n bytes."]
    pub localMemoryTotal: u32,
    #[doc = " The correlation ID of the kernel. Each kernel execution is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver or runtime API activity record that\n launched the kernel."]
    pub correlationId: u32,
    #[doc = " The grid ID of the kernel. Each kernel is assigned a unique\n grid ID at runtime."]
    pub gridId: i64,
    #[doc = " The name of the kernel. This name is shared across all activity\n records representing the same kernel, and so should not be\n modified."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
    #[doc = " The timestamp when the kernel is queued up in the command buffer, in ns.\n A value of CUPTI_TIMESTAMP_UNKNOWN indicates that the queued time\n could not be collected for the kernel. This timestamp is not collected\n by default. Use API \\ref cuptiActivityEnableLatencyTimestamps() to\n enable collection.\n\n Command buffer is a buffer written by CUDA driver to send commands\n like kernel launch, memory copy etc to the GPU. All launches of CUDA\n kernels are asynchronous with respect to the host, the host requests\n the launch by writing commands into the command buffer, then returns\n without checking the GPU's progress."]
    pub queued: u64,
    #[doc = " The timestamp when the command buffer containing the kernel launch\n is submitted to the GPU, in ns. A value of CUPTI_TIMESTAMP_UNKNOWN\n indicates that the submitted time could not be collected for the kernel.\n This timestamp is not collected by default. Use API \\ref\n cuptiActivityEnableLatencyTimestamps() to enable collection."]
    pub submitted: u64,
    #[doc = " The indicates if the kernel was executed via a regular launch or via a\n single/multi device cooperative launch. \\see CUpti_ActivityLaunchType"]
    pub launchType: u8,
    #[doc = " This indicates if CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT was\n updated for the kernel launch"]
    pub isSharedMemoryCarveoutRequested: u8,
    #[doc = " Shared memory carveout value requested for the function in percentage of\n the total resource. The value will be updated only if field\n isSharedMemoryCarveoutRequested is set."]
    pub sharedMemoryCarveoutRequested: u8,
    #[doc = " Undefined. Reserved for internal use."]
    pub padding: u8,
    #[doc = " Shared memory size set by the driver."]
    pub sharedMemoryExecuted: u32,
}
#[doc = " For devices with compute capability 7.5+ cacheConfig values are not updated\n in case field isSharedMemoryCarveoutRequested is set"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityKernel4__bindgen_ty_1 {
    pub both: u8,
    pub config: CUpti_ActivityKernel4__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityKernel4__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel4__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityKernel4__bindgen_ty_1__bindgen_ty_1>() - 1usize];
    ["Alignment of CUpti_ActivityKernel4__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityKernel4__bindgen_ty_1__bindgen_ty_1>() - 1usize];
};
impl CUpti_ActivityKernel4__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn requested(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_requested(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn requested_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_requested_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn executed(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_executed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn executed_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_executed_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(requested: u8, executed: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let requested: u8 = unsafe { ::std::mem::transmute(requested) };
            requested as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let executed: u8 = unsafe { ::std::mem::transmute(executed) };
            executed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel4__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityKernel4__bindgen_ty_1>() - 1usize];
    ["Alignment of CUpti_ActivityKernel4__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityKernel4__bindgen_ty_1>() - 1usize];
    ["Offset of field: CUpti_ActivityKernel4__bindgen_ty_1::both"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4__bindgen_ty_1, both) - 0usize];
    ["Offset of field: CUpti_ActivityKernel4__bindgen_ty_1::config"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4__bindgen_ty_1, config) - 0usize];
};
impl Default for CUpti_ActivityKernel4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel4__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityKernel4__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel4"][::std::mem::size_of::<CUpti_ActivityKernel4>() - 144usize];
    ["Alignment of CUpti_ActivityKernel4"]
        [::std::mem::align_of::<CUpti_ActivityKernel4>() - 8usize];
    ["Offset of field: CUpti_ActivityKernel4::kind"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, kind) - 0usize];
    ["Offset of field: CUpti_ActivityKernel4::cacheConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, cacheConfig) - 4usize];
    ["Offset of field: CUpti_ActivityKernel4::sharedMemoryConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, sharedMemoryConfig) - 5usize];
    ["Offset of field: CUpti_ActivityKernel4::registersPerThread"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, registersPerThread) - 6usize];
    ["Offset of field: CUpti_ActivityKernel4::partitionedGlobalCacheRequested"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, partitionedGlobalCacheRequested) - 8usize];
    ["Offset of field: CUpti_ActivityKernel4::partitionedGlobalCacheExecuted"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, partitionedGlobalCacheExecuted) - 12usize];
    ["Offset of field: CUpti_ActivityKernel4::start"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, start) - 16usize];
    ["Offset of field: CUpti_ActivityKernel4::end"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, end) - 24usize];
    ["Offset of field: CUpti_ActivityKernel4::completed"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, completed) - 32usize];
    ["Offset of field: CUpti_ActivityKernel4::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, deviceId) - 40usize];
    ["Offset of field: CUpti_ActivityKernel4::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, contextId) - 44usize];
    ["Offset of field: CUpti_ActivityKernel4::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, streamId) - 48usize];
    ["Offset of field: CUpti_ActivityKernel4::gridX"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, gridX) - 52usize];
    ["Offset of field: CUpti_ActivityKernel4::gridY"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, gridY) - 56usize];
    ["Offset of field: CUpti_ActivityKernel4::gridZ"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, gridZ) - 60usize];
    ["Offset of field: CUpti_ActivityKernel4::blockX"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, blockX) - 64usize];
    ["Offset of field: CUpti_ActivityKernel4::blockY"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, blockY) - 68usize];
    ["Offset of field: CUpti_ActivityKernel4::blockZ"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, blockZ) - 72usize];
    ["Offset of field: CUpti_ActivityKernel4::staticSharedMemory"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, staticSharedMemory) - 76usize];
    ["Offset of field: CUpti_ActivityKernel4::dynamicSharedMemory"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, dynamicSharedMemory) - 80usize];
    ["Offset of field: CUpti_ActivityKernel4::localMemoryPerThread"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, localMemoryPerThread) - 84usize];
    ["Offset of field: CUpti_ActivityKernel4::localMemoryTotal"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, localMemoryTotal) - 88usize];
    ["Offset of field: CUpti_ActivityKernel4::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, correlationId) - 92usize];
    ["Offset of field: CUpti_ActivityKernel4::gridId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, gridId) - 96usize];
    ["Offset of field: CUpti_ActivityKernel4::name"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, name) - 104usize];
    ["Offset of field: CUpti_ActivityKernel4::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, reserved0) - 112usize];
    ["Offset of field: CUpti_ActivityKernel4::queued"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, queued) - 120usize];
    ["Offset of field: CUpti_ActivityKernel4::submitted"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, submitted) - 128usize];
    ["Offset of field: CUpti_ActivityKernel4::launchType"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, launchType) - 136usize];
    ["Offset of field: CUpti_ActivityKernel4::isSharedMemoryCarveoutRequested"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, isSharedMemoryCarveoutRequested) - 137usize];
    ["Offset of field: CUpti_ActivityKernel4::sharedMemoryCarveoutRequested"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, sharedMemoryCarveoutRequested) - 138usize];
    ["Offset of field: CUpti_ActivityKernel4::padding"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, padding) - 139usize];
    ["Offset of field: CUpti_ActivityKernel4::sharedMemoryExecuted"]
        [::std::mem::offset_of!(CUpti_ActivityKernel4, sharedMemoryExecuted) - 140usize];
};
impl Default for CUpti_ActivityKernel4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel4 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityKernel4 {{ kind: {:?}, cacheConfig: {:?}, partitionedGlobalCacheRequested: {:?}, partitionedGlobalCacheExecuted: {:?}, name: {:?}, reserved0: {:?} }}",
            self.kind,
            self.cacheConfig,
            self.partitionedGlobalCacheRequested,
            self.partitionedGlobalCacheExecuted,
            self.name,
            self.reserved0
        )
    }
}
#[doc = " \\brief The activity record for a kernel (CUDA 11.0(with sm_80 support) onwards).\n (deprecated in CUDA 11.2)\n This activity record represents a kernel execution\n (CUPTI_ACTIVITY_KIND_KERNEL and\n CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL) but is no longer generated\n by CUPTI. Kernel activities are now reported using the\n CUpti_ActivityKernel9 activity record."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityKernel5 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_KERNEL or\n CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL."]
    pub kind: CUpti_ActivityKind,
    pub cacheConfig: CUpti_ActivityKernel5__bindgen_ty_1,
    #[doc = " The shared memory configuration used for the kernel. The value is one of\n the CUsharedconfig enumeration values from cuda.h."]
    pub sharedMemoryConfig: u8,
    #[doc = " The number of registers required for each thread executing the\n kernel."]
    pub registersPerThread: u16,
    #[doc = " The partitioned global caching requested for the kernel. Partitioned\n global caching is required to enable caching on certain chips, such as\n devices with compute capability 5.2."]
    pub partitionedGlobalCacheRequested: CUpti_ActivityPartitionedGlobalCacheConfig,
    #[doc = " The partitioned global caching executed for the kernel. Partitioned\n global caching is required to enable caching on certain chips, such as\n devices with compute capability 5.2. Partitioned global caching can be\n automatically disabled if the occupancy requirement of the launch cannot\n support caching."]
    pub partitionedGlobalCacheExecuted: CUpti_ActivityPartitionedGlobalCacheConfig,
    #[doc = " The start timestamp for the kernel execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the kernel."]
    pub start: u64,
    #[doc = " The end timestamp for the kernel execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the kernel."]
    pub end: u64,
    #[doc = " The completed timestamp for the kernel execution, in ns.  It\n represents the completion of all it's child kernels and the\n kernel itself. A value of CUPTI_TIMESTAMP_UNKNOWN indicates that\n the completion time is unknown."]
    pub completed: u64,
    #[doc = " The ID of the device where the kernel is executing."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the kernel is executing."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the kernel is executing."]
    pub streamId: u32,
    #[doc = " The X-dimension grid size for the kernel."]
    pub gridX: i32,
    #[doc = " The Y-dimension grid size for the kernel."]
    pub gridY: i32,
    #[doc = " The Z-dimension grid size for the kernel."]
    pub gridZ: i32,
    #[doc = " The X-dimension block size for the kernel."]
    pub blockX: i32,
    #[doc = " The Y-dimension block size for the kernel."]
    pub blockY: i32,
    #[doc = " The Z-dimension grid size for the kernel."]
    pub blockZ: i32,
    #[doc = " The static shared memory allocated for the kernel, in bytes."]
    pub staticSharedMemory: i32,
    #[doc = " The dynamic shared memory reserved for the kernel, in bytes."]
    pub dynamicSharedMemory: i32,
    #[doc = " The amount of local memory reserved for each thread, in bytes."]
    pub localMemoryPerThread: u32,
    #[doc = " The total amount of local memory reserved for the kernel, in\n bytes."]
    pub localMemoryTotal: u32,
    #[doc = " The correlation ID of the kernel. Each kernel execution is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver or runtime API activity record that\n launched the kernel."]
    pub correlationId: u32,
    #[doc = " The grid ID of the kernel. Each kernel is assigned a unique\n grid ID at runtime."]
    pub gridId: i64,
    #[doc = " The name of the kernel. This name is shared across all activity\n records representing the same kernel, and so should not be\n modified."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
    #[doc = " The timestamp when the kernel is queued up in the command buffer, in ns.\n A value of CUPTI_TIMESTAMP_UNKNOWN indicates that the queued time\n could not be collected for the kernel. This timestamp is not collected\n by default. Use API \\ref cuptiActivityEnableLatencyTimestamps() to\n enable collection.\n\n Command buffer is a buffer written by CUDA driver to send commands\n like kernel launch, memory copy etc to the GPU. All launches of CUDA\n kernels are asynchronous with respect to the host, the host requests\n the launch by writing commands into the command buffer, then returns\n without checking the GPU's progress."]
    pub queued: u64,
    #[doc = " The timestamp when the command buffer containing the kernel launch\n is submitted to the GPU, in ns. A value of CUPTI_TIMESTAMP_UNKNOWN\n indicates that the submitted time could not be collected for the kernel.\n This timestamp is not collected by default. Use API \\ref\n cuptiActivityEnableLatencyTimestamps() to enable collection."]
    pub submitted: u64,
    #[doc = " The indicates if the kernel was executed via a regular launch or via a\n single/multi device cooperative launch. \\see CUpti_ActivityLaunchType"]
    pub launchType: u8,
    #[doc = " This indicates if CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT was\n updated for the kernel launch"]
    pub isSharedMemoryCarveoutRequested: u8,
    #[doc = " Shared memory carveout value requested for the function in percentage of\n the total resource. The value will be updated only if field\n isSharedMemoryCarveoutRequested is set."]
    pub sharedMemoryCarveoutRequested: u8,
    #[doc = " Undefined. Reserved for internal use."]
    pub padding: u8,
    #[doc = " Shared memory size set by the driver."]
    pub sharedMemoryExecuted: u32,
    #[doc = " The unique ID of the graph node that launched this kernel through graph launch APIs.\n This field will be 0 if the kernel is not launched through graph launch APIs."]
    pub graphNodeId: u64,
    #[doc = " The shared memory limit config for the kernel. This field shows whether user has opted for a\n higher per block limit of dynamic shared memory."]
    pub shmemLimitConfig: CUpti_FuncShmemLimitConfig,
    #[doc = " The unique ID of the graph that launched this kernel through graph launch APIs.\n This field will be 0 if the kernel is not launched through graph launch APIs."]
    pub graphId: u32,
}
#[doc = " For devices with compute capability 7.5+ cacheConfig values are not updated\n in case field isSharedMemoryCarveoutRequested is set"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityKernel5__bindgen_ty_1 {
    pub both: u8,
    pub config: CUpti_ActivityKernel5__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityKernel5__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel5__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityKernel5__bindgen_ty_1__bindgen_ty_1>() - 1usize];
    ["Alignment of CUpti_ActivityKernel5__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityKernel5__bindgen_ty_1__bindgen_ty_1>() - 1usize];
};
impl CUpti_ActivityKernel5__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn requested(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_requested(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn requested_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_requested_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn executed(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_executed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn executed_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_executed_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(requested: u8, executed: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let requested: u8 = unsafe { ::std::mem::transmute(requested) };
            requested as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let executed: u8 = unsafe { ::std::mem::transmute(executed) };
            executed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel5__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityKernel5__bindgen_ty_1>() - 1usize];
    ["Alignment of CUpti_ActivityKernel5__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityKernel5__bindgen_ty_1>() - 1usize];
    ["Offset of field: CUpti_ActivityKernel5__bindgen_ty_1::both"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5__bindgen_ty_1, both) - 0usize];
    ["Offset of field: CUpti_ActivityKernel5__bindgen_ty_1::config"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5__bindgen_ty_1, config) - 0usize];
};
impl Default for CUpti_ActivityKernel5__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel5__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityKernel5__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel5"][::std::mem::size_of::<CUpti_ActivityKernel5>() - 160usize];
    ["Alignment of CUpti_ActivityKernel5"]
        [::std::mem::align_of::<CUpti_ActivityKernel5>() - 8usize];
    ["Offset of field: CUpti_ActivityKernel5::kind"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, kind) - 0usize];
    ["Offset of field: CUpti_ActivityKernel5::cacheConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, cacheConfig) - 4usize];
    ["Offset of field: CUpti_ActivityKernel5::sharedMemoryConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, sharedMemoryConfig) - 5usize];
    ["Offset of field: CUpti_ActivityKernel5::registersPerThread"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, registersPerThread) - 6usize];
    ["Offset of field: CUpti_ActivityKernel5::partitionedGlobalCacheRequested"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, partitionedGlobalCacheRequested) - 8usize];
    ["Offset of field: CUpti_ActivityKernel5::partitionedGlobalCacheExecuted"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, partitionedGlobalCacheExecuted) - 12usize];
    ["Offset of field: CUpti_ActivityKernel5::start"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, start) - 16usize];
    ["Offset of field: CUpti_ActivityKernel5::end"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, end) - 24usize];
    ["Offset of field: CUpti_ActivityKernel5::completed"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, completed) - 32usize];
    ["Offset of field: CUpti_ActivityKernel5::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, deviceId) - 40usize];
    ["Offset of field: CUpti_ActivityKernel5::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, contextId) - 44usize];
    ["Offset of field: CUpti_ActivityKernel5::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, streamId) - 48usize];
    ["Offset of field: CUpti_ActivityKernel5::gridX"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, gridX) - 52usize];
    ["Offset of field: CUpti_ActivityKernel5::gridY"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, gridY) - 56usize];
    ["Offset of field: CUpti_ActivityKernel5::gridZ"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, gridZ) - 60usize];
    ["Offset of field: CUpti_ActivityKernel5::blockX"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, blockX) - 64usize];
    ["Offset of field: CUpti_ActivityKernel5::blockY"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, blockY) - 68usize];
    ["Offset of field: CUpti_ActivityKernel5::blockZ"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, blockZ) - 72usize];
    ["Offset of field: CUpti_ActivityKernel5::staticSharedMemory"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, staticSharedMemory) - 76usize];
    ["Offset of field: CUpti_ActivityKernel5::dynamicSharedMemory"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, dynamicSharedMemory) - 80usize];
    ["Offset of field: CUpti_ActivityKernel5::localMemoryPerThread"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, localMemoryPerThread) - 84usize];
    ["Offset of field: CUpti_ActivityKernel5::localMemoryTotal"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, localMemoryTotal) - 88usize];
    ["Offset of field: CUpti_ActivityKernel5::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, correlationId) - 92usize];
    ["Offset of field: CUpti_ActivityKernel5::gridId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, gridId) - 96usize];
    ["Offset of field: CUpti_ActivityKernel5::name"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, name) - 104usize];
    ["Offset of field: CUpti_ActivityKernel5::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, reserved0) - 112usize];
    ["Offset of field: CUpti_ActivityKernel5::queued"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, queued) - 120usize];
    ["Offset of field: CUpti_ActivityKernel5::submitted"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, submitted) - 128usize];
    ["Offset of field: CUpti_ActivityKernel5::launchType"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, launchType) - 136usize];
    ["Offset of field: CUpti_ActivityKernel5::isSharedMemoryCarveoutRequested"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, isSharedMemoryCarveoutRequested) - 137usize];
    ["Offset of field: CUpti_ActivityKernel5::sharedMemoryCarveoutRequested"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, sharedMemoryCarveoutRequested) - 138usize];
    ["Offset of field: CUpti_ActivityKernel5::padding"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, padding) - 139usize];
    ["Offset of field: CUpti_ActivityKernel5::sharedMemoryExecuted"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, sharedMemoryExecuted) - 140usize];
    ["Offset of field: CUpti_ActivityKernel5::graphNodeId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, graphNodeId) - 144usize];
    ["Offset of field: CUpti_ActivityKernel5::shmemLimitConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, shmemLimitConfig) - 152usize];
    ["Offset of field: CUpti_ActivityKernel5::graphId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel5, graphId) - 156usize];
};
impl Default for CUpti_ActivityKernel5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel5 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityKernel5 {{ kind: {:?}, cacheConfig: {:?}, partitionedGlobalCacheRequested: {:?}, partitionedGlobalCacheExecuted: {:?}, name: {:?}, reserved0: {:?}, shmemLimitConfig: {:?} }}",
            self.kind,
            self.cacheConfig,
            self.partitionedGlobalCacheRequested,
            self.partitionedGlobalCacheExecuted,
            self.name,
            self.reserved0,
            self.shmemLimitConfig
        )
    }
}
#[doc = " \\brief The activity record for kernel. (deprecated in CUDA 11.6)\n\n This activity record represents a kernel execution\n (CUPTI_ACTIVITY_KIND_KERNEL and\n CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL) but is no longer generated\n by CUPTI. Kernel activities are now reported using the\n CUpti_ActivityKernel9 activity record."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityKernel6 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_KERNEL or\n CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL."]
    pub kind: CUpti_ActivityKind,
    pub cacheConfig: CUpti_ActivityKernel6__bindgen_ty_1,
    #[doc = " The shared memory configuration used for the kernel. The value is one of\n the CUsharedconfig enumeration values from cuda.h."]
    pub sharedMemoryConfig: u8,
    #[doc = " The number of registers required for each thread executing the\n kernel."]
    pub registersPerThread: u16,
    #[doc = " The partitioned global caching requested for the kernel. Partitioned\n global caching is required to enable caching on certain chips, such as\n devices with compute capability 5.2."]
    pub partitionedGlobalCacheRequested: CUpti_ActivityPartitionedGlobalCacheConfig,
    #[doc = " The partitioned global caching executed for the kernel. Partitioned\n global caching is required to enable caching on certain chips, such as\n devices with compute capability 5.2. Partitioned global caching can be\n automatically disabled if the occupancy requirement of the launch cannot\n support caching."]
    pub partitionedGlobalCacheExecuted: CUpti_ActivityPartitionedGlobalCacheConfig,
    #[doc = " The start timestamp for the kernel execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the kernel."]
    pub start: u64,
    #[doc = " The end timestamp for the kernel execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the kernel."]
    pub end: u64,
    #[doc = " The completed timestamp for the kernel execution, in ns.  It\n represents the completion of all it's child kernels and the\n kernel itself. A value of CUPTI_TIMESTAMP_UNKNOWN indicates that\n the completion time is unknown."]
    pub completed: u64,
    #[doc = " The ID of the device where the kernel is executing."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the kernel is executing."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the kernel is executing."]
    pub streamId: u32,
    #[doc = " The X-dimension grid size for the kernel."]
    pub gridX: i32,
    #[doc = " The Y-dimension grid size for the kernel."]
    pub gridY: i32,
    #[doc = " The Z-dimension grid size for the kernel."]
    pub gridZ: i32,
    #[doc = " The X-dimension block size for the kernel."]
    pub blockX: i32,
    #[doc = " The Y-dimension block size for the kernel."]
    pub blockY: i32,
    #[doc = " The Z-dimension grid size for the kernel."]
    pub blockZ: i32,
    #[doc = " The static shared memory allocated for the kernel, in bytes."]
    pub staticSharedMemory: i32,
    #[doc = " The dynamic shared memory reserved for the kernel, in bytes."]
    pub dynamicSharedMemory: i32,
    #[doc = " The amount of local memory reserved for each thread, in bytes."]
    pub localMemoryPerThread: u32,
    #[doc = " The total amount of local memory reserved for the kernel, in\n bytes."]
    pub localMemoryTotal: u32,
    #[doc = " The correlation ID of the kernel. Each kernel execution is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver or runtime API activity record that\n launched the kernel."]
    pub correlationId: u32,
    #[doc = " The grid ID of the kernel. Each kernel is assigned a unique\n grid ID at runtime."]
    pub gridId: i64,
    #[doc = " The name of the kernel. This name is shared across all activity\n records representing the same kernel, and so should not be\n modified."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
    #[doc = " The timestamp when the kernel is queued up in the command buffer, in ns.\n A value of CUPTI_TIMESTAMP_UNKNOWN indicates that the queued time\n could not be collected for the kernel. This timestamp is not collected\n by default. Use API \\ref cuptiActivityEnableLatencyTimestamps() to\n enable collection.\n\n Command buffer is a buffer written by CUDA driver to send commands\n like kernel launch, memory copy etc to the GPU. All launches of CUDA\n kernels are asynchronous with respect to the host, the host requests\n the launch by writing commands into the command buffer, then returns\n without checking the GPU's progress."]
    pub queued: u64,
    #[doc = " The timestamp when the command buffer containing the kernel launch\n is submitted to the GPU, in ns. A value of CUPTI_TIMESTAMP_UNKNOWN\n indicates that the submitted time could not be collected for the kernel.\n This timestamp is not collected by default. Use API \\ref\n cuptiActivityEnableLatencyTimestamps() to enable collection."]
    pub submitted: u64,
    #[doc = " The indicates if the kernel was executed via a regular launch or via a\n single/multi device cooperative launch. \\see CUpti_ActivityLaunchType"]
    pub launchType: u8,
    #[doc = " This indicates if CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT was\n updated for the kernel launch"]
    pub isSharedMemoryCarveoutRequested: u8,
    #[doc = " Shared memory carveout value requested for the function in percentage of\n the total resource. The value will be updated only if field\n isSharedMemoryCarveoutRequested is set."]
    pub sharedMemoryCarveoutRequested: u8,
    #[doc = " Undefined. Reserved for internal use."]
    pub padding: u8,
    #[doc = " Shared memory size set by the driver."]
    pub sharedMemoryExecuted: u32,
    #[doc = " The unique ID of the graph node that launched this kernel through graph launch APIs.\n This field will be 0 if the kernel is not launched through graph launch APIs."]
    pub graphNodeId: u64,
    #[doc = " The shared memory limit config for the kernel. This field shows whether user has opted for a\n higher per block limit of dynamic shared memory."]
    pub shmemLimitConfig: CUpti_FuncShmemLimitConfig,
    #[doc = " The unique ID of the graph that launched this kernel through graph launch APIs.\n This field will be 0 if the kernel is not launched through graph launch APIs."]
    pub graphId: u32,
    #[doc = " The pointer to the access policy window. The structure CUaccessPolicyWindow is\n defined in cuda.h."]
    pub pAccessPolicyWindow: *mut CUaccessPolicyWindow,
}
#[doc = " For devices with compute capability 7.5+ cacheConfig values are not updated\n in case field isSharedMemoryCarveoutRequested is set"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityKernel6__bindgen_ty_1 {
    pub both: u8,
    pub config: CUpti_ActivityKernel6__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityKernel6__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel6__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityKernel6__bindgen_ty_1__bindgen_ty_1>() - 1usize];
    ["Alignment of CUpti_ActivityKernel6__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityKernel6__bindgen_ty_1__bindgen_ty_1>() - 1usize];
};
impl CUpti_ActivityKernel6__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn requested(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_requested(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn requested_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_requested_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn executed(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_executed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn executed_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_executed_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(requested: u8, executed: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let requested: u8 = unsafe { ::std::mem::transmute(requested) };
            requested as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let executed: u8 = unsafe { ::std::mem::transmute(executed) };
            executed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel6__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityKernel6__bindgen_ty_1>() - 1usize];
    ["Alignment of CUpti_ActivityKernel6__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityKernel6__bindgen_ty_1>() - 1usize];
    ["Offset of field: CUpti_ActivityKernel6__bindgen_ty_1::both"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6__bindgen_ty_1, both) - 0usize];
    ["Offset of field: CUpti_ActivityKernel6__bindgen_ty_1::config"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6__bindgen_ty_1, config) - 0usize];
};
impl Default for CUpti_ActivityKernel6__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel6__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityKernel6__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel6"][::std::mem::size_of::<CUpti_ActivityKernel6>() - 168usize];
    ["Alignment of CUpti_ActivityKernel6"]
        [::std::mem::align_of::<CUpti_ActivityKernel6>() - 8usize];
    ["Offset of field: CUpti_ActivityKernel6::kind"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, kind) - 0usize];
    ["Offset of field: CUpti_ActivityKernel6::cacheConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, cacheConfig) - 4usize];
    ["Offset of field: CUpti_ActivityKernel6::sharedMemoryConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, sharedMemoryConfig) - 5usize];
    ["Offset of field: CUpti_ActivityKernel6::registersPerThread"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, registersPerThread) - 6usize];
    ["Offset of field: CUpti_ActivityKernel6::partitionedGlobalCacheRequested"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, partitionedGlobalCacheRequested) - 8usize];
    ["Offset of field: CUpti_ActivityKernel6::partitionedGlobalCacheExecuted"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, partitionedGlobalCacheExecuted) - 12usize];
    ["Offset of field: CUpti_ActivityKernel6::start"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, start) - 16usize];
    ["Offset of field: CUpti_ActivityKernel6::end"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, end) - 24usize];
    ["Offset of field: CUpti_ActivityKernel6::completed"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, completed) - 32usize];
    ["Offset of field: CUpti_ActivityKernel6::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, deviceId) - 40usize];
    ["Offset of field: CUpti_ActivityKernel6::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, contextId) - 44usize];
    ["Offset of field: CUpti_ActivityKernel6::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, streamId) - 48usize];
    ["Offset of field: CUpti_ActivityKernel6::gridX"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, gridX) - 52usize];
    ["Offset of field: CUpti_ActivityKernel6::gridY"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, gridY) - 56usize];
    ["Offset of field: CUpti_ActivityKernel6::gridZ"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, gridZ) - 60usize];
    ["Offset of field: CUpti_ActivityKernel6::blockX"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, blockX) - 64usize];
    ["Offset of field: CUpti_ActivityKernel6::blockY"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, blockY) - 68usize];
    ["Offset of field: CUpti_ActivityKernel6::blockZ"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, blockZ) - 72usize];
    ["Offset of field: CUpti_ActivityKernel6::staticSharedMemory"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, staticSharedMemory) - 76usize];
    ["Offset of field: CUpti_ActivityKernel6::dynamicSharedMemory"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, dynamicSharedMemory) - 80usize];
    ["Offset of field: CUpti_ActivityKernel6::localMemoryPerThread"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, localMemoryPerThread) - 84usize];
    ["Offset of field: CUpti_ActivityKernel6::localMemoryTotal"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, localMemoryTotal) - 88usize];
    ["Offset of field: CUpti_ActivityKernel6::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, correlationId) - 92usize];
    ["Offset of field: CUpti_ActivityKernel6::gridId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, gridId) - 96usize];
    ["Offset of field: CUpti_ActivityKernel6::name"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, name) - 104usize];
    ["Offset of field: CUpti_ActivityKernel6::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, reserved0) - 112usize];
    ["Offset of field: CUpti_ActivityKernel6::queued"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, queued) - 120usize];
    ["Offset of field: CUpti_ActivityKernel6::submitted"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, submitted) - 128usize];
    ["Offset of field: CUpti_ActivityKernel6::launchType"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, launchType) - 136usize];
    ["Offset of field: CUpti_ActivityKernel6::isSharedMemoryCarveoutRequested"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, isSharedMemoryCarveoutRequested) - 137usize];
    ["Offset of field: CUpti_ActivityKernel6::sharedMemoryCarveoutRequested"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, sharedMemoryCarveoutRequested) - 138usize];
    ["Offset of field: CUpti_ActivityKernel6::padding"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, padding) - 139usize];
    ["Offset of field: CUpti_ActivityKernel6::sharedMemoryExecuted"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, sharedMemoryExecuted) - 140usize];
    ["Offset of field: CUpti_ActivityKernel6::graphNodeId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, graphNodeId) - 144usize];
    ["Offset of field: CUpti_ActivityKernel6::shmemLimitConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, shmemLimitConfig) - 152usize];
    ["Offset of field: CUpti_ActivityKernel6::graphId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, graphId) - 156usize];
    ["Offset of field: CUpti_ActivityKernel6::pAccessPolicyWindow"]
        [::std::mem::offset_of!(CUpti_ActivityKernel6, pAccessPolicyWindow) - 160usize];
};
impl Default for CUpti_ActivityKernel6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel6 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityKernel6 {{ kind: {:?}, cacheConfig: {:?}, partitionedGlobalCacheRequested: {:?}, partitionedGlobalCacheExecuted: {:?}, name: {:?}, reserved0: {:?}, shmemLimitConfig: {:?}, pAccessPolicyWindow: {:?} }}",
            self.kind,
            self.cacheConfig,
            self.partitionedGlobalCacheRequested,
            self.partitionedGlobalCacheExecuted,
            self.name,
            self.reserved0,
            self.shmemLimitConfig,
            self.pAccessPolicyWindow
        )
    }
}
#[doc = " \\brief The activity record for kernel. (deprecated in CUDA 11.8)\n\n This activity record represents a kernel execution\n (CUPTI_ACTIVITY_KIND_KERNEL and\n CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL) but is no longer generated\n by CUPTI. Kernel activities are now reported using the\n CUpti_ActivityKernel9 activity record."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityKernel7 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_KERNEL or\n CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL."]
    pub kind: CUpti_ActivityKind,
    pub cacheConfig: CUpti_ActivityKernel7__bindgen_ty_1,
    #[doc = " The shared memory configuration used for the kernel. The value is one of\n the CUsharedconfig enumeration values from cuda.h."]
    pub sharedMemoryConfig: u8,
    #[doc = " The number of registers required for each thread executing the\n kernel."]
    pub registersPerThread: u16,
    #[doc = " The partitioned global caching requested for the kernel. Partitioned\n global caching is required to enable caching on certain chips, such as\n devices with compute capability 5.2."]
    pub partitionedGlobalCacheRequested: CUpti_ActivityPartitionedGlobalCacheConfig,
    #[doc = " The partitioned global caching executed for the kernel. Partitioned\n global caching is required to enable caching on certain chips, such as\n devices with compute capability 5.2. Partitioned global caching can be\n automatically disabled if the occupancy requirement of the launch cannot\n support caching."]
    pub partitionedGlobalCacheExecuted: CUpti_ActivityPartitionedGlobalCacheConfig,
    #[doc = " The start timestamp for the kernel execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the kernel."]
    pub start: u64,
    #[doc = " The end timestamp for the kernel execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the kernel."]
    pub end: u64,
    #[doc = " The completed timestamp for the kernel execution, in ns.  It\n represents the completion of all it's child kernels and the\n kernel itself. A value of CUPTI_TIMESTAMP_UNKNOWN indicates that\n the completion time is unknown."]
    pub completed: u64,
    #[doc = " The ID of the device where the kernel is executing."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the kernel is executing."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the kernel is executing."]
    pub streamId: u32,
    #[doc = " The X-dimension grid size for the kernel."]
    pub gridX: i32,
    #[doc = " The Y-dimension grid size for the kernel."]
    pub gridY: i32,
    #[doc = " The Z-dimension grid size for the kernel."]
    pub gridZ: i32,
    #[doc = " The X-dimension block size for the kernel."]
    pub blockX: i32,
    #[doc = " The Y-dimension block size for the kernel."]
    pub blockY: i32,
    #[doc = " The Z-dimension grid size for the kernel."]
    pub blockZ: i32,
    #[doc = " The static shared memory allocated for the kernel, in bytes."]
    pub staticSharedMemory: i32,
    #[doc = " The dynamic shared memory reserved for the kernel, in bytes."]
    pub dynamicSharedMemory: i32,
    #[doc = " The amount of local memory reserved for each thread, in bytes."]
    pub localMemoryPerThread: u32,
    #[doc = " The total amount of local memory reserved for the kernel, in\n bytes."]
    pub localMemoryTotal: u32,
    #[doc = " The correlation ID of the kernel. Each kernel execution is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver or runtime API activity record that\n launched the kernel."]
    pub correlationId: u32,
    #[doc = " The grid ID of the kernel. Each kernel is assigned a unique\n grid ID at runtime."]
    pub gridId: i64,
    #[doc = " The name of the kernel. This name is shared across all activity\n records representing the same kernel, and so should not be\n modified."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
    #[doc = " The timestamp when the kernel is queued up in the command buffer, in ns.\n A value of CUPTI_TIMESTAMP_UNKNOWN indicates that the queued time\n could not be collected for the kernel. This timestamp is not collected\n by default. Use API \\ref cuptiActivityEnableLatencyTimestamps() to\n enable collection.\n\n Command buffer is a buffer written by CUDA driver to send commands\n like kernel launch, memory copy etc to the GPU. All launches of CUDA\n kernels are asynchronous with respect to the host, the host requests\n the launch by writing commands into the command buffer, then returns\n without checking the GPU's progress."]
    pub queued: u64,
    #[doc = " The timestamp when the command buffer containing the kernel launch\n is submitted to the GPU, in ns. A value of CUPTI_TIMESTAMP_UNKNOWN\n indicates that the submitted time could not be collected for the kernel.\n This timestamp is not collected by default. Use API \\ref\n cuptiActivityEnableLatencyTimestamps() to enable collection."]
    pub submitted: u64,
    #[doc = " The indicates if the kernel was executed via a regular launch or via a\n single/multi device cooperative launch. \\see CUpti_ActivityLaunchType"]
    pub launchType: u8,
    #[doc = " This indicates if CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT was\n updated for the kernel launch"]
    pub isSharedMemoryCarveoutRequested: u8,
    #[doc = " Shared memory carveout value requested for the function in percentage of\n the total resource. The value will be updated only if field\n isSharedMemoryCarveoutRequested is set."]
    pub sharedMemoryCarveoutRequested: u8,
    #[doc = " Undefined. Reserved for internal use."]
    pub padding: u8,
    #[doc = " Shared memory size set by the driver."]
    pub sharedMemoryExecuted: u32,
    #[doc = " The unique ID of the graph node that launched this kernel through graph launch APIs.\n This field will be 0 if the kernel is not launched through graph launch APIs."]
    pub graphNodeId: u64,
    #[doc = " The shared memory limit config for the kernel. This field shows whether user has opted for a\n higher per block limit of dynamic shared memory."]
    pub shmemLimitConfig: CUpti_FuncShmemLimitConfig,
    #[doc = " The unique ID of the graph that launched this kernel through graph launch APIs.\n This field will be 0 if the kernel is not launched through graph launch APIs."]
    pub graphId: u32,
    #[doc = " The pointer to the access policy window. The structure CUaccessPolicyWindow is\n defined in cuda.h."]
    pub pAccessPolicyWindow: *mut CUaccessPolicyWindow,
    #[doc = " The ID of the HW channel on which the kernel is launched."]
    pub channelID: u32,
    #[doc = " The type of the channel"]
    pub channelType: CUpti_ChannelType,
}
#[doc = " For devices with compute capability 7.5+ cacheConfig values are not updated\n in case field isSharedMemoryCarveoutRequested is set"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityKernel7__bindgen_ty_1 {
    pub both: u8,
    pub config: CUpti_ActivityKernel7__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityKernel7__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel7__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityKernel7__bindgen_ty_1__bindgen_ty_1>() - 1usize];
    ["Alignment of CUpti_ActivityKernel7__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityKernel7__bindgen_ty_1__bindgen_ty_1>() - 1usize];
};
impl CUpti_ActivityKernel7__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn requested(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_requested(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn requested_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_requested_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn executed(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_executed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn executed_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_executed_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(requested: u8, executed: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let requested: u8 = unsafe { ::std::mem::transmute(requested) };
            requested as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let executed: u8 = unsafe { ::std::mem::transmute(executed) };
            executed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel7__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityKernel7__bindgen_ty_1>() - 1usize];
    ["Alignment of CUpti_ActivityKernel7__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityKernel7__bindgen_ty_1>() - 1usize];
    ["Offset of field: CUpti_ActivityKernel7__bindgen_ty_1::both"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7__bindgen_ty_1, both) - 0usize];
    ["Offset of field: CUpti_ActivityKernel7__bindgen_ty_1::config"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7__bindgen_ty_1, config) - 0usize];
};
impl Default for CUpti_ActivityKernel7__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel7__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityKernel7__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel7"][::std::mem::size_of::<CUpti_ActivityKernel7>() - 176usize];
    ["Alignment of CUpti_ActivityKernel7"]
        [::std::mem::align_of::<CUpti_ActivityKernel7>() - 8usize];
    ["Offset of field: CUpti_ActivityKernel7::kind"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, kind) - 0usize];
    ["Offset of field: CUpti_ActivityKernel7::cacheConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, cacheConfig) - 4usize];
    ["Offset of field: CUpti_ActivityKernel7::sharedMemoryConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, sharedMemoryConfig) - 5usize];
    ["Offset of field: CUpti_ActivityKernel7::registersPerThread"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, registersPerThread) - 6usize];
    ["Offset of field: CUpti_ActivityKernel7::partitionedGlobalCacheRequested"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, partitionedGlobalCacheRequested) - 8usize];
    ["Offset of field: CUpti_ActivityKernel7::partitionedGlobalCacheExecuted"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, partitionedGlobalCacheExecuted) - 12usize];
    ["Offset of field: CUpti_ActivityKernel7::start"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, start) - 16usize];
    ["Offset of field: CUpti_ActivityKernel7::end"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, end) - 24usize];
    ["Offset of field: CUpti_ActivityKernel7::completed"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, completed) - 32usize];
    ["Offset of field: CUpti_ActivityKernel7::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, deviceId) - 40usize];
    ["Offset of field: CUpti_ActivityKernel7::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, contextId) - 44usize];
    ["Offset of field: CUpti_ActivityKernel7::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, streamId) - 48usize];
    ["Offset of field: CUpti_ActivityKernel7::gridX"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, gridX) - 52usize];
    ["Offset of field: CUpti_ActivityKernel7::gridY"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, gridY) - 56usize];
    ["Offset of field: CUpti_ActivityKernel7::gridZ"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, gridZ) - 60usize];
    ["Offset of field: CUpti_ActivityKernel7::blockX"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, blockX) - 64usize];
    ["Offset of field: CUpti_ActivityKernel7::blockY"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, blockY) - 68usize];
    ["Offset of field: CUpti_ActivityKernel7::blockZ"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, blockZ) - 72usize];
    ["Offset of field: CUpti_ActivityKernel7::staticSharedMemory"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, staticSharedMemory) - 76usize];
    ["Offset of field: CUpti_ActivityKernel7::dynamicSharedMemory"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, dynamicSharedMemory) - 80usize];
    ["Offset of field: CUpti_ActivityKernel7::localMemoryPerThread"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, localMemoryPerThread) - 84usize];
    ["Offset of field: CUpti_ActivityKernel7::localMemoryTotal"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, localMemoryTotal) - 88usize];
    ["Offset of field: CUpti_ActivityKernel7::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, correlationId) - 92usize];
    ["Offset of field: CUpti_ActivityKernel7::gridId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, gridId) - 96usize];
    ["Offset of field: CUpti_ActivityKernel7::name"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, name) - 104usize];
    ["Offset of field: CUpti_ActivityKernel7::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, reserved0) - 112usize];
    ["Offset of field: CUpti_ActivityKernel7::queued"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, queued) - 120usize];
    ["Offset of field: CUpti_ActivityKernel7::submitted"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, submitted) - 128usize];
    ["Offset of field: CUpti_ActivityKernel7::launchType"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, launchType) - 136usize];
    ["Offset of field: CUpti_ActivityKernel7::isSharedMemoryCarveoutRequested"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, isSharedMemoryCarveoutRequested) - 137usize];
    ["Offset of field: CUpti_ActivityKernel7::sharedMemoryCarveoutRequested"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, sharedMemoryCarveoutRequested) - 138usize];
    ["Offset of field: CUpti_ActivityKernel7::padding"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, padding) - 139usize];
    ["Offset of field: CUpti_ActivityKernel7::sharedMemoryExecuted"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, sharedMemoryExecuted) - 140usize];
    ["Offset of field: CUpti_ActivityKernel7::graphNodeId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, graphNodeId) - 144usize];
    ["Offset of field: CUpti_ActivityKernel7::shmemLimitConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, shmemLimitConfig) - 152usize];
    ["Offset of field: CUpti_ActivityKernel7::graphId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, graphId) - 156usize];
    ["Offset of field: CUpti_ActivityKernel7::pAccessPolicyWindow"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, pAccessPolicyWindow) - 160usize];
    ["Offset of field: CUpti_ActivityKernel7::channelID"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, channelID) - 168usize];
    ["Offset of field: CUpti_ActivityKernel7::channelType"]
        [::std::mem::offset_of!(CUpti_ActivityKernel7, channelType) - 172usize];
};
impl Default for CUpti_ActivityKernel7 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel7 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityKernel7 {{ kind: {:?}, cacheConfig: {:?}, partitionedGlobalCacheRequested: {:?}, partitionedGlobalCacheExecuted: {:?}, name: {:?}, reserved0: {:?}, shmemLimitConfig: {:?}, pAccessPolicyWindow: {:?}, channelType: {:?} }}",
            self.kind,
            self.cacheConfig,
            self.partitionedGlobalCacheRequested,
            self.partitionedGlobalCacheExecuted,
            self.name,
            self.reserved0,
            self.shmemLimitConfig,
            self.pAccessPolicyWindow,
            self.channelType
        )
    }
}
#[doc = " \\brief The activity record for kernel.\n\n This activity record represents a kernel execution\n (CUPTI_ACTIVITY_KIND_KERNEL and\n CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL)"]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityKernel8 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_KERNEL or\n CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL."]
    pub kind: CUpti_ActivityKind,
    pub cacheConfig: CUpti_ActivityKernel8__bindgen_ty_1,
    #[doc = " The shared memory configuration used for the kernel. The value is one of\n the CUsharedconfig enumeration values from cuda.h."]
    pub sharedMemoryConfig: u8,
    #[doc = " The number of registers required for each thread executing the\n kernel."]
    pub registersPerThread: u16,
    #[doc = " The partitioned global caching requested for the kernel. Partitioned\n global caching is required to enable caching on certain chips, such as\n devices with compute capability 5.2."]
    pub partitionedGlobalCacheRequested: CUpti_ActivityPartitionedGlobalCacheConfig,
    #[doc = " The partitioned global caching executed for the kernel. Partitioned\n global caching is required to enable caching on certain chips, such as\n devices with compute capability 5.2. Partitioned global caching can be\n automatically disabled if the occupancy requirement of the launch cannot\n support caching."]
    pub partitionedGlobalCacheExecuted: CUpti_ActivityPartitionedGlobalCacheConfig,
    #[doc = " The start timestamp for the kernel execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the kernel."]
    pub start: u64,
    #[doc = " The end timestamp for the kernel execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the kernel."]
    pub end: u64,
    #[doc = " The completed timestamp for the kernel execution, in ns.  It\n represents the completion of all it's child kernels and the\n kernel itself. A value of CUPTI_TIMESTAMP_UNKNOWN indicates that\n the completion time is unknown."]
    pub completed: u64,
    #[doc = " The ID of the device where the kernel is executing."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the kernel is executing."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the kernel is executing."]
    pub streamId: u32,
    #[doc = " The X-dimension grid size for the kernel."]
    pub gridX: i32,
    #[doc = " The Y-dimension grid size for the kernel."]
    pub gridY: i32,
    #[doc = " The Z-dimension grid size for the kernel."]
    pub gridZ: i32,
    #[doc = " The X-dimension block size for the kernel."]
    pub blockX: i32,
    #[doc = " The Y-dimension block size for the kernel."]
    pub blockY: i32,
    #[doc = " The Z-dimension grid size for the kernel."]
    pub blockZ: i32,
    #[doc = " The static shared memory allocated for the kernel, in bytes."]
    pub staticSharedMemory: i32,
    #[doc = " The dynamic shared memory reserved for the kernel, in bytes."]
    pub dynamicSharedMemory: i32,
    #[doc = " The amount of local memory reserved for each thread, in bytes."]
    pub localMemoryPerThread: u32,
    #[doc = " The total amount of local memory reserved for the kernel, in\n bytes (deprecated in CUDA 11.8).\n Refer field localMemoryTotal_v2"]
    pub localMemoryTotal: u32,
    #[doc = " The correlation ID of the kernel. Each kernel execution is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver or runtime API activity record that\n launched the kernel."]
    pub correlationId: u32,
    #[doc = " The grid ID of the kernel. Each kernel is assigned a unique\n grid ID at runtime."]
    pub gridId: i64,
    #[doc = " The name of the kernel. This name is shared across all activity\n records representing the same kernel, and so should not be\n modified."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
    #[doc = " The timestamp when the kernel is queued up in the command buffer, in ns.\n A value of CUPTI_TIMESTAMP_UNKNOWN indicates that the queued time\n could not be collected for the kernel. This timestamp is not collected\n by default. Use API \\ref cuptiActivityEnableLatencyTimestamps() to\n enable collection.\n\n Command buffer is a buffer written by CUDA driver to send commands\n like kernel launch, memory copy etc to the GPU. All launches of CUDA\n kernels are asynchronous with respect to the host, the host requests\n the launch by writing commands into the command buffer, then returns\n without checking the GPU's progress."]
    pub queued: u64,
    #[doc = " The timestamp when the command buffer containing the kernel launch\n is submitted to the GPU, in ns. A value of CUPTI_TIMESTAMP_UNKNOWN\n indicates that the submitted time could not be collected for the kernel.\n This timestamp is not collected by default. Use API \\ref\n cuptiActivityEnableLatencyTimestamps() to enable collection."]
    pub submitted: u64,
    #[doc = " The indicates if the kernel was executed via a regular launch or via a\n single/multi device cooperative launch. \\see CUpti_ActivityLaunchType"]
    pub launchType: u8,
    #[doc = " This indicates if CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT was\n updated for the kernel launch"]
    pub isSharedMemoryCarveoutRequested: u8,
    #[doc = " Shared memory carveout value requested for the function in percentage of\n the total resource. The value will be updated only if field\n isSharedMemoryCarveoutRequested is set."]
    pub sharedMemoryCarveoutRequested: u8,
    #[doc = " Undefined. Reserved for internal use."]
    pub padding: u8,
    #[doc = " Shared memory size set by the driver."]
    pub sharedMemoryExecuted: u32,
    #[doc = " The unique ID of the graph node that launched this kernel through graph launch APIs.\n This field will be 0 if the kernel is not launched through graph launch APIs."]
    pub graphNodeId: u64,
    #[doc = " The shared memory limit config for the kernel. This field shows whether user has opted for a\n higher per block limit of dynamic shared memory."]
    pub shmemLimitConfig: CUpti_FuncShmemLimitConfig,
    #[doc = " The unique ID of the graph that launched this kernel through graph launch APIs.\n This field will be 0 if the kernel is not launched through graph launch APIs."]
    pub graphId: u32,
    #[doc = " The pointer to the access policy window. The structure CUaccessPolicyWindow is\n defined in cuda.h."]
    pub pAccessPolicyWindow: *mut CUaccessPolicyWindow,
    #[doc = " The ID of the HW channel on which the kernel is launched."]
    pub channelID: u32,
    #[doc = " The type of the channel"]
    pub channelType: CUpti_ChannelType,
    #[doc = " The X-dimension cluster size for the kernel.\n Field is valid for devices with compute capability 9.0 and higher"]
    pub clusterX: u32,
    #[doc = " The Y-dimension cluster size for the kernel.\n Field is valid for devices with compute capability 9.0 and higher"]
    pub clusterY: u32,
    #[doc = " The Z-dimension cluster size for the kernel.\n Field is valid for devices with compute capability 9.0 and higher"]
    pub clusterZ: u32,
    #[doc = " The cluster scheduling policy for the kernel. Refer CUclusterSchedulingPolicy\n Field is valid for devices with compute capability 9.0 and higher"]
    pub clusterSchedulingPolicy: u32,
    #[doc = " The total amount of local memory reserved for the kernel, in\n bytes."]
    pub localMemoryTotal_v2: u64,
}
#[doc = " For devices with compute capability 7.5+ cacheConfig values are not updated\n in case field isSharedMemoryCarveoutRequested is set"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityKernel8__bindgen_ty_1 {
    pub both: u8,
    pub config: CUpti_ActivityKernel8__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityKernel8__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel8__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityKernel8__bindgen_ty_1__bindgen_ty_1>() - 1usize];
    ["Alignment of CUpti_ActivityKernel8__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityKernel8__bindgen_ty_1__bindgen_ty_1>() - 1usize];
};
impl CUpti_ActivityKernel8__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn requested(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_requested(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn requested_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_requested_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn executed(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_executed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn executed_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_executed_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(requested: u8, executed: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let requested: u8 = unsafe { ::std::mem::transmute(requested) };
            requested as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let executed: u8 = unsafe { ::std::mem::transmute(executed) };
            executed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel8__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityKernel8__bindgen_ty_1>() - 1usize];
    ["Alignment of CUpti_ActivityKernel8__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityKernel8__bindgen_ty_1>() - 1usize];
    ["Offset of field: CUpti_ActivityKernel8__bindgen_ty_1::both"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8__bindgen_ty_1, both) - 0usize];
    ["Offset of field: CUpti_ActivityKernel8__bindgen_ty_1::config"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8__bindgen_ty_1, config) - 0usize];
};
impl Default for CUpti_ActivityKernel8__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel8__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityKernel8__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel8"][::std::mem::size_of::<CUpti_ActivityKernel8>() - 200usize];
    ["Alignment of CUpti_ActivityKernel8"]
        [::std::mem::align_of::<CUpti_ActivityKernel8>() - 8usize];
    ["Offset of field: CUpti_ActivityKernel8::kind"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, kind) - 0usize];
    ["Offset of field: CUpti_ActivityKernel8::cacheConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, cacheConfig) - 4usize];
    ["Offset of field: CUpti_ActivityKernel8::sharedMemoryConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, sharedMemoryConfig) - 5usize];
    ["Offset of field: CUpti_ActivityKernel8::registersPerThread"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, registersPerThread) - 6usize];
    ["Offset of field: CUpti_ActivityKernel8::partitionedGlobalCacheRequested"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, partitionedGlobalCacheRequested) - 8usize];
    ["Offset of field: CUpti_ActivityKernel8::partitionedGlobalCacheExecuted"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, partitionedGlobalCacheExecuted) - 12usize];
    ["Offset of field: CUpti_ActivityKernel8::start"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, start) - 16usize];
    ["Offset of field: CUpti_ActivityKernel8::end"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, end) - 24usize];
    ["Offset of field: CUpti_ActivityKernel8::completed"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, completed) - 32usize];
    ["Offset of field: CUpti_ActivityKernel8::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, deviceId) - 40usize];
    ["Offset of field: CUpti_ActivityKernel8::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, contextId) - 44usize];
    ["Offset of field: CUpti_ActivityKernel8::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, streamId) - 48usize];
    ["Offset of field: CUpti_ActivityKernel8::gridX"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, gridX) - 52usize];
    ["Offset of field: CUpti_ActivityKernel8::gridY"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, gridY) - 56usize];
    ["Offset of field: CUpti_ActivityKernel8::gridZ"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, gridZ) - 60usize];
    ["Offset of field: CUpti_ActivityKernel8::blockX"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, blockX) - 64usize];
    ["Offset of field: CUpti_ActivityKernel8::blockY"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, blockY) - 68usize];
    ["Offset of field: CUpti_ActivityKernel8::blockZ"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, blockZ) - 72usize];
    ["Offset of field: CUpti_ActivityKernel8::staticSharedMemory"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, staticSharedMemory) - 76usize];
    ["Offset of field: CUpti_ActivityKernel8::dynamicSharedMemory"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, dynamicSharedMemory) - 80usize];
    ["Offset of field: CUpti_ActivityKernel8::localMemoryPerThread"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, localMemoryPerThread) - 84usize];
    ["Offset of field: CUpti_ActivityKernel8::localMemoryTotal"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, localMemoryTotal) - 88usize];
    ["Offset of field: CUpti_ActivityKernel8::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, correlationId) - 92usize];
    ["Offset of field: CUpti_ActivityKernel8::gridId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, gridId) - 96usize];
    ["Offset of field: CUpti_ActivityKernel8::name"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, name) - 104usize];
    ["Offset of field: CUpti_ActivityKernel8::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, reserved0) - 112usize];
    ["Offset of field: CUpti_ActivityKernel8::queued"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, queued) - 120usize];
    ["Offset of field: CUpti_ActivityKernel8::submitted"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, submitted) - 128usize];
    ["Offset of field: CUpti_ActivityKernel8::launchType"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, launchType) - 136usize];
    ["Offset of field: CUpti_ActivityKernel8::isSharedMemoryCarveoutRequested"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, isSharedMemoryCarveoutRequested) - 137usize];
    ["Offset of field: CUpti_ActivityKernel8::sharedMemoryCarveoutRequested"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, sharedMemoryCarveoutRequested) - 138usize];
    ["Offset of field: CUpti_ActivityKernel8::padding"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, padding) - 139usize];
    ["Offset of field: CUpti_ActivityKernel8::sharedMemoryExecuted"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, sharedMemoryExecuted) - 140usize];
    ["Offset of field: CUpti_ActivityKernel8::graphNodeId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, graphNodeId) - 144usize];
    ["Offset of field: CUpti_ActivityKernel8::shmemLimitConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, shmemLimitConfig) - 152usize];
    ["Offset of field: CUpti_ActivityKernel8::graphId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, graphId) - 156usize];
    ["Offset of field: CUpti_ActivityKernel8::pAccessPolicyWindow"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, pAccessPolicyWindow) - 160usize];
    ["Offset of field: CUpti_ActivityKernel8::channelID"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, channelID) - 168usize];
    ["Offset of field: CUpti_ActivityKernel8::channelType"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, channelType) - 172usize];
    ["Offset of field: CUpti_ActivityKernel8::clusterX"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, clusterX) - 176usize];
    ["Offset of field: CUpti_ActivityKernel8::clusterY"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, clusterY) - 180usize];
    ["Offset of field: CUpti_ActivityKernel8::clusterZ"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, clusterZ) - 184usize];
    ["Offset of field: CUpti_ActivityKernel8::clusterSchedulingPolicy"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, clusterSchedulingPolicy) - 188usize];
    ["Offset of field: CUpti_ActivityKernel8::localMemoryTotal_v2"]
        [::std::mem::offset_of!(CUpti_ActivityKernel8, localMemoryTotal_v2) - 192usize];
};
impl Default for CUpti_ActivityKernel8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel8 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityKernel8 {{ kind: {:?}, cacheConfig: {:?}, partitionedGlobalCacheRequested: {:?}, partitionedGlobalCacheExecuted: {:?}, name: {:?}, reserved0: {:?}, shmemLimitConfig: {:?}, pAccessPolicyWindow: {:?}, channelType: {:?} }}",
            self.kind,
            self.cacheConfig,
            self.partitionedGlobalCacheRequested,
            self.partitionedGlobalCacheExecuted,
            self.name,
            self.reserved0,
            self.shmemLimitConfig,
            self.pAccessPolicyWindow,
            self.channelType
        )
    }
}
#[doc = " \\brief The activity record for kernel.\n\n This activity record represents a kernel execution\n (CUPTI_ACTIVITY_KIND_KERNEL and\n CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL)"]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityKernel9 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_KERNEL or\n CUPTI_ACTIVITY_KIND_CONCURRENT_KERNEL."]
    pub kind: CUpti_ActivityKind,
    pub cacheConfig: CUpti_ActivityKernel9__bindgen_ty_1,
    #[doc = " The shared memory configuration used for the kernel. The value is one of\n the CUsharedconfig enumeration values from cuda.h."]
    pub sharedMemoryConfig: u8,
    #[doc = " The number of registers required for each thread executing the\n kernel."]
    pub registersPerThread: u16,
    #[doc = " The partitioned global caching requested for the kernel. Partitioned\n global caching is required to enable caching on certain chips, such as\n devices with compute capability 5.2."]
    pub partitionedGlobalCacheRequested: CUpti_ActivityPartitionedGlobalCacheConfig,
    #[doc = " The partitioned global caching executed for the kernel. Partitioned\n global caching is required to enable caching on certain chips, such as\n devices with compute capability 5.2. Partitioned global caching can be\n automatically disabled if the occupancy requirement of the launch cannot\n support caching."]
    pub partitionedGlobalCacheExecuted: CUpti_ActivityPartitionedGlobalCacheConfig,
    #[doc = " The start timestamp for the kernel execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the kernel."]
    pub start: u64,
    #[doc = " The end timestamp for the kernel execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the kernel."]
    pub end: u64,
    #[doc = " The completed timestamp for the kernel execution, in ns.  It\n represents the completion of all it's child kernels and the\n kernel itself. A value of CUPTI_TIMESTAMP_UNKNOWN indicates that\n the completion time is unknown."]
    pub completed: u64,
    #[doc = " The ID of the device where the kernel is executing."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the kernel is executing."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the kernel is executing."]
    pub streamId: u32,
    #[doc = " The X-dimension grid size for the kernel."]
    pub gridX: i32,
    #[doc = " The Y-dimension grid size for the kernel."]
    pub gridY: i32,
    #[doc = " The Z-dimension grid size for the kernel."]
    pub gridZ: i32,
    #[doc = " The X-dimension block size for the kernel."]
    pub blockX: i32,
    #[doc = " The Y-dimension block size for the kernel."]
    pub blockY: i32,
    #[doc = " The Z-dimension grid size for the kernel."]
    pub blockZ: i32,
    #[doc = " The static shared memory allocated for the kernel, in bytes."]
    pub staticSharedMemory: i32,
    #[doc = " The dynamic shared memory reserved for the kernel, in bytes."]
    pub dynamicSharedMemory: i32,
    #[doc = " The amount of local memory reserved for each thread, in bytes."]
    pub localMemoryPerThread: u32,
    #[doc = " The total amount of local memory reserved for the kernel, in\n bytes (deprecated in CUDA 11.8).\n Refer field localMemoryTotal_v2"]
    pub localMemoryTotal: u32,
    #[doc = " The correlation ID of the kernel. Each kernel execution is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver or runtime API activity record that\n launched the kernel."]
    pub correlationId: u32,
    #[doc = " The grid ID of the kernel. Each kernel is assigned a unique\n grid ID at runtime."]
    pub gridId: i64,
    #[doc = " The name of the kernel. This name is shared across all activity\n records representing the same kernel, and so should not be\n modified."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
    #[doc = " The timestamp when the kernel is queued up in the command buffer, in ns.\n A value of CUPTI_TIMESTAMP_UNKNOWN indicates that the queued time\n could not be collected for the kernel. This timestamp is not collected\n by default. Use API \\ref cuptiActivityEnableLatencyTimestamps() to\n enable collection.\n\n Command buffer is a buffer written by CUDA driver to send commands\n like kernel launch, memory copy etc to the GPU. All launches of CUDA\n kernels are asynchronous with respect to the host, the host requests\n the launch by writing commands into the command buffer, then returns\n without checking the GPU's progress."]
    pub queued: u64,
    #[doc = " The timestamp when the command buffer containing the kernel launch\n is submitted to the GPU, in ns. A value of CUPTI_TIMESTAMP_UNKNOWN\n indicates that the submitted time could not be collected for the kernel.\n This timestamp is not collected by default. Use API \\ref\n cuptiActivityEnableLatencyTimestamps() to enable collection."]
    pub submitted: u64,
    #[doc = " The indicates if the kernel was executed via a regular launch or via a\n single/multi device cooperative launch. \\see CUpti_ActivityLaunchType"]
    pub launchType: u8,
    #[doc = " This indicates if CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT was\n updated for the kernel launch"]
    pub isSharedMemoryCarveoutRequested: u8,
    #[doc = " Shared memory carveout value requested for the function in percentage of\n the total resource. The value will be updated only if field\n isSharedMemoryCarveoutRequested is set."]
    pub sharedMemoryCarveoutRequested: u8,
    #[doc = " Undefined. Reserved for internal use."]
    pub padding: u8,
    #[doc = " Shared memory size set by the driver."]
    pub sharedMemoryExecuted: u32,
    #[doc = " The unique ID of the graph node that launched this kernel through graph launch APIs.\n This field will be 0 if the kernel is not launched through graph launch APIs."]
    pub graphNodeId: u64,
    #[doc = " The shared memory limit config for the kernel. This field shows whether user has opted for a\n higher per block limit of dynamic shared memory."]
    pub shmemLimitConfig: CUpti_FuncShmemLimitConfig,
    #[doc = " The unique ID of the graph that launched this kernel through graph launch APIs.\n This field will be 0 if the kernel is not launched through graph launch APIs."]
    pub graphId: u32,
    #[doc = " The pointer to the access policy window. The structure CUaccessPolicyWindow is\n defined in cuda.h."]
    pub pAccessPolicyWindow: *mut CUaccessPolicyWindow,
    #[doc = " The ID of the HW channel on which the kernel is launched."]
    pub channelID: u32,
    #[doc = " The type of the channel"]
    pub channelType: CUpti_ChannelType,
    #[doc = " The X-dimension cluster size for the kernel.\n Field is valid for devices with compute capability 9.0 and higher"]
    pub clusterX: u32,
    #[doc = " The Y-dimension cluster size for the kernel.\n Field is valid for devices with compute capability 9.0 and higher"]
    pub clusterY: u32,
    #[doc = " The Z-dimension cluster size for the kernel.\n Field is valid for devices with compute capability 9.0 and higher"]
    pub clusterZ: u32,
    #[doc = " The cluster scheduling policy for the kernel. Refer CUclusterSchedulingPolicy\n Field is valid for devices with compute capability 9.0 and higher"]
    pub clusterSchedulingPolicy: u32,
    #[doc = " The total amount of local memory reserved for the kernel, in\n bytes."]
    pub localMemoryTotal_v2: u64,
    #[doc = " The maximum cluster size for the kernel"]
    pub maxPotentialClusterSize: u32,
    #[doc = " The maximum clusters that could co-exist on the target device for the kernel"]
    pub maxActiveClusters: u32,
}
#[doc = " For devices with compute capability 7.5+ cacheConfig values are not updated\n in case field isSharedMemoryCarveoutRequested is set"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityKernel9__bindgen_ty_1 {
    pub both: u8,
    pub config: CUpti_ActivityKernel9__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityKernel9__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel9__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityKernel9__bindgen_ty_1__bindgen_ty_1>() - 1usize];
    ["Alignment of CUpti_ActivityKernel9__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityKernel9__bindgen_ty_1__bindgen_ty_1>() - 1usize];
};
impl CUpti_ActivityKernel9__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn requested(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_requested(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn requested_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_requested_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn executed(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_executed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn executed_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_executed_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(requested: u8, executed: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let requested: u8 = unsafe { ::std::mem::transmute(requested) };
            requested as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let executed: u8 = unsafe { ::std::mem::transmute(executed) };
            executed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel9__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityKernel9__bindgen_ty_1>() - 1usize];
    ["Alignment of CUpti_ActivityKernel9__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityKernel9__bindgen_ty_1>() - 1usize];
    ["Offset of field: CUpti_ActivityKernel9__bindgen_ty_1::both"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9__bindgen_ty_1, both) - 0usize];
    ["Offset of field: CUpti_ActivityKernel9__bindgen_ty_1::config"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9__bindgen_ty_1, config) - 0usize];
};
impl Default for CUpti_ActivityKernel9__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel9__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityKernel9__bindgen_ty_1 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityKernel9"][::std::mem::size_of::<CUpti_ActivityKernel9>() - 208usize];
    ["Alignment of CUpti_ActivityKernel9"]
        [::std::mem::align_of::<CUpti_ActivityKernel9>() - 8usize];
    ["Offset of field: CUpti_ActivityKernel9::kind"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, kind) - 0usize];
    ["Offset of field: CUpti_ActivityKernel9::cacheConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, cacheConfig) - 4usize];
    ["Offset of field: CUpti_ActivityKernel9::sharedMemoryConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, sharedMemoryConfig) - 5usize];
    ["Offset of field: CUpti_ActivityKernel9::registersPerThread"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, registersPerThread) - 6usize];
    ["Offset of field: CUpti_ActivityKernel9::partitionedGlobalCacheRequested"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, partitionedGlobalCacheRequested) - 8usize];
    ["Offset of field: CUpti_ActivityKernel9::partitionedGlobalCacheExecuted"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, partitionedGlobalCacheExecuted) - 12usize];
    ["Offset of field: CUpti_ActivityKernel9::start"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, start) - 16usize];
    ["Offset of field: CUpti_ActivityKernel9::end"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, end) - 24usize];
    ["Offset of field: CUpti_ActivityKernel9::completed"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, completed) - 32usize];
    ["Offset of field: CUpti_ActivityKernel9::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, deviceId) - 40usize];
    ["Offset of field: CUpti_ActivityKernel9::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, contextId) - 44usize];
    ["Offset of field: CUpti_ActivityKernel9::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, streamId) - 48usize];
    ["Offset of field: CUpti_ActivityKernel9::gridX"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, gridX) - 52usize];
    ["Offset of field: CUpti_ActivityKernel9::gridY"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, gridY) - 56usize];
    ["Offset of field: CUpti_ActivityKernel9::gridZ"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, gridZ) - 60usize];
    ["Offset of field: CUpti_ActivityKernel9::blockX"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, blockX) - 64usize];
    ["Offset of field: CUpti_ActivityKernel9::blockY"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, blockY) - 68usize];
    ["Offset of field: CUpti_ActivityKernel9::blockZ"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, blockZ) - 72usize];
    ["Offset of field: CUpti_ActivityKernel9::staticSharedMemory"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, staticSharedMemory) - 76usize];
    ["Offset of field: CUpti_ActivityKernel9::dynamicSharedMemory"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, dynamicSharedMemory) - 80usize];
    ["Offset of field: CUpti_ActivityKernel9::localMemoryPerThread"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, localMemoryPerThread) - 84usize];
    ["Offset of field: CUpti_ActivityKernel9::localMemoryTotal"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, localMemoryTotal) - 88usize];
    ["Offset of field: CUpti_ActivityKernel9::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, correlationId) - 92usize];
    ["Offset of field: CUpti_ActivityKernel9::gridId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, gridId) - 96usize];
    ["Offset of field: CUpti_ActivityKernel9::name"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, name) - 104usize];
    ["Offset of field: CUpti_ActivityKernel9::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, reserved0) - 112usize];
    ["Offset of field: CUpti_ActivityKernel9::queued"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, queued) - 120usize];
    ["Offset of field: CUpti_ActivityKernel9::submitted"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, submitted) - 128usize];
    ["Offset of field: CUpti_ActivityKernel9::launchType"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, launchType) - 136usize];
    ["Offset of field: CUpti_ActivityKernel9::isSharedMemoryCarveoutRequested"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, isSharedMemoryCarveoutRequested) - 137usize];
    ["Offset of field: CUpti_ActivityKernel9::sharedMemoryCarveoutRequested"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, sharedMemoryCarveoutRequested) - 138usize];
    ["Offset of field: CUpti_ActivityKernel9::padding"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, padding) - 139usize];
    ["Offset of field: CUpti_ActivityKernel9::sharedMemoryExecuted"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, sharedMemoryExecuted) - 140usize];
    ["Offset of field: CUpti_ActivityKernel9::graphNodeId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, graphNodeId) - 144usize];
    ["Offset of field: CUpti_ActivityKernel9::shmemLimitConfig"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, shmemLimitConfig) - 152usize];
    ["Offset of field: CUpti_ActivityKernel9::graphId"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, graphId) - 156usize];
    ["Offset of field: CUpti_ActivityKernel9::pAccessPolicyWindow"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, pAccessPolicyWindow) - 160usize];
    ["Offset of field: CUpti_ActivityKernel9::channelID"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, channelID) - 168usize];
    ["Offset of field: CUpti_ActivityKernel9::channelType"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, channelType) - 172usize];
    ["Offset of field: CUpti_ActivityKernel9::clusterX"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, clusterX) - 176usize];
    ["Offset of field: CUpti_ActivityKernel9::clusterY"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, clusterY) - 180usize];
    ["Offset of field: CUpti_ActivityKernel9::clusterZ"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, clusterZ) - 184usize];
    ["Offset of field: CUpti_ActivityKernel9::clusterSchedulingPolicy"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, clusterSchedulingPolicy) - 188usize];
    ["Offset of field: CUpti_ActivityKernel9::localMemoryTotal_v2"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, localMemoryTotal_v2) - 192usize];
    ["Offset of field: CUpti_ActivityKernel9::maxPotentialClusterSize"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, maxPotentialClusterSize) - 200usize];
    ["Offset of field: CUpti_ActivityKernel9::maxActiveClusters"]
        [::std::mem::offset_of!(CUpti_ActivityKernel9, maxActiveClusters) - 204usize];
};
impl Default for CUpti_ActivityKernel9 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityKernel9 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityKernel9 {{ kind: {:?}, cacheConfig: {:?}, partitionedGlobalCacheRequested: {:?}, partitionedGlobalCacheExecuted: {:?}, name: {:?}, reserved0: {:?}, shmemLimitConfig: {:?}, pAccessPolicyWindow: {:?}, channelType: {:?} }}",
            self.kind,
            self.cacheConfig,
            self.partitionedGlobalCacheRequested,
            self.partitionedGlobalCacheExecuted,
            self.name,
            self.reserved0,
            self.shmemLimitConfig,
            self.pAccessPolicyWindow,
            self.channelType
        )
    }
}
#[doc = " \\brief The activity record for memory copies. (deprecated)\n\n This activity record represents a memory copy\n (CUPTI_ACTIVITY_KIND_MEMCPY)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemcpy {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMCPY."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The kind of the memory copy, stored as a byte to reduce record\n size. \\see CUpti_ActivityMemcpyKind"]
    pub copyKind: u8,
    #[doc = " The source memory kind read by the memory copy, stored as a byte\n to reduce record size. \\see CUpti_ActivityMemoryKind"]
    pub srcKind: u8,
    #[doc = " The destination memory kind read by the memory copy, stored as a\n byte to reduce record size. \\see CUpti_ActivityMemoryKind"]
    pub dstKind: u8,
    #[doc = " The flags associated with the memory copy. \\see CUpti_ActivityFlag"]
    pub flags: u8,
    #[doc = " The number of bytes transferred by the memory copy."]
    pub bytes: u64,
    #[doc = " The start timestamp for the memory copy, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory copy."]
    pub start: u64,
    #[doc = " The end timestamp for the memory copy, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory copy."]
    pub end: u64,
    #[doc = " The ID of the device where the memory copy is occurring."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the memory copy is occurring."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the memory copy is occurring."]
    pub streamId: u32,
    #[doc = " The correlation ID of the memory copy. Each memory copy is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver API activity record that launched\n the memory copy."]
    pub correlationId: u32,
    #[doc = " The runtime correlation ID of the memory copy. Each memory copy\n is assigned a unique runtime correlation ID that is identical to\n the correlation ID in the runtime API activity record that\n launched the memory copy."]
    pub runtimeCorrelationId: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemcpy"][::std::mem::size_of::<CUpti_ActivityMemcpy>() - 64usize];
    ["Alignment of CUpti_ActivityMemcpy"][::std::mem::align_of::<CUpti_ActivityMemcpy>() - 8usize];
    ["Offset of field: CUpti_ActivityMemcpy::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMemcpy::copyKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy, copyKind) - 4usize];
    ["Offset of field: CUpti_ActivityMemcpy::srcKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy, srcKind) - 5usize];
    ["Offset of field: CUpti_ActivityMemcpy::dstKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy, dstKind) - 6usize];
    ["Offset of field: CUpti_ActivityMemcpy::flags"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy, flags) - 7usize];
    ["Offset of field: CUpti_ActivityMemcpy::bytes"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy, bytes) - 8usize];
    ["Offset of field: CUpti_ActivityMemcpy::start"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy, start) - 16usize];
    ["Offset of field: CUpti_ActivityMemcpy::end"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy, end) - 24usize];
    ["Offset of field: CUpti_ActivityMemcpy::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy, deviceId) - 32usize];
    ["Offset of field: CUpti_ActivityMemcpy::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy, contextId) - 36usize];
    ["Offset of field: CUpti_ActivityMemcpy::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy, streamId) - 40usize];
    ["Offset of field: CUpti_ActivityMemcpy::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy, correlationId) - 44usize];
    ["Offset of field: CUpti_ActivityMemcpy::runtimeCorrelationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy, runtimeCorrelationId) - 48usize];
    ["Offset of field: CUpti_ActivityMemcpy::pad"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy, pad) - 52usize];
    ["Offset of field: CUpti_ActivityMemcpy::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy, reserved0) - 56usize];
};
impl Default for CUpti_ActivityMemcpy {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for memory copies. (deprecated in CUDA 11.1)\n\n This activity record represents a memory copy\n (CUPTI_ACTIVITY_KIND_MEMCPY)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemcpy3 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMCPY."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The kind of the memory copy, stored as a byte to reduce record\n size. \\see CUpti_ActivityMemcpyKind"]
    pub copyKind: u8,
    #[doc = " The source memory kind read by the memory copy, stored as a byte\n to reduce record size. \\see CUpti_ActivityMemoryKind"]
    pub srcKind: u8,
    #[doc = " The destination memory kind read by the memory copy, stored as a\n byte to reduce record size. \\see CUpti_ActivityMemoryKind"]
    pub dstKind: u8,
    #[doc = " The flags associated with the memory copy. \\see CUpti_ActivityFlag"]
    pub flags: u8,
    #[doc = " The number of bytes transferred by the memory copy."]
    pub bytes: u64,
    #[doc = " The start timestamp for the memory copy, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory copy."]
    pub start: u64,
    #[doc = " The end timestamp for the memory copy, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory copy."]
    pub end: u64,
    #[doc = " The ID of the device where the memory copy is occurring."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the memory copy is occurring."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the memory copy is occurring."]
    pub streamId: u32,
    #[doc = " The correlation ID of the memory copy. Each memory copy is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver API activity record that launched\n the memory copy."]
    pub correlationId: u32,
    #[doc = " The runtime correlation ID of the memory copy. Each memory copy\n is assigned a unique runtime correlation ID that is identical to\n the correlation ID in the runtime API activity record that\n launched the memory copy."]
    pub runtimeCorrelationId: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
    #[doc = " The unique ID of the graph node that executed this memcpy through graph launch.\n This field will be 0 if the memcpy is not done through graph launch."]
    pub graphNodeId: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemcpy3"][::std::mem::size_of::<CUpti_ActivityMemcpy3>() - 72usize];
    ["Alignment of CUpti_ActivityMemcpy3"]
        [::std::mem::align_of::<CUpti_ActivityMemcpy3>() - 8usize];
    ["Offset of field: CUpti_ActivityMemcpy3::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy3, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMemcpy3::copyKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy3, copyKind) - 4usize];
    ["Offset of field: CUpti_ActivityMemcpy3::srcKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy3, srcKind) - 5usize];
    ["Offset of field: CUpti_ActivityMemcpy3::dstKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy3, dstKind) - 6usize];
    ["Offset of field: CUpti_ActivityMemcpy3::flags"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy3, flags) - 7usize];
    ["Offset of field: CUpti_ActivityMemcpy3::bytes"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy3, bytes) - 8usize];
    ["Offset of field: CUpti_ActivityMemcpy3::start"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy3, start) - 16usize];
    ["Offset of field: CUpti_ActivityMemcpy3::end"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy3, end) - 24usize];
    ["Offset of field: CUpti_ActivityMemcpy3::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy3, deviceId) - 32usize];
    ["Offset of field: CUpti_ActivityMemcpy3::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy3, contextId) - 36usize];
    ["Offset of field: CUpti_ActivityMemcpy3::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy3, streamId) - 40usize];
    ["Offset of field: CUpti_ActivityMemcpy3::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy3, correlationId) - 44usize];
    ["Offset of field: CUpti_ActivityMemcpy3::runtimeCorrelationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy3, runtimeCorrelationId) - 48usize];
    ["Offset of field: CUpti_ActivityMemcpy3::pad"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy3, pad) - 52usize];
    ["Offset of field: CUpti_ActivityMemcpy3::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy3, reserved0) - 56usize];
    ["Offset of field: CUpti_ActivityMemcpy3::graphNodeId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy3, graphNodeId) - 64usize];
};
impl Default for CUpti_ActivityMemcpy3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for memory copies. (deprecated in CUDA 11.6)\n\n This activity record represents a memory copy\n (CUPTI_ACTIVITY_KIND_MEMCPY)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemcpy4 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMCPY."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The kind of the memory copy, stored as a byte to reduce record\n size. \\see CUpti_ActivityMemcpyKind"]
    pub copyKind: u8,
    #[doc = " The source memory kind read by the memory copy, stored as a byte\n to reduce record size. \\see CUpti_ActivityMemoryKind"]
    pub srcKind: u8,
    #[doc = " The destination memory kind read by the memory copy, stored as a\n byte to reduce record size. \\see CUpti_ActivityMemoryKind"]
    pub dstKind: u8,
    #[doc = " The flags associated with the memory copy. \\see CUpti_ActivityFlag"]
    pub flags: u8,
    #[doc = " The number of bytes transferred by the memory copy."]
    pub bytes: u64,
    #[doc = " The start timestamp for the memory copy, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory copy."]
    pub start: u64,
    #[doc = " The end timestamp for the memory copy, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory copy."]
    pub end: u64,
    #[doc = " The ID of the device where the memory copy is occurring."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the memory copy is occurring."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the memory copy is occurring."]
    pub streamId: u32,
    #[doc = " The correlation ID of the memory copy. Each memory copy is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver API activity record that launched\n the memory copy."]
    pub correlationId: u32,
    #[doc = " The runtime correlation ID of the memory copy. Each memory copy\n is assigned a unique runtime correlation ID that is identical to\n the correlation ID in the runtime API activity record that\n launched the memory copy."]
    pub runtimeCorrelationId: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
    #[doc = " The unique ID of the graph node that executed this memcpy through graph launch.\n This field will be 0 if the memcpy is not done through graph launch."]
    pub graphNodeId: u64,
    #[doc = " The unique ID of the graph that executed this memcpy through graph launch.\n This field will be 0 if the memcpy is not done through graph launch."]
    pub graphId: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub padding: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemcpy4"][::std::mem::size_of::<CUpti_ActivityMemcpy4>() - 80usize];
    ["Alignment of CUpti_ActivityMemcpy4"]
        [::std::mem::align_of::<CUpti_ActivityMemcpy4>() - 8usize];
    ["Offset of field: CUpti_ActivityMemcpy4::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy4, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMemcpy4::copyKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy4, copyKind) - 4usize];
    ["Offset of field: CUpti_ActivityMemcpy4::srcKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy4, srcKind) - 5usize];
    ["Offset of field: CUpti_ActivityMemcpy4::dstKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy4, dstKind) - 6usize];
    ["Offset of field: CUpti_ActivityMemcpy4::flags"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy4, flags) - 7usize];
    ["Offset of field: CUpti_ActivityMemcpy4::bytes"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy4, bytes) - 8usize];
    ["Offset of field: CUpti_ActivityMemcpy4::start"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy4, start) - 16usize];
    ["Offset of field: CUpti_ActivityMemcpy4::end"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy4, end) - 24usize];
    ["Offset of field: CUpti_ActivityMemcpy4::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy4, deviceId) - 32usize];
    ["Offset of field: CUpti_ActivityMemcpy4::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy4, contextId) - 36usize];
    ["Offset of field: CUpti_ActivityMemcpy4::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy4, streamId) - 40usize];
    ["Offset of field: CUpti_ActivityMemcpy4::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy4, correlationId) - 44usize];
    ["Offset of field: CUpti_ActivityMemcpy4::runtimeCorrelationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy4, runtimeCorrelationId) - 48usize];
    ["Offset of field: CUpti_ActivityMemcpy4::pad"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy4, pad) - 52usize];
    ["Offset of field: CUpti_ActivityMemcpy4::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy4, reserved0) - 56usize];
    ["Offset of field: CUpti_ActivityMemcpy4::graphNodeId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy4, graphNodeId) - 64usize];
    ["Offset of field: CUpti_ActivityMemcpy4::graphId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy4, graphId) - 72usize];
    ["Offset of field: CUpti_ActivityMemcpy4::padding"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy4, padding) - 76usize];
};
impl Default for CUpti_ActivityMemcpy4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for peer-to-peer memory copies.\n\n This activity record represents a peer-to-peer memory copy\n (CUPTI_ACTIVITY_KIND_MEMCPY2) but is no longer generated\n by CUPTI. Peer-to-peer memory copy activities are now reported using the\n CUpti_ActivityMemcpyPtoP2 activity record.."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemcpyPtoP {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMCPY2."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The kind of the memory copy, stored as a byte to reduce record\n size.  \\see CUpti_ActivityMemcpyKind"]
    pub copyKind: u8,
    #[doc = " The source memory kind read by the memory copy, stored as a byte\n to reduce record size.  \\see CUpti_ActivityMemoryKind"]
    pub srcKind: u8,
    #[doc = " The destination memory kind read by the memory copy, stored as a\n byte to reduce record size.  \\see CUpti_ActivityMemoryKind"]
    pub dstKind: u8,
    #[doc = " The flags associated with the memory copy. \\see\n CUpti_ActivityFlag"]
    pub flags: u8,
    #[doc = " The number of bytes transferred by the memory copy."]
    pub bytes: u64,
    #[doc = " The start timestamp for the memory copy, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory copy."]
    pub start: u64,
    #[doc = " The end timestamp for the memory copy, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory copy."]
    pub end: u64,
    #[doc = " The ID of the device where the memory copy is occurring."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the memory copy is occurring."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the memory copy is occurring."]
    pub streamId: u32,
    #[doc = " The ID of the device where memory is being copied from."]
    pub srcDeviceId: u32,
    #[doc = " The ID of the context owning the memory being copied from."]
    pub srcContextId: u32,
    #[doc = " The ID of the device where memory is being copied to."]
    pub dstDeviceId: u32,
    #[doc = " The ID of the context owning the memory being copied to."]
    pub dstContextId: u32,
    #[doc = " The correlation ID of the memory copy. Each memory copy is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver and runtime API activity record that\n launched the memory copy."]
    pub correlationId: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemcpyPtoP"]
        [::std::mem::size_of::<CUpti_ActivityMemcpyPtoP>() - 72usize];
    ["Alignment of CUpti_ActivityMemcpyPtoP"]
        [::std::mem::align_of::<CUpti_ActivityMemcpyPtoP>() - 8usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP::copyKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, copyKind) - 4usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP::srcKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, srcKind) - 5usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP::dstKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, dstKind) - 6usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP::flags"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, flags) - 7usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP::bytes"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, bytes) - 8usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP::start"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, start) - 16usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP::end"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, end) - 24usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, deviceId) - 32usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, contextId) - 36usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, streamId) - 40usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP::srcDeviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, srcDeviceId) - 44usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP::srcContextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, srcContextId) - 48usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP::dstDeviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, dstDeviceId) - 52usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP::dstContextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, dstContextId) - 56usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, correlationId) - 60usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP, reserved0) - 64usize];
};
impl Default for CUpti_ActivityMemcpyPtoP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for peer-to-peer memory copies.\n\n This activity record represents a peer-to-peer memory copy\n (CUPTI_ACTIVITY_KIND_MEMCPY2) but is no longer generated\n by CUPTI. Peer-to-peer memory copy activities are now reported using the\n CUpti_ActivityMemcpyPtoP2 activity record.."]
pub type CUpti_ActivityMemcpy2 = CUpti_ActivityMemcpyPtoP;
#[doc = " \\brief The activity record for peer-to-peer memory copies.\n (deprecated in CUDA 11.1)\n\n This activity record represents a peer-to-peer memory copy\n (CUPTI_ACTIVITY_KIND_MEMCPY2)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemcpyPtoP2 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMCPY2."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The kind of the memory copy, stored as a byte to reduce record\n size.  \\see CUpti_ActivityMemcpyKind"]
    pub copyKind: u8,
    #[doc = " The source memory kind read by the memory copy, stored as a byte\n to reduce record size.  \\see CUpti_ActivityMemoryKind"]
    pub srcKind: u8,
    #[doc = " The destination memory kind read by the memory copy, stored as a\n byte to reduce record size.  \\see CUpti_ActivityMemoryKind"]
    pub dstKind: u8,
    #[doc = " The flags associated with the memory copy. \\see\n CUpti_ActivityFlag"]
    pub flags: u8,
    #[doc = " The number of bytes transferred by the memory copy."]
    pub bytes: u64,
    #[doc = " The start timestamp for the memory copy, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory copy."]
    pub start: u64,
    #[doc = " The end timestamp for the memory copy, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory copy."]
    pub end: u64,
    #[doc = " The ID of the device where the memory copy is occurring."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the memory copy is occurring."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the memory copy is occurring."]
    pub streamId: u32,
    #[doc = " The ID of the device where memory is being copied from."]
    pub srcDeviceId: u32,
    #[doc = " The ID of the context owning the memory being copied from."]
    pub srcContextId: u32,
    #[doc = " The ID of the device where memory is being copied to."]
    pub dstDeviceId: u32,
    #[doc = " The ID of the context owning the memory being copied to."]
    pub dstContextId: u32,
    #[doc = " The correlation ID of the memory copy. Each memory copy is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver and runtime API activity record that\n launched the memory copy."]
    pub correlationId: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
    #[doc = " The unique ID of the graph node that executed the memcpy through graph launch.\n This field will be 0 if memcpy is not done using graph launch."]
    pub graphNodeId: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemcpyPtoP2"]
        [::std::mem::size_of::<CUpti_ActivityMemcpyPtoP2>() - 80usize];
    ["Alignment of CUpti_ActivityMemcpyPtoP2"]
        [::std::mem::align_of::<CUpti_ActivityMemcpyPtoP2>() - 8usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP2::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP2::copyKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, copyKind) - 4usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP2::srcKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, srcKind) - 5usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP2::dstKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, dstKind) - 6usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP2::flags"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, flags) - 7usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP2::bytes"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, bytes) - 8usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP2::start"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, start) - 16usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP2::end"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, end) - 24usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP2::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, deviceId) - 32usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP2::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, contextId) - 36usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP2::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, streamId) - 40usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP2::srcDeviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, srcDeviceId) - 44usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP2::srcContextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, srcContextId) - 48usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP2::dstDeviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, dstDeviceId) - 52usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP2::dstContextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, dstContextId) - 56usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP2::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, correlationId) - 60usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP2::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, reserved0) - 64usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP2::graphNodeId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP2, graphNodeId) - 72usize];
};
impl Default for CUpti_ActivityMemcpyPtoP2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for peer-to-peer memory copies.\n (deprecated in CUDA 11.6)\n\n This activity record represents a peer-to-peer memory copy\n (CUPTI_ACTIVITY_KIND_MEMCPY2)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemcpyPtoP3 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMCPY2."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The kind of the memory copy, stored as a byte to reduce record\n size.  \\see CUpti_ActivityMemcpyKind"]
    pub copyKind: u8,
    #[doc = " The source memory kind read by the memory copy, stored as a byte\n to reduce record size.  \\see CUpti_ActivityMemoryKind"]
    pub srcKind: u8,
    #[doc = " The destination memory kind read by the memory copy, stored as a\n byte to reduce record size.  \\see CUpti_ActivityMemoryKind"]
    pub dstKind: u8,
    #[doc = " The flags associated with the memory copy. \\see\n CUpti_ActivityFlag"]
    pub flags: u8,
    #[doc = " The number of bytes transferred by the memory copy."]
    pub bytes: u64,
    #[doc = " The start timestamp for the memory copy, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory copy."]
    pub start: u64,
    #[doc = " The end timestamp for the memory copy, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory copy."]
    pub end: u64,
    #[doc = " The ID of the device where the memory copy is occurring."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the memory copy is occurring."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the memory copy is occurring."]
    pub streamId: u32,
    #[doc = " The ID of the device where memory is being copied from."]
    pub srcDeviceId: u32,
    #[doc = " The ID of the context owning the memory being copied from."]
    pub srcContextId: u32,
    #[doc = " The ID of the device where memory is being copied to."]
    pub dstDeviceId: u32,
    #[doc = " The ID of the context owning the memory being copied to."]
    pub dstContextId: u32,
    #[doc = " The correlation ID of the memory copy. Each memory copy is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver and runtime API activity record that\n launched the memory copy."]
    pub correlationId: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
    #[doc = " The unique ID of the graph node that executed the memcpy through graph launch.\n This field will be 0 if memcpy is not done using graph launch."]
    pub graphNodeId: u64,
    #[doc = " The unique ID of the graph that executed this memcpy through graph launch.\n This field will be 0 if the memcpy is not done through graph launch."]
    pub graphId: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub padding: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemcpyPtoP3"]
        [::std::mem::size_of::<CUpti_ActivityMemcpyPtoP3>() - 88usize];
    ["Alignment of CUpti_ActivityMemcpyPtoP3"]
        [::std::mem::align_of::<CUpti_ActivityMemcpyPtoP3>() - 8usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP3::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP3::copyKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, copyKind) - 4usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP3::srcKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, srcKind) - 5usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP3::dstKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, dstKind) - 6usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP3::flags"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, flags) - 7usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP3::bytes"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, bytes) - 8usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP3::start"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, start) - 16usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP3::end"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, end) - 24usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP3::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, deviceId) - 32usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP3::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, contextId) - 36usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP3::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, streamId) - 40usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP3::srcDeviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, srcDeviceId) - 44usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP3::srcContextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, srcContextId) - 48usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP3::dstDeviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, dstDeviceId) - 52usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP3::dstContextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, dstContextId) - 56usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP3::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, correlationId) - 60usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP3::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, reserved0) - 64usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP3::graphNodeId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, graphNodeId) - 72usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP3::graphId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, graphId) - 80usize];
    ["Offset of field: CUpti_ActivityMemcpyPtoP3::padding"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpyPtoP3, padding) - 84usize];
};
impl Default for CUpti_ActivityMemcpyPtoP3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for memset. (deprecated)\n\n This activity record represents a memory set operation\n (CUPTI_ACTIVITY_KIND_MEMSET)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemset {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMSET."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The value being assigned to memory by the memory set."]
    pub value: u32,
    #[doc = " The number of bytes being set by the memory set."]
    pub bytes: u64,
    #[doc = " The start timestamp for the memory set, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory set."]
    pub start: u64,
    #[doc = " The end timestamp for the memory set, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory set."]
    pub end: u64,
    #[doc = " The ID of the device where the memory set is occurring."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the memory set is occurring."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the memory set is occurring."]
    pub streamId: u32,
    #[doc = " The correlation ID of the memory set. Each memory set is assigned\n a unique correlation ID that is identical to the correlation ID\n in the driver API activity record that launched the memory set."]
    pub correlationId: u32,
    #[doc = " The flags associated with the memset. \\see CUpti_ActivityFlag"]
    pub flags: u16,
    #[doc = " The memory kind of the memory set \\see CUpti_ActivityMemoryKind"]
    pub memoryKind: u16,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemset"][::std::mem::size_of::<CUpti_ActivityMemset>() - 64usize];
    ["Alignment of CUpti_ActivityMemset"][::std::mem::align_of::<CUpti_ActivityMemset>() - 8usize];
    ["Offset of field: CUpti_ActivityMemset::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMemset, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMemset::value"]
        [::std::mem::offset_of!(CUpti_ActivityMemset, value) - 4usize];
    ["Offset of field: CUpti_ActivityMemset::bytes"]
        [::std::mem::offset_of!(CUpti_ActivityMemset, bytes) - 8usize];
    ["Offset of field: CUpti_ActivityMemset::start"]
        [::std::mem::offset_of!(CUpti_ActivityMemset, start) - 16usize];
    ["Offset of field: CUpti_ActivityMemset::end"]
        [::std::mem::offset_of!(CUpti_ActivityMemset, end) - 24usize];
    ["Offset of field: CUpti_ActivityMemset::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemset, deviceId) - 32usize];
    ["Offset of field: CUpti_ActivityMemset::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemset, contextId) - 36usize];
    ["Offset of field: CUpti_ActivityMemset::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityMemset, streamId) - 40usize];
    ["Offset of field: CUpti_ActivityMemset::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemset, correlationId) - 44usize];
    ["Offset of field: CUpti_ActivityMemset::flags"]
        [::std::mem::offset_of!(CUpti_ActivityMemset, flags) - 48usize];
    ["Offset of field: CUpti_ActivityMemset::memoryKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemset, memoryKind) - 50usize];
    ["Offset of field: CUpti_ActivityMemset::pad"]
        [::std::mem::offset_of!(CUpti_ActivityMemset, pad) - 52usize];
    ["Offset of field: CUpti_ActivityMemset::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityMemset, reserved0) - 56usize];
};
impl Default for CUpti_ActivityMemset {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for memset. (deprecated in CUDA 11.1)\n\n This activity record represents a memory set operation\n (CUPTI_ACTIVITY_KIND_MEMSET)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemset2 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMSET."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The value being assigned to memory by the memory set."]
    pub value: u32,
    #[doc = " The number of bytes being set by the memory set."]
    pub bytes: u64,
    #[doc = " The start timestamp for the memory set, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory set."]
    pub start: u64,
    #[doc = " The end timestamp for the memory set, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory set."]
    pub end: u64,
    #[doc = " The ID of the device where the memory set is occurring."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the memory set is occurring."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the memory set is occurring."]
    pub streamId: u32,
    #[doc = " The correlation ID of the memory set. Each memory set is assigned\n a unique correlation ID that is identical to the correlation ID\n in the driver API activity record that launched the memory set."]
    pub correlationId: u32,
    #[doc = " The flags associated with the memset. \\see CUpti_ActivityFlag"]
    pub flags: u16,
    #[doc = " The memory kind of the memory set \\see CUpti_ActivityMemoryKind"]
    pub memoryKind: u16,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
    #[doc = " The unique ID of the graph node that executed this memset through graph launch.\n This field will be 0 if the memset is not executed through graph launch."]
    pub graphNodeId: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemset2"][::std::mem::size_of::<CUpti_ActivityMemset2>() - 72usize];
    ["Alignment of CUpti_ActivityMemset2"]
        [::std::mem::align_of::<CUpti_ActivityMemset2>() - 8usize];
    ["Offset of field: CUpti_ActivityMemset2::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMemset2, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMemset2::value"]
        [::std::mem::offset_of!(CUpti_ActivityMemset2, value) - 4usize];
    ["Offset of field: CUpti_ActivityMemset2::bytes"]
        [::std::mem::offset_of!(CUpti_ActivityMemset2, bytes) - 8usize];
    ["Offset of field: CUpti_ActivityMemset2::start"]
        [::std::mem::offset_of!(CUpti_ActivityMemset2, start) - 16usize];
    ["Offset of field: CUpti_ActivityMemset2::end"]
        [::std::mem::offset_of!(CUpti_ActivityMemset2, end) - 24usize];
    ["Offset of field: CUpti_ActivityMemset2::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemset2, deviceId) - 32usize];
    ["Offset of field: CUpti_ActivityMemset2::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemset2, contextId) - 36usize];
    ["Offset of field: CUpti_ActivityMemset2::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityMemset2, streamId) - 40usize];
    ["Offset of field: CUpti_ActivityMemset2::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemset2, correlationId) - 44usize];
    ["Offset of field: CUpti_ActivityMemset2::flags"]
        [::std::mem::offset_of!(CUpti_ActivityMemset2, flags) - 48usize];
    ["Offset of field: CUpti_ActivityMemset2::memoryKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemset2, memoryKind) - 50usize];
    ["Offset of field: CUpti_ActivityMemset2::pad"]
        [::std::mem::offset_of!(CUpti_ActivityMemset2, pad) - 52usize];
    ["Offset of field: CUpti_ActivityMemset2::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityMemset2, reserved0) - 56usize];
    ["Offset of field: CUpti_ActivityMemset2::graphNodeId"]
        [::std::mem::offset_of!(CUpti_ActivityMemset2, graphNodeId) - 64usize];
};
impl Default for CUpti_ActivityMemset2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for memset. (deprecated in CUDA 11.6)\n\n This activity record represents a memory set operation\n (CUPTI_ACTIVITY_KIND_MEMSET)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemset3 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMSET."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The value being assigned to memory by the memory set."]
    pub value: u32,
    #[doc = " The number of bytes being set by the memory set."]
    pub bytes: u64,
    #[doc = " The start timestamp for the memory set, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory set."]
    pub start: u64,
    #[doc = " The end timestamp for the memory set, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory set."]
    pub end: u64,
    #[doc = " The ID of the device where the memory set is occurring."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the memory set is occurring."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the memory set is occurring."]
    pub streamId: u32,
    #[doc = " The correlation ID of the memory set. Each memory set is assigned\n a unique correlation ID that is identical to the correlation ID\n in the driver API activity record that launched the memory set."]
    pub correlationId: u32,
    #[doc = " The flags associated with the memset. \\see CUpti_ActivityFlag"]
    pub flags: u16,
    #[doc = " The memory kind of the memory set \\see CUpti_ActivityMemoryKind"]
    pub memoryKind: u16,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
    #[doc = " The unique ID of the graph node that executed this memset through graph launch.\n This field will be 0 if the memset is not executed through graph launch."]
    pub graphNodeId: u64,
    #[doc = " The unique ID of the graph that executed this memset through graph launch.\n This field will be 0 if the memset is not executed through graph launch."]
    pub graphId: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub padding: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemset3"][::std::mem::size_of::<CUpti_ActivityMemset3>() - 80usize];
    ["Alignment of CUpti_ActivityMemset3"]
        [::std::mem::align_of::<CUpti_ActivityMemset3>() - 8usize];
    ["Offset of field: CUpti_ActivityMemset3::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMemset3, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMemset3::value"]
        [::std::mem::offset_of!(CUpti_ActivityMemset3, value) - 4usize];
    ["Offset of field: CUpti_ActivityMemset3::bytes"]
        [::std::mem::offset_of!(CUpti_ActivityMemset3, bytes) - 8usize];
    ["Offset of field: CUpti_ActivityMemset3::start"]
        [::std::mem::offset_of!(CUpti_ActivityMemset3, start) - 16usize];
    ["Offset of field: CUpti_ActivityMemset3::end"]
        [::std::mem::offset_of!(CUpti_ActivityMemset3, end) - 24usize];
    ["Offset of field: CUpti_ActivityMemset3::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemset3, deviceId) - 32usize];
    ["Offset of field: CUpti_ActivityMemset3::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemset3, contextId) - 36usize];
    ["Offset of field: CUpti_ActivityMemset3::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityMemset3, streamId) - 40usize];
    ["Offset of field: CUpti_ActivityMemset3::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemset3, correlationId) - 44usize];
    ["Offset of field: CUpti_ActivityMemset3::flags"]
        [::std::mem::offset_of!(CUpti_ActivityMemset3, flags) - 48usize];
    ["Offset of field: CUpti_ActivityMemset3::memoryKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemset3, memoryKind) - 50usize];
    ["Offset of field: CUpti_ActivityMemset3::pad"]
        [::std::mem::offset_of!(CUpti_ActivityMemset3, pad) - 52usize];
    ["Offset of field: CUpti_ActivityMemset3::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityMemset3, reserved0) - 56usize];
    ["Offset of field: CUpti_ActivityMemset3::graphNodeId"]
        [::std::mem::offset_of!(CUpti_ActivityMemset3, graphNodeId) - 64usize];
    ["Offset of field: CUpti_ActivityMemset3::graphId"]
        [::std::mem::offset_of!(CUpti_ActivityMemset3, graphId) - 72usize];
    ["Offset of field: CUpti_ActivityMemset3::padding"]
        [::std::mem::offset_of!(CUpti_ActivityMemset3, padding) - 76usize];
};
impl Default for CUpti_ActivityMemset3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for memory.\n\n This activity record represents a memory allocation and free operation\n (CUPTI_ACTIVITY_KIND_MEMORY2).\n This activity record provides separate records for memory allocation and\n memory release operations.\n This allows to correlate the corresponding driver and runtime API\n activity record with the memory operation.\n\n Note: This activity record is an upgrade over \\ref CUpti_ActivityMemory\n enabled using the kind \\ref CUPTI_ACTIVITY_KIND_MEMORY.\n \\ref CUpti_ActivityMemory provides a single record for the memory\n allocation and memory release operations."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMemory2 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMORY2"]
    pub kind: CUpti_ActivityKind,
    #[doc = " The memory operation requested by the user, \\ref CUpti_ActivityMemoryOperationType."]
    pub memoryOperationType: CUpti_ActivityMemoryOperationType,
    #[doc = " The memory kind requested by the user, \\ref CUpti_ActivityMemoryKind."]
    pub memoryKind: CUpti_ActivityMemoryKind,
    #[doc = " The correlation ID of the memory operation. Each memory operation is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver and runtime API activity record that\n launched the memory operation."]
    pub correlationId: u32,
    #[doc = " The virtual address of the allocation."]
    pub address: u64,
    #[doc = " The number of bytes of memory allocated."]
    pub bytes: u64,
    #[doc = " The start timestamp for the memory operation, in ns."]
    pub timestamp: u64,
    #[doc = " The program counter of the memory operation."]
    pub PC: u64,
    #[doc = " The ID of the process to which this record belongs to."]
    pub processId: u32,
    #[doc = " The ID of the device where the memory operation is taking place."]
    pub deviceId: u32,
    #[doc = " The ID of the context. If context is NULL, \\p contextId is set to CUPTI_INVALID_CONTEXT_ID."]
    pub contextId: u32,
    #[doc = " The ID of the stream. If memory operation is not async, \\p streamId is set to CUPTI_INVALID_STREAM_ID."]
    pub streamId: u32,
    #[doc = " Variable name. This name is shared across all activity\n records representing the same symbol, and so should not be\n modified."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " \\p isAsync is set if memory operation happens through async memory APIs."]
    pub isAsync: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad1: u32,
    pub memoryPoolConfig: CUpti_ActivityMemory2__bindgen_ty_1,
}
#[doc = " The memory pool configuration used for the memory operations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMemory2__bindgen_ty_1 {
    #[doc = " The type of the memory pool, \\ref CUpti_ActivityMemoryPoolType"]
    pub memoryPoolType: CUpti_ActivityMemoryPoolType,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad2: u32,
    #[doc = " The base address of the memory pool."]
    pub address: u64,
    #[doc = " The release threshold of the memory pool in bytes. \\p releaseThreshold is\n valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \\ref CUpti_ActivityMemoryPoolType."]
    pub releaseThreshold: u64,
    pub pool: CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1,
}
#[doc = " The size of the memory pool in bytes and the processID of the memory pool.\n \\p size is valid if \\p memoryPoolType is\n CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \\ref CUpti_ActivityMemoryPoolType.\n \\p processId is valid if \\p memoryPoolType is\n CUPTI_ACTIVITY_MEMORY_POOL_TYPE_IMPORTED, \\ref CUpti_ActivityMemoryPoolType."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1 {
    pub size: u64,
    pub processId: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1::size"]
        [::std::mem::offset_of!(CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1, size) - 0usize];
    ["Offset of field: CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1::processId"][::std::mem::offset_of!(
        CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1,
        processId
    ) - 0usize];
};
impl Default for CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMemory2__bindgen_ty_1__bindgen_ty_1 {{ union }}"
        )
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemory2__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityMemory2__bindgen_ty_1>() - 32usize];
    ["Alignment of CUpti_ActivityMemory2__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityMemory2__bindgen_ty_1>() - 8usize];
    ["Offset of field: CUpti_ActivityMemory2__bindgen_ty_1::memoryPoolType"]
        [::std::mem::offset_of!(CUpti_ActivityMemory2__bindgen_ty_1, memoryPoolType) - 0usize];
    ["Offset of field: CUpti_ActivityMemory2__bindgen_ty_1::pad2"]
        [::std::mem::offset_of!(CUpti_ActivityMemory2__bindgen_ty_1, pad2) - 4usize];
    ["Offset of field: CUpti_ActivityMemory2__bindgen_ty_1::address"]
        [::std::mem::offset_of!(CUpti_ActivityMemory2__bindgen_ty_1, address) - 8usize];
    ["Offset of field: CUpti_ActivityMemory2__bindgen_ty_1::releaseThreshold"]
        [::std::mem::offset_of!(CUpti_ActivityMemory2__bindgen_ty_1, releaseThreshold) - 16usize];
    ["Offset of field: CUpti_ActivityMemory2__bindgen_ty_1::pool"]
        [::std::mem::offset_of!(CUpti_ActivityMemory2__bindgen_ty_1, pool) - 24usize];
};
impl Default for CUpti_ActivityMemory2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMemory2__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMemory2__bindgen_ty_1 {{ memoryPoolType: {:?}, pool: {:?} }}",
            self.memoryPoolType, self.pool
        )
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemory2"][::std::mem::size_of::<CUpti_ActivityMemory2>() - 112usize];
    ["Alignment of CUpti_ActivityMemory2"]
        [::std::mem::align_of::<CUpti_ActivityMemory2>() - 8usize];
    ["Offset of field: CUpti_ActivityMemory2::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMemory2, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMemory2::memoryOperationType"]
        [::std::mem::offset_of!(CUpti_ActivityMemory2, memoryOperationType) - 4usize];
    ["Offset of field: CUpti_ActivityMemory2::memoryKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemory2, memoryKind) - 8usize];
    ["Offset of field: CUpti_ActivityMemory2::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemory2, correlationId) - 12usize];
    ["Offset of field: CUpti_ActivityMemory2::address"]
        [::std::mem::offset_of!(CUpti_ActivityMemory2, address) - 16usize];
    ["Offset of field: CUpti_ActivityMemory2::bytes"]
        [::std::mem::offset_of!(CUpti_ActivityMemory2, bytes) - 24usize];
    ["Offset of field: CUpti_ActivityMemory2::timestamp"]
        [::std::mem::offset_of!(CUpti_ActivityMemory2, timestamp) - 32usize];
    ["Offset of field: CUpti_ActivityMemory2::PC"]
        [::std::mem::offset_of!(CUpti_ActivityMemory2, PC) - 40usize];
    ["Offset of field: CUpti_ActivityMemory2::processId"]
        [::std::mem::offset_of!(CUpti_ActivityMemory2, processId) - 48usize];
    ["Offset of field: CUpti_ActivityMemory2::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemory2, deviceId) - 52usize];
    ["Offset of field: CUpti_ActivityMemory2::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemory2, contextId) - 56usize];
    ["Offset of field: CUpti_ActivityMemory2::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityMemory2, streamId) - 60usize];
    ["Offset of field: CUpti_ActivityMemory2::name"]
        [::std::mem::offset_of!(CUpti_ActivityMemory2, name) - 64usize];
    ["Offset of field: CUpti_ActivityMemory2::isAsync"]
        [::std::mem::offset_of!(CUpti_ActivityMemory2, isAsync) - 72usize];
    ["Offset of field: CUpti_ActivityMemory2::pad1"]
        [::std::mem::offset_of!(CUpti_ActivityMemory2, pad1) - 76usize];
    ["Offset of field: CUpti_ActivityMemory2::memoryPoolConfig"]
        [::std::mem::offset_of!(CUpti_ActivityMemory2, memoryPoolConfig) - 80usize];
};
impl Default for CUpti_ActivityMemory2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMemory2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMemory2 {{ kind: {:?}, memoryOperationType: {:?}, memoryKind: {:?}, name: {:?}, memoryPoolConfig: {:?} }}",
            self.kind, self.memoryOperationType, self.memoryKind, self.name, self.memoryPoolConfig
        )
    }
}
#[doc = " \\brief The activity record for memory.\n\n This activity record represents a memory allocation and free operation\n (CUPTI_ACTIVITY_KIND_MEMORY2).\n This activity record provides separate records for memory allocation and\n memory release operations.\n This allows to correlate the corresponding driver and runtime API\n activity record with the memory operation.\n\n Note: This activity record is an upgrade over \\ref CUpti_ActivityMemory2\n enabled using the kind \\ref CUPTI_ACTIVITY_KIND_MEMORY.\n \\ref CUpti_ActivityMemory provides a single record for the memory\n allocation and memory release operations."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMemory3 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMORY2"]
    pub kind: CUpti_ActivityKind,
    #[doc = " The memory operation requested by the user, \\ref CUpti_ActivityMemoryOperationType."]
    pub memoryOperationType: CUpti_ActivityMemoryOperationType,
    #[doc = " The memory kind requested by the user, \\ref CUpti_ActivityMemoryKind."]
    pub memoryKind: CUpti_ActivityMemoryKind,
    #[doc = " The correlation ID of the memory operation. Each memory operation is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver and runtime API activity record that\n launched the memory operation."]
    pub correlationId: u32,
    #[doc = " The virtual address of the allocation."]
    pub address: u64,
    #[doc = " The number of bytes of memory allocated."]
    pub bytes: u64,
    #[doc = " The start timestamp for the memory operation, in ns."]
    pub timestamp: u64,
    #[doc = " The program counter of the memory operation."]
    pub PC: u64,
    #[doc = " The ID of the process to which this record belongs to."]
    pub processId: u32,
    #[doc = " The ID of the device where the memory operation is taking place."]
    pub deviceId: u32,
    #[doc = " The ID of the context. If context is NULL, \\p contextId is set to CUPTI_INVALID_CONTEXT_ID."]
    pub contextId: u32,
    #[doc = " The ID of the stream. If memory operation is not async, \\p streamId is set to CUPTI_INVALID_STREAM_ID."]
    pub streamId: u32,
    #[doc = " Variable name. This name is shared across all activity\n records representing the same symbol, and so should not be\n modified."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " \\p isAsync is set if memory operation happens through async memory APIs."]
    pub isAsync: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad1: u32,
    pub memoryPoolConfig: CUpti_ActivityMemory3__bindgen_ty_1,
}
#[doc = " The memory pool configuration used for the memory operations."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMemory3__bindgen_ty_1 {
    #[doc = " The type of the memory pool, \\ref CUpti_ActivityMemoryPoolType"]
    pub memoryPoolType: CUpti_ActivityMemoryPoolType,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad2: u32,
    #[doc = " The base address of the memory pool."]
    pub address: u64,
    #[doc = " The release threshold of the memory pool in bytes. \\p releaseThreshold is\n valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \\ref CUpti_ActivityMemoryPoolType."]
    pub releaseThreshold: u64,
    pub pool: CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1,
    #[doc = " The utilized size of the memory pool. \\p utilizedSize is\n valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \\ref CUpti_ActivityMemoryPoolType."]
    pub utilizedSize: u64,
}
#[doc = " The size of memory pool in bytes and the processId of the memory pools\n \\p size is valid if \\p memoryPoolType is\n CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \\ref CUpti_ActivityMemoryPoolType.\n \\p processId is valid if \\p memoryPoolType is\n CUPTI_ACTIVITY_MEMORY_POOL_TYPE_IMPORTED, \\ref CUpti_ActivityMemoryPoolType"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1 {
    pub size: u64,
    pub processId: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1::size"]
        [::std::mem::offset_of!(CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1, size) - 0usize];
    ["Offset of field: CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1::processId"][::std::mem::offset_of!(
        CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1,
        processId
    ) - 0usize];
};
impl Default for CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMemory3__bindgen_ty_1__bindgen_ty_1 {{ union }}"
        )
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemory3__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityMemory3__bindgen_ty_1>() - 40usize];
    ["Alignment of CUpti_ActivityMemory3__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityMemory3__bindgen_ty_1>() - 8usize];
    ["Offset of field: CUpti_ActivityMemory3__bindgen_ty_1::memoryPoolType"]
        [::std::mem::offset_of!(CUpti_ActivityMemory3__bindgen_ty_1, memoryPoolType) - 0usize];
    ["Offset of field: CUpti_ActivityMemory3__bindgen_ty_1::pad2"]
        [::std::mem::offset_of!(CUpti_ActivityMemory3__bindgen_ty_1, pad2) - 4usize];
    ["Offset of field: CUpti_ActivityMemory3__bindgen_ty_1::address"]
        [::std::mem::offset_of!(CUpti_ActivityMemory3__bindgen_ty_1, address) - 8usize];
    ["Offset of field: CUpti_ActivityMemory3__bindgen_ty_1::releaseThreshold"]
        [::std::mem::offset_of!(CUpti_ActivityMemory3__bindgen_ty_1, releaseThreshold) - 16usize];
    ["Offset of field: CUpti_ActivityMemory3__bindgen_ty_1::pool"]
        [::std::mem::offset_of!(CUpti_ActivityMemory3__bindgen_ty_1, pool) - 24usize];
    ["Offset of field: CUpti_ActivityMemory3__bindgen_ty_1::utilizedSize"]
        [::std::mem::offset_of!(CUpti_ActivityMemory3__bindgen_ty_1, utilizedSize) - 32usize];
};
impl Default for CUpti_ActivityMemory3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMemory3__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMemory3__bindgen_ty_1 {{ memoryPoolType: {:?}, pool: {:?} }}",
            self.memoryPoolType, self.pool
        )
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemory3"][::std::mem::size_of::<CUpti_ActivityMemory3>() - 120usize];
    ["Alignment of CUpti_ActivityMemory3"]
        [::std::mem::align_of::<CUpti_ActivityMemory3>() - 8usize];
    ["Offset of field: CUpti_ActivityMemory3::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMemory3, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMemory3::memoryOperationType"]
        [::std::mem::offset_of!(CUpti_ActivityMemory3, memoryOperationType) - 4usize];
    ["Offset of field: CUpti_ActivityMemory3::memoryKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemory3, memoryKind) - 8usize];
    ["Offset of field: CUpti_ActivityMemory3::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemory3, correlationId) - 12usize];
    ["Offset of field: CUpti_ActivityMemory3::address"]
        [::std::mem::offset_of!(CUpti_ActivityMemory3, address) - 16usize];
    ["Offset of field: CUpti_ActivityMemory3::bytes"]
        [::std::mem::offset_of!(CUpti_ActivityMemory3, bytes) - 24usize];
    ["Offset of field: CUpti_ActivityMemory3::timestamp"]
        [::std::mem::offset_of!(CUpti_ActivityMemory3, timestamp) - 32usize];
    ["Offset of field: CUpti_ActivityMemory3::PC"]
        [::std::mem::offset_of!(CUpti_ActivityMemory3, PC) - 40usize];
    ["Offset of field: CUpti_ActivityMemory3::processId"]
        [::std::mem::offset_of!(CUpti_ActivityMemory3, processId) - 48usize];
    ["Offset of field: CUpti_ActivityMemory3::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemory3, deviceId) - 52usize];
    ["Offset of field: CUpti_ActivityMemory3::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemory3, contextId) - 56usize];
    ["Offset of field: CUpti_ActivityMemory3::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityMemory3, streamId) - 60usize];
    ["Offset of field: CUpti_ActivityMemory3::name"]
        [::std::mem::offset_of!(CUpti_ActivityMemory3, name) - 64usize];
    ["Offset of field: CUpti_ActivityMemory3::isAsync"]
        [::std::mem::offset_of!(CUpti_ActivityMemory3, isAsync) - 72usize];
    ["Offset of field: CUpti_ActivityMemory3::pad1"]
        [::std::mem::offset_of!(CUpti_ActivityMemory3, pad1) - 76usize];
    ["Offset of field: CUpti_ActivityMemory3::memoryPoolConfig"]
        [::std::mem::offset_of!(CUpti_ActivityMemory3, memoryPoolConfig) - 80usize];
};
impl Default for CUpti_ActivityMemory3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMemory3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMemory3 {{ kind: {:?}, memoryOperationType: {:?}, memoryKind: {:?}, name: {:?}, memoryPoolConfig: {:?} }}",
            self.kind, self.memoryOperationType, self.memoryKind, self.name, self.memoryPoolConfig
        )
    }
}
#[doc = " \\brief The activity record for memory pool.\n\n This activity record represents a memory pool creation, destruction and\n trimming (CUPTI_ACTIVITY_KIND_MEMORY_POOL).\n This activity record provides separate records for memory pool creation,\n destruction and trimming operations.\n This allows to correlate the corresponding driver and runtime API\n activity record with the memory pool operation.\n"]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemoryPool {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMORY_POOL"]
    pub kind: CUpti_ActivityKind,
    #[doc = " The memory operation requested by the user, \\ref CUpti_ActivityMemoryPoolOperationType."]
    pub memoryPoolOperationType: CUpti_ActivityMemoryPoolOperationType,
    #[doc = " The type of the memory pool, \\ref CUpti_ActivityMemoryPoolType"]
    pub memoryPoolType: CUpti_ActivityMemoryPoolType,
    #[doc = " The correlation ID of the memory pool operation. Each memory pool\n operation is assigned a unique correlation ID that is identical to the\n correlation ID in the driver and runtime API activity record that\n launched the memory operation."]
    pub correlationId: u32,
    #[doc = " The ID of the process to which this record belongs to."]
    pub processId: u32,
    #[doc = " The ID of the device where the memory pool is created."]
    pub deviceId: u32,
    #[doc = " The minimum bytes to keep of the memory pool. \\p minBytesToKeep is\n valid for CUPTI_ACTIVITY_MEMORY_POOL_OPERATION_TYPE_TRIMMED,\n \\ref CUpti_ActivityMemoryPoolOperationType"]
    pub minBytesToKeep: usize,
    #[doc = " The virtual address of the allocation."]
    pub address: u64,
    #[doc = " The size of the memory pool operation in bytes. \\p size is\n valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \\ref CUpti_ActivityMemoryPoolType."]
    pub size: u64,
    #[doc = " The release threshold of the memory pool. \\p releaseThreshold is\n valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \\ref CUpti_ActivityMemoryPoolType."]
    pub releaseThreshold: u64,
    #[doc = " The start timestamp for the memory operation, in ns."]
    pub timestamp: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemoryPool"]
        [::std::mem::size_of::<CUpti_ActivityMemoryPool>() - 64usize];
    ["Alignment of CUpti_ActivityMemoryPool"]
        [::std::mem::align_of::<CUpti_ActivityMemoryPool>() - 8usize];
    ["Offset of field: CUpti_ActivityMemoryPool::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMemoryPool::memoryPoolOperationType"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool, memoryPoolOperationType) - 4usize];
    ["Offset of field: CUpti_ActivityMemoryPool::memoryPoolType"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool, memoryPoolType) - 8usize];
    ["Offset of field: CUpti_ActivityMemoryPool::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool, correlationId) - 12usize];
    ["Offset of field: CUpti_ActivityMemoryPool::processId"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool, processId) - 16usize];
    ["Offset of field: CUpti_ActivityMemoryPool::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool, deviceId) - 20usize];
    ["Offset of field: CUpti_ActivityMemoryPool::minBytesToKeep"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool, minBytesToKeep) - 24usize];
    ["Offset of field: CUpti_ActivityMemoryPool::address"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool, address) - 32usize];
    ["Offset of field: CUpti_ActivityMemoryPool::size"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool, size) - 40usize];
    ["Offset of field: CUpti_ActivityMemoryPool::releaseThreshold"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool, releaseThreshold) - 48usize];
    ["Offset of field: CUpti_ActivityMemoryPool::timestamp"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool, timestamp) - 56usize];
};
impl Default for CUpti_ActivityMemoryPool {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for memory pool.\n\n This activity record represents a memory pool creation, destruction and\n trimming (CUPTI_ACTIVITY_KIND_MEMORY_POOL).\n This activity record provides separate records for memory pool creation,\n destruction and trimming operations.\n This allows to correlate the corresponding driver and runtime API\n activity record with the memory pool operation.\n"]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemoryPool2 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMORY_POOL"]
    pub kind: CUpti_ActivityKind,
    #[doc = " The memory operation requested by the user, \\ref CUpti_ActivityMemoryPoolOperationType."]
    pub memoryPoolOperationType: CUpti_ActivityMemoryPoolOperationType,
    #[doc = " The type of the memory pool, \\ref CUpti_ActivityMemoryPoolType"]
    pub memoryPoolType: CUpti_ActivityMemoryPoolType,
    #[doc = " The correlation ID of the memory pool operation. Each memory pool\n operation is assigned a unique correlation ID that is identical to the\n correlation ID in the driver and runtime API activity record that\n launched the memory operation."]
    pub correlationId: u32,
    #[doc = " The ID of the process to which this record belongs to."]
    pub processId: u32,
    #[doc = " The ID of the device where the memory pool is created."]
    pub deviceId: u32,
    #[doc = " The minimum bytes to keep of the memory pool. \\p minBytesToKeep is\n valid for CUPTI_ACTIVITY_MEMORY_POOL_OPERATION_TYPE_TRIMMED,\n \\ref CUpti_ActivityMemoryPoolOperationType"]
    pub minBytesToKeep: usize,
    #[doc = " The virtual address of the allocation."]
    pub address: u64,
    #[doc = " The size of the memory pool operation in bytes. \\p size is\n valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \\ref CUpti_ActivityMemoryPoolType."]
    pub size: u64,
    #[doc = " The release threshold of the memory pool. \\p releaseThreshold is\n valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \\ref CUpti_ActivityMemoryPoolType."]
    pub releaseThreshold: u64,
    #[doc = " The start timestamp for the memory operation, in ns."]
    pub timestamp: u64,
    #[doc = " The utilized size of the memory pool. \\p utilizedSize is\n valid for CUPTI_ACTIVITY_MEMORY_POOL_TYPE_LOCAL, \\ref CUpti_ActivityMemoryPoolType."]
    pub utilizedSize: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemoryPool2"]
        [::std::mem::size_of::<CUpti_ActivityMemoryPool2>() - 72usize];
    ["Alignment of CUpti_ActivityMemoryPool2"]
        [::std::mem::align_of::<CUpti_ActivityMemoryPool2>() - 8usize];
    ["Offset of field: CUpti_ActivityMemoryPool2::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool2, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMemoryPool2::memoryPoolOperationType"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool2, memoryPoolOperationType) - 4usize];
    ["Offset of field: CUpti_ActivityMemoryPool2::memoryPoolType"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool2, memoryPoolType) - 8usize];
    ["Offset of field: CUpti_ActivityMemoryPool2::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool2, correlationId) - 12usize];
    ["Offset of field: CUpti_ActivityMemoryPool2::processId"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool2, processId) - 16usize];
    ["Offset of field: CUpti_ActivityMemoryPool2::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool2, deviceId) - 20usize];
    ["Offset of field: CUpti_ActivityMemoryPool2::minBytesToKeep"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool2, minBytesToKeep) - 24usize];
    ["Offset of field: CUpti_ActivityMemoryPool2::address"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool2, address) - 32usize];
    ["Offset of field: CUpti_ActivityMemoryPool2::size"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool2, size) - 40usize];
    ["Offset of field: CUpti_ActivityMemoryPool2::releaseThreshold"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool2, releaseThreshold) - 48usize];
    ["Offset of field: CUpti_ActivityMemoryPool2::timestamp"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool2, timestamp) - 56usize];
    ["Offset of field: CUpti_ActivityMemoryPool2::utilizedSize"]
        [::std::mem::offset_of!(CUpti_ActivityMemoryPool2, utilizedSize) - 64usize];
};
impl Default for CUpti_ActivityMemoryPool2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record providing a marker which is an\n instantaneous point in time. (deprecated in CUDA 8.0)\n\n The marker is specified with a descriptive name and unique id\n (CUPTI_ACTIVITY_KIND_MARKER).\n Marker activity is now reported using the\n CUpti_ActivityMarker2 activity record."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMarker {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MARKER."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The flags associated with the marker. \\see CUpti_ActivityFlag"]
    pub flags: CUpti_ActivityFlag,
    #[doc = " The timestamp for the marker, in ns. A value of 0 indicates that\n timestamp information could not be collected for the marker."]
    pub timestamp: u64,
    #[doc = " The marker ID."]
    pub id: u32,
    #[doc = " The kind of activity object associated with this marker."]
    pub objectKind: CUpti_ActivityObjectKind,
    #[doc = " The identifier for the activity object associated with this\n marker. 'objectKind' indicates which ID is valid for this record."]
    pub objectId: CUpti_ActivityObjectKindId,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
    #[doc = " The marker name for an instantaneous or start marker. This will\n be NULL for an end marker."]
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMarker"][::std::mem::size_of::<CUpti_ActivityMarker>() - 48usize];
    ["Alignment of CUpti_ActivityMarker"][::std::mem::align_of::<CUpti_ActivityMarker>() - 8usize];
    ["Offset of field: CUpti_ActivityMarker::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMarker, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMarker::flags"]
        [::std::mem::offset_of!(CUpti_ActivityMarker, flags) - 4usize];
    ["Offset of field: CUpti_ActivityMarker::timestamp"]
        [::std::mem::offset_of!(CUpti_ActivityMarker, timestamp) - 8usize];
    ["Offset of field: CUpti_ActivityMarker::id"]
        [::std::mem::offset_of!(CUpti_ActivityMarker, id) - 16usize];
    ["Offset of field: CUpti_ActivityMarker::objectKind"]
        [::std::mem::offset_of!(CUpti_ActivityMarker, objectKind) - 20usize];
    ["Offset of field: CUpti_ActivityMarker::objectId"]
        [::std::mem::offset_of!(CUpti_ActivityMarker, objectId) - 24usize];
    ["Offset of field: CUpti_ActivityMarker::pad"]
        [::std::mem::offset_of!(CUpti_ActivityMarker, pad) - 36usize];
    ["Offset of field: CUpti_ActivityMarker::name"]
        [::std::mem::offset_of!(CUpti_ActivityMarker, name) - 40usize];
};
impl Default for CUpti_ActivityMarker {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMarker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMarker {{ kind: {:?}, flags: {:?}, objectKind: {:?}, objectId: {:?}, name: {:?} }}",
            self.kind, self.flags, self.objectKind, self.objectId, self.name
        )
    }
}
#[doc = " \\brief The activity record for source-level global\n access. (deprecated)\n\n This activity records the locations of the global\n accesses in the source (CUPTI_ACTIVITY_KIND_GLOBAL_ACCESS).\n Global access activities are now reported using the\n CUpti_ActivityGlobalAccess3 activity record."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityGlobalAccess {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_GLOBAL_ACCESS."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The properties of this global access."]
    pub flags: CUpti_ActivityFlag,
    #[doc = " The ID for source locator."]
    pub sourceLocatorId: u32,
    #[doc = " The correlation ID of the kernel to which this result is associated."]
    pub correlationId: u32,
    #[doc = " The pc offset for the access."]
    pub pcOffset: u32,
    #[doc = " The number of times this instruction was executed per warp. It will be incremented\n when at least one of thread among warp is active with predicate and condition code\n evaluating to true."]
    pub executed: u32,
    #[doc = " This increments each time when this instruction is executed by number\n of threads that executed this instruction with predicate and condition code evaluating to true."]
    pub threadsExecuted: u64,
    #[doc = " The total number of 32 bytes transactions to L2 cache generated by this access"]
    pub l2_transactions: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityGlobalAccess"]
        [::std::mem::size_of::<CUpti_ActivityGlobalAccess>() - 40usize];
    ["Alignment of CUpti_ActivityGlobalAccess"]
        [::std::mem::align_of::<CUpti_ActivityGlobalAccess>() - 8usize];
    ["Offset of field: CUpti_ActivityGlobalAccess::kind"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess, kind) - 0usize];
    ["Offset of field: CUpti_ActivityGlobalAccess::flags"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess, flags) - 4usize];
    ["Offset of field: CUpti_ActivityGlobalAccess::sourceLocatorId"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess, sourceLocatorId) - 8usize];
    ["Offset of field: CUpti_ActivityGlobalAccess::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess, correlationId) - 12usize];
    ["Offset of field: CUpti_ActivityGlobalAccess::pcOffset"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess, pcOffset) - 16usize];
    ["Offset of field: CUpti_ActivityGlobalAccess::executed"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess, executed) - 20usize];
    ["Offset of field: CUpti_ActivityGlobalAccess::threadsExecuted"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess, threadsExecuted) - 24usize];
    ["Offset of field: CUpti_ActivityGlobalAccess::l2_transactions"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess, l2_transactions) - 32usize];
};
impl Default for CUpti_ActivityGlobalAccess {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for source-level global\n access. (deprecated in CUDA 9.0)\n\n This activity records the locations of the global\n accesses in the source (CUPTI_ACTIVITY_KIND_GLOBAL_ACCESS).\n Global access activities are now reported using the\n CUpti_ActivityGlobalAccess3 activity record."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityGlobalAccess2 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_GLOBAL_ACCESS."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The properties of this global access."]
    pub flags: CUpti_ActivityFlag,
    #[doc = " The ID for source locator."]
    pub sourceLocatorId: u32,
    #[doc = " The correlation ID of the kernel to which this result is associated."]
    pub correlationId: u32,
    #[doc = " Correlation ID with global/device function name"]
    pub functionId: u32,
    #[doc = " The pc offset for the access."]
    pub pcOffset: u32,
    #[doc = " This increments each time when this instruction is executed by number\n of threads that executed this instruction with predicate and condition code evaluating to true."]
    pub threadsExecuted: u64,
    #[doc = " The total number of 32 bytes transactions to L2 cache generated by this access"]
    pub l2_transactions: u64,
    #[doc = " The minimum number of L2 transactions possible based on the access pattern."]
    pub theoreticalL2Transactions: u64,
    #[doc = " The number of times this instruction was executed per warp. It will be incremented\n when at least one of thread among warp is active with predicate and condition code\n evaluating to true."]
    pub executed: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityGlobalAccess2"]
        [::std::mem::size_of::<CUpti_ActivityGlobalAccess2>() - 56usize];
    ["Alignment of CUpti_ActivityGlobalAccess2"]
        [::std::mem::align_of::<CUpti_ActivityGlobalAccess2>() - 8usize];
    ["Offset of field: CUpti_ActivityGlobalAccess2::kind"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess2, kind) - 0usize];
    ["Offset of field: CUpti_ActivityGlobalAccess2::flags"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess2, flags) - 4usize];
    ["Offset of field: CUpti_ActivityGlobalAccess2::sourceLocatorId"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess2, sourceLocatorId) - 8usize];
    ["Offset of field: CUpti_ActivityGlobalAccess2::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess2, correlationId) - 12usize];
    ["Offset of field: CUpti_ActivityGlobalAccess2::functionId"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess2, functionId) - 16usize];
    ["Offset of field: CUpti_ActivityGlobalAccess2::pcOffset"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess2, pcOffset) - 20usize];
    ["Offset of field: CUpti_ActivityGlobalAccess2::threadsExecuted"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess2, threadsExecuted) - 24usize];
    ["Offset of field: CUpti_ActivityGlobalAccess2::l2_transactions"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess2, l2_transactions) - 32usize];
    ["Offset of field: CUpti_ActivityGlobalAccess2::theoreticalL2Transactions"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess2, theoreticalL2Transactions) - 40usize];
    ["Offset of field: CUpti_ActivityGlobalAccess2::executed"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess2, executed) - 48usize];
    ["Offset of field: CUpti_ActivityGlobalAccess2::pad"]
        [::std::mem::offset_of!(CUpti_ActivityGlobalAccess2, pad) - 52usize];
};
impl Default for CUpti_ActivityGlobalAccess2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for source level result\n branch. (deprecated)\n\n This activity record the locations of the branches in the\n source (CUPTI_ACTIVITY_KIND_BRANCH).\n Branch activities are now reported using the\n CUpti_ActivityBranch2 activity record."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityBranch {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_BRANCH."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The ID for source locator."]
    pub sourceLocatorId: u32,
    #[doc = " The correlation ID of the kernel to which this result is associated."]
    pub correlationId: u32,
    #[doc = " The pc offset for the branch."]
    pub pcOffset: u32,
    #[doc = " The number of times this instruction was executed per warp. It will be incremented\n regardless of predicate or condition code."]
    pub executed: u32,
    #[doc = " Number of times this branch diverged"]
    pub diverged: u32,
    #[doc = " This increments each time when this instruction is executed by number\n of threads that executed this instruction"]
    pub threadsExecuted: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityBranch"][::std::mem::size_of::<CUpti_ActivityBranch>() - 32usize];
    ["Alignment of CUpti_ActivityBranch"][::std::mem::align_of::<CUpti_ActivityBranch>() - 8usize];
    ["Offset of field: CUpti_ActivityBranch::kind"]
        [::std::mem::offset_of!(CUpti_ActivityBranch, kind) - 0usize];
    ["Offset of field: CUpti_ActivityBranch::sourceLocatorId"]
        [::std::mem::offset_of!(CUpti_ActivityBranch, sourceLocatorId) - 4usize];
    ["Offset of field: CUpti_ActivityBranch::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityBranch, correlationId) - 8usize];
    ["Offset of field: CUpti_ActivityBranch::pcOffset"]
        [::std::mem::offset_of!(CUpti_ActivityBranch, pcOffset) - 12usize];
    ["Offset of field: CUpti_ActivityBranch::executed"]
        [::std::mem::offset_of!(CUpti_ActivityBranch, executed) - 16usize];
    ["Offset of field: CUpti_ActivityBranch::diverged"]
        [::std::mem::offset_of!(CUpti_ActivityBranch, diverged) - 20usize];
    ["Offset of field: CUpti_ActivityBranch::threadsExecuted"]
        [::std::mem::offset_of!(CUpti_ActivityBranch, threadsExecuted) - 24usize];
};
impl Default for CUpti_ActivityBranch {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for PC sampling. (deprecated in CUDA 8.0)\n\n This activity records information obtained by sampling PC\n (CUPTI_ACTIVITY_KIND_PC_SAMPLING).\n PC sampling activities are now reported using the\n CUpti_ActivityPCSampling2 activity record."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityPCSampling {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_PC_SAMPLING."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The properties of this instruction."]
    pub flags: CUpti_ActivityFlag,
    #[doc = " The ID for source locator."]
    pub sourceLocatorId: u32,
    #[doc = " The correlation ID of the kernel to which this result is associated."]
    pub correlationId: u32,
    #[doc = " Correlation ID with global/device function name"]
    pub functionId: u32,
    #[doc = " The pc offset for the instruction."]
    pub pcOffset: u32,
    #[doc = " Number of times the PC was sampled with the stallReason in the record.\n The same PC can be sampled with different stall reasons."]
    pub samples: u32,
    #[doc = " Current stall reason. Includes one of the reasons from\n \\ref CUpti_ActivityPCSamplingStallReason"]
    pub stallReason: CUpti_ActivityPCSamplingStallReason,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityPCSampling"]
        [::std::mem::size_of::<CUpti_ActivityPCSampling>() - 32usize];
    ["Alignment of CUpti_ActivityPCSampling"]
        [::std::mem::align_of::<CUpti_ActivityPCSampling>() - 8usize];
    ["Offset of field: CUpti_ActivityPCSampling::kind"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling, kind) - 0usize];
    ["Offset of field: CUpti_ActivityPCSampling::flags"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling, flags) - 4usize];
    ["Offset of field: CUpti_ActivityPCSampling::sourceLocatorId"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling, sourceLocatorId) - 8usize];
    ["Offset of field: CUpti_ActivityPCSampling::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling, correlationId) - 12usize];
    ["Offset of field: CUpti_ActivityPCSampling::functionId"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling, functionId) - 16usize];
    ["Offset of field: CUpti_ActivityPCSampling::pcOffset"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling, pcOffset) - 20usize];
    ["Offset of field: CUpti_ActivityPCSampling::samples"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling, samples) - 24usize];
    ["Offset of field: CUpti_ActivityPCSampling::stallReason"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling, stallReason) - 28usize];
};
impl Default for CUpti_ActivityPCSampling {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for PC sampling. (deprecated in CUDA 9.0)\n\n This activity records information obtained by sampling PC\n (CUPTI_ACTIVITY_KIND_PC_SAMPLING).\n PC sampling activities are now reported using the\n CUpti_ActivityPCSampling3 activity record."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityPCSampling2 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_PC_SAMPLING."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The properties of this instruction."]
    pub flags: CUpti_ActivityFlag,
    #[doc = " The ID for source locator."]
    pub sourceLocatorId: u32,
    #[doc = " The correlation ID of the kernel to which this result is associated."]
    pub correlationId: u32,
    #[doc = " Correlation ID with global/device function name"]
    pub functionId: u32,
    #[doc = " The pc offset for the instruction."]
    pub pcOffset: u32,
    #[doc = " Number of times the PC was sampled with the stallReason in the record.\n These samples indicate that no instruction was issued in that cycle from\n the warp scheduler from where the warp was sampled.\n Field is valid for devices with compute capability 6.0 and higher"]
    pub latencySamples: u32,
    #[doc = " Number of times the PC was sampled with the stallReason in the record.\n The same PC can be sampled with different stall reasons. The count includes\n latencySamples."]
    pub samples: u32,
    #[doc = " Current stall reason. Includes one of the reasons from\n \\ref CUpti_ActivityPCSamplingStallReason"]
    pub stallReason: CUpti_ActivityPCSamplingStallReason,
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityPCSampling2"]
        [::std::mem::size_of::<CUpti_ActivityPCSampling2>() - 40usize];
    ["Alignment of CUpti_ActivityPCSampling2"]
        [::std::mem::align_of::<CUpti_ActivityPCSampling2>() - 8usize];
    ["Offset of field: CUpti_ActivityPCSampling2::kind"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling2, kind) - 0usize];
    ["Offset of field: CUpti_ActivityPCSampling2::flags"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling2, flags) - 4usize];
    ["Offset of field: CUpti_ActivityPCSampling2::sourceLocatorId"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling2, sourceLocatorId) - 8usize];
    ["Offset of field: CUpti_ActivityPCSampling2::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling2, correlationId) - 12usize];
    ["Offset of field: CUpti_ActivityPCSampling2::functionId"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling2, functionId) - 16usize];
    ["Offset of field: CUpti_ActivityPCSampling2::pcOffset"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling2, pcOffset) - 20usize];
    ["Offset of field: CUpti_ActivityPCSampling2::latencySamples"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling2, latencySamples) - 24usize];
    ["Offset of field: CUpti_ActivityPCSampling2::samples"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling2, samples) - 28usize];
    ["Offset of field: CUpti_ActivityPCSampling2::stallReason"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling2, stallReason) - 32usize];
    ["Offset of field: CUpti_ActivityPCSampling2::pad"]
        [::std::mem::offset_of!(CUpti_ActivityPCSampling2, pad) - 36usize];
};
impl Default for CUpti_ActivityPCSampling2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for Unified Memory counters (deprecated in CUDA 7.0)\n\n This activity record represents a Unified Memory counter\n (CUPTI_ACTIVITY_KIND_UNIFIED_MEMORY_COUNTER)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityUnifiedMemoryCounter {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_UNIFIED_MEMORY_COUNTER"]
    pub kind: CUpti_ActivityKind,
    #[doc = " The Unified Memory counter kind. See \\ref CUpti_ActivityUnifiedMemoryCounterKind"]
    pub counterKind: CUpti_ActivityUnifiedMemoryCounterKind,
    #[doc = " Scope of the Unified Memory counter. See \\ref CUpti_ActivityUnifiedMemoryCounterScope"]
    pub scope: CUpti_ActivityUnifiedMemoryCounterScope,
    #[doc = " The ID of the device involved in the memory transfer operation.\n It is not relevant if the scope of the counter is global (all devices)."]
    pub deviceId: u32,
    #[doc = " Value of the counter\n"]
    pub value: u64,
    #[doc = " The timestamp when this sample was retrieved, in ns. A value of 0\n indicates that timestamp information could not be collected"]
    pub timestamp: u64,
    #[doc = " The ID of the process to which this record belongs to. In case of\n global scope, processId is undefined."]
    pub processId: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityUnifiedMemoryCounter"]
        [::std::mem::size_of::<CUpti_ActivityUnifiedMemoryCounter>() - 40usize];
    ["Alignment of CUpti_ActivityUnifiedMemoryCounter"]
        [::std::mem::align_of::<CUpti_ActivityUnifiedMemoryCounter>() - 8usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter::kind"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter, kind) - 0usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter::counterKind"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter, counterKind) - 4usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter::scope"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter, scope) - 8usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter, deviceId) - 12usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter::value"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter, value) - 16usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter::timestamp"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter, timestamp) - 24usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter::processId"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter, processId) - 32usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter::pad"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter, pad) - 36usize];
};
impl Default for CUpti_ActivityUnifiedMemoryCounter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for Unified Memory counters (deprecated in 12.8)\n\n This activity record represents a Unified Memory counter\n (CUPTI_ACTIVITY_KIND_UNIFIED_MEMORY_COUNTER)."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityUnifiedMemoryCounter2 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_UNIFIED_MEMORY_COUNTER"]
    pub kind: CUpti_ActivityKind,
    #[doc = " The Unified Memory counter kind"]
    pub counterKind: CUpti_ActivityUnifiedMemoryCounterKind,
    #[doc = " Value of the counter\n For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD,\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_DTOH,\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THREASHING and\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_REMOTE_MAP, it is the size of the\n memory region in bytes.\n For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT, it\n is the number of page fault groups for the same page.\n For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT,\n it is the program counter for the instruction that caused fault."]
    pub value: u64,
    #[doc = " The start timestamp of the counter, in ns.\n For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD and\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_DTOH, timestamp is\n captured when activity starts on GPU.\n For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT and\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT, timestamp is\n captured when CUDA driver started processing the fault.\n For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING, timestamp\n is captured when CUDA driver detected thrashing of memory region.\n For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING,\n timestamp is captured when throttling operation was started by CUDA driver.\n For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_REMOTE_MAP,\n timestamp is captured when CUDA driver has pushed all required operations\n to the processor specified by dstId."]
    pub start: u64,
    #[doc = " The end timestamp of the counter, in ns.\n Ignore this field if counterKind is\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT or\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING or\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_REMOTE_MAP.\n For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD and\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_DTOH, timestamp is\n captured when activity finishes on GPU.\n For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT, timestamp is\n captured when CUDA driver queues the replay of faulting memory accesses on the GPU\n For counterKind CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING, timestamp\n is captured when throttling operation was finished by CUDA driver"]
    pub end: u64,
    #[doc = " This is the virtual base address of the page/s being transferred. For cpu and\n gpu faults, the virtual address for the page that faulted."]
    pub address: u64,
    #[doc = " The ID of the source CPU/device involved in the memory transfer, page fault, thrashing,\n throttling or remote map operation. For counterKind\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING, it is a bitwise ORing of the\n device IDs fighting for the memory region. Ignore this field if counterKind is\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT"]
    pub srcId: u32,
    #[doc = " The ID of the destination CPU/device involved in the memory transfer or remote map\n operation. Ignore this field if counterKind is\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT or\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_CPU_PAGE_FAULT_COUNT or\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING or\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING"]
    pub dstId: u32,
    #[doc = " The ID of the stream causing the transfer.\n This value of this field is invalid."]
    pub streamId: u32,
    #[doc = " The ID of the process to which this record belongs to."]
    pub processId: u32,
    #[doc = " The flags associated with this record. See enums \\ref CUpti_ActivityUnifiedMemoryAccessType\n if counterKind is CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_GPU_PAGE_FAULT\n and \\ref CUpti_ActivityUnifiedMemoryMigrationCause if counterKind is\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD or\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_BYTES_TRANSFER_HTOD\n and \\ref CUpti_ActivityUnifiedMemoryRemoteMapCause if counterKind is\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_REMOTE_MAP and \\ref CUpti_ActivityFlag\n if counterKind is CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THRASHING or\n CUPTI_ACTIVITY_UNIFIED_MEMORY_COUNTER_KIND_THROTTLING"]
    pub flags: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityUnifiedMemoryCounter2"]
        [::std::mem::size_of::<CUpti_ActivityUnifiedMemoryCounter2>() - 64usize];
    ["Alignment of CUpti_ActivityUnifiedMemoryCounter2"]
        [::std::mem::align_of::<CUpti_ActivityUnifiedMemoryCounter2>() - 8usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter2::kind"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, kind) - 0usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter2::counterKind"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, counterKind) - 4usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter2::value"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, value) - 8usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter2::start"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, start) - 16usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter2::end"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, end) - 24usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter2::address"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, address) - 32usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter2::srcId"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, srcId) - 40usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter2::dstId"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, dstId) - 44usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter2::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, streamId) - 48usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter2::processId"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, processId) - 52usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter2::flags"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, flags) - 56usize];
    ["Offset of field: CUpti_ActivityUnifiedMemoryCounter2::pad"]
        [::std::mem::offset_of!(CUpti_ActivityUnifiedMemoryCounter2, pad) - 60usize];
};
impl Default for CUpti_ActivityUnifiedMemoryCounter2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief NVLink information. (deprecated in CUDA 9.0)\n\n This structure gives capabilities of each logical NVLink connection between two devices,\n gpu<->gpu or gpu<->CPU which can be used to understand the topology.\n NVLink information are now reported using the\n CUpti_ActivityNvLink2 activity record."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityNvLink {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_NVLINK."]
    pub kind: CUpti_ActivityKind,
    #[doc = " NVLink version."]
    pub nvlinkVersion: u32,
    #[doc = " Type of device 0 \\ref CUpti_DevType"]
    pub typeDev0: CUpti_DevType,
    #[doc = " Type of device 1 \\ref CUpti_DevType"]
    pub typeDev1: CUpti_DevType,
    pub idDev0: CUpti_ActivityNvLink__bindgen_ty_1,
    pub idDev1: CUpti_ActivityNvLink__bindgen_ty_2,
    #[doc = " Flag gives capabilities of the link \\see CUpti_LinkFlag"]
    pub flag: u32,
    #[doc = " Number of physical NVLinks present between two devices."]
    pub physicalNvLinkCount: u32,
    #[doc = " Port numbers for maximum 4 NVLinks connected to device 0.\n If typeDev0 is CUPTI_DEV_TYPE_NPU, ignore this field.\n In case of invalid/unknown port number, this field will be set\n to value CUPTI_NVLINK_INVALID_PORT.\n This will be used to correlate the metric values to individual\n physical link and attribute traffic to the logical NVLink in\n the topology."]
    pub portDev0: [i8; 4usize],
    #[doc = " Port numbers for maximum 4 NVLinks connected to device 1.\n If typeDev1 is CUPTI_DEV_TYPE_NPU, ignore this field.\n In case of invalid/unknown port number, this field will be set\n to value CUPTI_NVLINK_INVALID_PORT.\n This will be used to correlate the metric values to individual\n physical link and attribute traffic to the logical NVLink in\n the topology."]
    pub portDev1: [i8; 4usize],
    #[doc = " Bandwidth of NVLink in kbytes/sec"]
    pub bandwidth: u64,
}
#[doc = " If typeDev0 is CUPTI_DEV_TYPE_GPU, UUID for device 0. \\ref CUpti_ActivityDevice5.\n If typeDev0 is CUPTI_DEV_TYPE_NPU, struct npu for NPU."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityNvLink__bindgen_ty_1 {
    pub uuidDev: CUuuid,
    pub npu: CUpti_ActivityNvLink__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityNvLink__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Index of the NPU. First index will always be zero."]
    pub index: u32,
    #[doc = " Domain ID of NPU. On Linux, this can be queried using lspci."]
    pub domainId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityNvLink__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityNvLink__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of CUpti_ActivityNvLink__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityNvLink__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: CUpti_ActivityNvLink__bindgen_ty_1__bindgen_ty_1::index"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink__bindgen_ty_1__bindgen_ty_1, index) - 0usize];
    ["Offset of field: CUpti_ActivityNvLink__bindgen_ty_1__bindgen_ty_1::domainId"][::std::mem::offset_of!(
        CUpti_ActivityNvLink__bindgen_ty_1__bindgen_ty_1,
        domainId
    ) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityNvLink__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityNvLink__bindgen_ty_1>() - 16usize];
    ["Alignment of CUpti_ActivityNvLink__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityNvLink__bindgen_ty_1>() - 4usize];
    ["Offset of field: CUpti_ActivityNvLink__bindgen_ty_1::uuidDev"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink__bindgen_ty_1, uuidDev) - 0usize];
    ["Offset of field: CUpti_ActivityNvLink__bindgen_ty_1::npu"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink__bindgen_ty_1, npu) - 0usize];
};
impl Default for CUpti_ActivityNvLink__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityNvLink__bindgen_ty_1 {{ union }}")
    }
}
#[doc = " If typeDev1 is CUPTI_DEV_TYPE_GPU, UUID for device 1. \\ref CUpti_ActivityDevice5.\n If typeDev1 is CUPTI_DEV_TYPE_NPU, struct npu for NPU."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityNvLink__bindgen_ty_2 {
    pub uuidDev: CUuuid,
    pub npu: CUpti_ActivityNvLink__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityNvLink__bindgen_ty_2__bindgen_ty_1 {
    #[doc = " Index of the NPU. First index will always be zero."]
    pub index: u32,
    #[doc = " Domain ID of NPU. On Linux, this can be queried using lspci."]
    pub domainId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityNvLink__bindgen_ty_2__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityNvLink__bindgen_ty_2__bindgen_ty_1>() - 8usize];
    ["Alignment of CUpti_ActivityNvLink__bindgen_ty_2__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityNvLink__bindgen_ty_2__bindgen_ty_1>() - 4usize];
    ["Offset of field: CUpti_ActivityNvLink__bindgen_ty_2__bindgen_ty_1::index"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink__bindgen_ty_2__bindgen_ty_1, index) - 0usize];
    ["Offset of field: CUpti_ActivityNvLink__bindgen_ty_2__bindgen_ty_1::domainId"][::std::mem::offset_of!(
        CUpti_ActivityNvLink__bindgen_ty_2__bindgen_ty_1,
        domainId
    ) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityNvLink__bindgen_ty_2"]
        [::std::mem::size_of::<CUpti_ActivityNvLink__bindgen_ty_2>() - 16usize];
    ["Alignment of CUpti_ActivityNvLink__bindgen_ty_2"]
        [::std::mem::align_of::<CUpti_ActivityNvLink__bindgen_ty_2>() - 4usize];
    ["Offset of field: CUpti_ActivityNvLink__bindgen_ty_2::uuidDev"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink__bindgen_ty_2, uuidDev) - 0usize];
    ["Offset of field: CUpti_ActivityNvLink__bindgen_ty_2::npu"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink__bindgen_ty_2, npu) - 0usize];
};
impl Default for CUpti_ActivityNvLink__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityNvLink__bindgen_ty_2 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityNvLink"][::std::mem::size_of::<CUpti_ActivityNvLink>() - 72usize];
    ["Alignment of CUpti_ActivityNvLink"][::std::mem::align_of::<CUpti_ActivityNvLink>() - 8usize];
    ["Offset of field: CUpti_ActivityNvLink::kind"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink, kind) - 0usize];
    ["Offset of field: CUpti_ActivityNvLink::nvlinkVersion"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink, nvlinkVersion) - 4usize];
    ["Offset of field: CUpti_ActivityNvLink::typeDev0"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink, typeDev0) - 8usize];
    ["Offset of field: CUpti_ActivityNvLink::typeDev1"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink, typeDev1) - 12usize];
    ["Offset of field: CUpti_ActivityNvLink::idDev0"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink, idDev0) - 16usize];
    ["Offset of field: CUpti_ActivityNvLink::idDev1"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink, idDev1) - 32usize];
    ["Offset of field: CUpti_ActivityNvLink::flag"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink, flag) - 48usize];
    ["Offset of field: CUpti_ActivityNvLink::physicalNvLinkCount"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink, physicalNvLinkCount) - 52usize];
    ["Offset of field: CUpti_ActivityNvLink::portDev0"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink, portDev0) - 56usize];
    ["Offset of field: CUpti_ActivityNvLink::portDev1"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink, portDev1) - 60usize];
    ["Offset of field: CUpti_ActivityNvLink::bandwidth"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink, bandwidth) - 64usize];
};
impl Default for CUpti_ActivityNvLink {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityNvLink {{ kind: {:?}, typeDev0: {:?}, typeDev1: {:?}, idDev0: {:?}, idDev1: {:?}, portDev0: {:?}, portDev1: {:?} }}",
            self.kind,
            self.typeDev0,
            self.typeDev1,
            self.idDev0,
            self.idDev1,
            self.portDev0,
            self.portDev1
        )
    }
}
#[doc = " \\brief NVLink information. (deprecated in CUDA 10.0)\n\n This structure gives capabilities of each logical NVLink connection between two devices,\n gpu<->gpu or gpu<->CPU which can be used to understand the topology.\n NvLink information are now reported using the\n CUpti_ActivityNvLink4 activity record."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityNvLink2 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_NVLINK."]
    pub kind: CUpti_ActivityKind,
    #[doc = " NvLink version."]
    pub nvlinkVersion: u32,
    #[doc = " Type of device 0 \\ref CUpti_DevType"]
    pub typeDev0: CUpti_DevType,
    #[doc = " Type of device 1 \\ref CUpti_DevType"]
    pub typeDev1: CUpti_DevType,
    pub idDev0: CUpti_ActivityNvLink2__bindgen_ty_1,
    pub idDev1: CUpti_ActivityNvLink2__bindgen_ty_2,
    #[doc = " Flag gives capabilities of the link \\see CUpti_LinkFlag"]
    pub flag: u32,
    #[doc = " Number of physical NVLinks present between two devices."]
    pub physicalNvLinkCount: u32,
    #[doc = " Port numbers for maximum 16 NVLinks connected to device 0.\n If typeDev0 is CUPTI_DEV_TYPE_NPU, ignore this field.\n In case of invalid/unknown port number, this field will be set\n to value CUPTI_NVLINK_INVALID_PORT.\n This will be used to correlate the metric values to individual\n physical link and attribute traffic to the logical NVLink in\n the topology."]
    pub portDev0: [i8; 32usize],
    #[doc = " Port numbers for maximum 16 NVLinks connected to device 1.\n If typeDev1 is CUPTI_DEV_TYPE_NPU, ignore this field.\n In case of invalid/unknown port number, this field will be set\n to value CUPTI_NVLINK_INVALID_PORT.\n This will be used to correlate the metric values to individual\n physical link and attribute traffic to the logical NVLink in\n the topology."]
    pub portDev1: [i8; 32usize],
    #[doc = " Bandwidth of NVLink in kbytes/sec"]
    pub bandwidth: u64,
}
#[doc = " If typeDev0 is CUPTI_DEV_TYPE_GPU, UUID for device 0. \\ref CUpti_ActivityDevice5.\n If typeDev0 is CUPTI_DEV_TYPE_NPU, struct npu for NPU."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityNvLink2__bindgen_ty_1 {
    pub uuidDev: CUuuid,
    pub npu: CUpti_ActivityNvLink2__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityNvLink2__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Index of the NPU. First index will always be zero."]
    pub index: u32,
    #[doc = " Domain ID of NPU. On Linux, this can be queried using lspci."]
    pub domainId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityNvLink2__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityNvLink2__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of CUpti_ActivityNvLink2__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityNvLink2__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: CUpti_ActivityNvLink2__bindgen_ty_1__bindgen_ty_1::index"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink2__bindgen_ty_1__bindgen_ty_1, index) - 0usize];
    ["Offset of field: CUpti_ActivityNvLink2__bindgen_ty_1__bindgen_ty_1::domainId"][::std::mem::offset_of!(
        CUpti_ActivityNvLink2__bindgen_ty_1__bindgen_ty_1,
        domainId
    ) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityNvLink2__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityNvLink2__bindgen_ty_1>() - 16usize];
    ["Alignment of CUpti_ActivityNvLink2__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityNvLink2__bindgen_ty_1>() - 4usize];
    ["Offset of field: CUpti_ActivityNvLink2__bindgen_ty_1::uuidDev"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink2__bindgen_ty_1, uuidDev) - 0usize];
    ["Offset of field: CUpti_ActivityNvLink2__bindgen_ty_1::npu"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink2__bindgen_ty_1, npu) - 0usize];
};
impl Default for CUpti_ActivityNvLink2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink2__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityNvLink2__bindgen_ty_1 {{ union }}")
    }
}
#[doc = " If typeDev1 is CUPTI_DEV_TYPE_GPU, UUID for device 1. \\ref CUpti_ActivityDevice5.\n If typeDev1 is CUPTI_DEV_TYPE_NPU, struct npu for NPU."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityNvLink2__bindgen_ty_2 {
    pub uuidDev: CUuuid,
    pub npu: CUpti_ActivityNvLink2__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityNvLink2__bindgen_ty_2__bindgen_ty_1 {
    #[doc = " Index of the NPU. First index will always be zero."]
    pub index: u32,
    #[doc = " Domain ID of NPU. On Linux, this can be queried using lspci."]
    pub domainId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityNvLink2__bindgen_ty_2__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityNvLink2__bindgen_ty_2__bindgen_ty_1>() - 8usize];
    ["Alignment of CUpti_ActivityNvLink2__bindgen_ty_2__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityNvLink2__bindgen_ty_2__bindgen_ty_1>() - 4usize];
    ["Offset of field: CUpti_ActivityNvLink2__bindgen_ty_2__bindgen_ty_1::index"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink2__bindgen_ty_2__bindgen_ty_1, index) - 0usize];
    ["Offset of field: CUpti_ActivityNvLink2__bindgen_ty_2__bindgen_ty_1::domainId"][::std::mem::offset_of!(
        CUpti_ActivityNvLink2__bindgen_ty_2__bindgen_ty_1,
        domainId
    ) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityNvLink2__bindgen_ty_2"]
        [::std::mem::size_of::<CUpti_ActivityNvLink2__bindgen_ty_2>() - 16usize];
    ["Alignment of CUpti_ActivityNvLink2__bindgen_ty_2"]
        [::std::mem::align_of::<CUpti_ActivityNvLink2__bindgen_ty_2>() - 4usize];
    ["Offset of field: CUpti_ActivityNvLink2__bindgen_ty_2::uuidDev"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink2__bindgen_ty_2, uuidDev) - 0usize];
    ["Offset of field: CUpti_ActivityNvLink2__bindgen_ty_2::npu"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink2__bindgen_ty_2, npu) - 0usize];
};
impl Default for CUpti_ActivityNvLink2__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink2__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityNvLink2__bindgen_ty_2 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityNvLink2"][::std::mem::size_of::<CUpti_ActivityNvLink2>() - 128usize];
    ["Alignment of CUpti_ActivityNvLink2"]
        [::std::mem::align_of::<CUpti_ActivityNvLink2>() - 8usize];
    ["Offset of field: CUpti_ActivityNvLink2::kind"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink2, kind) - 0usize];
    ["Offset of field: CUpti_ActivityNvLink2::nvlinkVersion"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink2, nvlinkVersion) - 4usize];
    ["Offset of field: CUpti_ActivityNvLink2::typeDev0"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink2, typeDev0) - 8usize];
    ["Offset of field: CUpti_ActivityNvLink2::typeDev1"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink2, typeDev1) - 12usize];
    ["Offset of field: CUpti_ActivityNvLink2::idDev0"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink2, idDev0) - 16usize];
    ["Offset of field: CUpti_ActivityNvLink2::idDev1"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink2, idDev1) - 32usize];
    ["Offset of field: CUpti_ActivityNvLink2::flag"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink2, flag) - 48usize];
    ["Offset of field: CUpti_ActivityNvLink2::physicalNvLinkCount"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink2, physicalNvLinkCount) - 52usize];
    ["Offset of field: CUpti_ActivityNvLink2::portDev0"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink2, portDev0) - 56usize];
    ["Offset of field: CUpti_ActivityNvLink2::portDev1"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink2, portDev1) - 88usize];
    ["Offset of field: CUpti_ActivityNvLink2::bandwidth"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink2, bandwidth) - 120usize];
};
impl Default for CUpti_ActivityNvLink2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityNvLink2 {{ kind: {:?}, typeDev0: {:?}, typeDev1: {:?}, idDev0: {:?}, idDev1: {:?}, portDev0: {:?}, portDev1: {:?} }}",
            self.kind,
            self.typeDev0,
            self.typeDev1,
            self.idDev0,
            self.idDev1,
            self.portDev0,
            self.portDev1
        )
    }
}
#[doc = " \\brief NVLink information.\n\n This structure gives capabilities of each logical NVLink connection between two devices,\n gpu<->gpu or gpu<->CPU which can be used to understand the topology.\n NvLink information are now reported using the\n CUpti_ActivityNvLink4 activity record."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityNvLink3 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_NVLINK."]
    pub kind: CUpti_ActivityKind,
    #[doc = " NvLink version."]
    pub nvlinkVersion: u32,
    #[doc = " Type of device 0 \\ref CUpti_DevType"]
    pub typeDev0: CUpti_DevType,
    #[doc = " Type of device 1 \\ref CUpti_DevType"]
    pub typeDev1: CUpti_DevType,
    pub idDev0: CUpti_ActivityNvLink3__bindgen_ty_1,
    pub idDev1: CUpti_ActivityNvLink3__bindgen_ty_2,
    #[doc = " Flag gives capabilities of the link \\see CUpti_LinkFlag"]
    pub flag: u32,
    #[doc = " Number of physical NVLinks present between two devices."]
    pub physicalNvLinkCount: u32,
    #[doc = " Port numbers for maximum 16 NVLinks connected to device 0.\n If typeDev0 is CUPTI_DEV_TYPE_NPU, ignore this field.\n In case of invalid/unknown port number, this field will be set\n to value CUPTI_NVLINK_INVALID_PORT.\n This will be used to correlate the metric values to individual\n physical link and attribute traffic to the logical NVLink in\n the topology."]
    pub portDev0: [i8; 32usize],
    #[doc = " Port numbers for maximum 16 NVLinks connected to device 1.\n If typeDev1 is CUPTI_DEV_TYPE_NPU, ignore this field.\n In case of invalid/unknown port number, this field will be set\n to value CUPTI_NVLINK_INVALID_PORT.\n This will be used to correlate the metric values to individual\n physical link and attribute traffic to the logical NVLink in\n the topology."]
    pub portDev1: [i8; 32usize],
    #[doc = " Bandwidth of NVLink in kbytes/sec"]
    pub bandwidth: u64,
    #[doc = " NVSwitch is connected as an intermediate node."]
    pub nvswitchConnected: u8,
    #[doc = " Undefined. reserved for internal use"]
    pub pad: [u8; 7usize],
}
#[doc = " If typeDev0 is CUPTI_DEV_TYPE_GPU, UUID for device 0. \\ref CUpti_ActivityDevice5.\n If typeDev0 is CUPTI_DEV_TYPE_NPU, struct npu for NPU."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityNvLink3__bindgen_ty_1 {
    pub uuidDev: CUuuid,
    pub npu: CUpti_ActivityNvLink3__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityNvLink3__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " Index of the NPU. First index will always be zero."]
    pub index: u32,
    #[doc = " Domain ID of NPU. On Linux, this can be queried using lspci."]
    pub domainId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityNvLink3__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityNvLink3__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of CUpti_ActivityNvLink3__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityNvLink3__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: CUpti_ActivityNvLink3__bindgen_ty_1__bindgen_ty_1::index"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink3__bindgen_ty_1__bindgen_ty_1, index) - 0usize];
    ["Offset of field: CUpti_ActivityNvLink3__bindgen_ty_1__bindgen_ty_1::domainId"][::std::mem::offset_of!(
        CUpti_ActivityNvLink3__bindgen_ty_1__bindgen_ty_1,
        domainId
    ) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityNvLink3__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityNvLink3__bindgen_ty_1>() - 16usize];
    ["Alignment of CUpti_ActivityNvLink3__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityNvLink3__bindgen_ty_1>() - 4usize];
    ["Offset of field: CUpti_ActivityNvLink3__bindgen_ty_1::uuidDev"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink3__bindgen_ty_1, uuidDev) - 0usize];
    ["Offset of field: CUpti_ActivityNvLink3__bindgen_ty_1::npu"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink3__bindgen_ty_1, npu) - 0usize];
};
impl Default for CUpti_ActivityNvLink3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink3__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityNvLink3__bindgen_ty_1 {{ union }}")
    }
}
#[doc = " If typeDev1 is CUPTI_DEV_TYPE_GPU, UUID for device 1. \\ref CUpti_ActivityDevice5.\n If typeDev1 is CUPTI_DEV_TYPE_NPU, struct npu for NPU."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_ActivityNvLink3__bindgen_ty_2 {
    pub uuidDev: CUuuid,
    pub npu: CUpti_ActivityNvLink3__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_ActivityNvLink3__bindgen_ty_2__bindgen_ty_1 {
    #[doc = " Index of the NPU. First index will always be zero."]
    pub index: u32,
    #[doc = " Domain ID of NPU. On Linux, this can be queried using lspci."]
    pub domainId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityNvLink3__bindgen_ty_2__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_ActivityNvLink3__bindgen_ty_2__bindgen_ty_1>() - 8usize];
    ["Alignment of CUpti_ActivityNvLink3__bindgen_ty_2__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_ActivityNvLink3__bindgen_ty_2__bindgen_ty_1>() - 4usize];
    ["Offset of field: CUpti_ActivityNvLink3__bindgen_ty_2__bindgen_ty_1::index"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink3__bindgen_ty_2__bindgen_ty_1, index) - 0usize];
    ["Offset of field: CUpti_ActivityNvLink3__bindgen_ty_2__bindgen_ty_1::domainId"][::std::mem::offset_of!(
        CUpti_ActivityNvLink3__bindgen_ty_2__bindgen_ty_1,
        domainId
    ) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityNvLink3__bindgen_ty_2"]
        [::std::mem::size_of::<CUpti_ActivityNvLink3__bindgen_ty_2>() - 16usize];
    ["Alignment of CUpti_ActivityNvLink3__bindgen_ty_2"]
        [::std::mem::align_of::<CUpti_ActivityNvLink3__bindgen_ty_2>() - 4usize];
    ["Offset of field: CUpti_ActivityNvLink3__bindgen_ty_2::uuidDev"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink3__bindgen_ty_2, uuidDev) - 0usize];
    ["Offset of field: CUpti_ActivityNvLink3__bindgen_ty_2::npu"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink3__bindgen_ty_2, npu) - 0usize];
};
impl Default for CUpti_ActivityNvLink3__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink3__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "CUpti_ActivityNvLink3__bindgen_ty_2 {{ union }}")
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityNvLink3"][::std::mem::size_of::<CUpti_ActivityNvLink3>() - 136usize];
    ["Alignment of CUpti_ActivityNvLink3"]
        [::std::mem::align_of::<CUpti_ActivityNvLink3>() - 8usize];
    ["Offset of field: CUpti_ActivityNvLink3::kind"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink3, kind) - 0usize];
    ["Offset of field: CUpti_ActivityNvLink3::nvlinkVersion"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink3, nvlinkVersion) - 4usize];
    ["Offset of field: CUpti_ActivityNvLink3::typeDev0"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink3, typeDev0) - 8usize];
    ["Offset of field: CUpti_ActivityNvLink3::typeDev1"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink3, typeDev1) - 12usize];
    ["Offset of field: CUpti_ActivityNvLink3::idDev0"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink3, idDev0) - 16usize];
    ["Offset of field: CUpti_ActivityNvLink3::idDev1"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink3, idDev1) - 32usize];
    ["Offset of field: CUpti_ActivityNvLink3::flag"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink3, flag) - 48usize];
    ["Offset of field: CUpti_ActivityNvLink3::physicalNvLinkCount"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink3, physicalNvLinkCount) - 52usize];
    ["Offset of field: CUpti_ActivityNvLink3::portDev0"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink3, portDev0) - 56usize];
    ["Offset of field: CUpti_ActivityNvLink3::portDev1"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink3, portDev1) - 88usize];
    ["Offset of field: CUpti_ActivityNvLink3::bandwidth"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink3, bandwidth) - 120usize];
    ["Offset of field: CUpti_ActivityNvLink3::nvswitchConnected"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink3, nvswitchConnected) - 128usize];
    ["Offset of field: CUpti_ActivityNvLink3::pad"]
        [::std::mem::offset_of!(CUpti_ActivityNvLink3, pad) - 129usize];
};
impl Default for CUpti_ActivityNvLink3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityNvLink3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityNvLink3 {{ kind: {:?}, typeDev0: {:?}, typeDev1: {:?}, idDev0: {:?}, idDev1: {:?}, portDev0: {:?}, portDev1: {:?}, pad: {:?} }}",
            self.kind,
            self.typeDev0,
            self.typeDev1,
            self.idDev0,
            self.idDev1,
            self.portDev0,
            self.portDev1,
            self.pad
        )
    }
}
#[doc = " \\brief The activity record for trace of graph execution.\n\n This activity record represents execution for a graph without giving visibility\n about the execution of its nodes. This is intended to reduce overheads in tracing\n each node. The activity kind is CUPTI_ACTIVITY_KIND_GRAPH_TRACE\n Graph trace activity is now reported using CUpti_ActivityGraphTrace2 record."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityGraphTrace {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_GRAPH_TRACE"]
    pub kind: CUpti_ActivityKind,
    #[doc = " The correlation ID of the graph launch. Each graph launch is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver API activity record that launched\n the graph."]
    pub correlationId: u32,
    #[doc = " The start timestamp for the graph execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the graph."]
    pub start: u64,
    #[doc = " The end timestamp for the graph execution, in ns. A value of 0\n for both the start and end timestamps indicates that timestamp\n information could not be collected for the graph."]
    pub end: u64,
    #[doc = " The ID of the device where the graph execution is occurring."]
    pub deviceId: u32,
    #[doc = " The unique ID of the graph that is launched."]
    pub graphId: u32,
    #[doc = " The ID of the context where the graph is being launched."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the graph is being launched."]
    pub streamId: u32,
    #[doc = " This field is reserved for internal use"]
    pub reserved: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityGraphTrace"]
        [::std::mem::size_of::<CUpti_ActivityGraphTrace>() - 48usize];
    ["Alignment of CUpti_ActivityGraphTrace"]
        [::std::mem::align_of::<CUpti_ActivityGraphTrace>() - 8usize];
    ["Offset of field: CUpti_ActivityGraphTrace::kind"]
        [::std::mem::offset_of!(CUpti_ActivityGraphTrace, kind) - 0usize];
    ["Offset of field: CUpti_ActivityGraphTrace::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityGraphTrace, correlationId) - 4usize];
    ["Offset of field: CUpti_ActivityGraphTrace::start"]
        [::std::mem::offset_of!(CUpti_ActivityGraphTrace, start) - 8usize];
    ["Offset of field: CUpti_ActivityGraphTrace::end"]
        [::std::mem::offset_of!(CUpti_ActivityGraphTrace, end) - 16usize];
    ["Offset of field: CUpti_ActivityGraphTrace::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityGraphTrace, deviceId) - 24usize];
    ["Offset of field: CUpti_ActivityGraphTrace::graphId"]
        [::std::mem::offset_of!(CUpti_ActivityGraphTrace, graphId) - 28usize];
    ["Offset of field: CUpti_ActivityGraphTrace::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityGraphTrace, contextId) - 32usize];
    ["Offset of field: CUpti_ActivityGraphTrace::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityGraphTrace, streamId) - 36usize];
    ["Offset of field: CUpti_ActivityGraphTrace::reserved"]
        [::std::mem::offset_of!(CUpti_ActivityGraphTrace, reserved) - 40usize];
};
impl Default for CUpti_ActivityGraphTrace {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for a context.\n\n This activity record represents information about a context\n (CUPTI_ACTIVITY_KIND_CONTEXT).\n Context activity is now reported using CUpti_ActivityContext3 record"]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityContext {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_CONTEXT."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The context ID."]
    pub contextId: u32,
    #[doc = " The device ID."]
    pub deviceId: u32,
    #[doc = " The compute API kind. \\see CUpti_ActivityComputeApiKind"]
    pub computeApiKind: u16,
    #[doc = " The ID for the NULL stream in this context"]
    pub nullStreamId: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityContext"][::std::mem::size_of::<CUpti_ActivityContext>() - 16usize];
    ["Alignment of CUpti_ActivityContext"]
        [::std::mem::align_of::<CUpti_ActivityContext>() - 8usize];
    ["Offset of field: CUpti_ActivityContext::kind"]
        [::std::mem::offset_of!(CUpti_ActivityContext, kind) - 0usize];
    ["Offset of field: CUpti_ActivityContext::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityContext, contextId) - 4usize];
    ["Offset of field: CUpti_ActivityContext::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityContext, deviceId) - 8usize];
    ["Offset of field: CUpti_ActivityContext::computeApiKind"]
        [::std::mem::offset_of!(CUpti_ActivityContext, computeApiKind) - 12usize];
    ["Offset of field: CUpti_ActivityContext::nullStreamId"]
        [::std::mem::offset_of!(CUpti_ActivityContext, nullStreamId) - 14usize];
};
impl Default for CUpti_ActivityContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for a context.\n\n This activity record represents information about a context\n (CUPTI_ACTIVITY_KIND_CONTEXT).\n Context activity is now reported using CUpti_ActivityContext3 record"]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityContext2 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_CONTEXT."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The context ID."]
    pub contextId: u32,
    #[doc = " The device ID."]
    pub deviceId: u32,
    #[doc = " The compute API kind. \\see CUpti_ActivityComputeApiKind"]
    pub computeApiKind: u16,
    #[doc = " The ID for the NULL stream in this context"]
    pub nullStreamId: u16,
    #[doc = " The ID of the parent context. It would be 0 if\n context does not have parent"]
    pub parentContextId: u32,
    #[doc = " This field indicates whether the context is a green context"]
    pub isGreenContext: u8,
    pub padding: u8,
    #[doc = " Number of multiprocessors assigned to the green context\n Invalid if the field 'isGreenContext' is 0"]
    pub numMultiprocessors: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityContext2"][::std::mem::size_of::<CUpti_ActivityContext2>() - 24usize];
    ["Alignment of CUpti_ActivityContext2"]
        [::std::mem::align_of::<CUpti_ActivityContext2>() - 8usize];
    ["Offset of field: CUpti_ActivityContext2::kind"]
        [::std::mem::offset_of!(CUpti_ActivityContext2, kind) - 0usize];
    ["Offset of field: CUpti_ActivityContext2::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityContext2, contextId) - 4usize];
    ["Offset of field: CUpti_ActivityContext2::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityContext2, deviceId) - 8usize];
    ["Offset of field: CUpti_ActivityContext2::computeApiKind"]
        [::std::mem::offset_of!(CUpti_ActivityContext2, computeApiKind) - 12usize];
    ["Offset of field: CUpti_ActivityContext2::nullStreamId"]
        [::std::mem::offset_of!(CUpti_ActivityContext2, nullStreamId) - 14usize];
    ["Offset of field: CUpti_ActivityContext2::parentContextId"]
        [::std::mem::offset_of!(CUpti_ActivityContext2, parentContextId) - 16usize];
    ["Offset of field: CUpti_ActivityContext2::isGreenContext"]
        [::std::mem::offset_of!(CUpti_ActivityContext2, isGreenContext) - 20usize];
    ["Offset of field: CUpti_ActivityContext2::padding"]
        [::std::mem::offset_of!(CUpti_ActivityContext2, padding) - 21usize];
    ["Offset of field: CUpti_ActivityContext2::numMultiprocessors"]
        [::std::mem::offset_of!(CUpti_ActivityContext2, numMultiprocessors) - 22usize];
};
impl Default for CUpti_ActivityContext2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for JIT operations.\n This activity represents the JIT operations (compile, load, store) of a CUmodule\n from the Compute Cache.\n Gives the exact hashed path of where the cached module is loaded from,\n or where the module will be stored after Just-In-Time (JIT) compilation.\n\n JIT activity is now reported using CUpti_ActivityJit2 record"]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityJit {
    #[doc = " The activity record kind must be CUPTI_ACTIVITY_KIND_JIT."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The JIT entry type."]
    pub jitEntryType: CUpti_ActivityJitEntryType,
    #[doc = " The JIT operation type."]
    pub jitOperationType: CUpti_ActivityJitOperationType,
    #[doc = " The device ID."]
    pub deviceId: u32,
    #[doc = " The start timestamp for the JIT operation, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the JIT operation."]
    pub start: u64,
    #[doc = " The end timestamp for the JIT operation, in ns. A value of 0 for both\n the start and end timestamps indicates that timestamp information\n could not be collected for the JIT operation."]
    pub end: u64,
    #[doc = " The correlation ID of the JIT operation to which\n records belong to. Each JIT operation is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver or runtime API activity record that\n launched the JIT operation."]
    pub correlationId: u32,
    #[doc = " Internal use."]
    pub padding: u32,
    #[doc = " The correlation ID to correlate JIT compilation, load and store operations.\n Each JIT compilation unit is assigned a unique correlation ID\n at the time of the JIT compilation. This correlation id can be used\n to find the matching JIT cache load/store records."]
    pub jitOperationCorrelationId: u64,
    #[doc = " The size of compute cache."]
    pub cacheSize: u64,
    #[doc = " The path where the fat binary is cached."]
    pub cachePath: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityJit"][::std::mem::size_of::<CUpti_ActivityJit>() - 64usize];
    ["Alignment of CUpti_ActivityJit"][::std::mem::align_of::<CUpti_ActivityJit>() - 8usize];
    ["Offset of field: CUpti_ActivityJit::kind"]
        [::std::mem::offset_of!(CUpti_ActivityJit, kind) - 0usize];
    ["Offset of field: CUpti_ActivityJit::jitEntryType"]
        [::std::mem::offset_of!(CUpti_ActivityJit, jitEntryType) - 4usize];
    ["Offset of field: CUpti_ActivityJit::jitOperationType"]
        [::std::mem::offset_of!(CUpti_ActivityJit, jitOperationType) - 8usize];
    ["Offset of field: CUpti_ActivityJit::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityJit, deviceId) - 12usize];
    ["Offset of field: CUpti_ActivityJit::start"]
        [::std::mem::offset_of!(CUpti_ActivityJit, start) - 16usize];
    ["Offset of field: CUpti_ActivityJit::end"]
        [::std::mem::offset_of!(CUpti_ActivityJit, end) - 24usize];
    ["Offset of field: CUpti_ActivityJit::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityJit, correlationId) - 32usize];
    ["Offset of field: CUpti_ActivityJit::padding"]
        [::std::mem::offset_of!(CUpti_ActivityJit, padding) - 36usize];
    ["Offset of field: CUpti_ActivityJit::jitOperationCorrelationId"]
        [::std::mem::offset_of!(CUpti_ActivityJit, jitOperationCorrelationId) - 40usize];
    ["Offset of field: CUpti_ActivityJit::cacheSize"]
        [::std::mem::offset_of!(CUpti_ActivityJit, cacheSize) - 48usize];
    ["Offset of field: CUpti_ActivityJit::cachePath"]
        [::std::mem::offset_of!(CUpti_ActivityJit, cachePath) - 56usize];
};
impl Default for CUpti_ActivityJit {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for CUDA event.\n\n This activity is used to track recorded events.\n (CUPTI_ACTIVITY_KIND_CUDA_EVENT).\n\n Structure deprecated in CUDA 12.8: Refer to CUpti_ActivityCudaEvent2\n for the latest structure."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityCudaEvent {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_CUDA_EVENT."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The correlation ID of the API to which this result is associated."]
    pub correlationId: u32,
    #[doc = " The ID of the context where the event was recorded."]
    pub contextId: u32,
    #[doc = " The compute stream where the event was recorded."]
    pub streamId: u32,
    #[doc = " A unique event ID to identify the event record."]
    pub eventId: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityCudaEvent"][::std::mem::size_of::<CUpti_ActivityCudaEvent>() - 24usize];
    ["Alignment of CUpti_ActivityCudaEvent"]
        [::std::mem::align_of::<CUpti_ActivityCudaEvent>() - 8usize];
    ["Offset of field: CUpti_ActivityCudaEvent::kind"]
        [::std::mem::offset_of!(CUpti_ActivityCudaEvent, kind) - 0usize];
    ["Offset of field: CUpti_ActivityCudaEvent::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityCudaEvent, correlationId) - 4usize];
    ["Offset of field: CUpti_ActivityCudaEvent::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityCudaEvent, contextId) - 8usize];
    ["Offset of field: CUpti_ActivityCudaEvent::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityCudaEvent, streamId) - 12usize];
    ["Offset of field: CUpti_ActivityCudaEvent::eventId"]
        [::std::mem::offset_of!(CUpti_ActivityCudaEvent, eventId) - 16usize];
    ["Offset of field: CUpti_ActivityCudaEvent::pad"]
        [::std::mem::offset_of!(CUpti_ActivityCudaEvent, pad) - 20usize];
};
impl Default for CUpti_ActivityCudaEvent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for synchronization management.\n\n This activity is used to track various CUDA synchronization APIs.\n (CUPTI_ACTIVITY_KIND_SYNCHRONIZATION).\n\n Structure deprecated in CUDA 12.8: Refer to CUpti_ActivitySynchronization2\n for the latest structure."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivitySynchronization {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_SYNCHRONIZATION."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The type of record."]
    pub type_: CUpti_ActivitySynchronizationType,
    #[doc = " The start timestamp for the function, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the function."]
    pub start: u64,
    #[doc = " The end timestamp for the function, in ns. A value of 0 for both\n the start and end timestamps indicates that timestamp information\n could not be collected for the function."]
    pub end: u64,
    #[doc = " The correlation ID of the API to which this result is associated."]
    pub correlationId: u32,
    #[doc = " The ID of the context for which the synchronization API is called.\n In case of context synchronization API it is the context id for which the API is called.\n In case of stream/event synchronization it is the ID of the context where the stream/event was created."]
    pub contextId: u32,
    #[doc = " The compute stream for which the synchronization API is called.\n A CUPTI_SYNCHRONIZATION_INVALID_VALUE value indicate the field is not applicable for this record.\n Not valid for cuCtxSynchronize, cuEventSynchronize."]
    pub streamId: u32,
    #[doc = " The event ID for which the synchronization API is called.\n A CUPTI_SYNCHRONIZATION_INVALID_VALUE value indicate the field is not applicable for this record.\n Not valid for cuCtxSynchronize, cuStreamSynchronize."]
    pub cudaEventId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivitySynchronization"]
        [::std::mem::size_of::<CUpti_ActivitySynchronization>() - 40usize];
    ["Alignment of CUpti_ActivitySynchronization"]
        [::std::mem::align_of::<CUpti_ActivitySynchronization>() - 8usize];
    ["Offset of field: CUpti_ActivitySynchronization::kind"]
        [::std::mem::offset_of!(CUpti_ActivitySynchronization, kind) - 0usize];
    ["Offset of field: CUpti_ActivitySynchronization::type_"]
        [::std::mem::offset_of!(CUpti_ActivitySynchronization, type_) - 4usize];
    ["Offset of field: CUpti_ActivitySynchronization::start"]
        [::std::mem::offset_of!(CUpti_ActivitySynchronization, start) - 8usize];
    ["Offset of field: CUpti_ActivitySynchronization::end"]
        [::std::mem::offset_of!(CUpti_ActivitySynchronization, end) - 16usize];
    ["Offset of field: CUpti_ActivitySynchronization::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivitySynchronization, correlationId) - 24usize];
    ["Offset of field: CUpti_ActivitySynchronization::contextId"]
        [::std::mem::offset_of!(CUpti_ActivitySynchronization, contextId) - 28usize];
    ["Offset of field: CUpti_ActivitySynchronization::streamId"]
        [::std::mem::offset_of!(CUpti_ActivitySynchronization, streamId) - 32usize];
    ["Offset of field: CUpti_ActivitySynchronization::cudaEventId"]
        [::std::mem::offset_of!(CUpti_ActivitySynchronization, cudaEventId) - 36usize];
};
impl Default for CUpti_ActivitySynchronization {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record for memory copies.\n\n This activity record represents a memory copy\n (CUPTI_ACTIVITY_KIND_MEMCPY).\n\n Structure deprecated in CUDA 12.8: Refer to CUpti_ActivityMemcpy6\n for the latest structure."]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_ActivityMemcpy5 {
    #[doc = " The activity record kind, must be CUPTI_ACTIVITY_KIND_MEMCPY."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The kind of the memory copy, stored as a byte to reduce record\n size. \\see CUpti_ActivityMemcpyKind"]
    pub copyKind: u8,
    #[doc = " The source memory kind read by the memory copy, stored as a byte\n to reduce record size. \\see CUpti_ActivityMemoryKind"]
    pub srcKind: u8,
    #[doc = " The destination memory kind read by the memory copy, stored as a\n byte to reduce record size. \\see CUpti_ActivityMemoryKind"]
    pub dstKind: u8,
    #[doc = " The flags associated with the memory copy. \\see CUpti_ActivityFlag"]
    pub flags: u8,
    #[doc = " The number of bytes transferred by the memory copy."]
    pub bytes: u64,
    #[doc = " The start timestamp for the memory copy, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory copy."]
    pub start: u64,
    #[doc = " The end timestamp for the memory copy, in ns. A value of 0 for\n both the start and end timestamps indicates that timestamp\n information could not be collected for the memory copy."]
    pub end: u64,
    #[doc = " The ID of the device where the memory copy is occurring."]
    pub deviceId: u32,
    #[doc = " The ID of the context where the memory copy is occurring."]
    pub contextId: u32,
    #[doc = " The ID of the stream where the memory copy is occurring."]
    pub streamId: u32,
    #[doc = " The correlation ID of the memory copy. Each memory copy is\n assigned a unique correlation ID that is identical to the\n correlation ID in the driver API activity record that launched\n the memory copy."]
    pub correlationId: u32,
    #[doc = " The runtime correlation ID of the memory copy. Each memory copy\n is assigned a unique runtime correlation ID that is identical to\n the correlation ID in the runtime API activity record that\n launched the memory copy."]
    pub runtimeCorrelationId: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub pad: u32,
    #[doc = " Undefined. Reserved for internal use."]
    pub reserved0: *mut ::std::os::raw::c_void,
    #[doc = " The unique ID of the graph node that executed this memcpy through graph launch.\n This field will be 0 if the memcpy is not done through graph launch."]
    pub graphNodeId: u64,
    #[doc = " The unique ID of the graph that executed this memcpy through graph launch.\n This field will be 0 if the memcpy is not done through graph launch."]
    pub graphId: u32,
    #[doc = " The ID of the HW channel on which the memory copy is occurring."]
    pub channelID: u32,
    #[doc = " The type of the channel"]
    pub channelType: CUpti_ChannelType,
    #[doc = "  Reserved for internal use."]
    pub pad2: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMemcpy5"][::std::mem::size_of::<CUpti_ActivityMemcpy5>() - 88usize];
    ["Alignment of CUpti_ActivityMemcpy5"]
        [::std::mem::align_of::<CUpti_ActivityMemcpy5>() - 8usize];
    ["Offset of field: CUpti_ActivityMemcpy5::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy5, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMemcpy5::copyKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy5, copyKind) - 4usize];
    ["Offset of field: CUpti_ActivityMemcpy5::srcKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy5, srcKind) - 5usize];
    ["Offset of field: CUpti_ActivityMemcpy5::dstKind"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy5, dstKind) - 6usize];
    ["Offset of field: CUpti_ActivityMemcpy5::flags"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy5, flags) - 7usize];
    ["Offset of field: CUpti_ActivityMemcpy5::bytes"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy5, bytes) - 8usize];
    ["Offset of field: CUpti_ActivityMemcpy5::start"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy5, start) - 16usize];
    ["Offset of field: CUpti_ActivityMemcpy5::end"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy5, end) - 24usize];
    ["Offset of field: CUpti_ActivityMemcpy5::deviceId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy5, deviceId) - 32usize];
    ["Offset of field: CUpti_ActivityMemcpy5::contextId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy5, contextId) - 36usize];
    ["Offset of field: CUpti_ActivityMemcpy5::streamId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy5, streamId) - 40usize];
    ["Offset of field: CUpti_ActivityMemcpy5::correlationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy5, correlationId) - 44usize];
    ["Offset of field: CUpti_ActivityMemcpy5::runtimeCorrelationId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy5, runtimeCorrelationId) - 48usize];
    ["Offset of field: CUpti_ActivityMemcpy5::pad"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy5, pad) - 52usize];
    ["Offset of field: CUpti_ActivityMemcpy5::reserved0"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy5, reserved0) - 56usize];
    ["Offset of field: CUpti_ActivityMemcpy5::graphNodeId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy5, graphNodeId) - 64usize];
    ["Offset of field: CUpti_ActivityMemcpy5::graphId"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy5, graphId) - 72usize];
    ["Offset of field: CUpti_ActivityMemcpy5::channelID"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy5, channelID) - 76usize];
    ["Offset of field: CUpti_ActivityMemcpy5::channelType"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy5, channelType) - 80usize];
    ["Offset of field: CUpti_ActivityMemcpy5::pad2"]
        [::std::mem::offset_of!(CUpti_ActivityMemcpy5, pad2) - 84usize];
};
impl Default for CUpti_ActivityMemcpy5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief The activity record providing detailed information for a marker.\n\n User must enable CUPTI_ACTIVITY_KIND_MARKER as well\n to get records for marker data.\n The marker data contains color, payload, and category.\n (CUPTI_ACTIVITY_KIND_MARKER_DATA).\n\n Structure deprecated in CUDA 13.1: Refer to CUpti_ActivityMarkerData2\n for the latest structure."]
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct CUpti_ActivityMarkerData {
    #[doc = " The activity record kind, must be\n CUPTI_ACTIVITY_KIND_MARKER_DATA."]
    pub kind: CUpti_ActivityKind,
    #[doc = " The flags associated with the marker. \\see CUpti_ActivityFlag"]
    pub flags: CUpti_ActivityFlag,
    #[doc = " The marker ID."]
    pub id: u32,
    #[doc = " Defines the payload format for the value associated with the marker."]
    pub payloadKind: CUpti_MetricValueKind,
    #[doc = " The payload value."]
    pub payload: CUpti_MetricValue,
    #[doc = " The color for the marker."]
    pub color: u32,
    #[doc = " The category for the marker."]
    pub category: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_ActivityMarkerData"]
        [::std::mem::size_of::<CUpti_ActivityMarkerData>() - 32usize];
    ["Alignment of CUpti_ActivityMarkerData"]
        [::std::mem::align_of::<CUpti_ActivityMarkerData>() - 8usize];
    ["Offset of field: CUpti_ActivityMarkerData::kind"]
        [::std::mem::offset_of!(CUpti_ActivityMarkerData, kind) - 0usize];
    ["Offset of field: CUpti_ActivityMarkerData::flags"]
        [::std::mem::offset_of!(CUpti_ActivityMarkerData, flags) - 4usize];
    ["Offset of field: CUpti_ActivityMarkerData::id"]
        [::std::mem::offset_of!(CUpti_ActivityMarkerData, id) - 8usize];
    ["Offset of field: CUpti_ActivityMarkerData::payloadKind"]
        [::std::mem::offset_of!(CUpti_ActivityMarkerData, payloadKind) - 12usize];
    ["Offset of field: CUpti_ActivityMarkerData::payload"]
        [::std::mem::offset_of!(CUpti_ActivityMarkerData, payload) - 16usize];
    ["Offset of field: CUpti_ActivityMarkerData::color"]
        [::std::mem::offset_of!(CUpti_ActivityMarkerData, color) - 24usize];
    ["Offset of field: CUpti_ActivityMarkerData::category"]
        [::std::mem::offset_of!(CUpti_ActivityMarkerData, category) - 28usize];
};
impl Default for CUpti_ActivityMarkerData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_ActivityMarkerData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_ActivityMarkerData {{ kind: {:?}, flags: {:?}, payloadKind: {:?}, payload: {:?} }}",
            self.kind, self.flags, self.payloadKind, self.payload
        )
    }
}
pub const CUPTI_DRIVER_TRACE_CBID_INVALID: CUpti_driver_api_trace_cbid_enum = 0;
pub const CUPTI_DRIVER_TRACE_CBID_cuInit: CUpti_driver_api_trace_cbid_enum = 1;
pub const CUPTI_DRIVER_TRACE_CBID_cuDriverGetVersion: CUpti_driver_api_trace_cbid_enum = 2;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGet: CUpti_driver_api_trace_cbid_enum = 3;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetCount: CUpti_driver_api_trace_cbid_enum = 4;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetName: CUpti_driver_api_trace_cbid_enum = 5;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceComputeCapability: CUpti_driver_api_trace_cbid_enum = 6;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceTotalMem: CUpti_driver_api_trace_cbid_enum = 7;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetProperties: CUpti_driver_api_trace_cbid_enum = 8;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetAttribute: CUpti_driver_api_trace_cbid_enum = 9;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxCreate: CUpti_driver_api_trace_cbid_enum = 10;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxDestroy: CUpti_driver_api_trace_cbid_enum = 11;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxAttach: CUpti_driver_api_trace_cbid_enum = 12;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxDetach: CUpti_driver_api_trace_cbid_enum = 13;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxPushCurrent: CUpti_driver_api_trace_cbid_enum = 14;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxPopCurrent: CUpti_driver_api_trace_cbid_enum = 15;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetDevice: CUpti_driver_api_trace_cbid_enum = 16;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxSynchronize: CUpti_driver_api_trace_cbid_enum = 17;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleLoad: CUpti_driver_api_trace_cbid_enum = 18;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleLoadData: CUpti_driver_api_trace_cbid_enum = 19;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleLoadDataEx: CUpti_driver_api_trace_cbid_enum = 20;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleLoadFatBinary: CUpti_driver_api_trace_cbid_enum = 21;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleUnload: CUpti_driver_api_trace_cbid_enum = 22;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleGetFunction: CUpti_driver_api_trace_cbid_enum = 23;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleGetGlobal: CUpti_driver_api_trace_cbid_enum = 24;
pub const CUPTI_DRIVER_TRACE_CBID_cu64ModuleGetGlobal: CUpti_driver_api_trace_cbid_enum = 25;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleGetTexRef: CUpti_driver_api_trace_cbid_enum = 26;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemGetInfo: CUpti_driver_api_trace_cbid_enum = 27;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemGetInfo: CUpti_driver_api_trace_cbid_enum = 28;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAlloc: CUpti_driver_api_trace_cbid_enum = 29;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemAlloc: CUpti_driver_api_trace_cbid_enum = 30;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAllocPitch: CUpti_driver_api_trace_cbid_enum = 31;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemAllocPitch: CUpti_driver_api_trace_cbid_enum = 32;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemFree: CUpti_driver_api_trace_cbid_enum = 33;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemFree: CUpti_driver_api_trace_cbid_enum = 34;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemGetAddressRange: CUpti_driver_api_trace_cbid_enum = 35;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemGetAddressRange: CUpti_driver_api_trace_cbid_enum = 36;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAllocHost: CUpti_driver_api_trace_cbid_enum = 37;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemFreeHost: CUpti_driver_api_trace_cbid_enum = 38;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemHostAlloc: CUpti_driver_api_trace_cbid_enum = 39;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemHostGetDevicePointer: CUpti_driver_api_trace_cbid_enum = 40;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemHostGetDevicePointer: CUpti_driver_api_trace_cbid_enum =
    41;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemHostGetFlags: CUpti_driver_api_trace_cbid_enum = 42;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoD: CUpti_driver_api_trace_cbid_enum = 43;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemcpyHtoD: CUpti_driver_api_trace_cbid_enum = 44;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoH: CUpti_driver_api_trace_cbid_enum = 45;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemcpyDtoH: CUpti_driver_api_trace_cbid_enum = 46;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoD: CUpti_driver_api_trace_cbid_enum = 47;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemcpyDtoD: CUpti_driver_api_trace_cbid_enum = 48;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoA: CUpti_driver_api_trace_cbid_enum = 49;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemcpyDtoA: CUpti_driver_api_trace_cbid_enum = 50;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoD: CUpti_driver_api_trace_cbid_enum = 51;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemcpyAtoD: CUpti_driver_api_trace_cbid_enum = 52;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoA: CUpti_driver_api_trace_cbid_enum = 53;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoH: CUpti_driver_api_trace_cbid_enum = 54;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoA: CUpti_driver_api_trace_cbid_enum = 55;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy2D: CUpti_driver_api_trace_cbid_enum = 56;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy2DUnaligned: CUpti_driver_api_trace_cbid_enum = 57;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3D: CUpti_driver_api_trace_cbid_enum = 58;
pub const CUPTI_DRIVER_TRACE_CBID_cu64Memcpy3D: CUpti_driver_api_trace_cbid_enum = 59;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoDAsync: CUpti_driver_api_trace_cbid_enum = 60;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemcpyHtoDAsync: CUpti_driver_api_trace_cbid_enum = 61;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoHAsync: CUpti_driver_api_trace_cbid_enum = 62;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemcpyDtoHAsync: CUpti_driver_api_trace_cbid_enum = 63;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoDAsync: CUpti_driver_api_trace_cbid_enum = 64;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemcpyDtoDAsync: CUpti_driver_api_trace_cbid_enum = 65;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoAAsync: CUpti_driver_api_trace_cbid_enum = 66;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoHAsync: CUpti_driver_api_trace_cbid_enum = 67;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy2DAsync: CUpti_driver_api_trace_cbid_enum = 68;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3DAsync: CUpti_driver_api_trace_cbid_enum = 69;
pub const CUPTI_DRIVER_TRACE_CBID_cu64Memcpy3DAsync: CUpti_driver_api_trace_cbid_enum = 70;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD8: CUpti_driver_api_trace_cbid_enum = 71;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD8: CUpti_driver_api_trace_cbid_enum = 72;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD16: CUpti_driver_api_trace_cbid_enum = 73;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD16: CUpti_driver_api_trace_cbid_enum = 74;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD32: CUpti_driver_api_trace_cbid_enum = 75;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD32: CUpti_driver_api_trace_cbid_enum = 76;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D8: CUpti_driver_api_trace_cbid_enum = 77;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD2D8: CUpti_driver_api_trace_cbid_enum = 78;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D16: CUpti_driver_api_trace_cbid_enum = 79;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD2D16: CUpti_driver_api_trace_cbid_enum = 80;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D32: CUpti_driver_api_trace_cbid_enum = 81;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD2D32: CUpti_driver_api_trace_cbid_enum = 82;
pub const CUPTI_DRIVER_TRACE_CBID_cuFuncSetBlockShape: CUpti_driver_api_trace_cbid_enum = 83;
pub const CUPTI_DRIVER_TRACE_CBID_cuFuncSetSharedSize: CUpti_driver_api_trace_cbid_enum = 84;
pub const CUPTI_DRIVER_TRACE_CBID_cuFuncGetAttribute: CUpti_driver_api_trace_cbid_enum = 85;
pub const CUPTI_DRIVER_TRACE_CBID_cuFuncSetCacheConfig: CUpti_driver_api_trace_cbid_enum = 86;
pub const CUPTI_DRIVER_TRACE_CBID_cuArrayCreate: CUpti_driver_api_trace_cbid_enum = 87;
pub const CUPTI_DRIVER_TRACE_CBID_cuArrayGetDescriptor: CUpti_driver_api_trace_cbid_enum = 88;
pub const CUPTI_DRIVER_TRACE_CBID_cuArrayDestroy: CUpti_driver_api_trace_cbid_enum = 89;
pub const CUPTI_DRIVER_TRACE_CBID_cuArray3DCreate: CUpti_driver_api_trace_cbid_enum = 90;
pub const CUPTI_DRIVER_TRACE_CBID_cuArray3DGetDescriptor: CUpti_driver_api_trace_cbid_enum = 91;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefCreate: CUpti_driver_api_trace_cbid_enum = 92;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefDestroy: CUpti_driver_api_trace_cbid_enum = 93;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetArray: CUpti_driver_api_trace_cbid_enum = 94;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetAddress: CUpti_driver_api_trace_cbid_enum = 95;
pub const CUPTI_DRIVER_TRACE_CBID_cu64TexRefSetAddress: CUpti_driver_api_trace_cbid_enum = 96;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetAddress2D: CUpti_driver_api_trace_cbid_enum = 97;
pub const CUPTI_DRIVER_TRACE_CBID_cu64TexRefSetAddress2D: CUpti_driver_api_trace_cbid_enum = 98;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetFormat: CUpti_driver_api_trace_cbid_enum = 99;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetAddressMode: CUpti_driver_api_trace_cbid_enum = 100;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetFilterMode: CUpti_driver_api_trace_cbid_enum = 101;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetFlags: CUpti_driver_api_trace_cbid_enum = 102;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetAddress: CUpti_driver_api_trace_cbid_enum = 103;
pub const CUPTI_DRIVER_TRACE_CBID_cu64TexRefGetAddress: CUpti_driver_api_trace_cbid_enum = 104;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetArray: CUpti_driver_api_trace_cbid_enum = 105;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetAddressMode: CUpti_driver_api_trace_cbid_enum = 106;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetFilterMode: CUpti_driver_api_trace_cbid_enum = 107;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetFormat: CUpti_driver_api_trace_cbid_enum = 108;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetFlags: CUpti_driver_api_trace_cbid_enum = 109;
pub const CUPTI_DRIVER_TRACE_CBID_cuParamSetSize: CUpti_driver_api_trace_cbid_enum = 110;
pub const CUPTI_DRIVER_TRACE_CBID_cuParamSeti: CUpti_driver_api_trace_cbid_enum = 111;
pub const CUPTI_DRIVER_TRACE_CBID_cuParamSetf: CUpti_driver_api_trace_cbid_enum = 112;
pub const CUPTI_DRIVER_TRACE_CBID_cuParamSetv: CUpti_driver_api_trace_cbid_enum = 113;
pub const CUPTI_DRIVER_TRACE_CBID_cuParamSetTexRef: CUpti_driver_api_trace_cbid_enum = 114;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunch: CUpti_driver_api_trace_cbid_enum = 115;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunchGrid: CUpti_driver_api_trace_cbid_enum = 116;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunchGridAsync: CUpti_driver_api_trace_cbid_enum = 117;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventCreate: CUpti_driver_api_trace_cbid_enum = 118;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventRecord: CUpti_driver_api_trace_cbid_enum = 119;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventQuery: CUpti_driver_api_trace_cbid_enum = 120;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventSynchronize: CUpti_driver_api_trace_cbid_enum = 121;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventDestroy: CUpti_driver_api_trace_cbid_enum = 122;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventElapsedTime: CUpti_driver_api_trace_cbid_enum = 123;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamCreate: CUpti_driver_api_trace_cbid_enum = 124;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamQuery: CUpti_driver_api_trace_cbid_enum = 125;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamSynchronize: CUpti_driver_api_trace_cbid_enum = 126;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamDestroy: CUpti_driver_api_trace_cbid_enum = 127;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsUnregisterResource: CUpti_driver_api_trace_cbid_enum =
    128;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsSubResourceGetMappedArray:
    CUpti_driver_api_trace_cbid_enum = 129;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsResourceGetMappedPointer:
    CUpti_driver_api_trace_cbid_enum = 130;
pub const CUPTI_DRIVER_TRACE_CBID_cu64GraphicsResourceGetMappedPointer:
    CUpti_driver_api_trace_cbid_enum = 131;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsResourceSetMapFlags: CUpti_driver_api_trace_cbid_enum =
    132;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsMapResources: CUpti_driver_api_trace_cbid_enum = 133;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsUnmapResources: CUpti_driver_api_trace_cbid_enum = 134;
pub const CUPTI_DRIVER_TRACE_CBID_cuGetExportTable: CUpti_driver_api_trace_cbid_enum = 135;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxSetLimit: CUpti_driver_api_trace_cbid_enum = 136;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetLimit: CUpti_driver_api_trace_cbid_enum = 137;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10GetDevice: CUpti_driver_api_trace_cbid_enum = 138;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10CtxCreate: CUpti_driver_api_trace_cbid_enum = 139;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsD3D10RegisterResource:
    CUpti_driver_api_trace_cbid_enum = 140;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10RegisterResource: CUpti_driver_api_trace_cbid_enum = 141;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10UnregisterResource: CUpti_driver_api_trace_cbid_enum = 142;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10MapResources: CUpti_driver_api_trace_cbid_enum = 143;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10UnmapResources: CUpti_driver_api_trace_cbid_enum = 144;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10ResourceSetMapFlags: CUpti_driver_api_trace_cbid_enum =
    145;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10ResourceGetMappedArray: CUpti_driver_api_trace_cbid_enum =
    146;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10ResourceGetMappedPointer:
    CUpti_driver_api_trace_cbid_enum = 147;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10ResourceGetMappedSize: CUpti_driver_api_trace_cbid_enum =
    148;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10ResourceGetMappedPitch: CUpti_driver_api_trace_cbid_enum =
    149;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10ResourceGetSurfaceDimensions:
    CUpti_driver_api_trace_cbid_enum = 150;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D11GetDevice: CUpti_driver_api_trace_cbid_enum = 151;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D11CtxCreate: CUpti_driver_api_trace_cbid_enum = 152;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsD3D11RegisterResource:
    CUpti_driver_api_trace_cbid_enum = 153;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9GetDevice: CUpti_driver_api_trace_cbid_enum = 154;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9CtxCreate: CUpti_driver_api_trace_cbid_enum = 155;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsD3D9RegisterResource: CUpti_driver_api_trace_cbid_enum =
    156;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9GetDirect3DDevice: CUpti_driver_api_trace_cbid_enum = 157;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9RegisterResource: CUpti_driver_api_trace_cbid_enum = 158;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9UnregisterResource: CUpti_driver_api_trace_cbid_enum = 159;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9MapResources: CUpti_driver_api_trace_cbid_enum = 160;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9UnmapResources: CUpti_driver_api_trace_cbid_enum = 161;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9ResourceSetMapFlags: CUpti_driver_api_trace_cbid_enum = 162;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9ResourceGetSurfaceDimensions:
    CUpti_driver_api_trace_cbid_enum = 163;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9ResourceGetMappedArray: CUpti_driver_api_trace_cbid_enum =
    164;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9ResourceGetMappedPointer: CUpti_driver_api_trace_cbid_enum =
    165;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9ResourceGetMappedSize: CUpti_driver_api_trace_cbid_enum =
    166;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9ResourceGetMappedPitch: CUpti_driver_api_trace_cbid_enum =
    167;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9Begin: CUpti_driver_api_trace_cbid_enum = 168;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9End: CUpti_driver_api_trace_cbid_enum = 169;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9RegisterVertexBuffer: CUpti_driver_api_trace_cbid_enum =
    170;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9MapVertexBuffer: CUpti_driver_api_trace_cbid_enum = 171;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9UnmapVertexBuffer: CUpti_driver_api_trace_cbid_enum = 172;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9UnregisterVertexBuffer: CUpti_driver_api_trace_cbid_enum =
    173;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLCtxCreate: CUpti_driver_api_trace_cbid_enum = 174;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsGLRegisterBuffer: CUpti_driver_api_trace_cbid_enum =
    175;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsGLRegisterImage: CUpti_driver_api_trace_cbid_enum = 176;
pub const CUPTI_DRIVER_TRACE_CBID_cuWGLGetDevice: CUpti_driver_api_trace_cbid_enum = 177;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLInit: CUpti_driver_api_trace_cbid_enum = 178;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLRegisterBufferObject: CUpti_driver_api_trace_cbid_enum = 179;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLMapBufferObject: CUpti_driver_api_trace_cbid_enum = 180;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLUnmapBufferObject: CUpti_driver_api_trace_cbid_enum = 181;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLUnregisterBufferObject: CUpti_driver_api_trace_cbid_enum =
    182;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLSetBufferObjectMapFlags: CUpti_driver_api_trace_cbid_enum =
    183;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLMapBufferObjectAsync: CUpti_driver_api_trace_cbid_enum = 184;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLUnmapBufferObjectAsync: CUpti_driver_api_trace_cbid_enum =
    185;
pub const CUPTI_DRIVER_TRACE_CBID_cuVDPAUGetDevice: CUpti_driver_api_trace_cbid_enum = 186;
pub const CUPTI_DRIVER_TRACE_CBID_cuVDPAUCtxCreate: CUpti_driver_api_trace_cbid_enum = 187;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsVDPAURegisterVideoSurface:
    CUpti_driver_api_trace_cbid_enum = 188;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsVDPAURegisterOutputSurface:
    CUpti_driver_api_trace_cbid_enum = 189;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleGetSurfRef: CUpti_driver_api_trace_cbid_enum = 190;
pub const CUPTI_DRIVER_TRACE_CBID_cuSurfRefCreate: CUpti_driver_api_trace_cbid_enum = 191;
pub const CUPTI_DRIVER_TRACE_CBID_cuSurfRefDestroy: CUpti_driver_api_trace_cbid_enum = 192;
pub const CUPTI_DRIVER_TRACE_CBID_cuSurfRefSetFormat: CUpti_driver_api_trace_cbid_enum = 193;
pub const CUPTI_DRIVER_TRACE_CBID_cuSurfRefSetArray: CUpti_driver_api_trace_cbid_enum = 194;
pub const CUPTI_DRIVER_TRACE_CBID_cuSurfRefGetFormat: CUpti_driver_api_trace_cbid_enum = 195;
pub const CUPTI_DRIVER_TRACE_CBID_cuSurfRefGetArray: CUpti_driver_api_trace_cbid_enum = 196;
pub const CUPTI_DRIVER_TRACE_CBID_cu64DeviceTotalMem: CUpti_driver_api_trace_cbid_enum = 197;
pub const CUPTI_DRIVER_TRACE_CBID_cu64D3D10ResourceGetMappedPointer:
    CUpti_driver_api_trace_cbid_enum = 198;
pub const CUPTI_DRIVER_TRACE_CBID_cu64D3D10ResourceGetMappedSize: CUpti_driver_api_trace_cbid_enum =
    199;
pub const CUPTI_DRIVER_TRACE_CBID_cu64D3D10ResourceGetMappedPitch:
    CUpti_driver_api_trace_cbid_enum = 200;
pub const CUPTI_DRIVER_TRACE_CBID_cu64D3D10ResourceGetSurfaceDimensions:
    CUpti_driver_api_trace_cbid_enum = 201;
pub const CUPTI_DRIVER_TRACE_CBID_cu64D3D9ResourceGetSurfaceDimensions:
    CUpti_driver_api_trace_cbid_enum = 202;
pub const CUPTI_DRIVER_TRACE_CBID_cu64D3D9ResourceGetMappedPointer:
    CUpti_driver_api_trace_cbid_enum = 203;
pub const CUPTI_DRIVER_TRACE_CBID_cu64D3D9ResourceGetMappedSize: CUpti_driver_api_trace_cbid_enum =
    204;
pub const CUPTI_DRIVER_TRACE_CBID_cu64D3D9ResourceGetMappedPitch: CUpti_driver_api_trace_cbid_enum =
    205;
pub const CUPTI_DRIVER_TRACE_CBID_cu64D3D9MapVertexBuffer: CUpti_driver_api_trace_cbid_enum = 206;
pub const CUPTI_DRIVER_TRACE_CBID_cu64GLMapBufferObject: CUpti_driver_api_trace_cbid_enum = 207;
pub const CUPTI_DRIVER_TRACE_CBID_cu64GLMapBufferObjectAsync: CUpti_driver_api_trace_cbid_enum =
    208;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D11GetDevices: CUpti_driver_api_trace_cbid_enum = 209;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D11CtxCreateOnDevice: CUpti_driver_api_trace_cbid_enum = 210;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10GetDevices: CUpti_driver_api_trace_cbid_enum = 211;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10CtxCreateOnDevice: CUpti_driver_api_trace_cbid_enum = 212;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9GetDevices: CUpti_driver_api_trace_cbid_enum = 213;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9CtxCreateOnDevice: CUpti_driver_api_trace_cbid_enum = 214;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemHostAlloc: CUpti_driver_api_trace_cbid_enum = 215;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD8Async: CUpti_driver_api_trace_cbid_enum = 216;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD8Async: CUpti_driver_api_trace_cbid_enum = 217;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD16Async: CUpti_driver_api_trace_cbid_enum = 218;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD16Async: CUpti_driver_api_trace_cbid_enum = 219;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD32Async: CUpti_driver_api_trace_cbid_enum = 220;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD32Async: CUpti_driver_api_trace_cbid_enum = 221;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D8Async: CUpti_driver_api_trace_cbid_enum = 222;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD2D8Async: CUpti_driver_api_trace_cbid_enum = 223;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D16Async: CUpti_driver_api_trace_cbid_enum = 224;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD2D16Async: CUpti_driver_api_trace_cbid_enum = 225;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D32Async: CUpti_driver_api_trace_cbid_enum = 226;
pub const CUPTI_DRIVER_TRACE_CBID_cu64MemsetD2D32Async: CUpti_driver_api_trace_cbid_enum = 227;
pub const CUPTI_DRIVER_TRACE_CBID_cu64ArrayCreate: CUpti_driver_api_trace_cbid_enum = 228;
pub const CUPTI_DRIVER_TRACE_CBID_cu64ArrayGetDescriptor: CUpti_driver_api_trace_cbid_enum = 229;
pub const CUPTI_DRIVER_TRACE_CBID_cu64Array3DCreate: CUpti_driver_api_trace_cbid_enum = 230;
pub const CUPTI_DRIVER_TRACE_CBID_cu64Array3DGetDescriptor: CUpti_driver_api_trace_cbid_enum = 231;
pub const CUPTI_DRIVER_TRACE_CBID_cu64Memcpy2D: CUpti_driver_api_trace_cbid_enum = 232;
pub const CUPTI_DRIVER_TRACE_CBID_cu64Memcpy2DUnaligned: CUpti_driver_api_trace_cbid_enum = 233;
pub const CUPTI_DRIVER_TRACE_CBID_cu64Memcpy2DAsync: CUpti_driver_api_trace_cbid_enum = 234;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxCreate_v2: CUpti_driver_api_trace_cbid_enum = 235;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10CtxCreate_v2: CUpti_driver_api_trace_cbid_enum = 236;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D11CtxCreate_v2: CUpti_driver_api_trace_cbid_enum = 237;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9CtxCreate_v2: CUpti_driver_api_trace_cbid_enum = 238;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLCtxCreate_v2: CUpti_driver_api_trace_cbid_enum = 239;
pub const CUPTI_DRIVER_TRACE_CBID_cuVDPAUCtxCreate_v2: CUpti_driver_api_trace_cbid_enum = 240;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleGetGlobal_v2: CUpti_driver_api_trace_cbid_enum = 241;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemGetInfo_v2: CUpti_driver_api_trace_cbid_enum = 242;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAlloc_v2: CUpti_driver_api_trace_cbid_enum = 243;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAllocPitch_v2: CUpti_driver_api_trace_cbid_enum = 244;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemFree_v2: CUpti_driver_api_trace_cbid_enum = 245;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemGetAddressRange_v2: CUpti_driver_api_trace_cbid_enum = 246;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemHostGetDevicePointer_v2: CUpti_driver_api_trace_cbid_enum =
    247;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy_v2: CUpti_driver_api_trace_cbid_enum = 248;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD8_v2: CUpti_driver_api_trace_cbid_enum = 249;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD16_v2: CUpti_driver_api_trace_cbid_enum = 250;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD32_v2: CUpti_driver_api_trace_cbid_enum = 251;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D8_v2: CUpti_driver_api_trace_cbid_enum = 252;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D16_v2: CUpti_driver_api_trace_cbid_enum = 253;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D32_v2: CUpti_driver_api_trace_cbid_enum = 254;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetAddress_v2: CUpti_driver_api_trace_cbid_enum = 255;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetAddress2D_v2: CUpti_driver_api_trace_cbid_enum = 256;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetAddress_v2: CUpti_driver_api_trace_cbid_enum = 257;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsResourceGetMappedPointer_v2:
    CUpti_driver_api_trace_cbid_enum = 258;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceTotalMem_v2: CUpti_driver_api_trace_cbid_enum = 259;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10ResourceGetMappedPointer_v2:
    CUpti_driver_api_trace_cbid_enum = 260;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10ResourceGetMappedSize_v2:
    CUpti_driver_api_trace_cbid_enum = 261;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10ResourceGetMappedPitch_v2:
    CUpti_driver_api_trace_cbid_enum = 262;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10ResourceGetSurfaceDimensions_v2:
    CUpti_driver_api_trace_cbid_enum = 263;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9ResourceGetSurfaceDimensions_v2:
    CUpti_driver_api_trace_cbid_enum = 264;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9ResourceGetMappedPointer_v2:
    CUpti_driver_api_trace_cbid_enum = 265;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9ResourceGetMappedSize_v2: CUpti_driver_api_trace_cbid_enum =
    266;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9ResourceGetMappedPitch_v2:
    CUpti_driver_api_trace_cbid_enum = 267;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D9MapVertexBuffer_v2: CUpti_driver_api_trace_cbid_enum = 268;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLMapBufferObject_v2: CUpti_driver_api_trace_cbid_enum = 269;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLMapBufferObjectAsync_v2: CUpti_driver_api_trace_cbid_enum =
    270;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemHostAlloc_v2: CUpti_driver_api_trace_cbid_enum = 271;
pub const CUPTI_DRIVER_TRACE_CBID_cuArrayCreate_v2: CUpti_driver_api_trace_cbid_enum = 272;
pub const CUPTI_DRIVER_TRACE_CBID_cuArrayGetDescriptor_v2: CUpti_driver_api_trace_cbid_enum = 273;
pub const CUPTI_DRIVER_TRACE_CBID_cuArray3DCreate_v2: CUpti_driver_api_trace_cbid_enum = 274;
pub const CUPTI_DRIVER_TRACE_CBID_cuArray3DGetDescriptor_v2: CUpti_driver_api_trace_cbid_enum = 275;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoD_v2: CUpti_driver_api_trace_cbid_enum = 276;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoDAsync_v2: CUpti_driver_api_trace_cbid_enum = 277;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoH_v2: CUpti_driver_api_trace_cbid_enum = 278;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoHAsync_v2: CUpti_driver_api_trace_cbid_enum = 279;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoD_v2: CUpti_driver_api_trace_cbid_enum = 280;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoDAsync_v2: CUpti_driver_api_trace_cbid_enum = 281;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoH_v2: CUpti_driver_api_trace_cbid_enum = 282;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoHAsync_v2: CUpti_driver_api_trace_cbid_enum = 283;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoD_v2: CUpti_driver_api_trace_cbid_enum = 284;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoA_v2: CUpti_driver_api_trace_cbid_enum = 285;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoA_v2: CUpti_driver_api_trace_cbid_enum = 286;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy2D_v2: CUpti_driver_api_trace_cbid_enum = 287;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy2DUnaligned_v2: CUpti_driver_api_trace_cbid_enum = 288;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy2DAsync_v2: CUpti_driver_api_trace_cbid_enum = 289;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3D_v2: CUpti_driver_api_trace_cbid_enum = 290;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3DAsync_v2: CUpti_driver_api_trace_cbid_enum = 291;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoA_v2: CUpti_driver_api_trace_cbid_enum = 292;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoAAsync_v2: CUpti_driver_api_trace_cbid_enum = 293;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAllocHost_v2: CUpti_driver_api_trace_cbid_enum = 294;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWaitEvent: CUpti_driver_api_trace_cbid_enum = 295;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetApiVersion: CUpti_driver_api_trace_cbid_enum = 296;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D10GetDirect3DDevice: CUpti_driver_api_trace_cbid_enum = 297;
pub const CUPTI_DRIVER_TRACE_CBID_cuD3D11GetDirect3DDevice: CUpti_driver_api_trace_cbid_enum = 298;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetCacheConfig: CUpti_driver_api_trace_cbid_enum = 299;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxSetCacheConfig: CUpti_driver_api_trace_cbid_enum = 300;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemHostRegister: CUpti_driver_api_trace_cbid_enum = 301;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemHostUnregister: CUpti_driver_api_trace_cbid_enum = 302;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxSetCurrent: CUpti_driver_api_trace_cbid_enum = 303;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetCurrent: CUpti_driver_api_trace_cbid_enum = 304;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy: CUpti_driver_api_trace_cbid_enum = 305;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAsync: CUpti_driver_api_trace_cbid_enum = 306;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunchKernel: CUpti_driver_api_trace_cbid_enum = 307;
pub const CUPTI_DRIVER_TRACE_CBID_cuProfilerStart: CUpti_driver_api_trace_cbid_enum = 308;
pub const CUPTI_DRIVER_TRACE_CBID_cuProfilerStop: CUpti_driver_api_trace_cbid_enum = 309;
pub const CUPTI_DRIVER_TRACE_CBID_cuPointerGetAttribute: CUpti_driver_api_trace_cbid_enum = 310;
pub const CUPTI_DRIVER_TRACE_CBID_cuProfilerInitialize: CUpti_driver_api_trace_cbid_enum = 311;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceCanAccessPeer: CUpti_driver_api_trace_cbid_enum = 312;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxEnablePeerAccess: CUpti_driver_api_trace_cbid_enum = 313;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxDisablePeerAccess: CUpti_driver_api_trace_cbid_enum = 314;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPeerRegister: CUpti_driver_api_trace_cbid_enum = 315;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPeerUnregister: CUpti_driver_api_trace_cbid_enum = 316;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPeerGetDevicePointer: CUpti_driver_api_trace_cbid_enum = 317;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyPeer: CUpti_driver_api_trace_cbid_enum = 318;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyPeerAsync: CUpti_driver_api_trace_cbid_enum = 319;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3DPeer: CUpti_driver_api_trace_cbid_enum = 320;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3DPeerAsync: CUpti_driver_api_trace_cbid_enum = 321;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxDestroy_v2: CUpti_driver_api_trace_cbid_enum = 322;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxPushCurrent_v2: CUpti_driver_api_trace_cbid_enum = 323;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxPopCurrent_v2: CUpti_driver_api_trace_cbid_enum = 324;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventDestroy_v2: CUpti_driver_api_trace_cbid_enum = 325;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamDestroy_v2: CUpti_driver_api_trace_cbid_enum = 326;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetAddress2D_v3: CUpti_driver_api_trace_cbid_enum = 327;
pub const CUPTI_DRIVER_TRACE_CBID_cuIpcGetMemHandle: CUpti_driver_api_trace_cbid_enum = 328;
pub const CUPTI_DRIVER_TRACE_CBID_cuIpcOpenMemHandle: CUpti_driver_api_trace_cbid_enum = 329;
pub const CUPTI_DRIVER_TRACE_CBID_cuIpcCloseMemHandle: CUpti_driver_api_trace_cbid_enum = 330;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetByPCIBusId: CUpti_driver_api_trace_cbid_enum = 331;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetPCIBusId: CUpti_driver_api_trace_cbid_enum = 332;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLGetDevices: CUpti_driver_api_trace_cbid_enum = 333;
pub const CUPTI_DRIVER_TRACE_CBID_cuIpcGetEventHandle: CUpti_driver_api_trace_cbid_enum = 334;
pub const CUPTI_DRIVER_TRACE_CBID_cuIpcOpenEventHandle: CUpti_driver_api_trace_cbid_enum = 335;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxSetSharedMemConfig: CUpti_driver_api_trace_cbid_enum = 336;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetSharedMemConfig: CUpti_driver_api_trace_cbid_enum = 337;
pub const CUPTI_DRIVER_TRACE_CBID_cuFuncSetSharedMemConfig: CUpti_driver_api_trace_cbid_enum = 338;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexObjectCreate: CUpti_driver_api_trace_cbid_enum = 339;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexObjectDestroy: CUpti_driver_api_trace_cbid_enum = 340;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexObjectGetResourceDesc: CUpti_driver_api_trace_cbid_enum =
    341;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexObjectGetTextureDesc: CUpti_driver_api_trace_cbid_enum = 342;
pub const CUPTI_DRIVER_TRACE_CBID_cuSurfObjectCreate: CUpti_driver_api_trace_cbid_enum = 343;
pub const CUPTI_DRIVER_TRACE_CBID_cuSurfObjectDestroy: CUpti_driver_api_trace_cbid_enum = 344;
pub const CUPTI_DRIVER_TRACE_CBID_cuSurfObjectGetResourceDesc: CUpti_driver_api_trace_cbid_enum =
    345;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamAddCallback: CUpti_driver_api_trace_cbid_enum = 346;
pub const CUPTI_DRIVER_TRACE_CBID_cuMipmappedArrayCreate: CUpti_driver_api_trace_cbid_enum = 347;
pub const CUPTI_DRIVER_TRACE_CBID_cuMipmappedArrayGetLevel: CUpti_driver_api_trace_cbid_enum = 348;
pub const CUPTI_DRIVER_TRACE_CBID_cuMipmappedArrayDestroy: CUpti_driver_api_trace_cbid_enum = 349;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetMipmappedArray: CUpti_driver_api_trace_cbid_enum = 350;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetMipmapFilterMode: CUpti_driver_api_trace_cbid_enum =
    351;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetMipmapLevelBias: CUpti_driver_api_trace_cbid_enum =
    352;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetMipmapLevelClamp: CUpti_driver_api_trace_cbid_enum =
    353;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetMaxAnisotropy: CUpti_driver_api_trace_cbid_enum = 354;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetMipmappedArray: CUpti_driver_api_trace_cbid_enum = 355;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetMipmapFilterMode: CUpti_driver_api_trace_cbid_enum =
    356;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetMipmapLevelBias: CUpti_driver_api_trace_cbid_enum =
    357;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetMipmapLevelClamp: CUpti_driver_api_trace_cbid_enum =
    358;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetMaxAnisotropy: CUpti_driver_api_trace_cbid_enum = 359;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsResourceGetMappedMipmappedArray:
    CUpti_driver_api_trace_cbid_enum = 360;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexObjectGetResourceViewDesc: CUpti_driver_api_trace_cbid_enum =
    361;
pub const CUPTI_DRIVER_TRACE_CBID_cuLinkCreate: CUpti_driver_api_trace_cbid_enum = 362;
pub const CUPTI_DRIVER_TRACE_CBID_cuLinkAddData: CUpti_driver_api_trace_cbid_enum = 363;
pub const CUPTI_DRIVER_TRACE_CBID_cuLinkAddFile: CUpti_driver_api_trace_cbid_enum = 364;
pub const CUPTI_DRIVER_TRACE_CBID_cuLinkComplete: CUpti_driver_api_trace_cbid_enum = 365;
pub const CUPTI_DRIVER_TRACE_CBID_cuLinkDestroy: CUpti_driver_api_trace_cbid_enum = 366;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamCreateWithPriority: CUpti_driver_api_trace_cbid_enum =
    367;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetPriority: CUpti_driver_api_trace_cbid_enum = 368;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetFlags: CUpti_driver_api_trace_cbid_enum = 369;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetStreamPriorityRange: CUpti_driver_api_trace_cbid_enum =
    370;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAllocManaged: CUpti_driver_api_trace_cbid_enum = 371;
pub const CUPTI_DRIVER_TRACE_CBID_cuGetErrorString: CUpti_driver_api_trace_cbid_enum = 372;
pub const CUPTI_DRIVER_TRACE_CBID_cuGetErrorName: CUpti_driver_api_trace_cbid_enum = 373;
pub const CUPTI_DRIVER_TRACE_CBID_cuOccupancyMaxActiveBlocksPerMultiprocessor:
    CUpti_driver_api_trace_cbid_enum = 374;
pub const CUPTI_DRIVER_TRACE_CBID_cuCompilePtx: CUpti_driver_api_trace_cbid_enum = 375;
pub const CUPTI_DRIVER_TRACE_CBID_cuBinaryFree: CUpti_driver_api_trace_cbid_enum = 376;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamAttachMemAsync: CUpti_driver_api_trace_cbid_enum = 377;
pub const CUPTI_DRIVER_TRACE_CBID_cuPointerSetAttribute: CUpti_driver_api_trace_cbid_enum = 378;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemHostRegister_v2: CUpti_driver_api_trace_cbid_enum = 379;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsResourceSetMapFlags_v2:
    CUpti_driver_api_trace_cbid_enum = 380;
pub const CUPTI_DRIVER_TRACE_CBID_cuLinkCreate_v2: CUpti_driver_api_trace_cbid_enum = 381;
pub const CUPTI_DRIVER_TRACE_CBID_cuLinkAddData_v2: CUpti_driver_api_trace_cbid_enum = 382;
pub const CUPTI_DRIVER_TRACE_CBID_cuLinkAddFile_v2: CUpti_driver_api_trace_cbid_enum = 383;
pub const CUPTI_DRIVER_TRACE_CBID_cuOccupancyMaxPotentialBlockSize:
    CUpti_driver_api_trace_cbid_enum = 384;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLGetDevices_v2: CUpti_driver_api_trace_cbid_enum = 385;
pub const CUPTI_DRIVER_TRACE_CBID_cuDevicePrimaryCtxRetain: CUpti_driver_api_trace_cbid_enum = 386;
pub const CUPTI_DRIVER_TRACE_CBID_cuDevicePrimaryCtxRelease: CUpti_driver_api_trace_cbid_enum = 387;
pub const CUPTI_DRIVER_TRACE_CBID_cuDevicePrimaryCtxSetFlags: CUpti_driver_api_trace_cbid_enum =
    388;
pub const CUPTI_DRIVER_TRACE_CBID_cuDevicePrimaryCtxReset: CUpti_driver_api_trace_cbid_enum = 389;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsEGLRegisterImage: CUpti_driver_api_trace_cbid_enum =
    390;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetFlags: CUpti_driver_api_trace_cbid_enum = 391;
pub const CUPTI_DRIVER_TRACE_CBID_cuDevicePrimaryCtxGetState: CUpti_driver_api_trace_cbid_enum =
    392;
pub const CUPTI_DRIVER_TRACE_CBID_cuEGLStreamConsumerConnect: CUpti_driver_api_trace_cbid_enum =
    393;
pub const CUPTI_DRIVER_TRACE_CBID_cuEGLStreamConsumerDisconnect: CUpti_driver_api_trace_cbid_enum =
    394;
pub const CUPTI_DRIVER_TRACE_CBID_cuEGLStreamConsumerAcquireFrame:
    CUpti_driver_api_trace_cbid_enum = 395;
pub const CUPTI_DRIVER_TRACE_CBID_cuEGLStreamConsumerReleaseFrame:
    CUpti_driver_api_trace_cbid_enum = 396;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoD_v2_ptds: CUpti_driver_api_trace_cbid_enum = 397;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoH_v2_ptds: CUpti_driver_api_trace_cbid_enum = 398;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoD_v2_ptds: CUpti_driver_api_trace_cbid_enum = 399;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoA_v2_ptds: CUpti_driver_api_trace_cbid_enum = 400;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoD_v2_ptds: CUpti_driver_api_trace_cbid_enum = 401;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoA_v2_ptds: CUpti_driver_api_trace_cbid_enum = 402;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoH_v2_ptds: CUpti_driver_api_trace_cbid_enum = 403;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoA_v2_ptds: CUpti_driver_api_trace_cbid_enum = 404;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy2D_v2_ptds: CUpti_driver_api_trace_cbid_enum = 405;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy2DUnaligned_v2_ptds: CUpti_driver_api_trace_cbid_enum =
    406;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3D_v2_ptds: CUpti_driver_api_trace_cbid_enum = 407;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy_ptds: CUpti_driver_api_trace_cbid_enum = 408;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyPeer_ptds: CUpti_driver_api_trace_cbid_enum = 409;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3DPeer_ptds: CUpti_driver_api_trace_cbid_enum = 410;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD8_v2_ptds: CUpti_driver_api_trace_cbid_enum = 411;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD16_v2_ptds: CUpti_driver_api_trace_cbid_enum = 412;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD32_v2_ptds: CUpti_driver_api_trace_cbid_enum = 413;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D8_v2_ptds: CUpti_driver_api_trace_cbid_enum = 414;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D16_v2_ptds: CUpti_driver_api_trace_cbid_enum = 415;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D32_v2_ptds: CUpti_driver_api_trace_cbid_enum = 416;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLMapBufferObject_v2_ptds: CUpti_driver_api_trace_cbid_enum =
    417;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 418;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoAAsync_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 419;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyAtoHAsync_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 420;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyHtoDAsync_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 421;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoHAsync_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 422;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyDtoDAsync_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 423;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy2DAsync_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 424;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3DAsync_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 425;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyPeerAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 426;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3DPeerAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 427;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD8Async_ptsz: CUpti_driver_api_trace_cbid_enum = 428;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD16Async_ptsz: CUpti_driver_api_trace_cbid_enum = 429;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD32Async_ptsz: CUpti_driver_api_trace_cbid_enum = 430;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D8Async_ptsz: CUpti_driver_api_trace_cbid_enum = 431;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D16Async_ptsz: CUpti_driver_api_trace_cbid_enum = 432;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemsetD2D32Async_ptsz: CUpti_driver_api_trace_cbid_enum = 433;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetPriority_ptsz: CUpti_driver_api_trace_cbid_enum = 434;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetFlags_ptsz: CUpti_driver_api_trace_cbid_enum = 435;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWaitEvent_ptsz: CUpti_driver_api_trace_cbid_enum = 436;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamAddCallback_ptsz: CUpti_driver_api_trace_cbid_enum = 437;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamAttachMemAsync_ptsz: CUpti_driver_api_trace_cbid_enum =
    438;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamQuery_ptsz: CUpti_driver_api_trace_cbid_enum = 439;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamSynchronize_ptsz: CUpti_driver_api_trace_cbid_enum = 440;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventRecord_ptsz: CUpti_driver_api_trace_cbid_enum = 441;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunchKernel_ptsz: CUpti_driver_api_trace_cbid_enum = 442;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsMapResources_ptsz: CUpti_driver_api_trace_cbid_enum =
    443;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsUnmapResources_ptsz: CUpti_driver_api_trace_cbid_enum =
    444;
pub const CUPTI_DRIVER_TRACE_CBID_cuGLMapBufferObjectAsync_v2_ptsz:
    CUpti_driver_api_trace_cbid_enum = 445;
pub const CUPTI_DRIVER_TRACE_CBID_cuEGLStreamProducerConnect: CUpti_driver_api_trace_cbid_enum =
    446;
pub const CUPTI_DRIVER_TRACE_CBID_cuEGLStreamProducerDisconnect: CUpti_driver_api_trace_cbid_enum =
    447;
pub const CUPTI_DRIVER_TRACE_CBID_cuEGLStreamProducerPresentFrame:
    CUpti_driver_api_trace_cbid_enum = 448;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphicsResourceGetMappedEglFrame:
    CUpti_driver_api_trace_cbid_enum = 449;
pub const CUPTI_DRIVER_TRACE_CBID_cuPointerGetAttributes: CUpti_driver_api_trace_cbid_enum = 450;
pub const CUPTI_DRIVER_TRACE_CBID_cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags:
    CUpti_driver_api_trace_cbid_enum = 451;
pub const CUPTI_DRIVER_TRACE_CBID_cuOccupancyMaxPotentialBlockSizeWithFlags:
    CUpti_driver_api_trace_cbid_enum = 452;
pub const CUPTI_DRIVER_TRACE_CBID_cuEGLStreamProducerReturnFrame: CUpti_driver_api_trace_cbid_enum =
    453;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetP2PAttribute: CUpti_driver_api_trace_cbid_enum = 454;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefSetBorderColor: CUpti_driver_api_trace_cbid_enum = 455;
pub const CUPTI_DRIVER_TRACE_CBID_cuTexRefGetBorderColor: CUpti_driver_api_trace_cbid_enum = 456;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAdvise: CUpti_driver_api_trace_cbid_enum = 457;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWaitValue32: CUpti_driver_api_trace_cbid_enum = 458;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWaitValue32_ptsz: CUpti_driver_api_trace_cbid_enum = 459;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWriteValue32: CUpti_driver_api_trace_cbid_enum = 460;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWriteValue32_ptsz: CUpti_driver_api_trace_cbid_enum = 461;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamBatchMemOp: CUpti_driver_api_trace_cbid_enum = 462;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamBatchMemOp_ptsz: CUpti_driver_api_trace_cbid_enum = 463;
pub const CUPTI_DRIVER_TRACE_CBID_cuNVNbufferGetPointer: CUpti_driver_api_trace_cbid_enum = 464;
pub const CUPTI_DRIVER_TRACE_CBID_cuNVNtextureGetArray: CUpti_driver_api_trace_cbid_enum = 465;
pub const CUPTI_DRIVER_TRACE_CBID_cuNNSetAllocator: CUpti_driver_api_trace_cbid_enum = 466;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPrefetchAsync: CUpti_driver_api_trace_cbid_enum = 467;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPrefetchAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 468;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventCreateFromNVNSync: CUpti_driver_api_trace_cbid_enum = 469;
pub const CUPTI_DRIVER_TRACE_CBID_cuEGLStreamConsumerConnectWithFlags:
    CUpti_driver_api_trace_cbid_enum = 470;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemRangeGetAttribute: CUpti_driver_api_trace_cbid_enum = 471;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemRangeGetAttributes: CUpti_driver_api_trace_cbid_enum = 472;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWaitValue64: CUpti_driver_api_trace_cbid_enum = 473;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWaitValue64_ptsz: CUpti_driver_api_trace_cbid_enum = 474;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWriteValue64: CUpti_driver_api_trace_cbid_enum = 475;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWriteValue64_ptsz: CUpti_driver_api_trace_cbid_enum = 476;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunchCooperativeKernel: CUpti_driver_api_trace_cbid_enum = 477;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunchCooperativeKernel_ptsz: CUpti_driver_api_trace_cbid_enum =
    478;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventCreateFromEGLSync: CUpti_driver_api_trace_cbid_enum = 479;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunchCooperativeKernelMultiDevice:
    CUpti_driver_api_trace_cbid_enum = 480;
pub const CUPTI_DRIVER_TRACE_CBID_cuFuncSetAttribute: CUpti_driver_api_trace_cbid_enum = 481;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetUuid: CUpti_driver_api_trace_cbid_enum = 482;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetCtx: CUpti_driver_api_trace_cbid_enum = 483;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetCtx_ptsz: CUpti_driver_api_trace_cbid_enum = 484;
pub const CUPTI_DRIVER_TRACE_CBID_cuImportExternalMemory: CUpti_driver_api_trace_cbid_enum = 485;
pub const CUPTI_DRIVER_TRACE_CBID_cuExternalMemoryGetMappedBuffer:
    CUpti_driver_api_trace_cbid_enum = 486;
pub const CUPTI_DRIVER_TRACE_CBID_cuExternalMemoryGetMappedMipmappedArray:
    CUpti_driver_api_trace_cbid_enum = 487;
pub const CUPTI_DRIVER_TRACE_CBID_cuDestroyExternalMemory: CUpti_driver_api_trace_cbid_enum = 488;
pub const CUPTI_DRIVER_TRACE_CBID_cuImportExternalSemaphore: CUpti_driver_api_trace_cbid_enum = 489;
pub const CUPTI_DRIVER_TRACE_CBID_cuSignalExternalSemaphoresAsync:
    CUpti_driver_api_trace_cbid_enum = 490;
pub const CUPTI_DRIVER_TRACE_CBID_cuSignalExternalSemaphoresAsync_ptsz:
    CUpti_driver_api_trace_cbid_enum = 491;
pub const CUPTI_DRIVER_TRACE_CBID_cuWaitExternalSemaphoresAsync: CUpti_driver_api_trace_cbid_enum =
    492;
pub const CUPTI_DRIVER_TRACE_CBID_cuWaitExternalSemaphoresAsync_ptsz:
    CUpti_driver_api_trace_cbid_enum = 493;
pub const CUPTI_DRIVER_TRACE_CBID_cuDestroyExternalSemaphore: CUpti_driver_api_trace_cbid_enum =
    494;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamBeginCapture: CUpti_driver_api_trace_cbid_enum = 495;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamBeginCapture_ptsz: CUpti_driver_api_trace_cbid_enum = 496;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamEndCapture: CUpti_driver_api_trace_cbid_enum = 497;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamEndCapture_ptsz: CUpti_driver_api_trace_cbid_enum = 498;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamIsCapturing: CUpti_driver_api_trace_cbid_enum = 499;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamIsCapturing_ptsz: CUpti_driver_api_trace_cbid_enum = 500;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphCreate: CUpti_driver_api_trace_cbid_enum = 501;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddKernelNode: CUpti_driver_api_trace_cbid_enum = 502;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphKernelNodeGetParams: CUpti_driver_api_trace_cbid_enum =
    503;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddMemcpyNode: CUpti_driver_api_trace_cbid_enum = 504;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphMemcpyNodeGetParams: CUpti_driver_api_trace_cbid_enum =
    505;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddMemsetNode: CUpti_driver_api_trace_cbid_enum = 506;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphMemsetNodeGetParams: CUpti_driver_api_trace_cbid_enum =
    507;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphMemsetNodeSetParams: CUpti_driver_api_trace_cbid_enum =
    508;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphNodeGetType: CUpti_driver_api_trace_cbid_enum = 509;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphGetRootNodes: CUpti_driver_api_trace_cbid_enum = 510;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphNodeGetDependencies: CUpti_driver_api_trace_cbid_enum =
    511;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphNodeGetDependentNodes: CUpti_driver_api_trace_cbid_enum =
    512;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphInstantiate: CUpti_driver_api_trace_cbid_enum = 513;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphLaunch: CUpti_driver_api_trace_cbid_enum = 514;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphLaunch_ptsz: CUpti_driver_api_trace_cbid_enum = 515;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecDestroy: CUpti_driver_api_trace_cbid_enum = 516;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphDestroy: CUpti_driver_api_trace_cbid_enum = 517;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddDependencies: CUpti_driver_api_trace_cbid_enum = 518;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphRemoveDependencies: CUpti_driver_api_trace_cbid_enum = 519;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphMemcpyNodeSetParams: CUpti_driver_api_trace_cbid_enum =
    520;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphKernelNodeSetParams: CUpti_driver_api_trace_cbid_enum =
    521;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphDestroyNode: CUpti_driver_api_trace_cbid_enum = 522;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphClone: CUpti_driver_api_trace_cbid_enum = 523;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphNodeFindInClone: CUpti_driver_api_trace_cbid_enum = 524;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddChildGraphNode: CUpti_driver_api_trace_cbid_enum = 525;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddEmptyNode: CUpti_driver_api_trace_cbid_enum = 526;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunchHostFunc: CUpti_driver_api_trace_cbid_enum = 527;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunchHostFunc_ptsz: CUpti_driver_api_trace_cbid_enum = 528;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphChildGraphNodeGetGraph: CUpti_driver_api_trace_cbid_enum =
    529;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddHostNode: CUpti_driver_api_trace_cbid_enum = 530;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphHostNodeGetParams: CUpti_driver_api_trace_cbid_enum = 531;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetLuid: CUpti_driver_api_trace_cbid_enum = 532;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphHostNodeSetParams: CUpti_driver_api_trace_cbid_enum = 533;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphGetNodes: CUpti_driver_api_trace_cbid_enum = 534;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphGetEdges: CUpti_driver_api_trace_cbid_enum = 535;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetCaptureInfo: CUpti_driver_api_trace_cbid_enum = 536;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetCaptureInfo_ptsz: CUpti_driver_api_trace_cbid_enum =
    537;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecKernelNodeSetParams: CUpti_driver_api_trace_cbid_enum =
    538;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamBeginCapture_v2: CUpti_driver_api_trace_cbid_enum = 539;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamBeginCapture_v2_ptsz: CUpti_driver_api_trace_cbid_enum =
    540;
pub const CUPTI_DRIVER_TRACE_CBID_cuThreadExchangeStreamCaptureMode:
    CUpti_driver_api_trace_cbid_enum = 541;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetNvSciSyncAttributes: CUpti_driver_api_trace_cbid_enum =
    542;
pub const CUPTI_DRIVER_TRACE_CBID_cuOccupancyAvailableDynamicSMemPerBlock:
    CUpti_driver_api_trace_cbid_enum = 543;
pub const CUPTI_DRIVER_TRACE_CBID_cuDevicePrimaryCtxRelease_v2: CUpti_driver_api_trace_cbid_enum =
    544;
pub const CUPTI_DRIVER_TRACE_CBID_cuDevicePrimaryCtxReset_v2: CUpti_driver_api_trace_cbid_enum =
    545;
pub const CUPTI_DRIVER_TRACE_CBID_cuDevicePrimaryCtxSetFlags_v2: CUpti_driver_api_trace_cbid_enum =
    546;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAddressReserve: CUpti_driver_api_trace_cbid_enum = 547;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAddressFree: CUpti_driver_api_trace_cbid_enum = 548;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemCreate: CUpti_driver_api_trace_cbid_enum = 549;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemRelease: CUpti_driver_api_trace_cbid_enum = 550;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemMap: CUpti_driver_api_trace_cbid_enum = 551;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemUnmap: CUpti_driver_api_trace_cbid_enum = 552;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemSetAccess: CUpti_driver_api_trace_cbid_enum = 553;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemExportToShareableHandle: CUpti_driver_api_trace_cbid_enum =
    554;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemImportFromShareableHandle: CUpti_driver_api_trace_cbid_enum =
    555;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemGetAllocationGranularity: CUpti_driver_api_trace_cbid_enum =
    556;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemGetAllocationPropertiesFromHandle:
    CUpti_driver_api_trace_cbid_enum = 557;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemGetAccess: CUpti_driver_api_trace_cbid_enum = 558;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamSetFlags: CUpti_driver_api_trace_cbid_enum = 559;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamSetFlags_ptsz: CUpti_driver_api_trace_cbid_enum = 560;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecUpdate: CUpti_driver_api_trace_cbid_enum = 561;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecMemcpyNodeSetParams: CUpti_driver_api_trace_cbid_enum =
    562;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecMemsetNodeSetParams: CUpti_driver_api_trace_cbid_enum =
    563;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecHostNodeSetParams: CUpti_driver_api_trace_cbid_enum =
    564;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemRetainAllocationHandle: CUpti_driver_api_trace_cbid_enum =
    565;
pub const CUPTI_DRIVER_TRACE_CBID_cuFuncGetModule: CUpti_driver_api_trace_cbid_enum = 566;
pub const CUPTI_DRIVER_TRACE_CBID_cuIpcOpenMemHandle_v2: CUpti_driver_api_trace_cbid_enum = 567;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxResetPersistingL2Cache: CUpti_driver_api_trace_cbid_enum =
    568;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphKernelNodeCopyAttributes:
    CUpti_driver_api_trace_cbid_enum = 569;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphKernelNodeGetAttribute: CUpti_driver_api_trace_cbid_enum =
    570;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphKernelNodeSetAttribute: CUpti_driver_api_trace_cbid_enum =
    571;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamCopyAttributes: CUpti_driver_api_trace_cbid_enum = 572;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamCopyAttributes_ptsz: CUpti_driver_api_trace_cbid_enum =
    573;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetAttribute: CUpti_driver_api_trace_cbid_enum = 574;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetAttribute_ptsz: CUpti_driver_api_trace_cbid_enum = 575;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamSetAttribute: CUpti_driver_api_trace_cbid_enum = 576;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamSetAttribute_ptsz: CUpti_driver_api_trace_cbid_enum = 577;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphInstantiate_v2: CUpti_driver_api_trace_cbid_enum = 578;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetTexture1DLinearMaxWidth:
    CUpti_driver_api_trace_cbid_enum = 579;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphUpload: CUpti_driver_api_trace_cbid_enum = 580;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphUpload_ptsz: CUpti_driver_api_trace_cbid_enum = 581;
pub const CUPTI_DRIVER_TRACE_CBID_cuArrayGetSparseProperties: CUpti_driver_api_trace_cbid_enum =
    582;
pub const CUPTI_DRIVER_TRACE_CBID_cuMipmappedArrayGetSparseProperties:
    CUpti_driver_api_trace_cbid_enum = 583;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemMapArrayAsync: CUpti_driver_api_trace_cbid_enum = 584;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemMapArrayAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 585;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecChildGraphNodeSetParams:
    CUpti_driver_api_trace_cbid_enum = 586;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventRecordWithFlags: CUpti_driver_api_trace_cbid_enum = 587;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventRecordWithFlags_ptsz: CUpti_driver_api_trace_cbid_enum =
    588;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddEventRecordNode: CUpti_driver_api_trace_cbid_enum = 589;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddEventWaitNode: CUpti_driver_api_trace_cbid_enum = 590;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphEventRecordNodeGetEvent: CUpti_driver_api_trace_cbid_enum =
    591;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphEventWaitNodeGetEvent: CUpti_driver_api_trace_cbid_enum =
    592;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphEventRecordNodeSetEvent: CUpti_driver_api_trace_cbid_enum =
    593;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphEventWaitNodeSetEvent: CUpti_driver_api_trace_cbid_enum =
    594;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecEventRecordNodeSetEvent:
    CUpti_driver_api_trace_cbid_enum = 595;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecEventWaitNodeSetEvent:
    CUpti_driver_api_trace_cbid_enum = 596;
pub const CUPTI_DRIVER_TRACE_CBID_cuArrayGetPlane: CUpti_driver_api_trace_cbid_enum = 597;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAllocAsync: CUpti_driver_api_trace_cbid_enum = 598;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAllocAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 599;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemFreeAsync: CUpti_driver_api_trace_cbid_enum = 600;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemFreeAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 601;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPoolTrimTo: CUpti_driver_api_trace_cbid_enum = 602;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPoolSetAttribute: CUpti_driver_api_trace_cbid_enum = 603;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPoolGetAttribute: CUpti_driver_api_trace_cbid_enum = 604;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPoolSetAccess: CUpti_driver_api_trace_cbid_enum = 605;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetDefaultMemPool: CUpti_driver_api_trace_cbid_enum = 606;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPoolCreate: CUpti_driver_api_trace_cbid_enum = 607;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPoolDestroy: CUpti_driver_api_trace_cbid_enum = 608;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceSetMemPool: CUpti_driver_api_trace_cbid_enum = 609;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetMemPool: CUpti_driver_api_trace_cbid_enum = 610;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAllocFromPoolAsync: CUpti_driver_api_trace_cbid_enum = 611;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAllocFromPoolAsync_ptsz: CUpti_driver_api_trace_cbid_enum =
    612;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPoolExportToShareableHandle:
    CUpti_driver_api_trace_cbid_enum = 613;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPoolImportFromShareableHandle:
    CUpti_driver_api_trace_cbid_enum = 614;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPoolExportPointer: CUpti_driver_api_trace_cbid_enum = 615;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPoolImportPointer: CUpti_driver_api_trace_cbid_enum = 616;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPoolGetAccess: CUpti_driver_api_trace_cbid_enum = 617;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddExternalSemaphoresSignalNode:
    CUpti_driver_api_trace_cbid_enum = 618;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExternalSemaphoresSignalNodeGetParams:
    CUpti_driver_api_trace_cbid_enum = 619;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExternalSemaphoresSignalNodeSetParams:
    CUpti_driver_api_trace_cbid_enum = 620;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddExternalSemaphoresWaitNode:
    CUpti_driver_api_trace_cbid_enum = 621;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExternalSemaphoresWaitNodeGetParams:
    CUpti_driver_api_trace_cbid_enum = 622;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExternalSemaphoresWaitNodeSetParams:
    CUpti_driver_api_trace_cbid_enum = 623;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecExternalSemaphoresSignalNodeSetParams:
    CUpti_driver_api_trace_cbid_enum = 624;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecExternalSemaphoresWaitNodeSetParams:
    CUpti_driver_api_trace_cbid_enum = 625;
pub const CUPTI_DRIVER_TRACE_CBID_cuGetProcAddress: CUpti_driver_api_trace_cbid_enum = 626;
pub const CUPTI_DRIVER_TRACE_CBID_cuFlushGPUDirectRDMAWrites: CUpti_driver_api_trace_cbid_enum =
    627;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphDebugDotPrint: CUpti_driver_api_trace_cbid_enum = 628;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetCaptureInfo_v2: CUpti_driver_api_trace_cbid_enum = 629;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetCaptureInfo_v2_ptsz: CUpti_driver_api_trace_cbid_enum =
    630;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamUpdateCaptureDependencies:
    CUpti_driver_api_trace_cbid_enum = 631;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamUpdateCaptureDependencies_ptsz:
    CUpti_driver_api_trace_cbid_enum = 632;
pub const CUPTI_DRIVER_TRACE_CBID_cuUserObjectCreate: CUpti_driver_api_trace_cbid_enum = 633;
pub const CUPTI_DRIVER_TRACE_CBID_cuUserObjectRetain: CUpti_driver_api_trace_cbid_enum = 634;
pub const CUPTI_DRIVER_TRACE_CBID_cuUserObjectRelease: CUpti_driver_api_trace_cbid_enum = 635;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphRetainUserObject: CUpti_driver_api_trace_cbid_enum = 636;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphReleaseUserObject: CUpti_driver_api_trace_cbid_enum = 637;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddMemAllocNode: CUpti_driver_api_trace_cbid_enum = 638;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddMemFreeNode: CUpti_driver_api_trace_cbid_enum = 639;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGraphMemTrim: CUpti_driver_api_trace_cbid_enum = 640;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetGraphMemAttribute: CUpti_driver_api_trace_cbid_enum =
    641;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceSetGraphMemAttribute: CUpti_driver_api_trace_cbid_enum =
    642;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphInstantiateWithFlags: CUpti_driver_api_trace_cbid_enum =
    643;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetExecAffinitySupport: CUpti_driver_api_trace_cbid_enum =
    644;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxCreate_v3: CUpti_driver_api_trace_cbid_enum = 645;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetExecAffinity: CUpti_driver_api_trace_cbid_enum = 646;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetUuid_v2: CUpti_driver_api_trace_cbid_enum = 647;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphMemAllocNodeGetParams: CUpti_driver_api_trace_cbid_enum =
    648;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphMemFreeNodeGetParams: CUpti_driver_api_trace_cbid_enum =
    649;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphNodeSetEnabled: CUpti_driver_api_trace_cbid_enum = 650;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphNodeGetEnabled: CUpti_driver_api_trace_cbid_enum = 651;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunchKernelEx: CUpti_driver_api_trace_cbid_enum = 652;
pub const CUPTI_DRIVER_TRACE_CBID_cuLaunchKernelEx_ptsz: CUpti_driver_api_trace_cbid_enum = 653;
pub const CUPTI_DRIVER_TRACE_CBID_cuArrayGetMemoryRequirements: CUpti_driver_api_trace_cbid_enum =
    654;
pub const CUPTI_DRIVER_TRACE_CBID_cuMipmappedArrayGetMemoryRequirements:
    CUpti_driver_api_trace_cbid_enum = 655;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphInstantiateWithParams: CUpti_driver_api_trace_cbid_enum =
    656;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphInstantiateWithParams_ptsz:
    CUpti_driver_api_trace_cbid_enum = 657;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecGetFlags: CUpti_driver_api_trace_cbid_enum = 658;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWaitValue32_v2: CUpti_driver_api_trace_cbid_enum = 659;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWaitValue32_v2_ptsz: CUpti_driver_api_trace_cbid_enum =
    660;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWaitValue64_v2: CUpti_driver_api_trace_cbid_enum = 661;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWaitValue64_v2_ptsz: CUpti_driver_api_trace_cbid_enum =
    662;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWriteValue32_v2: CUpti_driver_api_trace_cbid_enum = 663;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWriteValue32_v2_ptsz: CUpti_driver_api_trace_cbid_enum =
    664;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWriteValue64_v2: CUpti_driver_api_trace_cbid_enum = 665;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamWriteValue64_v2_ptsz: CUpti_driver_api_trace_cbid_enum =
    666;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamBatchMemOp_v2: CUpti_driver_api_trace_cbid_enum = 667;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamBatchMemOp_v2_ptsz: CUpti_driver_api_trace_cbid_enum =
    668;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddBatchMemOpNode: CUpti_driver_api_trace_cbid_enum = 669;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphBatchMemOpNodeGetParams: CUpti_driver_api_trace_cbid_enum =
    670;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphBatchMemOpNodeSetParams: CUpti_driver_api_trace_cbid_enum =
    671;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecBatchMemOpNodeSetParams:
    CUpti_driver_api_trace_cbid_enum = 672;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleGetLoadingMode: CUpti_driver_api_trace_cbid_enum = 673;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemGetHandleForAddressRange: CUpti_driver_api_trace_cbid_enum =
    674;
pub const CUPTI_DRIVER_TRACE_CBID_cuOccupancyMaxPotentialClusterSize:
    CUpti_driver_api_trace_cbid_enum = 675;
pub const CUPTI_DRIVER_TRACE_CBID_cuOccupancyMaxActiveClusters: CUpti_driver_api_trace_cbid_enum =
    676;
pub const CUPTI_DRIVER_TRACE_CBID_cuGetProcAddress_v2: CUpti_driver_api_trace_cbid_enum = 677;
pub const CUPTI_DRIVER_TRACE_CBID_cuLibraryLoadData: CUpti_driver_api_trace_cbid_enum = 678;
pub const CUPTI_DRIVER_TRACE_CBID_cuLibraryLoadFromFile: CUpti_driver_api_trace_cbid_enum = 679;
pub const CUPTI_DRIVER_TRACE_CBID_cuLibraryUnload: CUpti_driver_api_trace_cbid_enum = 680;
pub const CUPTI_DRIVER_TRACE_CBID_cuLibraryGetKernel: CUpti_driver_api_trace_cbid_enum = 681;
pub const CUPTI_DRIVER_TRACE_CBID_cuLibraryGetModule: CUpti_driver_api_trace_cbid_enum = 682;
pub const CUPTI_DRIVER_TRACE_CBID_cuKernelGetFunction: CUpti_driver_api_trace_cbid_enum = 683;
pub const CUPTI_DRIVER_TRACE_CBID_cuLibraryGetGlobal: CUpti_driver_api_trace_cbid_enum = 684;
pub const CUPTI_DRIVER_TRACE_CBID_cuLibraryGetManaged: CUpti_driver_api_trace_cbid_enum = 685;
pub const CUPTI_DRIVER_TRACE_CBID_cuKernelGetAttribute: CUpti_driver_api_trace_cbid_enum = 686;
pub const CUPTI_DRIVER_TRACE_CBID_cuKernelSetAttribute: CUpti_driver_api_trace_cbid_enum = 687;
pub const CUPTI_DRIVER_TRACE_CBID_cuKernelSetCacheConfig: CUpti_driver_api_trace_cbid_enum = 688;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddKernelNode_v2: CUpti_driver_api_trace_cbid_enum = 689;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphKernelNodeGetParams_v2: CUpti_driver_api_trace_cbid_enum =
    690;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphKernelNodeSetParams_v2: CUpti_driver_api_trace_cbid_enum =
    691;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecKernelNodeSetParams_v2:
    CUpti_driver_api_trace_cbid_enum = 692;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetId: CUpti_driver_api_trace_cbid_enum = 693;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetId_ptsz: CUpti_driver_api_trace_cbid_enum = 694;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetId: CUpti_driver_api_trace_cbid_enum = 695;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecUpdate_v2: CUpti_driver_api_trace_cbid_enum = 696;
pub const CUPTI_DRIVER_TRACE_CBID_cuTensorMapEncodeTiled: CUpti_driver_api_trace_cbid_enum = 697;
pub const CUPTI_DRIVER_TRACE_CBID_cuTensorMapEncodeIm2col: CUpti_driver_api_trace_cbid_enum = 698;
pub const CUPTI_DRIVER_TRACE_CBID_cuTensorMapReplaceAddress: CUpti_driver_api_trace_cbid_enum = 699;
pub const CUPTI_DRIVER_TRACE_CBID_cuLibraryGetUnifiedFunction: CUpti_driver_api_trace_cbid_enum =
    700;
pub const CUPTI_DRIVER_TRACE_CBID_cuCoredumpGetAttribute: CUpti_driver_api_trace_cbid_enum = 701;
pub const CUPTI_DRIVER_TRACE_CBID_cuCoredumpGetAttributeGlobal: CUpti_driver_api_trace_cbid_enum =
    702;
pub const CUPTI_DRIVER_TRACE_CBID_cuCoredumpSetAttribute: CUpti_driver_api_trace_cbid_enum = 703;
pub const CUPTI_DRIVER_TRACE_CBID_cuCoredumpSetAttributeGlobal: CUpti_driver_api_trace_cbid_enum =
    704;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxSetFlags: CUpti_driver_api_trace_cbid_enum = 705;
pub const CUPTI_DRIVER_TRACE_CBID_cuMulticastCreate: CUpti_driver_api_trace_cbid_enum = 706;
pub const CUPTI_DRIVER_TRACE_CBID_cuMulticastAddDevice: CUpti_driver_api_trace_cbid_enum = 707;
pub const CUPTI_DRIVER_TRACE_CBID_cuMulticastBindMem: CUpti_driver_api_trace_cbid_enum = 708;
pub const CUPTI_DRIVER_TRACE_CBID_cuMulticastBindAddr: CUpti_driver_api_trace_cbid_enum = 709;
pub const CUPTI_DRIVER_TRACE_CBID_cuMulticastUnbind: CUpti_driver_api_trace_cbid_enum = 710;
pub const CUPTI_DRIVER_TRACE_CBID_cuMulticastGetGranularity: CUpti_driver_api_trace_cbid_enum = 711;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddNode: CUpti_driver_api_trace_cbid_enum = 712;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphNodeSetParams: CUpti_driver_api_trace_cbid_enum = 713;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphExecNodeSetParams: CUpti_driver_api_trace_cbid_enum = 714;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemAdvise_v2: CUpti_driver_api_trace_cbid_enum = 715;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPrefetchAsync_v2: CUpti_driver_api_trace_cbid_enum = 716;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPrefetchAsync_v2_ptsz: CUpti_driver_api_trace_cbid_enum =
    717;
pub const CUPTI_DRIVER_TRACE_CBID_cuFuncGetName: CUpti_driver_api_trace_cbid_enum = 718;
pub const CUPTI_DRIVER_TRACE_CBID_cuKernelGetName: CUpti_driver_api_trace_cbid_enum = 719;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamBeginCaptureToGraph: CUpti_driver_api_trace_cbid_enum =
    720;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamBeginCaptureToGraph_ptsz:
    CUpti_driver_api_trace_cbid_enum = 721;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphConditionalHandleCreate: CUpti_driver_api_trace_cbid_enum =
    722;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddNode_v2: CUpti_driver_api_trace_cbid_enum = 723;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphGetEdges_v2: CUpti_driver_api_trace_cbid_enum = 724;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphNodeGetDependencies_v2: CUpti_driver_api_trace_cbid_enum =
    725;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphNodeGetDependentNodes_v2:
    CUpti_driver_api_trace_cbid_enum = 726;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphAddDependencies_v2: CUpti_driver_api_trace_cbid_enum = 727;
pub const CUPTI_DRIVER_TRACE_CBID_cuGraphRemoveDependencies_v2: CUpti_driver_api_trace_cbid_enum =
    728;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetCaptureInfo_v3: CUpti_driver_api_trace_cbid_enum = 729;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetCaptureInfo_v3_ptsz: CUpti_driver_api_trace_cbid_enum =
    730;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamUpdateCaptureDependencies_v2:
    CUpti_driver_api_trace_cbid_enum = 731;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamUpdateCaptureDependencies_v2_ptsz:
    CUpti_driver_api_trace_cbid_enum = 732;
pub const CUPTI_DRIVER_TRACE_CBID_cuFuncGetParamInfo: CUpti_driver_api_trace_cbid_enum = 733;
pub const CUPTI_DRIVER_TRACE_CBID_cuKernelGetParamInfo: CUpti_driver_api_trace_cbid_enum = 734;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceRegisterAsyncNotification:
    CUpti_driver_api_trace_cbid_enum = 735;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceUnregisterAsyncNotification:
    CUpti_driver_api_trace_cbid_enum = 736;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleGetFunctionCount: CUpti_driver_api_trace_cbid_enum = 737;
pub const CUPTI_DRIVER_TRACE_CBID_cuModuleEnumerateFunctions: CUpti_driver_api_trace_cbid_enum =
    738;
pub const CUPTI_DRIVER_TRACE_CBID_cuLibraryGetKernelCount: CUpti_driver_api_trace_cbid_enum = 739;
pub const CUPTI_DRIVER_TRACE_CBID_cuLibraryEnumerateKernels: CUpti_driver_api_trace_cbid_enum = 740;
pub const CUPTI_DRIVER_TRACE_CBID_cuFuncIsLoaded: CUpti_driver_api_trace_cbid_enum = 741;
pub const CUPTI_DRIVER_TRACE_CBID_cuFuncLoad: CUpti_driver_api_trace_cbid_enum = 742;
pub const CUPTI_DRIVER_TRACE_CBID_cuGreenCtxCreate: CUpti_driver_api_trace_cbid_enum = 743;
pub const CUPTI_DRIVER_TRACE_CBID_cuGreenCtxDestroy: CUpti_driver_api_trace_cbid_enum = 744;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetDevResource: CUpti_driver_api_trace_cbid_enum = 745;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetDevResource: CUpti_driver_api_trace_cbid_enum = 746;
pub const CUPTI_DRIVER_TRACE_CBID_cuGreenCtxGetDevResource: CUpti_driver_api_trace_cbid_enum = 747;
pub const CUPTI_DRIVER_TRACE_CBID_cuDevResourceGenerateDesc: CUpti_driver_api_trace_cbid_enum = 748;
pub const CUPTI_DRIVER_TRACE_CBID_cuGreenCtxRecordEvent: CUpti_driver_api_trace_cbid_enum = 749;
pub const CUPTI_DRIVER_TRACE_CBID_cuGreenCtxWaitEvent: CUpti_driver_api_trace_cbid_enum = 750;
pub const CUPTI_DRIVER_TRACE_CBID_cuDevSmResourceSplitByCount: CUpti_driver_api_trace_cbid_enum =
    751;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetGreenCtx: CUpti_driver_api_trace_cbid_enum = 752;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxFromGreenCtx: CUpti_driver_api_trace_cbid_enum = 753;
pub const CUPTI_DRIVER_TRACE_CBID_cuKernelGetLibrary: CUpti_driver_api_trace_cbid_enum = 754;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxRecordEvent: CUpti_driver_api_trace_cbid_enum = 755;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxWaitEvent: CUpti_driver_api_trace_cbid_enum = 756;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxCreate_v4: CUpti_driver_api_trace_cbid_enum = 757;
pub const CUPTI_DRIVER_TRACE_CBID_cuGreenCtxStreamCreate: CUpti_driver_api_trace_cbid_enum = 758;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetCtx_v2: CUpti_driver_api_trace_cbid_enum = 759;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetCtx_v2_ptsz: CUpti_driver_api_trace_cbid_enum = 760;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemBatchDecompressAsync: CUpti_driver_api_trace_cbid_enum = 761;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemBatchDecompressAsync_ptsz: CUpti_driver_api_trace_cbid_enum =
    762;
pub const CUPTI_DRIVER_TRACE_CBID_cuLogsRegisterCallback: CUpti_driver_api_trace_cbid_enum = 763;
pub const CUPTI_DRIVER_TRACE_CBID_cuLogsUnregisterCallback: CUpti_driver_api_trace_cbid_enum = 764;
pub const CUPTI_DRIVER_TRACE_CBID_cuLogsCurrent: CUpti_driver_api_trace_cbid_enum = 765;
pub const CUPTI_DRIVER_TRACE_CBID_cuLogsDumpToFile: CUpti_driver_api_trace_cbid_enum = 766;
pub const CUPTI_DRIVER_TRACE_CBID_cuLogsDumpToMemory: CUpti_driver_api_trace_cbid_enum = 767;
pub const CUPTI_DRIVER_TRACE_CBID_cuCheckpointProcessGetRestoreThreadId:
    CUpti_driver_api_trace_cbid_enum = 768;
pub const CUPTI_DRIVER_TRACE_CBID_cuCheckpointProcessGetState: CUpti_driver_api_trace_cbid_enum =
    769;
pub const CUPTI_DRIVER_TRACE_CBID_cuCheckpointProcessLock: CUpti_driver_api_trace_cbid_enum = 770;
pub const CUPTI_DRIVER_TRACE_CBID_cuCheckpointProcessCheckpoint: CUpti_driver_api_trace_cbid_enum =
    771;
pub const CUPTI_DRIVER_TRACE_CBID_cuCheckpointProcessRestore: CUpti_driver_api_trace_cbid_enum =
    772;
pub const CUPTI_DRIVER_TRACE_CBID_cuCheckpointProcessUnlock: CUpti_driver_api_trace_cbid_enum = 773;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetDevice: CUpti_driver_api_trace_cbid_enum = 774;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamGetDevice_ptsz: CUpti_driver_api_trace_cbid_enum = 775;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyBatchAsync: CUpti_driver_api_trace_cbid_enum = 776;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyBatchAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 777;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3DBatchAsync: CUpti_driver_api_trace_cbid_enum = 778;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3DBatchAsync_ptsz: CUpti_driver_api_trace_cbid_enum = 779;
pub const CUPTI_DRIVER_TRACE_CBID_cuEventElapsedTime_v2: CUpti_driver_api_trace_cbid_enum = 780;
pub const CUPTI_DRIVER_TRACE_CBID_cuTensorMapEncodeIm2colWide: CUpti_driver_api_trace_cbid_enum =
    781;
pub const CUPTI_DRIVER_TRACE_CBID_cuGreenCtxGetId: CUpti_driver_api_trace_cbid_enum = 782;
pub const CUPTI_DRIVER_TRACE_CBID_cuStreamCreateForCaptureToCig: CUpti_driver_api_trace_cbid_enum =
    783;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPrefetchBatchAsync: CUpti_driver_api_trace_cbid_enum = 784;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemPrefetchBatchAsync_ptsz: CUpti_driver_api_trace_cbid_enum =
    785;
pub const CUPTI_DRIVER_TRACE_CBID_cuSemaphoreCreate: CUpti_driver_api_trace_cbid_enum = 786;
pub const CUPTI_DRIVER_TRACE_CBID_cuSemaphoreExport: CUpti_driver_api_trace_cbid_enum = 787;
pub const CUPTI_DRIVER_TRACE_CBID_cuSemaphoreDestroy: CUpti_driver_api_trace_cbid_enum = 788;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemDiscardBatchAsync: CUpti_driver_api_trace_cbid_enum = 789;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemDiscardBatchAsync_ptsz: CUpti_driver_api_trace_cbid_enum =
    790;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemDiscardAndPrefetchBatchAsync:
    CUpti_driver_api_trace_cbid_enum = 791;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemDiscardAndPrefetchBatchAsync_ptsz:
    CUpti_driver_api_trace_cbid_enum = 792;
pub const CUPTI_DRIVER_TRACE_CBID_cuMultiKernelCooperativeDomainCreate:
    CUpti_driver_api_trace_cbid_enum = 793;
pub const CUPTI_DRIVER_TRACE_CBID_cuMultiKernelCooperativeDomainDestroy:
    CUpti_driver_api_trace_cbid_enum = 794;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxGetDevice_v2: CUpti_driver_api_trace_cbid_enum = 795;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyBatchAsync_v2: CUpti_driver_api_trace_cbid_enum = 796;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpyBatchAsync_v2_ptsz: CUpti_driver_api_trace_cbid_enum =
    797;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3DBatchAsync_v2: CUpti_driver_api_trace_cbid_enum = 798;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemcpy3DBatchAsync_v2_ptsz: CUpti_driver_api_trace_cbid_enum =
    799;
pub const CUPTI_DRIVER_TRACE_CBID_cuCtxSynchronize_v2: CUpti_driver_api_trace_cbid_enum = 800;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemGetDefaultMemPool: CUpti_driver_api_trace_cbid_enum = 801;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemGetMemPool: CUpti_driver_api_trace_cbid_enum = 802;
pub const CUPTI_DRIVER_TRACE_CBID_cuMemSetMemPool: CUpti_driver_api_trace_cbid_enum = 803;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetP2PAtomicCapabilities:
    CUpti_driver_api_trace_cbid_enum = 804;
pub const CUPTI_DRIVER_TRACE_CBID_cuDeviceGetHostAtomicCapabilities:
    CUpti_driver_api_trace_cbid_enum = 805;
pub const CUPTI_DRIVER_TRACE_CBID_cuDriverGetGpuCodeIsaVersion: CUpti_driver_api_trace_cbid_enum =
    806;
pub const CUPTI_DRIVER_TRACE_CBID_SIZE: CUpti_driver_api_trace_cbid_enum = 807;
pub const CUPTI_DRIVER_TRACE_CBID_FORCE_INT: CUpti_driver_api_trace_cbid_enum = 2147483647;
pub type CUpti_driver_api_trace_cbid_enum = ::std::os::raw::c_uint;
pub use self::CUpti_driver_api_trace_cbid_enum as CUpti_driver_api_trace_cbid;
pub const CUPTI_RUNTIME_TRACE_CBID_INVALID: CUpti_runtime_api_trace_cbid_enum = 0;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDriverGetVersion_v3020: CUpti_runtime_api_trace_cbid_enum =
    1;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaRuntimeGetVersion_v3020: CUpti_runtime_api_trace_cbid_enum =
    2;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetDeviceCount_v3020: CUpti_runtime_api_trace_cbid_enum = 3;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetDeviceProperties_v3020:
    CUpti_runtime_api_trace_cbid_enum = 4;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaChooseDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 5;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetChannelDesc_v3020: CUpti_runtime_api_trace_cbid_enum = 6;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaCreateChannelDesc_v3020: CUpti_runtime_api_trace_cbid_enum =
    7;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaConfigureCall_v3020: CUpti_runtime_api_trace_cbid_enum = 8;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaSetupArgument_v3020: CUpti_runtime_api_trace_cbid_enum = 9;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetLastError_v3020: CUpti_runtime_api_trace_cbid_enum = 10;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaPeekAtLastError_v3020: CUpti_runtime_api_trace_cbid_enum =
    11;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetErrorString_v3020: CUpti_runtime_api_trace_cbid_enum = 12;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLaunch_v3020: CUpti_runtime_api_trace_cbid_enum = 13;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFuncSetCacheConfig_v3020: CUpti_runtime_api_trace_cbid_enum =
    14;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFuncGetAttributes_v3020: CUpti_runtime_api_trace_cbid_enum =
    15;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaSetDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 16;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 17;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaSetValidDevices_v3020: CUpti_runtime_api_trace_cbid_enum =
    18;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaSetDeviceFlags_v3020: CUpti_runtime_api_trace_cbid_enum = 19;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMalloc_v3020: CUpti_runtime_api_trace_cbid_enum = 20;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMallocPitch_v3020: CUpti_runtime_api_trace_cbid_enum = 21;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFree_v3020: CUpti_runtime_api_trace_cbid_enum = 22;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMallocArray_v3020: CUpti_runtime_api_trace_cbid_enum = 23;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFreeArray_v3020: CUpti_runtime_api_trace_cbid_enum = 24;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMallocHost_v3020: CUpti_runtime_api_trace_cbid_enum = 25;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFreeHost_v3020: CUpti_runtime_api_trace_cbid_enum = 26;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaHostAlloc_v3020: CUpti_runtime_api_trace_cbid_enum = 27;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaHostGetDevicePointer_v3020:
    CUpti_runtime_api_trace_cbid_enum = 28;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaHostGetFlags_v3020: CUpti_runtime_api_trace_cbid_enum = 29;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemGetInfo_v3020: CUpti_runtime_api_trace_cbid_enum = 30;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy_v3020: CUpti_runtime_api_trace_cbid_enum = 31;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2D_v3020: CUpti_runtime_api_trace_cbid_enum = 32;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyToArray_v3020: CUpti_runtime_api_trace_cbid_enum = 33;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DToArray_v3020: CUpti_runtime_api_trace_cbid_enum =
    34;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyFromArray_v3020: CUpti_runtime_api_trace_cbid_enum =
    35;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DFromArray_v3020: CUpti_runtime_api_trace_cbid_enum =
    36;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyArrayToArray_v3020: CUpti_runtime_api_trace_cbid_enum =
    37;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DArrayToArray_v3020:
    CUpti_runtime_api_trace_cbid_enum = 38;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyToSymbol_v3020: CUpti_runtime_api_trace_cbid_enum = 39;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyFromSymbol_v3020: CUpti_runtime_api_trace_cbid_enum =
    40;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyAsync_v3020: CUpti_runtime_api_trace_cbid_enum = 41;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyToArrayAsync_v3020: CUpti_runtime_api_trace_cbid_enum =
    42;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyFromArrayAsync_v3020:
    CUpti_runtime_api_trace_cbid_enum = 43;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DAsync_v3020: CUpti_runtime_api_trace_cbid_enum = 44;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DToArrayAsync_v3020:
    CUpti_runtime_api_trace_cbid_enum = 45;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DFromArrayAsync_v3020:
    CUpti_runtime_api_trace_cbid_enum = 46;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyToSymbolAsync_v3020:
    CUpti_runtime_api_trace_cbid_enum = 47;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyFromSymbolAsync_v3020:
    CUpti_runtime_api_trace_cbid_enum = 48;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemset_v3020: CUpti_runtime_api_trace_cbid_enum = 49;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemset2D_v3020: CUpti_runtime_api_trace_cbid_enum = 50;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemsetAsync_v3020: CUpti_runtime_api_trace_cbid_enum = 51;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemset2DAsync_v3020: CUpti_runtime_api_trace_cbid_enum = 52;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetSymbolAddress_v3020: CUpti_runtime_api_trace_cbid_enum =
    53;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetSymbolSize_v3020: CUpti_runtime_api_trace_cbid_enum = 54;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaBindTexture_v3020: CUpti_runtime_api_trace_cbid_enum = 55;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaBindTexture2D_v3020: CUpti_runtime_api_trace_cbid_enum = 56;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaBindTextureToArray_v3020: CUpti_runtime_api_trace_cbid_enum =
    57;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaUnbindTexture_v3020: CUpti_runtime_api_trace_cbid_enum = 58;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetTextureAlignmentOffset_v3020:
    CUpti_runtime_api_trace_cbid_enum = 59;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetTextureReference_v3020:
    CUpti_runtime_api_trace_cbid_enum = 60;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaBindSurfaceToArray_v3020: CUpti_runtime_api_trace_cbid_enum =
    61;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetSurfaceReference_v3020:
    CUpti_runtime_api_trace_cbid_enum = 62;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGLSetGLDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 63;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGLRegisterBufferObject_v3020:
    CUpti_runtime_api_trace_cbid_enum = 64;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGLMapBufferObject_v3020: CUpti_runtime_api_trace_cbid_enum =
    65;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGLUnmapBufferObject_v3020:
    CUpti_runtime_api_trace_cbid_enum = 66;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGLUnregisterBufferObject_v3020:
    CUpti_runtime_api_trace_cbid_enum = 67;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGLSetBufferObjectMapFlags_v3020:
    CUpti_runtime_api_trace_cbid_enum = 68;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGLMapBufferObjectAsync_v3020:
    CUpti_runtime_api_trace_cbid_enum = 69;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGLUnmapBufferObjectAsync_v3020:
    CUpti_runtime_api_trace_cbid_enum = 70;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaWGLGetDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 71;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsGLRegisterImage_v3020:
    CUpti_runtime_api_trace_cbid_enum = 72;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsGLRegisterBuffer_v3020:
    CUpti_runtime_api_trace_cbid_enum = 73;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsUnregisterResource_v3020:
    CUpti_runtime_api_trace_cbid_enum = 74;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsResourceSetMapFlags_v3020:
    CUpti_runtime_api_trace_cbid_enum = 75;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsMapResources_v3020:
    CUpti_runtime_api_trace_cbid_enum = 76;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsUnmapResources_v3020:
    CUpti_runtime_api_trace_cbid_enum = 77;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsResourceGetMappedPointer_v3020:
    CUpti_runtime_api_trace_cbid_enum = 78;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsSubResourceGetMappedArray_v3020:
    CUpti_runtime_api_trace_cbid_enum = 79;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaVDPAUGetDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 80;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaVDPAUSetVDPAUDevice_v3020:
    CUpti_runtime_api_trace_cbid_enum = 81;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsVDPAURegisterVideoSurface_v3020:
    CUpti_runtime_api_trace_cbid_enum = 82;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsVDPAURegisterOutputSurface_v3020:
    CUpti_runtime_api_trace_cbid_enum = 83;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D11GetDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 84;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D11GetDevices_v3020: CUpti_runtime_api_trace_cbid_enum =
    85;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D11SetDirect3DDevice_v3020:
    CUpti_runtime_api_trace_cbid_enum = 86;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsD3D11RegisterResource_v3020:
    CUpti_runtime_api_trace_cbid_enum = 87;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10GetDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 88;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10GetDevices_v3020: CUpti_runtime_api_trace_cbid_enum =
    89;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10SetDirect3DDevice_v3020:
    CUpti_runtime_api_trace_cbid_enum = 90;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsD3D10RegisterResource_v3020:
    CUpti_runtime_api_trace_cbid_enum = 91;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10RegisterResource_v3020:
    CUpti_runtime_api_trace_cbid_enum = 92;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10UnregisterResource_v3020:
    CUpti_runtime_api_trace_cbid_enum = 93;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10MapResources_v3020: CUpti_runtime_api_trace_cbid_enum =
    94;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10UnmapResources_v3020:
    CUpti_runtime_api_trace_cbid_enum = 95;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10ResourceSetMapFlags_v3020:
    CUpti_runtime_api_trace_cbid_enum = 96;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10ResourceGetSurfaceDimensions_v3020:
    CUpti_runtime_api_trace_cbid_enum = 97;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10ResourceGetMappedArray_v3020:
    CUpti_runtime_api_trace_cbid_enum = 98;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10ResourceGetMappedPointer_v3020:
    CUpti_runtime_api_trace_cbid_enum = 99;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10ResourceGetMappedSize_v3020:
    CUpti_runtime_api_trace_cbid_enum = 100;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10ResourceGetMappedPitch_v3020:
    CUpti_runtime_api_trace_cbid_enum = 101;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9GetDevice_v3020: CUpti_runtime_api_trace_cbid_enum = 102;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9GetDevices_v3020: CUpti_runtime_api_trace_cbid_enum =
    103;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9SetDirect3DDevice_v3020:
    CUpti_runtime_api_trace_cbid_enum = 104;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9GetDirect3DDevice_v3020:
    CUpti_runtime_api_trace_cbid_enum = 105;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsD3D9RegisterResource_v3020:
    CUpti_runtime_api_trace_cbid_enum = 106;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9RegisterResource_v3020:
    CUpti_runtime_api_trace_cbid_enum = 107;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9UnregisterResource_v3020:
    CUpti_runtime_api_trace_cbid_enum = 108;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9MapResources_v3020: CUpti_runtime_api_trace_cbid_enum =
    109;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9UnmapResources_v3020: CUpti_runtime_api_trace_cbid_enum =
    110;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9ResourceSetMapFlags_v3020:
    CUpti_runtime_api_trace_cbid_enum = 111;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9ResourceGetSurfaceDimensions_v3020:
    CUpti_runtime_api_trace_cbid_enum = 112;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9ResourceGetMappedArray_v3020:
    CUpti_runtime_api_trace_cbid_enum = 113;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9ResourceGetMappedPointer_v3020:
    CUpti_runtime_api_trace_cbid_enum = 114;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9ResourceGetMappedSize_v3020:
    CUpti_runtime_api_trace_cbid_enum = 115;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9ResourceGetMappedPitch_v3020:
    CUpti_runtime_api_trace_cbid_enum = 116;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9Begin_v3020: CUpti_runtime_api_trace_cbid_enum = 117;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9End_v3020: CUpti_runtime_api_trace_cbid_enum = 118;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9RegisterVertexBuffer_v3020:
    CUpti_runtime_api_trace_cbid_enum = 119;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9UnregisterVertexBuffer_v3020:
    CUpti_runtime_api_trace_cbid_enum = 120;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9MapVertexBuffer_v3020:
    CUpti_runtime_api_trace_cbid_enum = 121;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D9UnmapVertexBuffer_v3020:
    CUpti_runtime_api_trace_cbid_enum = 122;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaThreadExit_v3020: CUpti_runtime_api_trace_cbid_enum = 123;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaSetDoubleForDevice_v3020: CUpti_runtime_api_trace_cbid_enum =
    124;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaSetDoubleForHost_v3020: CUpti_runtime_api_trace_cbid_enum =
    125;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaThreadSynchronize_v3020: CUpti_runtime_api_trace_cbid_enum =
    126;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaThreadGetLimit_v3020: CUpti_runtime_api_trace_cbid_enum =
    127;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaThreadSetLimit_v3020: CUpti_runtime_api_trace_cbid_enum =
    128;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamCreate_v3020: CUpti_runtime_api_trace_cbid_enum = 129;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamDestroy_v3020: CUpti_runtime_api_trace_cbid_enum = 130;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamSynchronize_v3020: CUpti_runtime_api_trace_cbid_enum =
    131;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamQuery_v3020: CUpti_runtime_api_trace_cbid_enum = 132;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventCreate_v3020: CUpti_runtime_api_trace_cbid_enum = 133;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventCreateWithFlags_v3020:
    CUpti_runtime_api_trace_cbid_enum = 134;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventRecord_v3020: CUpti_runtime_api_trace_cbid_enum = 135;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventDestroy_v3020: CUpti_runtime_api_trace_cbid_enum = 136;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventSynchronize_v3020: CUpti_runtime_api_trace_cbid_enum =
    137;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventQuery_v3020: CUpti_runtime_api_trace_cbid_enum = 138;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventElapsedTime_v3020: CUpti_runtime_api_trace_cbid_enum =
    139;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMalloc3D_v3020: CUpti_runtime_api_trace_cbid_enum = 140;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMalloc3DArray_v3020: CUpti_runtime_api_trace_cbid_enum = 141;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemset3D_v3020: CUpti_runtime_api_trace_cbid_enum = 142;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemset3DAsync_v3020: CUpti_runtime_api_trace_cbid_enum = 143;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3D_v3020: CUpti_runtime_api_trace_cbid_enum = 144;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3DAsync_v3020: CUpti_runtime_api_trace_cbid_enum = 145;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaThreadSetCacheConfig_v3020:
    CUpti_runtime_api_trace_cbid_enum = 146;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamWaitEvent_v3020: CUpti_runtime_api_trace_cbid_enum =
    147;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D11GetDirect3DDevice_v3020:
    CUpti_runtime_api_trace_cbid_enum = 148;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaD3D10GetDirect3DDevice_v3020:
    CUpti_runtime_api_trace_cbid_enum = 149;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaThreadGetCacheConfig_v3020:
    CUpti_runtime_api_trace_cbid_enum = 150;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaPointerGetAttributes_v4000:
    CUpti_runtime_api_trace_cbid_enum = 151;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaHostRegister_v4000: CUpti_runtime_api_trace_cbid_enum = 152;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaHostUnregister_v4000: CUpti_runtime_api_trace_cbid_enum =
    153;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceCanAccessPeer_v4000:
    CUpti_runtime_api_trace_cbid_enum = 154;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceEnablePeerAccess_v4000:
    CUpti_runtime_api_trace_cbid_enum = 155;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceDisablePeerAccess_v4000:
    CUpti_runtime_api_trace_cbid_enum = 156;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaPeerRegister_v4000: CUpti_runtime_api_trace_cbid_enum = 157;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaPeerUnregister_v4000: CUpti_runtime_api_trace_cbid_enum =
    158;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaPeerGetDevicePointer_v4000:
    CUpti_runtime_api_trace_cbid_enum = 159;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyPeer_v4000: CUpti_runtime_api_trace_cbid_enum = 160;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyPeerAsync_v4000: CUpti_runtime_api_trace_cbid_enum =
    161;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3DPeer_v4000: CUpti_runtime_api_trace_cbid_enum = 162;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3DPeerAsync_v4000: CUpti_runtime_api_trace_cbid_enum =
    163;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceReset_v3020: CUpti_runtime_api_trace_cbid_enum = 164;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceSynchronize_v3020: CUpti_runtime_api_trace_cbid_enum =
    165;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetLimit_v3020: CUpti_runtime_api_trace_cbid_enum =
    166;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceSetLimit_v3020: CUpti_runtime_api_trace_cbid_enum =
    167;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetCacheConfig_v3020:
    CUpti_runtime_api_trace_cbid_enum = 168;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceSetCacheConfig_v3020:
    CUpti_runtime_api_trace_cbid_enum = 169;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaProfilerInitialize_v4000: CUpti_runtime_api_trace_cbid_enum =
    170;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaProfilerStart_v4000: CUpti_runtime_api_trace_cbid_enum = 171;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaProfilerStop_v4000: CUpti_runtime_api_trace_cbid_enum = 172;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetByPCIBusId_v4010:
    CUpti_runtime_api_trace_cbid_enum = 173;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetPCIBusId_v4010: CUpti_runtime_api_trace_cbid_enum =
    174;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGLGetDevices_v4010: CUpti_runtime_api_trace_cbid_enum = 175;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaIpcGetEventHandle_v4010: CUpti_runtime_api_trace_cbid_enum =
    176;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaIpcOpenEventHandle_v4010: CUpti_runtime_api_trace_cbid_enum =
    177;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaIpcGetMemHandle_v4010: CUpti_runtime_api_trace_cbid_enum =
    178;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaIpcOpenMemHandle_v4010: CUpti_runtime_api_trace_cbid_enum =
    179;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaIpcCloseMemHandle_v4010: CUpti_runtime_api_trace_cbid_enum =
    180;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaArrayGetInfo_v4010: CUpti_runtime_api_trace_cbid_enum = 181;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFuncSetSharedMemConfig_v4020:
    CUpti_runtime_api_trace_cbid_enum = 182;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetSharedMemConfig_v4020:
    CUpti_runtime_api_trace_cbid_enum = 183;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceSetSharedMemConfig_v4020:
    CUpti_runtime_api_trace_cbid_enum = 184;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaCreateTextureObject_v5000:
    CUpti_runtime_api_trace_cbid_enum = 185;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDestroyTextureObject_v5000:
    CUpti_runtime_api_trace_cbid_enum = 186;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetTextureObjectResourceDesc_v5000:
    CUpti_runtime_api_trace_cbid_enum = 187;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetTextureObjectTextureDesc_v5000:
    CUpti_runtime_api_trace_cbid_enum = 188;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaCreateSurfaceObject_v5000:
    CUpti_runtime_api_trace_cbid_enum = 189;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDestroySurfaceObject_v5000:
    CUpti_runtime_api_trace_cbid_enum = 190;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetSurfaceObjectResourceDesc_v5000:
    CUpti_runtime_api_trace_cbid_enum = 191;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMallocMipmappedArray_v5000:
    CUpti_runtime_api_trace_cbid_enum = 192;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetMipmappedArrayLevel_v5000:
    CUpti_runtime_api_trace_cbid_enum = 193;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFreeMipmappedArray_v5000: CUpti_runtime_api_trace_cbid_enum =
    194;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaBindTextureToMipmappedArray_v5000:
    CUpti_runtime_api_trace_cbid_enum = 195;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsResourceGetMappedMipmappedArray_v5000:
    CUpti_runtime_api_trace_cbid_enum = 196;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamAddCallback_v5000: CUpti_runtime_api_trace_cbid_enum =
    197;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamCreateWithFlags_v5000:
    CUpti_runtime_api_trace_cbid_enum = 198;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetTextureObjectResourceViewDesc_v5000:
    CUpti_runtime_api_trace_cbid_enum = 199;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetAttribute_v5000: CUpti_runtime_api_trace_cbid_enum =
    200;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamDestroy_v5050: CUpti_runtime_api_trace_cbid_enum = 201;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamCreateWithPriority_v5050:
    CUpti_runtime_api_trace_cbid_enum = 202;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetPriority_v5050: CUpti_runtime_api_trace_cbid_enum =
    203;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetFlags_v5050: CUpti_runtime_api_trace_cbid_enum =
    204;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetStreamPriorityRange_v5050:
    CUpti_runtime_api_trace_cbid_enum = 205;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMallocManaged_v6000: CUpti_runtime_api_trace_cbid_enum = 206;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaOccupancyMaxActiveBlocksPerMultiprocessor_v6000:
    CUpti_runtime_api_trace_cbid_enum = 207;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamAttachMemAsync_v6000:
    CUpti_runtime_api_trace_cbid_enum = 208;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetErrorName_v6050: CUpti_runtime_api_trace_cbid_enum = 209;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaOccupancyMaxActiveBlocksPerMultiprocessor_v6050:
    CUpti_runtime_api_trace_cbid_enum = 210;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLaunchKernel_v7000: CUpti_runtime_api_trace_cbid_enum = 211;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetDeviceFlags_v7000: CUpti_runtime_api_trace_cbid_enum =
    212;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLaunch_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum = 213;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLaunchKernel_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum =
    214;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy_ptds_v7000: CUpti_runtime_api_trace_cbid_enum = 215;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2D_ptds_v7000: CUpti_runtime_api_trace_cbid_enum = 216;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyToArray_ptds_v7000: CUpti_runtime_api_trace_cbid_enum =
    217;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DToArray_ptds_v7000:
    CUpti_runtime_api_trace_cbid_enum = 218;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyFromArray_ptds_v7000:
    CUpti_runtime_api_trace_cbid_enum = 219;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DFromArray_ptds_v7000:
    CUpti_runtime_api_trace_cbid_enum = 220;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyArrayToArray_ptds_v7000:
    CUpti_runtime_api_trace_cbid_enum = 221;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DArrayToArray_ptds_v7000:
    CUpti_runtime_api_trace_cbid_enum = 222;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyToSymbol_ptds_v7000:
    CUpti_runtime_api_trace_cbid_enum = 223;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyFromSymbol_ptds_v7000:
    CUpti_runtime_api_trace_cbid_enum = 224;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyAsync_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum =
    225;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyToArrayAsync_ptsz_v7000:
    CUpti_runtime_api_trace_cbid_enum = 226;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyFromArrayAsync_ptsz_v7000:
    CUpti_runtime_api_trace_cbid_enum = 227;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DAsync_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum =
    228;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DToArrayAsync_ptsz_v7000:
    CUpti_runtime_api_trace_cbid_enum = 229;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy2DFromArrayAsync_ptsz_v7000:
    CUpti_runtime_api_trace_cbid_enum = 230;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyToSymbolAsync_ptsz_v7000:
    CUpti_runtime_api_trace_cbid_enum = 231;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyFromSymbolAsync_ptsz_v7000:
    CUpti_runtime_api_trace_cbid_enum = 232;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemset_ptds_v7000: CUpti_runtime_api_trace_cbid_enum = 233;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemset2D_ptds_v7000: CUpti_runtime_api_trace_cbid_enum = 234;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemsetAsync_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum =
    235;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemset2DAsync_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum =
    236;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetPriority_ptsz_v7000:
    CUpti_runtime_api_trace_cbid_enum = 237;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetFlags_ptsz_v7000:
    CUpti_runtime_api_trace_cbid_enum = 238;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamSynchronize_ptsz_v7000:
    CUpti_runtime_api_trace_cbid_enum = 239;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamQuery_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum =
    240;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamAttachMemAsync_ptsz_v7000:
    CUpti_runtime_api_trace_cbid_enum = 241;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventRecord_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum =
    242;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemset3D_ptds_v7000: CUpti_runtime_api_trace_cbid_enum = 243;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemset3DAsync_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum =
    244;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3D_ptds_v7000: CUpti_runtime_api_trace_cbid_enum = 245;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3DAsync_ptsz_v7000: CUpti_runtime_api_trace_cbid_enum =
    246;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamWaitEvent_ptsz_v7000:
    CUpti_runtime_api_trace_cbid_enum = 247;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamAddCallback_ptsz_v7000:
    CUpti_runtime_api_trace_cbid_enum = 248;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3DPeer_ptds_v7000: CUpti_runtime_api_trace_cbid_enum =
    249;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3DPeerAsync_ptsz_v7000:
    CUpti_runtime_api_trace_cbid_enum = 250;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_v7000:
    CUpti_runtime_api_trace_cbid_enum = 251;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPrefetchAsync_v8000: CUpti_runtime_api_trace_cbid_enum =
    252;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPrefetchAsync_ptsz_v8000:
    CUpti_runtime_api_trace_cbid_enum = 253;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemAdvise_v8000: CUpti_runtime_api_trace_cbid_enum = 254;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetP2PAttribute_v8000:
    CUpti_runtime_api_trace_cbid_enum = 255;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsEGLRegisterImage_v7000:
    CUpti_runtime_api_trace_cbid_enum = 256;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEGLStreamConsumerConnect_v7000:
    CUpti_runtime_api_trace_cbid_enum = 257;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEGLStreamConsumerDisconnect_v7000:
    CUpti_runtime_api_trace_cbid_enum = 258;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEGLStreamConsumerAcquireFrame_v7000:
    CUpti_runtime_api_trace_cbid_enum = 259;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEGLStreamConsumerReleaseFrame_v7000:
    CUpti_runtime_api_trace_cbid_enum = 260;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEGLStreamProducerConnect_v7000:
    CUpti_runtime_api_trace_cbid_enum = 261;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEGLStreamProducerDisconnect_v7000:
    CUpti_runtime_api_trace_cbid_enum = 262;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEGLStreamProducerPresentFrame_v7000:
    CUpti_runtime_api_trace_cbid_enum = 263;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEGLStreamProducerReturnFrame_v7000:
    CUpti_runtime_api_trace_cbid_enum = 264;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphicsResourceGetMappedEglFrame_v7000:
    CUpti_runtime_api_trace_cbid_enum = 265;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemRangeGetAttribute_v8000:
    CUpti_runtime_api_trace_cbid_enum = 266;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemRangeGetAttributes_v8000:
    CUpti_runtime_api_trace_cbid_enum = 267;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEGLStreamConsumerConnectWithFlags_v7000:
    CUpti_runtime_api_trace_cbid_enum = 268;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLaunchCooperativeKernel_v9000:
    CUpti_runtime_api_trace_cbid_enum = 269;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLaunchCooperativeKernel_ptsz_v9000:
    CUpti_runtime_api_trace_cbid_enum = 270;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventCreateFromEGLSync_v9000:
    CUpti_runtime_api_trace_cbid_enum = 271;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLaunchCooperativeKernelMultiDevice_v9000:
    CUpti_runtime_api_trace_cbid_enum = 272;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFuncSetAttribute_v9000: CUpti_runtime_api_trace_cbid_enum =
    273;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaImportExternalMemory_v10000:
    CUpti_runtime_api_trace_cbid_enum = 274;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaExternalMemoryGetMappedBuffer_v10000:
    CUpti_runtime_api_trace_cbid_enum = 275;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaExternalMemoryGetMappedMipmappedArray_v10000:
    CUpti_runtime_api_trace_cbid_enum = 276;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDestroyExternalMemory_v10000:
    CUpti_runtime_api_trace_cbid_enum = 277;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaImportExternalSemaphore_v10000:
    CUpti_runtime_api_trace_cbid_enum = 278;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaSignalExternalSemaphoresAsync_v10000:
    CUpti_runtime_api_trace_cbid_enum = 279;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaSignalExternalSemaphoresAsync_ptsz_v10000:
    CUpti_runtime_api_trace_cbid_enum = 280;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaWaitExternalSemaphoresAsync_v10000:
    CUpti_runtime_api_trace_cbid_enum = 281;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaWaitExternalSemaphoresAsync_ptsz_v10000:
    CUpti_runtime_api_trace_cbid_enum = 282;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDestroyExternalSemaphore_v10000:
    CUpti_runtime_api_trace_cbid_enum = 283;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLaunchHostFunc_v10000: CUpti_runtime_api_trace_cbid_enum =
    284;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLaunchHostFunc_ptsz_v10000:
    CUpti_runtime_api_trace_cbid_enum = 285;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphCreate_v10000: CUpti_runtime_api_trace_cbid_enum = 286;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphKernelNodeGetParams_v10000:
    CUpti_runtime_api_trace_cbid_enum = 287;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphKernelNodeSetParams_v10000:
    CUpti_runtime_api_trace_cbid_enum = 288;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddKernelNode_v10000:
    CUpti_runtime_api_trace_cbid_enum = 289;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddMemcpyNode_v10000:
    CUpti_runtime_api_trace_cbid_enum = 290;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphMemcpyNodeGetParams_v10000:
    CUpti_runtime_api_trace_cbid_enum = 291;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphMemcpyNodeSetParams_v10000:
    CUpti_runtime_api_trace_cbid_enum = 292;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddMemsetNode_v10000:
    CUpti_runtime_api_trace_cbid_enum = 293;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphMemsetNodeGetParams_v10000:
    CUpti_runtime_api_trace_cbid_enum = 294;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphMemsetNodeSetParams_v10000:
    CUpti_runtime_api_trace_cbid_enum = 295;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddHostNode_v10000: CUpti_runtime_api_trace_cbid_enum =
    296;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphHostNodeGetParams_v10000:
    CUpti_runtime_api_trace_cbid_enum = 297;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddChildGraphNode_v10000:
    CUpti_runtime_api_trace_cbid_enum = 298;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphChildGraphNodeGetGraph_v10000:
    CUpti_runtime_api_trace_cbid_enum = 299;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddEmptyNode_v10000: CUpti_runtime_api_trace_cbid_enum =
    300;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphClone_v10000: CUpti_runtime_api_trace_cbid_enum = 301;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphNodeFindInClone_v10000:
    CUpti_runtime_api_trace_cbid_enum = 302;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphNodeGetType_v10000: CUpti_runtime_api_trace_cbid_enum =
    303;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphGetRootNodes_v10000: CUpti_runtime_api_trace_cbid_enum =
    304;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphNodeGetDependencies_v10000:
    CUpti_runtime_api_trace_cbid_enum = 305;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphNodeGetDependentNodes_v10000:
    CUpti_runtime_api_trace_cbid_enum = 306;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddDependencies_v10000:
    CUpti_runtime_api_trace_cbid_enum = 307;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphRemoveDependencies_v10000:
    CUpti_runtime_api_trace_cbid_enum = 308;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphDestroyNode_v10000: CUpti_runtime_api_trace_cbid_enum =
    309;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphInstantiate_v10000: CUpti_runtime_api_trace_cbid_enum =
    310;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphLaunch_v10000: CUpti_runtime_api_trace_cbid_enum = 311;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphLaunch_ptsz_v10000: CUpti_runtime_api_trace_cbid_enum =
    312;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecDestroy_v10000: CUpti_runtime_api_trace_cbid_enum =
    313;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphDestroy_v10000: CUpti_runtime_api_trace_cbid_enum = 314;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamBeginCapture_v10000:
    CUpti_runtime_api_trace_cbid_enum = 315;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamBeginCapture_ptsz_v10000:
    CUpti_runtime_api_trace_cbid_enum = 316;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamIsCapturing_v10000: CUpti_runtime_api_trace_cbid_enum =
    317;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamIsCapturing_ptsz_v10000:
    CUpti_runtime_api_trace_cbid_enum = 318;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamEndCapture_v10000: CUpti_runtime_api_trace_cbid_enum =
    319;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamEndCapture_ptsz_v10000:
    CUpti_runtime_api_trace_cbid_enum = 320;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphHostNodeSetParams_v10000:
    CUpti_runtime_api_trace_cbid_enum = 321;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphGetNodes_v10000: CUpti_runtime_api_trace_cbid_enum =
    322;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphGetEdges_v10000: CUpti_runtime_api_trace_cbid_enum =
    323;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetCaptureInfo_v10010:
    CUpti_runtime_api_trace_cbid_enum = 324;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetCaptureInfo_ptsz_v10010:
    CUpti_runtime_api_trace_cbid_enum = 325;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecKernelNodeSetParams_v10010:
    CUpti_runtime_api_trace_cbid_enum = 326;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaThreadExchangeStreamCaptureMode_v10010:
    CUpti_runtime_api_trace_cbid_enum = 327;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetNvSciSyncAttributes_v10020:
    CUpti_runtime_api_trace_cbid_enum = 328;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaOccupancyAvailableDynamicSMemPerBlock_v10200:
    CUpti_runtime_api_trace_cbid_enum = 329;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamSetFlags_v10200: CUpti_runtime_api_trace_cbid_enum =
    330;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamSetFlags_ptsz_v10200:
    CUpti_runtime_api_trace_cbid_enum = 331;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecMemcpyNodeSetParams_v10020:
    CUpti_runtime_api_trace_cbid_enum = 332;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecMemsetNodeSetParams_v10020:
    CUpti_runtime_api_trace_cbid_enum = 333;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecHostNodeSetParams_v10020:
    CUpti_runtime_api_trace_cbid_enum = 334;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecUpdate_v10020: CUpti_runtime_api_trace_cbid_enum =
    335;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetFuncBySymbol_v11000: CUpti_runtime_api_trace_cbid_enum =
    336;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaCtxResetPersistingL2Cache_v11000:
    CUpti_runtime_api_trace_cbid_enum = 337;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphKernelNodeCopyAttributes_v11000:
    CUpti_runtime_api_trace_cbid_enum = 338;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphKernelNodeGetAttribute_v11000:
    CUpti_runtime_api_trace_cbid_enum = 339;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphKernelNodeSetAttribute_v11000:
    CUpti_runtime_api_trace_cbid_enum = 340;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamCopyAttributes_v11000:
    CUpti_runtime_api_trace_cbid_enum = 341;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamCopyAttributes_ptsz_v11000:
    CUpti_runtime_api_trace_cbid_enum = 342;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetAttribute_v11000:
    CUpti_runtime_api_trace_cbid_enum = 343;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetAttribute_ptsz_v11000:
    CUpti_runtime_api_trace_cbid_enum = 344;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamSetAttribute_v11000:
    CUpti_runtime_api_trace_cbid_enum = 345;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamSetAttribute_ptsz_v11000:
    CUpti_runtime_api_trace_cbid_enum = 346;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetTexture1DLinearMaxWidth_v11010:
    CUpti_runtime_api_trace_cbid_enum = 347;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphUpload_v10000: CUpti_runtime_api_trace_cbid_enum = 348;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphUpload_ptsz_v10000: CUpti_runtime_api_trace_cbid_enum =
    349;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddMemcpyNodeToSymbol_v11010:
    CUpti_runtime_api_trace_cbid_enum = 350;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddMemcpyNodeFromSymbol_v11010:
    CUpti_runtime_api_trace_cbid_enum = 351;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddMemcpyNode1D_v11010:
    CUpti_runtime_api_trace_cbid_enum = 352;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphMemcpyNodeSetParamsToSymbol_v11010:
    CUpti_runtime_api_trace_cbid_enum = 353;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphMemcpyNodeSetParamsFromSymbol_v11010:
    CUpti_runtime_api_trace_cbid_enum = 354;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphMemcpyNodeSetParams1D_v11010:
    CUpti_runtime_api_trace_cbid_enum = 355;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecMemcpyNodeSetParamsToSymbol_v11010:
    CUpti_runtime_api_trace_cbid_enum = 356;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecMemcpyNodeSetParamsFromSymbol_v11010:
    CUpti_runtime_api_trace_cbid_enum = 357;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecMemcpyNodeSetParams1D_v11010:
    CUpti_runtime_api_trace_cbid_enum = 358;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaArrayGetSparseProperties_v11010:
    CUpti_runtime_api_trace_cbid_enum = 359;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMipmappedArrayGetSparseProperties_v11010:
    CUpti_runtime_api_trace_cbid_enum = 360;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecChildGraphNodeSetParams_v11010:
    CUpti_runtime_api_trace_cbid_enum = 361;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddEventRecordNode_v11010:
    CUpti_runtime_api_trace_cbid_enum = 362;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphEventRecordNodeGetEvent_v11010:
    CUpti_runtime_api_trace_cbid_enum = 363;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphEventRecordNodeSetEvent_v11010:
    CUpti_runtime_api_trace_cbid_enum = 364;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddEventWaitNode_v11010:
    CUpti_runtime_api_trace_cbid_enum = 365;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphEventWaitNodeGetEvent_v11010:
    CUpti_runtime_api_trace_cbid_enum = 366;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphEventWaitNodeSetEvent_v11010:
    CUpti_runtime_api_trace_cbid_enum = 367;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecEventRecordNodeSetEvent_v11010:
    CUpti_runtime_api_trace_cbid_enum = 368;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecEventWaitNodeSetEvent_v11010:
    CUpti_runtime_api_trace_cbid_enum = 369;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventRecordWithFlags_v11010:
    CUpti_runtime_api_trace_cbid_enum = 370;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventRecordWithFlags_ptsz_v11010:
    CUpti_runtime_api_trace_cbid_enum = 371;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetDefaultMemPool_v11020:
    CUpti_runtime_api_trace_cbid_enum = 372;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMallocAsync_v11020: CUpti_runtime_api_trace_cbid_enum = 373;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMallocAsync_ptsz_v11020: CUpti_runtime_api_trace_cbid_enum =
    374;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFreeAsync_v11020: CUpti_runtime_api_trace_cbid_enum = 375;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFreeAsync_ptsz_v11020: CUpti_runtime_api_trace_cbid_enum =
    376;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPoolTrimTo_v11020: CUpti_runtime_api_trace_cbid_enum =
    377;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPoolSetAttribute_v11020:
    CUpti_runtime_api_trace_cbid_enum = 378;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPoolGetAttribute_v11020:
    CUpti_runtime_api_trace_cbid_enum = 379;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPoolSetAccess_v11020: CUpti_runtime_api_trace_cbid_enum =
    380;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaArrayGetPlane_v11020: CUpti_runtime_api_trace_cbid_enum =
    381;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPoolGetAccess_v11020: CUpti_runtime_api_trace_cbid_enum =
    382;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPoolCreate_v11020: CUpti_runtime_api_trace_cbid_enum =
    383;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPoolDestroy_v11020: CUpti_runtime_api_trace_cbid_enum =
    384;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceSetMemPool_v11020: CUpti_runtime_api_trace_cbid_enum =
    385;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetMemPool_v11020: CUpti_runtime_api_trace_cbid_enum =
    386;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPoolExportToShareableHandle_v11020:
    CUpti_runtime_api_trace_cbid_enum = 387;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPoolImportFromShareableHandle_v11020:
    CUpti_runtime_api_trace_cbid_enum = 388;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPoolExportPointer_v11020:
    CUpti_runtime_api_trace_cbid_enum = 389;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPoolImportPointer_v11020:
    CUpti_runtime_api_trace_cbid_enum = 390;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMallocFromPoolAsync_v11020:
    CUpti_runtime_api_trace_cbid_enum = 391;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMallocFromPoolAsync_ptsz_v11020:
    CUpti_runtime_api_trace_cbid_enum = 392;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaSignalExternalSemaphoresAsync_v11020:
    CUpti_runtime_api_trace_cbid_enum = 393;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaSignalExternalSemaphoresAsync_ptsz_v11020:
    CUpti_runtime_api_trace_cbid_enum = 394;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaWaitExternalSemaphoresAsync_v11020:
    CUpti_runtime_api_trace_cbid_enum = 395;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaWaitExternalSemaphoresAsync_ptsz_v11020:
    CUpti_runtime_api_trace_cbid_enum = 396;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddExternalSemaphoresSignalNode_v11020:
    CUpti_runtime_api_trace_cbid_enum = 397;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExternalSemaphoresSignalNodeGetParams_v11020:
    CUpti_runtime_api_trace_cbid_enum = 398;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExternalSemaphoresSignalNodeSetParams_v11020:
    CUpti_runtime_api_trace_cbid_enum = 399;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddExternalSemaphoresWaitNode_v11020:
    CUpti_runtime_api_trace_cbid_enum = 400;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExternalSemaphoresWaitNodeGetParams_v11020:
    CUpti_runtime_api_trace_cbid_enum = 401;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExternalSemaphoresWaitNodeSetParams_v11020:
    CUpti_runtime_api_trace_cbid_enum = 402;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecExternalSemaphoresSignalNodeSetParams_v11020:
    CUpti_runtime_api_trace_cbid_enum = 403;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecExternalSemaphoresWaitNodeSetParams_v11020:
    CUpti_runtime_api_trace_cbid_enum = 404;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceFlushGPUDirectRDMAWrites_v11030:
    CUpti_runtime_api_trace_cbid_enum = 405;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetDriverEntryPoint_v11030:
    CUpti_runtime_api_trace_cbid_enum = 406;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetDriverEntryPoint_ptsz_v11030:
    CUpti_runtime_api_trace_cbid_enum = 407;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphDebugDotPrint_v11030:
    CUpti_runtime_api_trace_cbid_enum = 408;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetCaptureInfo_v2_v11030:
    CUpti_runtime_api_trace_cbid_enum = 409;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetCaptureInfo_v2_ptsz_v11030:
    CUpti_runtime_api_trace_cbid_enum = 410;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamUpdateCaptureDependencies_v11030:
    CUpti_runtime_api_trace_cbid_enum = 411;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamUpdateCaptureDependencies_ptsz_v11030:
    CUpti_runtime_api_trace_cbid_enum = 412;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaUserObjectCreate_v11030: CUpti_runtime_api_trace_cbid_enum =
    413;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaUserObjectRetain_v11030: CUpti_runtime_api_trace_cbid_enum =
    414;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaUserObjectRelease_v11030: CUpti_runtime_api_trace_cbid_enum =
    415;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphRetainUserObject_v11030:
    CUpti_runtime_api_trace_cbid_enum = 416;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphReleaseUserObject_v11030:
    CUpti_runtime_api_trace_cbid_enum = 417;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphInstantiateWithFlags_v11040:
    CUpti_runtime_api_trace_cbid_enum = 418;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddMemAllocNode_v11040:
    CUpti_runtime_api_trace_cbid_enum = 419;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphMemAllocNodeGetParams_v11040:
    CUpti_runtime_api_trace_cbid_enum = 420;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddMemFreeNode_v11040:
    CUpti_runtime_api_trace_cbid_enum = 421;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphMemFreeNodeGetParams_v11040:
    CUpti_runtime_api_trace_cbid_enum = 422;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGraphMemTrim_v11040:
    CUpti_runtime_api_trace_cbid_enum = 423;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetGraphMemAttribute_v11040:
    CUpti_runtime_api_trace_cbid_enum = 424;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceSetGraphMemAttribute_v11040:
    CUpti_runtime_api_trace_cbid_enum = 425;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphNodeSetEnabled_v11060:
    CUpti_runtime_api_trace_cbid_enum = 426;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphNodeGetEnabled_v11060:
    CUpti_runtime_api_trace_cbid_enum = 427;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaArrayGetMemoryRequirements_v11060:
    CUpti_runtime_api_trace_cbid_enum = 428;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMipmappedArrayGetMemoryRequirements_v11060:
    CUpti_runtime_api_trace_cbid_enum = 429;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLaunchKernelExC_v11060: CUpti_runtime_api_trace_cbid_enum =
    430;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLaunchKernelExC_ptsz_v11060:
    CUpti_runtime_api_trace_cbid_enum = 431;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaOccupancyMaxPotentialClusterSize_v11070:
    CUpti_runtime_api_trace_cbid_enum = 432;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaOccupancyMaxActiveClusters_v11070:
    CUpti_runtime_api_trace_cbid_enum = 433;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaCreateTextureObject_v2_v11080:
    CUpti_runtime_api_trace_cbid_enum = 434;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetTextureObjectTextureDesc_v2_v11080:
    CUpti_runtime_api_trace_cbid_enum = 435;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphInstantiateWithParams_v12000:
    CUpti_runtime_api_trace_cbid_enum = 436;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphInstantiateWithParams_ptsz_v12000:
    CUpti_runtime_api_trace_cbid_enum = 437;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecGetFlags_v12000: CUpti_runtime_api_trace_cbid_enum =
    438;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetKernel_v12000: CUpti_runtime_api_trace_cbid_enum = 439;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetDeviceProperties_v12000:
    CUpti_runtime_api_trace_cbid_enum = 440;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetId_v12000: CUpti_runtime_api_trace_cbid_enum = 441;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetId_ptsz_v12000: CUpti_runtime_api_trace_cbid_enum =
    442;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphInstantiate_v12000: CUpti_runtime_api_trace_cbid_enum =
    443;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaInitDevice_v12000: CUpti_runtime_api_trace_cbid_enum = 444;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddNode_v12020: CUpti_runtime_api_trace_cbid_enum = 445;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphNodeSetParams_v12020:
    CUpti_runtime_api_trace_cbid_enum = 446;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphExecNodeSetParams_v12020:
    CUpti_runtime_api_trace_cbid_enum = 447;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemAdvise_v12020: CUpti_runtime_api_trace_cbid_enum = 448;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPrefetchAsync_v12020: CUpti_runtime_api_trace_cbid_enum =
    449;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPrefetchAsync_ptsz_v12020:
    CUpti_runtime_api_trace_cbid_enum = 450;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFuncGetName_v12030: CUpti_runtime_api_trace_cbid_enum = 451;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamBeginCaptureToGraph_v12030:
    CUpti_runtime_api_trace_cbid_enum = 452;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamBeginCaptureToGraph_ptsz_v12030:
    CUpti_runtime_api_trace_cbid_enum = 453;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphConditionalHandleCreate_v12030:
    CUpti_runtime_api_trace_cbid_enum = 454;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphGetEdges_v12030: CUpti_runtime_api_trace_cbid_enum =
    455;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphNodeGetDependencies_v12030:
    CUpti_runtime_api_trace_cbid_enum = 456;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphNodeGetDependentNodes_v12030:
    CUpti_runtime_api_trace_cbid_enum = 457;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddDependencies_v12030:
    CUpti_runtime_api_trace_cbid_enum = 458;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphRemoveDependencies_v12030:
    CUpti_runtime_api_trace_cbid_enum = 459;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGraphAddNode_v12030: CUpti_runtime_api_trace_cbid_enum = 460;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetCaptureInfo_v12030:
    CUpti_runtime_api_trace_cbid_enum = 461;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetCaptureInfo_ptsz_v12030:
    CUpti_runtime_api_trace_cbid_enum = 462;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamUpdateCaptureDependencies_v12030:
    CUpti_runtime_api_trace_cbid_enum = 463;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamUpdateCaptureDependencies_ptsz_v12030:
    CUpti_runtime_api_trace_cbid_enum = 464;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceRegisterAsyncNotification_v12040:
    CUpti_runtime_api_trace_cbid_enum = 465;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceUnregisterAsyncNotification_v12040:
    CUpti_runtime_api_trace_cbid_enum = 466;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaFuncGetParamInfo_v12040: CUpti_runtime_api_trace_cbid_enum =
    467;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetDriverEntryPointByVersion_v12050:
    CUpti_runtime_api_trace_cbid_enum = 468;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetDriverEntryPointByVersion_ptsz_v12050:
    CUpti_runtime_api_trace_cbid_enum = 469;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLibraryLoadData_v12060: CUpti_runtime_api_trace_cbid_enum =
    470;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLibraryLoadFromFile_v12060:
    CUpti_runtime_api_trace_cbid_enum = 471;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLibraryUnload_v12060: CUpti_runtime_api_trace_cbid_enum =
    472;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLibraryGetKernel_v12060: CUpti_runtime_api_trace_cbid_enum =
    473;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLibraryGetGlobal_v12060: CUpti_runtime_api_trace_cbid_enum =
    474;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLibraryGetManaged_v12060: CUpti_runtime_api_trace_cbid_enum =
    475;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLibraryGetUnifiedFunction_v12060:
    CUpti_runtime_api_trace_cbid_enum = 476;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLibraryGetKernelCount_v12060:
    CUpti_runtime_api_trace_cbid_enum = 477;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLibraryEnumerateKernels_v12060:
    CUpti_runtime_api_trace_cbid_enum = 478;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaKernelSetAttributeForDevice_v12060:
    CUpti_runtime_api_trace_cbid_enum = 479;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetDevice_v12080: CUpti_runtime_api_trace_cbid_enum =
    480;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaStreamGetDevice_ptsz_v12080:
    CUpti_runtime_api_trace_cbid_enum = 481;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyBatchAsync_v12080: CUpti_runtime_api_trace_cbid_enum =
    482;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyBatchAsync_ptsz_v12080:
    CUpti_runtime_api_trace_cbid_enum = 483;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3DBatchAsync_v12080:
    CUpti_runtime_api_trace_cbid_enum = 484;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3DBatchAsync_ptsz_v12080:
    CUpti_runtime_api_trace_cbid_enum = 485;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaEventElapsedTime_v12080: CUpti_runtime_api_trace_cbid_enum =
    486;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPrefetchBatchAsync_v13000:
    CUpti_runtime_api_trace_cbid_enum = 487;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemPrefetchBatchAsync_ptsz_v13000:
    CUpti_runtime_api_trace_cbid_enum = 488;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemDiscardBatchAsync_v13000:
    CUpti_runtime_api_trace_cbid_enum = 489;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemDiscardBatchAsync_ptsz_v13000:
    CUpti_runtime_api_trace_cbid_enum = 490;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemDiscardAndPrefetchBatchAsync_v13000:
    CUpti_runtime_api_trace_cbid_enum = 491;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemDiscardAndPrefetchBatchAsync_ptsz_v13000:
    CUpti_runtime_api_trace_cbid_enum = 492;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaGetExportTable_v13000: CUpti_runtime_api_trace_cbid_enum =
    493;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaRegisterFatBinary_v13000:
    CUpti_runtime_api_trace_cbid_enum = 494;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaRegisterFatBinaryEnd_v13000:
    CUpti_runtime_api_trace_cbid_enum = 495;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaUnregisterFatBinary_v13000:
    CUpti_runtime_api_trace_cbid_enum = 496;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaRegisterVar_v13000: CUpti_runtime_api_trace_cbid_enum =
    497;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaRegisterHostVar_v13000: CUpti_runtime_api_trace_cbid_enum =
    498;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaRegisterFunction_v13000:
    CUpti_runtime_api_trace_cbid_enum = 499;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaRegisterManagedVar_v13000:
    CUpti_runtime_api_trace_cbid_enum = 500;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaInitModule_v13000: CUpti_runtime_api_trace_cbid_enum = 501;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaPushCallConfiguration_v13000:
    CUpti_runtime_api_trace_cbid_enum = 502;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaPopCallConfiguration_v13000:
    CUpti_runtime_api_trace_cbid_enum = 503;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaGetKernel_v13000: CUpti_runtime_api_trace_cbid_enum = 504;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaLaunchKernel_v13000: CUpti_runtime_api_trace_cbid_enum =
    505;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaLaunchKernel_ptsz_v13000:
    CUpti_runtime_api_trace_cbid_enum = 506;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaRegisterUnifiedTable_v13000:
    CUpti_runtime_api_trace_cbid_enum = 507;
pub const CUPTI_RUNTIME_TRACE_CBID___cudaGetProcAddress_v13000: CUpti_runtime_api_trace_cbid_enum =
    508;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyBatchAsync_v13000: CUpti_runtime_api_trace_cbid_enum =
    509;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpyBatchAsync_ptsz_v13000:
    CUpti_runtime_api_trace_cbid_enum = 510;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3DBatchAsync_v13000:
    CUpti_runtime_api_trace_cbid_enum = 511;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemcpy3DBatchAsync_ptsz_v13000:
    CUpti_runtime_api_trace_cbid_enum = 512;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLogsRegisterCallback_v13000:
    CUpti_runtime_api_trace_cbid_enum = 513;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLogsUnregisterCallback_v13000:
    CUpti_runtime_api_trace_cbid_enum = 514;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLogsCurrent_v13000: CUpti_runtime_api_trace_cbid_enum = 515;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLogsDumpToFile_v13000: CUpti_runtime_api_trace_cbid_enum =
    516;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaLogsDumpToMemory_v13000: CUpti_runtime_api_trace_cbid_enum =
    517;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemGetDefaultMemPool_v13000:
    CUpti_runtime_api_trace_cbid_enum = 518;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemGetMemPool_v13000: CUpti_runtime_api_trace_cbid_enum =
    519;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaMemSetMemPool_v13000: CUpti_runtime_api_trace_cbid_enum =
    520;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetHostAtomicCapabilities_v13000:
    CUpti_runtime_api_trace_cbid_enum = 521;
pub const CUPTI_RUNTIME_TRACE_CBID_cudaDeviceGetP2PAtomicCapabilities_v13000:
    CUpti_runtime_api_trace_cbid_enum = 522;
pub const CUPTI_RUNTIME_TRACE_CBID_SIZE: CUpti_runtime_api_trace_cbid_enum = 523;
pub const CUPTI_RUNTIME_TRACE_CBID_FORCE_INT: CUpti_runtime_api_trace_cbid_enum = 2147483647;
pub type CUpti_runtime_api_trace_cbid_enum = ::std::os::raw::c_uint;
pub use self::CUpti_runtime_api_trace_cbid_enum as CUpti_runtime_api_trace_cbid;
pub const CUPTI_CBID_NVTX_INVALID: CUpti_nvtx_api_trace_cbid = 0;
pub const CUPTI_CBID_NVTX_nvtxMarkA: CUpti_nvtx_api_trace_cbid = 1;
pub const CUPTI_CBID_NVTX_nvtxMarkW: CUpti_nvtx_api_trace_cbid = 2;
pub const CUPTI_CBID_NVTX_nvtxMarkEx: CUpti_nvtx_api_trace_cbid = 3;
pub const CUPTI_CBID_NVTX_nvtxRangeStartA: CUpti_nvtx_api_trace_cbid = 4;
pub const CUPTI_CBID_NVTX_nvtxRangeStartW: CUpti_nvtx_api_trace_cbid = 5;
pub const CUPTI_CBID_NVTX_nvtxRangeStartEx: CUpti_nvtx_api_trace_cbid = 6;
pub const CUPTI_CBID_NVTX_nvtxRangeEnd: CUpti_nvtx_api_trace_cbid = 7;
pub const CUPTI_CBID_NVTX_nvtxRangePushA: CUpti_nvtx_api_trace_cbid = 8;
pub const CUPTI_CBID_NVTX_nvtxRangePushW: CUpti_nvtx_api_trace_cbid = 9;
pub const CUPTI_CBID_NVTX_nvtxRangePushEx: CUpti_nvtx_api_trace_cbid = 10;
pub const CUPTI_CBID_NVTX_nvtxRangePop: CUpti_nvtx_api_trace_cbid = 11;
pub const CUPTI_CBID_NVTX_nvtxNameCategoryA: CUpti_nvtx_api_trace_cbid = 12;
pub const CUPTI_CBID_NVTX_nvtxNameCategoryW: CUpti_nvtx_api_trace_cbid = 13;
pub const CUPTI_CBID_NVTX_nvtxNameOsThreadA: CUpti_nvtx_api_trace_cbid = 14;
pub const CUPTI_CBID_NVTX_nvtxNameOsThreadW: CUpti_nvtx_api_trace_cbid = 15;
pub const CUPTI_CBID_NVTX_nvtxNameCuDeviceA: CUpti_nvtx_api_trace_cbid = 16;
pub const CUPTI_CBID_NVTX_nvtxNameCuDeviceW: CUpti_nvtx_api_trace_cbid = 17;
pub const CUPTI_CBID_NVTX_nvtxNameCuContextA: CUpti_nvtx_api_trace_cbid = 18;
pub const CUPTI_CBID_NVTX_nvtxNameCuContextW: CUpti_nvtx_api_trace_cbid = 19;
pub const CUPTI_CBID_NVTX_nvtxNameCuStreamA: CUpti_nvtx_api_trace_cbid = 20;
pub const CUPTI_CBID_NVTX_nvtxNameCuStreamW: CUpti_nvtx_api_trace_cbid = 21;
pub const CUPTI_CBID_NVTX_nvtxNameCuEventA: CUpti_nvtx_api_trace_cbid = 22;
pub const CUPTI_CBID_NVTX_nvtxNameCuEventW: CUpti_nvtx_api_trace_cbid = 23;
pub const CUPTI_CBID_NVTX_nvtxNameCudaDeviceA: CUpti_nvtx_api_trace_cbid = 24;
pub const CUPTI_CBID_NVTX_nvtxNameCudaDeviceW: CUpti_nvtx_api_trace_cbid = 25;
pub const CUPTI_CBID_NVTX_nvtxNameCudaStreamA: CUpti_nvtx_api_trace_cbid = 26;
pub const CUPTI_CBID_NVTX_nvtxNameCudaStreamW: CUpti_nvtx_api_trace_cbid = 27;
pub const CUPTI_CBID_NVTX_nvtxNameCudaEventA: CUpti_nvtx_api_trace_cbid = 28;
pub const CUPTI_CBID_NVTX_nvtxNameCudaEventW: CUpti_nvtx_api_trace_cbid = 29;
pub const CUPTI_CBID_NVTX_nvtxDomainMarkEx: CUpti_nvtx_api_trace_cbid = 30;
pub const CUPTI_CBID_NVTX_nvtxDomainRangeStartEx: CUpti_nvtx_api_trace_cbid = 31;
pub const CUPTI_CBID_NVTX_nvtxDomainRangeEnd: CUpti_nvtx_api_trace_cbid = 32;
pub const CUPTI_CBID_NVTX_nvtxDomainRangePushEx: CUpti_nvtx_api_trace_cbid = 33;
pub const CUPTI_CBID_NVTX_nvtxDomainRangePop: CUpti_nvtx_api_trace_cbid = 34;
pub const CUPTI_CBID_NVTX_nvtxDomainResourceCreate: CUpti_nvtx_api_trace_cbid = 35;
pub const CUPTI_CBID_NVTX_nvtxDomainResourceDestroy: CUpti_nvtx_api_trace_cbid = 36;
pub const CUPTI_CBID_NVTX_nvtxDomainNameCategoryA: CUpti_nvtx_api_trace_cbid = 37;
pub const CUPTI_CBID_NVTX_nvtxDomainNameCategoryW: CUpti_nvtx_api_trace_cbid = 38;
pub const CUPTI_CBID_NVTX_nvtxDomainRegisterStringA: CUpti_nvtx_api_trace_cbid = 39;
pub const CUPTI_CBID_NVTX_nvtxDomainRegisterStringW: CUpti_nvtx_api_trace_cbid = 40;
pub const CUPTI_CBID_NVTX_nvtxDomainCreateA: CUpti_nvtx_api_trace_cbid = 41;
pub const CUPTI_CBID_NVTX_nvtxDomainCreateW: CUpti_nvtx_api_trace_cbid = 42;
pub const CUPTI_CBID_NVTX_nvtxDomainDestroy: CUpti_nvtx_api_trace_cbid = 43;
pub const CUPTI_CBID_NVTX_nvtxDomainSyncUserCreate: CUpti_nvtx_api_trace_cbid = 44;
pub const CUPTI_CBID_NVTX_nvtxDomainSyncUserDestroy: CUpti_nvtx_api_trace_cbid = 45;
pub const CUPTI_CBID_NVTX_nvtxDomainSyncUserAcquireStart: CUpti_nvtx_api_trace_cbid = 46;
pub const CUPTI_CBID_NVTX_nvtxDomainSyncUserAcquireFailed: CUpti_nvtx_api_trace_cbid = 47;
pub const CUPTI_CBID_NVTX_nvtxDomainSyncUserAcquireSuccess: CUpti_nvtx_api_trace_cbid = 48;
pub const CUPTI_CBID_NVTX_nvtxDomainSyncUserReleasing: CUpti_nvtx_api_trace_cbid = 49;
pub const CUPTI_CBID_NVTX_SIZE: CUpti_nvtx_api_trace_cbid = 50;
pub const CUPTI_CBID_NVTX_FORCE_INT: CUpti_nvtx_api_trace_cbid = 2147483647;
pub type CUpti_nvtx_api_trace_cbid = ::std::os::raw::c_uint;
#[doc = "!< Default behavior"]
pub const CUPTI_CHECKPOINT_OPT_NONE: CUpti_CheckpointOptimizations = 0;
#[doc = "!< Determine which mem blocks have changed, and only restore those. This optimization is cached, which means cuptiCheckpointRestore must always be called at the same point in the application when this option is enabled, or the result may be incorrect."]
pub const CUPTI_CHECKPOINT_OPT_TRANSFER: CUpti_CheckpointOptimizations = 1;
#[doc = " \\brief Specifies optimization options for a checkpoint, may be OR'd together to specify multiple options."]
pub type CUpti_CheckpointOptimizations = ::std::os::raw::c_uint;
#[doc = " \\brief Configuration and handle for a CUPTI Checkpoint\n\n A CUptiCheckpoint object should be initialized with desired options prior to passing into any\n CUPTI Checkpoint API function.  The first call into a Checkpoint API function will initialize internal\n state based on these options.  Subsequent changes to these options will not have any effect.\n\n Checkpoint data is saved in device, host, and filesystem space.  There are options to reserve memory\n at each level (device, host, filesystem) which are intended to allow a guarantee that a certain amount\n of memory will remain free for use after the checkpoint is saved.\n Note, however, that falling back to slower levels of memory (host, and then filesystem) to save the checkpoint\n will result in performance degradation.\n Currently, the filesystem limitation is not implemented.  Note that falling back to filesystem storage may\n significantly impact the performance for saving and restoring a checkpoint."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Checkpoint {
    #[doc = "!< [in] Must be set to CUpti_Checkpoint_STRUCT_SIZE"]
    pub structSize: usize,
    #[doc = "!< [in] Set to context to save from, or will use current context if NULL"]
    pub ctx: CUcontext,
    #[doc = "!< [in] Restrict checkpoint from using last N MB of device memory (-1 = use no device memory)"]
    pub reserveDeviceMB: usize,
    #[doc = "!< [in] Restrict checkpoint from using last N MB of host memory (-1 = use no host memory)"]
    pub reserveHostMB: usize,
    #[doc = "!< [in] Boolean, Allow checkpoint to save over existing checkpoint"]
    pub allowOverwrite: u8,
    #[doc = "!< [in] Mask of CUpti_CheckpointOptimizations flags for this checkpoint"]
    pub optimizations: u8,
    #[doc = "!< [in] Assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Checkpoint"][::std::mem::size_of::<CUpti_Checkpoint>() - 48usize];
    ["Alignment of CUpti_Checkpoint"][::std::mem::align_of::<CUpti_Checkpoint>() - 8usize];
    ["Offset of field: CUpti_Checkpoint::structSize"]
        [::std::mem::offset_of!(CUpti_Checkpoint, structSize) - 0usize];
    ["Offset of field: CUpti_Checkpoint::ctx"]
        [::std::mem::offset_of!(CUpti_Checkpoint, ctx) - 8usize];
    ["Offset of field: CUpti_Checkpoint::reserveDeviceMB"]
        [::std::mem::offset_of!(CUpti_Checkpoint, reserveDeviceMB) - 16usize];
    ["Offset of field: CUpti_Checkpoint::reserveHostMB"]
        [::std::mem::offset_of!(CUpti_Checkpoint, reserveHostMB) - 24usize];
    ["Offset of field: CUpti_Checkpoint::allowOverwrite"]
        [::std::mem::offset_of!(CUpti_Checkpoint, allowOverwrite) - 32usize];
    ["Offset of field: CUpti_Checkpoint::optimizations"]
        [::std::mem::offset_of!(CUpti_Checkpoint, optimizations) - 33usize];
    ["Offset of field: CUpti_Checkpoint::pPriv"]
        [::std::mem::offset_of!(CUpti_Checkpoint, pPriv) - 40usize];
};
impl Default for CUpti_Checkpoint {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Initialize and save a checkpoint of the device state associated with the handle context\n\n Uses the handle options to configure and save a checkpoint of the device state associated with the specified context.\n\n \\param handle A pointer to a CUpti_Checkpoint object\n\n \\retval CUPTI_SUCCESS if a checkpoint was successfully initialized and saved\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p handle does not appear to refer to a valid CUpti_Checkpoint\n \\retval CUPTI_ERROR_INVALID_CONTEXT\n \\retval CUPTI_ERROR_INVALID_DEVICE if device associated with context is not compatible with checkpoint API\n \\retval CUPTI_ERROR_INVALID_OPERATION if Save is requested over an existing checkpoint, but \\p allowOverwrite was not originally specified\n \\retval CUPTI_ERROR_OUT_OF_MEMORY if as configured, not enough backing storage space to save the checkpoint"]
    #[link_name = "\u{1}_Z19cuptiCheckpointSaveP16CUpti_Checkpoint"]
    pub fn cuptiCheckpointSave(handle: *mut CUpti_Checkpoint) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Restore a checkpoint to the device associated with its context\n\n Restores device, pinned, and allocated memory to the state when the checkpoint was saved\n\n \\param handle A pointer to a previously saved CUpti_Checkpoint object\n\n \\retval CUTPI_SUCCESS if the checkpoint was successfully restored\n \\retval CUPTI_ERROR_NOT_INITIALIZED if the checkpoint was not previously initialized\n \\retval CUPTI_ERROR_INVALID_CONTEXT\n \\retval CUPTI_ERROR_INVALID_PARAMETER if the handle appears invalid\n \\retval CUPTI_ERROR_UNKNOWN if the restore or optimization operation fails"]
    #[link_name = "\u{1}_Z22cuptiCheckpointRestoreP16CUpti_Checkpoint"]
    pub fn cuptiCheckpointRestore(handle: *mut CUpti_Checkpoint) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Free the backing data for a checkpoint\n\n Frees all associated device, host memory and filesystem storage used for this context.\n After freeing a handle, it may be re-used as if it was new - options may be re-configured and will\n take effect on the next call to \\p cuptiCheckpointSave.\n\n \\param handle A pointer to a previously saved CUpti_Checkpoint object\n\n \\retval CUPTI_SUCCESS if the handle was successfully freed\n \\retval CUPTI_ERROR_INVALID_PARAMETER if the handle was already freed or appears invalid\n \\retval CUPTI_ERROR_INVALID_CONTEXT if the context is no longer valid"]
    #[link_name = "\u{1}_Z19cuptiCheckpointFreeP16CUpti_Checkpoint"]
    pub fn cuptiCheckpointFree(handle: *mut CUpti_Checkpoint) -> CUptiResult;
}
#[doc = " INVALID Value"]
pub const CUPTI_PC_SAMPLING_COLLECTION_MODE_INVALID: CUpti_PCSamplingCollectionMode = 0;
#[doc = " Continuous mode. Kernels are not serialized in this mode."]
pub const CUPTI_PC_SAMPLING_COLLECTION_MODE_CONTINUOUS: CUpti_PCSamplingCollectionMode = 1;
#[doc = " Serialized mode. Kernels are serialized in this mode."]
pub const CUPTI_PC_SAMPLING_COLLECTION_MODE_KERNEL_SERIALIZED: CUpti_PCSamplingCollectionMode = 2;
#[doc = " \\brief PC Sampling collection mode"]
pub type CUpti_PCSamplingCollectionMode = ::std::os::raw::c_uint;
#[doc = " \\brief PC Sampling stall reasons"]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_PCSamplingStallReason {
    #[doc = " [r] Collected stall reason index"]
    pub pcSamplingStallReasonIndex: u32,
    #[doc = " [r] Number of times the PC was sampled with the stallReason."]
    pub samples: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PCSamplingStallReason"]
        [::std::mem::size_of::<CUpti_PCSamplingStallReason>() - 8usize];
    ["Alignment of CUpti_PCSamplingStallReason"]
        [::std::mem::align_of::<CUpti_PCSamplingStallReason>() - 8usize];
    ["Offset of field: CUpti_PCSamplingStallReason::pcSamplingStallReasonIndex"]
        [::std::mem::offset_of!(CUpti_PCSamplingStallReason, pcSamplingStallReasonIndex) - 0usize];
    ["Offset of field: CUpti_PCSamplingStallReason::samples"]
        [::std::mem::offset_of!(CUpti_PCSamplingStallReason, samples) - 4usize];
};
#[doc = " \\brief PC Sampling data"]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingPCData {
    #[doc = " [w] Size of the data structure.\n CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are\n available in the structure. Used to preserve backward compatibility."]
    pub size: usize,
    #[doc = " [r] Unique cubin id"]
    pub cubinCrc: u64,
    #[doc = " [r] PC offset"]
    pub pcOffset: u64,
    #[doc = " The function's unique symbol index in the module."]
    pub functionIndex: u32,
    #[doc = " Padding"]
    pub pad: u32,
    #[doc = " [r] The function name. This name string might be shared across all the records\n including records from activity APIs representing the same function, and so it should not be\n modified or freed until post processing of all the records is done. Once done, it is users responsibility to\n free the memory using free() function."]
    pub functionName: *mut ::std::os::raw::c_char,
    #[doc = " [r] Collected stall reason count"]
    pub stallReasonCount: usize,
    #[doc = " [r] Stall reason id\n Total samples"]
    pub stallReason: *mut CUpti_PCSamplingStallReason,
    #[doc = " The correlation ID of the kernel to which this result is associated. Only valid for serialized mode of pc sampling collection.\n For continous mode of collection the correlationId will be set to 0."]
    pub correlationId: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PCSamplingPCData"][::std::mem::size_of::<CUpti_PCSamplingPCData>() - 64usize];
    ["Alignment of CUpti_PCSamplingPCData"]
        [::std::mem::align_of::<CUpti_PCSamplingPCData>() - 8usize];
    ["Offset of field: CUpti_PCSamplingPCData::size"]
        [::std::mem::offset_of!(CUpti_PCSamplingPCData, size) - 0usize];
    ["Offset of field: CUpti_PCSamplingPCData::cubinCrc"]
        [::std::mem::offset_of!(CUpti_PCSamplingPCData, cubinCrc) - 8usize];
    ["Offset of field: CUpti_PCSamplingPCData::pcOffset"]
        [::std::mem::offset_of!(CUpti_PCSamplingPCData, pcOffset) - 16usize];
    ["Offset of field: CUpti_PCSamplingPCData::functionIndex"]
        [::std::mem::offset_of!(CUpti_PCSamplingPCData, functionIndex) - 24usize];
    ["Offset of field: CUpti_PCSamplingPCData::pad"]
        [::std::mem::offset_of!(CUpti_PCSamplingPCData, pad) - 28usize];
    ["Offset of field: CUpti_PCSamplingPCData::functionName"]
        [::std::mem::offset_of!(CUpti_PCSamplingPCData, functionName) - 32usize];
    ["Offset of field: CUpti_PCSamplingPCData::stallReasonCount"]
        [::std::mem::offset_of!(CUpti_PCSamplingPCData, stallReasonCount) - 40usize];
    ["Offset of field: CUpti_PCSamplingPCData::stallReason"]
        [::std::mem::offset_of!(CUpti_PCSamplingPCData, stallReason) - 48usize];
    ["Offset of field: CUpti_PCSamplingPCData::correlationId"]
        [::std::mem::offset_of!(CUpti_PCSamplingPCData, correlationId) - 56usize];
};
impl Default for CUpti_PCSamplingPCData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CUPTI_PC_SAMPLING_OUTPUT_DATA_FORMAT_INVALID: CUpti_PCSamplingOutputDataFormat = 0;
#[doc = " HW buffer data will be parsed during collection of data"]
pub const CUPTI_PC_SAMPLING_OUTPUT_DATA_FORMAT_PARSED: CUpti_PCSamplingOutputDataFormat = 1;
#[doc = " \\brief PC Sampling output data format"]
pub type CUpti_PCSamplingOutputDataFormat = ::std::os::raw::c_uint;
#[doc = " \\brief Collected PC Sampling data\n"]
#[repr(C, packed(8))]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingData {
    #[doc = " [w] Size of the data structure.\n CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are\n available in the structure. Used to preserve backward compatibility."]
    pub size: usize,
    #[doc = " [w] Number of PCs to be collected"]
    pub collectNumPcs: usize,
    #[doc = " [r] Number of samples collected across all PCs.\n It includes samples for user modules, samples for non-user kernels and dropped samples.\n It includes counts for all non selected stall reasons.\n CUPTI does not provide PC records for non-user kernels.\n CUPTI does not provide PC records for instructions for which all selected stall reason metrics counts are zero."]
    pub totalSamples: u64,
    #[doc = " [r] Number of samples that were dropped by hardware due to backpressure/overflow."]
    pub droppedSamples: u64,
    #[doc = " [r] Number of PCs collected"]
    pub totalNumPcs: usize,
    #[doc = " [r] Number of PCs available for collection"]
    pub remainingNumPcs: usize,
    #[doc = " [r] Unique identifier for each range.\n Data collected across multiple ranges in multiple buffers can be identified using range id."]
    pub rangeId: u64,
    #[doc = " [r] Profiled PC data\n This data struct should have enough memory to collect number of PCs mentioned in \\brief collectNumPcs"]
    pub pPcData: *mut CUpti_PCSamplingPCData,
    #[doc = " [r] Number of samples collected across all non user kernels PCs.\n It includes samples for non-user kernels.\n It includes counts for all non selected stall reasons as well.\n CUPTI does not provide PC records for non-user kernels."]
    pub nonUsrKernelsTotalSamples: u64,
    #[doc = " [r] Status of the hardware buffer.\n CUPTI returns the error code CUPTI_ERROR_OUT_OF_MEMORY when hardware buffer is full.\n When hardware buffer is full, user will get pc data as 0. To mitigate this issue, one or more of the below options can be tried:\n 1. Increase the hardware buffer size using the attribute CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_HARDWARE_BUFFER_SIZE\n 2. Decrease the thread sleep span using the attribute CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_WORKER_THREAD_PERIODIC_SLEEP_SPAN\n 3. Decrease the sampling frequency using the attribute CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_SAMPLING_PERIOD"]
    pub hardwareBufferFull: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PCSamplingData"][::std::mem::size_of::<CUpti_PCSamplingData>() - 80usize];
    ["Alignment of CUpti_PCSamplingData"][::std::mem::align_of::<CUpti_PCSamplingData>() - 8usize];
    ["Offset of field: CUpti_PCSamplingData::size"]
        [::std::mem::offset_of!(CUpti_PCSamplingData, size) - 0usize];
    ["Offset of field: CUpti_PCSamplingData::collectNumPcs"]
        [::std::mem::offset_of!(CUpti_PCSamplingData, collectNumPcs) - 8usize];
    ["Offset of field: CUpti_PCSamplingData::totalSamples"]
        [::std::mem::offset_of!(CUpti_PCSamplingData, totalSamples) - 16usize];
    ["Offset of field: CUpti_PCSamplingData::droppedSamples"]
        [::std::mem::offset_of!(CUpti_PCSamplingData, droppedSamples) - 24usize];
    ["Offset of field: CUpti_PCSamplingData::totalNumPcs"]
        [::std::mem::offset_of!(CUpti_PCSamplingData, totalNumPcs) - 32usize];
    ["Offset of field: CUpti_PCSamplingData::remainingNumPcs"]
        [::std::mem::offset_of!(CUpti_PCSamplingData, remainingNumPcs) - 40usize];
    ["Offset of field: CUpti_PCSamplingData::rangeId"]
        [::std::mem::offset_of!(CUpti_PCSamplingData, rangeId) - 48usize];
    ["Offset of field: CUpti_PCSamplingData::pPcData"]
        [::std::mem::offset_of!(CUpti_PCSamplingData, pPcData) - 56usize];
    ["Offset of field: CUpti_PCSamplingData::nonUsrKernelsTotalSamples"]
        [::std::mem::offset_of!(CUpti_PCSamplingData, nonUsrKernelsTotalSamples) - 64usize];
    ["Offset of field: CUpti_PCSamplingData::hardwareBufferFull"]
        [::std::mem::offset_of!(CUpti_PCSamplingData, hardwareBufferFull) - 72usize];
};
impl Default for CUpti_PCSamplingData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_INVALID:
    CUpti_PCSamplingConfigurationAttributeType = 0;
#[doc = " [rw] Sampling period for PC Sampling.\n DEFAULT - CUPTI defined value based on number of SMs\n Valid values for the sampling\n periods are between 5 to 31 both inclusive. This will set the\n sampling period to (2^samplingPeriod) cycles.\n For e.g. for sampling period = 5 to 31, cycles = 32, 64, 128,..., 2^31\n Value is a uint32_t"]
pub const CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_SAMPLING_PERIOD:
    CUpti_PCSamplingConfigurationAttributeType = 1;
#[doc = " [w] Number of stall reasons to collect.\n DEFAULT - All stall reasons will be collected\n Value is a size_t\n [w] Stall reasons to collect\n DEFAULT - All stall reasons will be collected\n Input value should be a pointer pointing to array of stall reason indexes\n containing all the stall reason indexes to collect."]
pub const CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_STALL_REASON:
    CUpti_PCSamplingConfigurationAttributeType = 2;
#[doc = " [rw] Size of SW buffer for raw PC counter data downloaded from HW buffer\n DEFAULT - 1 MB, which can accommodate approximately 5500 PCs\n with all stall reasons\n Approximately it takes 16 Bytes (and some fixed size memory)\n to accommodate one PC with one stall reason\n For e.g. 1 PC with 1 stall reason = 32 Bytes\n          1 PC with 2 stall reason = 48 Bytes\n          1 PC with 4 stall reason = 96 Bytes\n Value is a size_t"]
pub const CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_SCRATCH_BUFFER_SIZE:
    CUpti_PCSamplingConfigurationAttributeType = 3;
#[doc = " [rw] Size of HW buffer in bytes\n DEFAULT - 512 MB\n If sampling period is too less, HW buffer can overflow\n and drop PC data\n Value is a size_t"]
pub const CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_HARDWARE_BUFFER_SIZE:
    CUpti_PCSamplingConfigurationAttributeType = 4;
#[doc = " [rw] PC Sampling collection mode\n DEFAULT - CUPTI_PC_SAMPLING_COLLECTION_MODE_CONTINUOUS\n Input value should be of type \\ref CUpti_PCSamplingCollectionMode."]
pub const CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_COLLECTION_MODE:
    CUpti_PCSamplingConfigurationAttributeType = 5;
#[doc = " [rw] Control over PC Sampling data collection range\n Default - 0\n 1 - Allows user to start and stop PC Sampling using APIs -\n \\ref cuptiPCSamplingStart() - Start PC Sampling\n \\ref cuptiPCSamplingStop() - Stop PC Sampling\n Value is a uint32_t"]
pub const CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_ENABLE_START_STOP_CONTROL:
    CUpti_PCSamplingConfigurationAttributeType = 6;
#[doc = " [w] Value for output data format\n Default - CUPTI_PC_SAMPLING_OUTPUT_DATA_FORMAT_PARSED\n Input value should be of type \\ref CUpti_PCSamplingOutputDataFormat."]
pub const CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_OUTPUT_DATA_FORMAT:
    CUpti_PCSamplingConfigurationAttributeType = 7;
#[doc = " [w] Data buffer to hold collected PC Sampling data PARSED_DATA\n Default - none.\n Buffer type is void * which can point to PARSED_DATA\n Refer \\ref CUpti_PCSamplingData for buffer format for PARSED_DATA"]
pub const CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_SAMPLING_DATA_BUFFER:
    CUpti_PCSamplingConfigurationAttributeType = 8;
#[doc = " [rw] Control sleep time of the worker threads created by CUPTI for various PC sampling operations.\n CUPTI creates multiple worker threads to offload certain operations to these threads. This includes decoding of HW data to\n the CUPTI PC sampling data and correlating PC data to SASS instructions. CUPTI wakes up these threads periodically.\n Default - 100 milliseconds.\n Value is a uint32_t"]
pub const CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_WORKER_THREAD_PERIODIC_SLEEP_SPAN:
    CUpti_PCSamplingConfigurationAttributeType = 9;
#[doc = " [rw] Control sleep time of the worker threads created by CUPTI for various PC sampling operations.\n CUPTI creates multiple worker threads to offload certain operations to these threads. This includes decoding of HW data to\n the CUPTI PC sampling data and correlating PC data to SASS instructions. CUPTI wakes up these threads periodically.\n Default - 100 milliseconds.\n Value is a uint32_t"]
pub const CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_FORCE_INT:
    CUpti_PCSamplingConfigurationAttributeType = 2147483647;
#[doc = " \\brief PC Sampling configuration attributes\n\n PC Sampling configuration attribute types. These attributes can be read\n using \\ref cuptiPCSamplingGetConfigurationAttribute and can be written\n using \\ref cuptiPCSamplingSetConfigurationAttribute. Attributes marked\n [r] can only be read using \\ref cuptiPCSamplingGetConfigurationAttribute\n [w] can only be written using \\ref cuptiPCSamplingSetConfigurationAttribute\n [rw] can be read using \\ref cuptiPCSamplingGetConfigurationAttribute and\n written using \\ref cuptiPCSamplingSetConfigurationAttribute"]
pub type CUpti_PCSamplingConfigurationAttributeType = ::std::os::raw::c_uint;
#[doc = " \\brief PC sampling configuration information structure\n\n This structure provides \\ref CUpti_PCSamplingConfigurationAttributeType which can be configured\n or queried for PC sampling configuration"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfo {
    #[doc = " Refer \\ref CUpti_PCSamplingConfigurationAttributeType for all supported attribute types"]
    pub attributeType: CUpti_PCSamplingConfigurationAttributeType,
    pub attributeStatus: CUptiResult,
    pub attributeData: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CUpti_PCSamplingConfigurationInfo__bindgen_ty_1 {
    pub invalidData: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_1,
    pub samplingPeriodData: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_2,
    pub stallReasonData: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_3,
    pub scratchBufferSizeData: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_4,
    pub hardwareBufferSizeData: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_5,
    pub collectionModeData: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_6,
    pub enableStartStopControlData: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_7,
    pub outputDataFormatData: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_8,
    pub samplingDataBufferData: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_9,
    pub workerThreadPeriodicSleepSpanData:
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_10,
}
#[doc = " Invalid Value"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_1 {
    pub data: [u64; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_1"][::std::mem::size_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_1,
    >() - 24usize];
    ["Alignment of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_1>()
            - 8usize];
    ["Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_1::data"][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_1,
        data
    )
        - 0usize];
};
#[doc = " Refer \\ref CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_SAMPLING_PERIOD"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_2 {
    pub samplingPeriod: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_2"][::std::mem::size_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_2,
    >() - 4usize];
    ["Alignment of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::align_of::<CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_2>()
            - 4usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_2::samplingPeriod",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_2,
        samplingPeriod
    ) - 0usize];
};
#[doc = " Refer \\ref CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_STALL_REASON"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_3 {
    pub stallReasonCount: usize,
    pub pStallReasonIndex: *mut u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_3"][::std::mem::size_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_3,
    >() - 16usize];
    ["Alignment of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::align_of::<CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_3>()
            - 8usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_3::stallReasonCount",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_3,
        stallReasonCount
    ) - 0usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_3::pStallReasonIndex",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_3,
        pStallReasonIndex
    ) - 8usize];
};
impl Default for CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Refer \\ref CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_SCRATCH_BUFFER_SIZE"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_4 {
    pub scratchBufferSize: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_4"][::std::mem::size_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_4,
    >() - 8usize];
    ["Alignment of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::align_of::<CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_4>()
            - 8usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_4::scratchBufferSize",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_4,
        scratchBufferSize
    ) - 0usize];
};
#[doc = " Refer \\ref CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_HARDWARE_BUFFER_SIZE"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_5 {
    pub hardwareBufferSize: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_5"][::std::mem::size_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_5,
    >() - 8usize];
    ["Alignment of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_5"]
        [::std::mem::align_of::<CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_5>()
            - 8usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_5::hardwareBufferSize",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_5,
        hardwareBufferSize
    ) - 0usize];
};
#[doc = " Refer \\ref CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_COLLECTION_MODE"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_6 {
    pub collectionMode: CUpti_PCSamplingCollectionMode,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_6"][::std::mem::size_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_6,
    >() - 4usize];
    ["Alignment of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_6"]
        [::std::mem::align_of::<CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_6>()
            - 4usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_6::collectionMode",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_6,
        collectionMode
    ) - 0usize];
};
impl Default for CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Refer \\ref CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_ENABLE_START_STOP_CONTROL"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_7 {
    pub enableStartStopControl: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_7"][::std::mem::size_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_7,
    >() - 4usize];
    ["Alignment of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_7"]
        [::std::mem::align_of::<CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_7>()
            - 4usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_7::enableStartStopControl",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_7,
        enableStartStopControl
    ) - 0usize];
};
#[doc = " Refer \\ref CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_OUTPUT_DATA_FORMAT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_8 {
    pub outputDataFormat: CUpti_PCSamplingOutputDataFormat,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_8"][::std::mem::size_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_8,
    >() - 4usize];
    ["Alignment of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_8"]
        [::std::mem::align_of::<CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_8>()
            - 4usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_8::outputDataFormat",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_8,
        outputDataFormat
    ) - 0usize];
};
impl Default for CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Refer \\ref CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_SAMPLING_DATA_BUFFER"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_9 {
    pub samplingDataBuffer: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_9"][::std::mem::size_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_9,
    >() - 8usize];
    ["Alignment of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_9"]
        [::std::mem::align_of::<CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_9>()
            - 8usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_9::samplingDataBuffer",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_9,
        samplingDataBuffer
    ) - 0usize];
};
impl Default for CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_9 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Refer \\ref CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_WORKER_THREAD_PERIODIC_SLEEP_SPAN"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_10 {
    pub workerThreadPeriodicSleepSpan: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_10"][::std::mem::size_of::<
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_10,
    >() - 4usize];
    ["Alignment of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_10"]
        [::std::mem::align_of::<CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_10>()
            - 4usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_10::workerThreadPeriodicSleepSpan",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1__bindgen_ty_10,
        workerThreadPeriodicSleepSpan
    ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1"]
        [::std::mem::size_of::<CUpti_PCSamplingConfigurationInfo__bindgen_ty_1>() - 24usize];
    ["Alignment of CUpti_PCSamplingConfigurationInfo__bindgen_ty_1"]
        [::std::mem::align_of::<CUpti_PCSamplingConfigurationInfo__bindgen_ty_1>() - 8usize];
    ["Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1::invalidData"][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1,
        invalidData
    ) - 0usize];
    ["Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1::samplingPeriodData"][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1,
        samplingPeriodData
    )
        - 0usize];
    ["Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1::stallReasonData"][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1,
        stallReasonData
    )
        - 0usize];
    ["Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1::scratchBufferSizeData"][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1,
        scratchBufferSizeData
    )
        - 0usize];
    ["Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1::hardwareBufferSizeData"][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1,
        hardwareBufferSizeData
    )
        - 0usize];
    ["Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1::collectionModeData"][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1,
        collectionModeData
    )
        - 0usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1::enableStartStopControlData",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1,
        enableStartStopControlData
    ) - 0usize];
    ["Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1::outputDataFormatData"][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1,
        outputDataFormatData
    )
        - 0usize];
    ["Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1::samplingDataBufferData"][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1,
        samplingDataBufferData
    )
        - 0usize];
    [
        "Offset of field: CUpti_PCSamplingConfigurationInfo__bindgen_ty_1::workerThreadPeriodicSleepSpanData",
    ][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfo__bindgen_ty_1,
        workerThreadPeriodicSleepSpanData
    ) - 0usize];
};
impl Default for CUpti_PCSamplingConfigurationInfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_PCSamplingConfigurationInfo__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_PCSamplingConfigurationInfo__bindgen_ty_1 {{ union }}"
        )
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PCSamplingConfigurationInfo"]
        [::std::mem::size_of::<CUpti_PCSamplingConfigurationInfo>() - 32usize];
    ["Alignment of CUpti_PCSamplingConfigurationInfo"]
        [::std::mem::align_of::<CUpti_PCSamplingConfigurationInfo>() - 8usize];
    ["Offset of field: CUpti_PCSamplingConfigurationInfo::attributeType"]
        [::std::mem::offset_of!(CUpti_PCSamplingConfigurationInfo, attributeType) - 0usize];
    ["Offset of field: CUpti_PCSamplingConfigurationInfo::attributeStatus"]
        [::std::mem::offset_of!(CUpti_PCSamplingConfigurationInfo, attributeStatus) - 4usize];
    ["Offset of field: CUpti_PCSamplingConfigurationInfo::attributeData"]
        [::std::mem::offset_of!(CUpti_PCSamplingConfigurationInfo, attributeData) - 8usize];
};
impl Default for CUpti_PCSamplingConfigurationInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::std::fmt::Debug for CUpti_PCSamplingConfigurationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "CUpti_PCSamplingConfigurationInfo {{ attributeType: {:?}, attributeStatus: {:?}, attributeData: {:?} }}",
            self.attributeType, self.attributeStatus, self.attributeData
        )
    }
}
#[doc = " \\brief PC sampling configuration structure\n\n This structure configures PC sampling using \\ref cuptiPCSamplingSetConfigurationAttribute\n and queries PC sampling default configuration using \\ref cuptiPCSamplingGetConfigurationAttribute"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingConfigurationInfoParams {
    #[doc = " [w] Size of the data structure i.e. CUpti_PCSamplingConfigurationInfoParamsSize\n CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are\n available in the structure. Used to preserve backward compatibility."]
    pub size: usize,
    #[doc = " [w] Assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [w] CUcontext"]
    pub ctx: CUcontext,
    #[doc = " [w] Number of attributes to configure using \\ref cuptiPCSamplingSetConfigurationAttribute or query\n using \\ref cuptiPCSamplingGetConfigurationAttribute"]
    pub numAttributes: usize,
    #[doc = " Refer \\ref CUpti_PCSamplingConfigurationInfo"]
    pub pPCSamplingConfigurationInfo: *mut CUpti_PCSamplingConfigurationInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PCSamplingConfigurationInfoParams"]
        [::std::mem::size_of::<CUpti_PCSamplingConfigurationInfoParams>() - 40usize];
    ["Alignment of CUpti_PCSamplingConfigurationInfoParams"]
        [::std::mem::align_of::<CUpti_PCSamplingConfigurationInfoParams>() - 8usize];
    ["Offset of field: CUpti_PCSamplingConfigurationInfoParams::size"]
        [::std::mem::offset_of!(CUpti_PCSamplingConfigurationInfoParams, size) - 0usize];
    ["Offset of field: CUpti_PCSamplingConfigurationInfoParams::pPriv"]
        [::std::mem::offset_of!(CUpti_PCSamplingConfigurationInfoParams, pPriv) - 8usize];
    ["Offset of field: CUpti_PCSamplingConfigurationInfoParams::ctx"]
        [::std::mem::offset_of!(CUpti_PCSamplingConfigurationInfoParams, ctx) - 16usize];
    ["Offset of field: CUpti_PCSamplingConfigurationInfoParams::numAttributes"]
        [::std::mem::offset_of!(CUpti_PCSamplingConfigurationInfoParams, numAttributes) - 24usize];
    ["Offset of field: CUpti_PCSamplingConfigurationInfoParams::pPCSamplingConfigurationInfo"][::std::mem::offset_of!(
        CUpti_PCSamplingConfigurationInfoParams,
        pPCSamplingConfigurationInfo
    )
        - 32usize];
};
impl Default for CUpti_PCSamplingConfigurationInfoParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Write PC Sampling configuration attribute.\n\n \\param pParams A pointer to \\ref CUpti_PCSamplingConfigurationInfoParams\n containing PC sampling configuration.\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_OPERATION if this API is called with\n some invalid \\p attrib.\n \\retval CUPTI_ERROR_INVALID_PARAMETER if attribute \\p value is not valid\n or any \\p pParams is not valid\n \\retval CUPTI_ERROR_NOT_SUPPORTED indicates that the system/device\n does not support the API"]
    pub fn cuptiPCSamplingSetConfigurationAttribute(
        pParams: *mut CUpti_PCSamplingConfigurationInfoParams,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Read PC Sampling configuration attribute.\n\n \\param pParams A pointer to \\ref CUpti_PCSamplingConfigurationInfoParams\n containing PC sampling configuration.\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_OPERATION if this API is called with\n some invalid attribute.\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p attrib is not valid\n or any \\p pParams is not valid\n \\retval CUPTI_ERROR_PARAMETER_SIZE_NOT_SUFFICIENT indicates that\n the \\p value buffer is too small to hold the attribute value\n \\retval CUPTI_ERROR_NOT_SUPPORTED indicates that the system/device\n does not support the API"]
    pub fn cuptiPCSamplingGetConfigurationAttribute(
        pParams: *mut CUpti_PCSamplingConfigurationInfoParams,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiPCSamplingEnable"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingGetDataParams {
    #[doc = " [w] Size of the data structure i.e. CUpti_PCSamplingGetDataParamsSize\n CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are\n available in the structure. Used to preserve backward compatibility."]
    pub size: usize,
    #[doc = " [w] Assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [w] CUcontext"]
    pub ctx: CUcontext,
    #[doc = " \\param pcSamplingData Data buffer to hold collected PC Sampling data PARSED_DATA\n Buffer type is void * which can point to PARSED_DATA\n Refer \\ref CUpti_PCSamplingData for buffer format for PARSED_DATA"]
    pub pcSamplingData: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PCSamplingGetDataParams"]
        [::std::mem::size_of::<CUpti_PCSamplingGetDataParams>() - 32usize];
    ["Alignment of CUpti_PCSamplingGetDataParams"]
        [::std::mem::align_of::<CUpti_PCSamplingGetDataParams>() - 8usize];
    ["Offset of field: CUpti_PCSamplingGetDataParams::size"]
        [::std::mem::offset_of!(CUpti_PCSamplingGetDataParams, size) - 0usize];
    ["Offset of field: CUpti_PCSamplingGetDataParams::pPriv"]
        [::std::mem::offset_of!(CUpti_PCSamplingGetDataParams, pPriv) - 8usize];
    ["Offset of field: CUpti_PCSamplingGetDataParams::ctx"]
        [::std::mem::offset_of!(CUpti_PCSamplingGetDataParams, ctx) - 16usize];
    ["Offset of field: CUpti_PCSamplingGetDataParams::pcSamplingData"]
        [::std::mem::offset_of!(CUpti_PCSamplingGetDataParams, pcSamplingData) - 24usize];
};
impl Default for CUpti_PCSamplingGetDataParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Flush GPU PC sampling data periodically.\n\n Flushing of GPU PC Sampling data is required at following point to maintain uniqueness of PCs:\n For \\brief CUPTI_PC_SAMPLING_COLLECTION_MODE_CONTINUOUS, after every module load-unload-load\n For \\brief CUPTI_PC_SAMPLING_COLLECTION_MODE_KERNEL_SERIALIZED, after every kernel ends\n If configuration option \\brief CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_ENABLE_START_STOP_CONTROL\n is enabled, then after every range end i.e. \\brief cuptiPCSamplingStop()\n\n If application is profiled in \\brief CUPTI_PC_SAMPLING_COLLECTION_MODE_CONTINUOUS, with disabled\n \\brief CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_ENABLE_START_STOP_CONTROL, and there is no module unload,\n user can collect data in two ways:\n Use \\brief cuptiPCSamplingGetData() API periodically\n Use \\brief cuptiPCSamplingDisable() on application exit and read GPU PC sampling data from sampling\n data buffer passed during configuration.\n Note: In case, \\brief cuptiPCSamplingGetData() API is not called periodically, then sampling data buffer\n passed during configuration should be large enough to hold all PCs data.\n       \\brief cuptiPCSamplingGetData() API never does device synchronization.\n       It is possible that when the API is called there is some unconsumed data from the HW buffer. In this case\n CUPTI provides only the data available with it at that moment.\n\n \\param pParams A pointer to \\ref CUpti_PCSamplingGetDataParams\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_OPERATION if this API is called without\n enabling PC sampling.\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_NOT_SUPPORTED indicates that the system/device\n \\retval CUPTI_ERROR_OUT_OF_MEMORY indicates that the HW buffer is full\n does not support the API"]
    pub fn cuptiPCSamplingGetData(pParams: *mut CUpti_PCSamplingGetDataParams) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiPCSamplingEnable"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingEnableParams {
    #[doc = " [w] Size of the data structure i.e. CUpti_PCSamplingEnableParamsSize\n CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are\n available in the structure. Used to preserve backward compatibility."]
    pub size: usize,
    #[doc = " [w] Assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [w] CUcontext"]
    pub ctx: CUcontext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PCSamplingEnableParams"]
        [::std::mem::size_of::<CUpti_PCSamplingEnableParams>() - 24usize];
    ["Alignment of CUpti_PCSamplingEnableParams"]
        [::std::mem::align_of::<CUpti_PCSamplingEnableParams>() - 8usize];
    ["Offset of field: CUpti_PCSamplingEnableParams::size"]
        [::std::mem::offset_of!(CUpti_PCSamplingEnableParams, size) - 0usize];
    ["Offset of field: CUpti_PCSamplingEnableParams::pPriv"]
        [::std::mem::offset_of!(CUpti_PCSamplingEnableParams, pPriv) - 8usize];
    ["Offset of field: CUpti_PCSamplingEnableParams::ctx"]
        [::std::mem::offset_of!(CUpti_PCSamplingEnableParams, ctx) - 16usize];
};
impl Default for CUpti_PCSamplingEnableParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Enable PC sampling.\n\n \\param pParams A pointer to \\ref CUpti_PCSamplingEnableParams\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_NOT_SUPPORTED indicates that the system/device\n does not support the API"]
    pub fn cuptiPCSamplingEnable(pParams: *mut CUpti_PCSamplingEnableParams) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiPCSamplingDisable"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingDisableParams {
    #[doc = " [w] Size of the data structure i.e. CUpti_PCSamplingDisableParamsSize\n CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are\n available in the structure. Used to preserve backward compatibility."]
    pub size: usize,
    #[doc = " [w] Assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [w] CUcontext"]
    pub ctx: CUcontext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PCSamplingDisableParams"]
        [::std::mem::size_of::<CUpti_PCSamplingDisableParams>() - 24usize];
    ["Alignment of CUpti_PCSamplingDisableParams"]
        [::std::mem::align_of::<CUpti_PCSamplingDisableParams>() - 8usize];
    ["Offset of field: CUpti_PCSamplingDisableParams::size"]
        [::std::mem::offset_of!(CUpti_PCSamplingDisableParams, size) - 0usize];
    ["Offset of field: CUpti_PCSamplingDisableParams::pPriv"]
        [::std::mem::offset_of!(CUpti_PCSamplingDisableParams, pPriv) - 8usize];
    ["Offset of field: CUpti_PCSamplingDisableParams::ctx"]
        [::std::mem::offset_of!(CUpti_PCSamplingDisableParams, ctx) - 16usize];
};
impl Default for CUpti_PCSamplingDisableParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Disable PC sampling.\n\n For application which doesn't destroy the CUDA context explicitly,\n this API does the PC Sampling tear-down, joins threads and copies PC records in the buffer provided\n during the PC sampling configuration. PC records which can't be accommodated in the buffer are discarded.\n\n \\param pParams A pointer to \\ref CUpti_PCSamplingDisableParams\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_NOT_SUPPORTED indicates that the system/device\n does not support the API"]
    pub fn cuptiPCSamplingDisable(pParams: *mut CUpti_PCSamplingDisableParams) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiPCSamplingStart"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingStartParams {
    #[doc = " [w] Size of the data structure i.e. CUpti_PCSamplingStartParamsSize\n CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are\n available in the structure. Used to preserve backward compatibility."]
    pub size: usize,
    #[doc = " [w] Assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [w] CUcontext"]
    pub ctx: CUcontext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PCSamplingStartParams"]
        [::std::mem::size_of::<CUpti_PCSamplingStartParams>() - 24usize];
    ["Alignment of CUpti_PCSamplingStartParams"]
        [::std::mem::align_of::<CUpti_PCSamplingStartParams>() - 8usize];
    ["Offset of field: CUpti_PCSamplingStartParams::size"]
        [::std::mem::offset_of!(CUpti_PCSamplingStartParams, size) - 0usize];
    ["Offset of field: CUpti_PCSamplingStartParams::pPriv"]
        [::std::mem::offset_of!(CUpti_PCSamplingStartParams, pPriv) - 8usize];
    ["Offset of field: CUpti_PCSamplingStartParams::ctx"]
        [::std::mem::offset_of!(CUpti_PCSamplingStartParams, ctx) - 16usize];
};
impl Default for CUpti_PCSamplingStartParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Start PC sampling.\n\n User can collect PC Sampling data for user-defined range specified by Start/Stop APIs.\n This API can be used to mark starting of range. Set configuration option\n \\brief CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_ENABLE_START_STOP_CONTROL to use this API.\n\n \\param pParams A pointer to \\ref CUpti_PCSamplingStartParams\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_OPERATION if this API is called with\n incorrect PC Sampling configuration.\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_NOT_SUPPORTED indicates that the system/device\n does not support the API"]
    pub fn cuptiPCSamplingStart(pParams: *mut CUpti_PCSamplingStartParams) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiPCSamplingStop"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingStopParams {
    #[doc = " [w] Size of the data structure i.e. CUpti_PCSamplingStopParamsSize\n CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are\n available in the structure. Used to preserve backward compatibility."]
    pub size: usize,
    #[doc = " [w] Assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [w] CUcontext"]
    pub ctx: CUcontext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PCSamplingStopParams"]
        [::std::mem::size_of::<CUpti_PCSamplingStopParams>() - 24usize];
    ["Alignment of CUpti_PCSamplingStopParams"]
        [::std::mem::align_of::<CUpti_PCSamplingStopParams>() - 8usize];
    ["Offset of field: CUpti_PCSamplingStopParams::size"]
        [::std::mem::offset_of!(CUpti_PCSamplingStopParams, size) - 0usize];
    ["Offset of field: CUpti_PCSamplingStopParams::pPriv"]
        [::std::mem::offset_of!(CUpti_PCSamplingStopParams, pPriv) - 8usize];
    ["Offset of field: CUpti_PCSamplingStopParams::ctx"]
        [::std::mem::offset_of!(CUpti_PCSamplingStopParams, ctx) - 16usize];
};
impl Default for CUpti_PCSamplingStopParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Stop PC sampling.\n\n User can collect PC Sampling data for user-defined range specified by Start/Stop APIs.\n This API can be used to mark end of range. Set configuration option\n \\brief CUPTI_PC_SAMPLING_CONFIGURATION_ATTR_TYPE_ENABLE_START_STOP_CONTROL to use this API.\n\n \\param pParams A pointer to \\ref CUpti_PCSamplingStopParams\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_OPERATION if this API is called with\n incorrect PC Sampling configuration.\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_NOT_SUPPORTED indicates that the system/device\n does not support the API"]
    pub fn cuptiPCSamplingStop(pParams: *mut CUpti_PCSamplingStopParams) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiPCSamplingGetNumStallReasons"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingGetNumStallReasonsParams {
    #[doc = " [w] Size of the data structure i.e. CUpti_PCSamplingGetNumStallReasonsParamsSize\n CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are\n available in the structure. Used to preserve backward compatibility."]
    pub size: usize,
    #[doc = " [w] Assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [w] CUcontext"]
    pub ctx: CUcontext,
    #[doc = " [r] Number of stall reasons"]
    pub numStallReasons: *mut usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PCSamplingGetNumStallReasonsParams"]
        [::std::mem::size_of::<CUpti_PCSamplingGetNumStallReasonsParams>() - 32usize];
    ["Alignment of CUpti_PCSamplingGetNumStallReasonsParams"]
        [::std::mem::align_of::<CUpti_PCSamplingGetNumStallReasonsParams>() - 8usize];
    ["Offset of field: CUpti_PCSamplingGetNumStallReasonsParams::size"]
        [::std::mem::offset_of!(CUpti_PCSamplingGetNumStallReasonsParams, size) - 0usize];
    ["Offset of field: CUpti_PCSamplingGetNumStallReasonsParams::pPriv"]
        [::std::mem::offset_of!(CUpti_PCSamplingGetNumStallReasonsParams, pPriv) - 8usize];
    ["Offset of field: CUpti_PCSamplingGetNumStallReasonsParams::ctx"]
        [::std::mem::offset_of!(CUpti_PCSamplingGetNumStallReasonsParams, ctx) - 16usize];
    ["Offset of field: CUpti_PCSamplingGetNumStallReasonsParams::numStallReasons"][::std::mem::offset_of!(
        CUpti_PCSamplingGetNumStallReasonsParams,
        numStallReasons
    ) - 24usize];
};
impl Default for CUpti_PCSamplingGetNumStallReasonsParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Get PC sampling stall reason count.\n\n \\param pParams A pointer to \\ref CUpti_PCSamplingGetNumStallReasonsParams\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_NOT_SUPPORTED indicates that the system/device\n does not support the API"]
    pub fn cuptiPCSamplingGetNumStallReasons(
        pParams: *mut CUpti_PCSamplingGetNumStallReasonsParams,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiPCSamplingGetStallReasons"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PCSamplingGetStallReasonsParams {
    #[doc = " [w] Size of the data structure i.e. CUpti_PCSamplingGetStallReasonsParamsSize\n CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are\n available in the structure. Used to preserve backward compatibility."]
    pub size: usize,
    #[doc = " [w] Assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [w] CUcontext"]
    pub ctx: CUcontext,
    #[doc = " [w] Number of stall reasons"]
    pub numStallReasons: usize,
    #[doc = " [r] Stall reason index"]
    pub stallReasonIndex: *mut u32,
    #[doc = " [r] Stall reasons name"]
    pub stallReasons: *mut *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PCSamplingGetStallReasonsParams"]
        [::std::mem::size_of::<CUpti_PCSamplingGetStallReasonsParams>() - 48usize];
    ["Alignment of CUpti_PCSamplingGetStallReasonsParams"]
        [::std::mem::align_of::<CUpti_PCSamplingGetStallReasonsParams>() - 8usize];
    ["Offset of field: CUpti_PCSamplingGetStallReasonsParams::size"]
        [::std::mem::offset_of!(CUpti_PCSamplingGetStallReasonsParams, size) - 0usize];
    ["Offset of field: CUpti_PCSamplingGetStallReasonsParams::pPriv"]
        [::std::mem::offset_of!(CUpti_PCSamplingGetStallReasonsParams, pPriv) - 8usize];
    ["Offset of field: CUpti_PCSamplingGetStallReasonsParams::ctx"]
        [::std::mem::offset_of!(CUpti_PCSamplingGetStallReasonsParams, ctx) - 16usize];
    ["Offset of field: CUpti_PCSamplingGetStallReasonsParams::numStallReasons"]
        [::std::mem::offset_of!(CUpti_PCSamplingGetStallReasonsParams, numStallReasons) - 24usize];
    ["Offset of field: CUpti_PCSamplingGetStallReasonsParams::stallReasonIndex"]
        [::std::mem::offset_of!(CUpti_PCSamplingGetStallReasonsParams, stallReasonIndex) - 32usize];
    ["Offset of field: CUpti_PCSamplingGetStallReasonsParams::stallReasons"]
        [::std::mem::offset_of!(CUpti_PCSamplingGetStallReasonsParams, stallReasons) - 40usize];
};
impl Default for CUpti_PCSamplingGetStallReasonsParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Get PC sampling stall reasons.\n\n \\param pParams A pointer to \\ref CUpti_PCSamplingGetStallReasonsParams\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_NOT_SUPPORTED indicates that the system/device\n does not support the API"]
    pub fn cuptiPCSamplingGetStallReasons(
        pParams: *mut CUpti_PCSamplingGetStallReasonsParams,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiGetSassToSourceCorrelation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_GetSassToSourceCorrelationParams {
    #[doc = " [w] Size of the data structure i.e. CUpti_GetSassToSourceCorrelationParamsSize\n CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are\n available in the structure. Used to preserve backward compatibility."]
    pub size: usize,
    #[doc = " [w] Pointer to cubin binary where function belongs."]
    pub cubin: *const ::std::os::raw::c_void,
    #[doc = " [w] Function name to which PC belongs."]
    pub functionName: *const ::std::os::raw::c_char,
    #[doc = " [w] Size of cubin binary."]
    pub cubinSize: usize,
    #[doc = " [r] Line number in the source code."]
    pub lineNumber: u32,
    #[doc = " [w] PC offset"]
    pub pcOffset: u64,
    #[doc = " [r] Path for the source file."]
    pub fileName: *mut ::std::os::raw::c_char,
    #[doc = " [r] Path for the directory of source file."]
    pub dirName: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_GetSassToSourceCorrelationParams"]
        [::std::mem::size_of::<CUpti_GetSassToSourceCorrelationParams>() - 64usize];
    ["Alignment of CUpti_GetSassToSourceCorrelationParams"]
        [::std::mem::align_of::<CUpti_GetSassToSourceCorrelationParams>() - 8usize];
    ["Offset of field: CUpti_GetSassToSourceCorrelationParams::size"]
        [::std::mem::offset_of!(CUpti_GetSassToSourceCorrelationParams, size) - 0usize];
    ["Offset of field: CUpti_GetSassToSourceCorrelationParams::cubin"]
        [::std::mem::offset_of!(CUpti_GetSassToSourceCorrelationParams, cubin) - 8usize];
    ["Offset of field: CUpti_GetSassToSourceCorrelationParams::functionName"]
        [::std::mem::offset_of!(CUpti_GetSassToSourceCorrelationParams, functionName) - 16usize];
    ["Offset of field: CUpti_GetSassToSourceCorrelationParams::cubinSize"]
        [::std::mem::offset_of!(CUpti_GetSassToSourceCorrelationParams, cubinSize) - 24usize];
    ["Offset of field: CUpti_GetSassToSourceCorrelationParams::lineNumber"]
        [::std::mem::offset_of!(CUpti_GetSassToSourceCorrelationParams, lineNumber) - 32usize];
    ["Offset of field: CUpti_GetSassToSourceCorrelationParams::pcOffset"]
        [::std::mem::offset_of!(CUpti_GetSassToSourceCorrelationParams, pcOffset) - 40usize];
    ["Offset of field: CUpti_GetSassToSourceCorrelationParams::fileName"]
        [::std::mem::offset_of!(CUpti_GetSassToSourceCorrelationParams, fileName) - 48usize];
    ["Offset of field: CUpti_GetSassToSourceCorrelationParams::dirName"]
        [::std::mem::offset_of!(CUpti_GetSassToSourceCorrelationParams, dirName) - 56usize];
};
impl Default for CUpti_GetSassToSourceCorrelationParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief SASS to Source correlation.\n\n \\param pParams A pointer to \\ref CUpti_GetSassToSourceCorrelationParams\n\n It is expected from user to free allocated memory for fileName and dirName after use.\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if either of the parameters cubin or functionName\n is NULL or cubinSize is zero or size field is not set correctly.\n \\retval CUPTI_ERROR_INVALID_MODULE provided cubin is invalid.\n \\retval CUPTI_ERROR_UNKNOWN an internal error occurred.\n This error code is also used for cases when the function is not present in the module.\n A better error code will be returned in the future release."]
    pub fn cuptiGetSassToSourceCorrelation(
        pParams: *mut CUpti_GetSassToSourceCorrelationParams,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiGetCubinCrc"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_GetCubinCrcParams {
    #[doc = " [w] Size of configuration structure.\n CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are\n available in the structure. Used to preserve backward compatibility."]
    pub size: usize,
    #[doc = " [w] Size of cubin binary."]
    pub cubinSize: usize,
    #[doc = " [w] Pointer to cubin binary"]
    pub cubin: *const ::std::os::raw::c_void,
    #[doc = " [r] Computed CRC will be stored in it."]
    pub cubinCrc: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_GetCubinCrcParams"][::std::mem::size_of::<CUpti_GetCubinCrcParams>() - 32usize];
    ["Alignment of CUpti_GetCubinCrcParams"]
        [::std::mem::align_of::<CUpti_GetCubinCrcParams>() - 8usize];
    ["Offset of field: CUpti_GetCubinCrcParams::size"]
        [::std::mem::offset_of!(CUpti_GetCubinCrcParams, size) - 0usize];
    ["Offset of field: CUpti_GetCubinCrcParams::cubinSize"]
        [::std::mem::offset_of!(CUpti_GetCubinCrcParams, cubinSize) - 8usize];
    ["Offset of field: CUpti_GetCubinCrcParams::cubin"]
        [::std::mem::offset_of!(CUpti_GetCubinCrcParams, cubin) - 16usize];
    ["Offset of field: CUpti_GetCubinCrcParams::cubinCrc"]
        [::std::mem::offset_of!(CUpti_GetCubinCrcParams, cubinCrc) - 24usize];
};
impl Default for CUpti_GetCubinCrcParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Get the CRC of cubin.\n\n This function returns the CRC of provided cubin binary.\n\n \\param pParams A pointer to \\ref CUpti_GetCubinCrcParams\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if parameter cubin is NULL or\n provided cubinSize is zero or size field is not set."]
    pub fn cuptiGetCubinCrc(pParams: *mut CUpti_GetCubinCrcParams) -> CUptiResult;
}
#[doc = " \\brief Function type for callback used by CUPTI to request crc of\n loaded module.\n\n This callback function ask for crc of provided module in function.\n The provided crc will be stored in PC sampling records i.e. in the field 'cubinCrc' of the PC sampling\n struct CUpti_PCSamplingPCData. The CRC is uses during the offline source correlation to uniquely identify the module.\n\n \\param cubin The pointer to cubin binary\n \\param cubinSize The size of cubin binary.\n \\param cubinCrc Returns the computed crc of cubin."]
pub type CUpti_ComputeCrcCallbackFunc = ::std::option::Option<
    unsafe extern "C" fn(
        cubin: *const ::std::os::raw::c_void,
        cubinSize: usize,
        cubinCrc: *mut u64,
    ),
>;
unsafe extern "C" {
    #[doc = " \\brief Register callback function with CUPTI to use\n your own algorithm to compute cubin crc.\n\n This function registers a callback function and it gets called\n from CUPTI when a CUDA module is loaded.\n\n \\param funcComputeCubinCrc callback is invoked when a CUDA module\n is loaded.\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if \\p funcComputeCubinCrc is NULL."]
    pub fn cuptiRegisterComputeCrcCallback(
        funcComputeCubinCrc: CUpti_ComputeCrcCallbackFunc,
    ) -> CUptiResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_Object {
    _unused: [u8; 0],
}
#[doc = " The trigger is based off of the SYSCLK frequency, note SYS frequency by default is variable.\n the sample interval (set in the struct CUpti_PmSampling_SetConfig_Params) is in terms of clocks."]
pub const CUPTI_PM_SAMPLING_TRIGGER_MODE_GPU_SYSCLK_INTERVAL: CUpti_PmSampling_TriggerMode = 0;
#[doc = " The trigger is based off of a fixed frequency source.\n The sample interval (set in the struct CUpti_PmSampling_SetConfig_Params) is in terms of nanoseconds.\n Note: This trigger mode is not supported on Turing GPU architecture and GA100 GPU.\n It is supported on Ampere GA10x and later GPU architectures."]
pub const CUPTI_PM_SAMPLING_TRIGGER_MODE_GPU_TIME_INTERVAL: CUpti_PmSampling_TriggerMode = 1;
#[doc = " The trigger is based off of a fixed frequency source.\n The sample interval (set in the struct CUpti_PmSampling_SetConfig_Params) is in terms of nanoseconds.\n Note: This trigger mode is not supported on Turing GPU architecture and GA100 GPU.\n It is supported on Ampere GA10x and later GPU architectures."]
pub const CUPTI_PM_SAMPLING_TRIGGER_MODE_COUNT: CUpti_PmSampling_TriggerMode = 2;
pub type CUpti_PmSampling_TriggerMode = ::std::os::raw::c_uint;
pub const CUPTI_PM_SAMPLING_DECODE_STOP_REASON_OTHER: CUpti_PmSampling_DecodeStopReason = 0;
#[doc = " Counter data image is full."]
pub const CUPTI_PM_SAMPLING_DECODE_STOP_REASON_COUNTER_DATA_FULL:
    CUpti_PmSampling_DecodeStopReason = 1;
#[doc = " All the records in the hardware buffer is decoded."]
pub const CUPTI_PM_SAMPLING_DECODE_STOP_REASON_END_OF_RECORDS: CUpti_PmSampling_DecodeStopReason =
    2;
#[doc = " All the records in the hardware buffer is decoded."]
pub const CUPTI_PM_SAMPLING_DECODE_STOP_REASON_COUNT: CUpti_PmSampling_DecodeStopReason = 3;
pub type CUpti_PmSampling_DecodeStopReason = ::std::os::raw::c_uint;
#[doc = " Keep the oldest records in the hardware buffer.\n CUPTI will report error for overflow in case hardware buffer is getting filled up."]
pub const CUPTI_PM_SAMPLING_HARDWARE_BUFFER_APPEND_MODE_KEEP_OLDEST:
    CUpti_PmSampling_HardwareBuffer_AppendMode = 0;
#[doc = " Keep the latest records in the hardware buffer.\n Note: This mode is not supported on Turing GPU architecture.\n It is supported on Ampere and later GPU architectures."]
pub const CUPTI_PM_SAMPLING_HARDWARE_BUFFER_APPEND_MODE_KEEP_LATEST:
    CUpti_PmSampling_HardwareBuffer_AppendMode = 1;
pub type CUpti_PmSampling_HardwareBuffer_AppendMode = ::std::os::raw::c_uint;
#[doc = " \\brief Params for cuptiPmSamplingSetConfig"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_SetConfig_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Set to NULL."]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] PM sampling object."]
    pub pPmSamplingObject: *mut CUpti_PmSampling_Object,
    #[doc = " [in] Size of the config image."]
    pub configSize: usize,
    #[doc = " [in] Config image."]
    pub pConfig: *const u8,
    #[doc = " [in] The hardware buffer size in which raw PM sampling data\n will be stored. These samples will be decoded to counter data\n image with \\ref cuptiPmSamplingDecodeData call."]
    pub hardwareBufferSize: usize,
    #[doc = " [in] For the trigger mode `CUPTI_PM_SAMPLING_TRIGGER_MODE_GPU_SYSCLK_INTERVAL`, sampling interval\n is the number of sys clock cycles. For the trigger mode `CUPTI_PM_SAMPLING_TRIGGER_MODE_GPU_TIME_INTERVAL`,\n sampling interval is in nanoseconds."]
    pub samplingInterval: u64,
    #[doc = " [in] Trigger mode.\n Note: CUPTI_PM_SAMPLING_TRIGGER_MODE_GPU_TIME_INTERVAL is not supported in Turing and GA100.\n Supported from GA10x onwards."]
    pub triggerMode: CUpti_PmSampling_TriggerMode,
    #[doc = " [in] Append mode for the records in hardware buffer.\n For KEEP_OLDEST mode, all the records will be kept in the buffer and in case hardware buffer is getting filled up.\n overflow will be set to 1 in \\ref CUpti_PmSampling_DecodeData_Params. For KEEP_LATEST mode, the new records will\n overwrite the oldest records in the buffer in case of filled buffer."]
    pub hwBufferAppendMode: CUpti_PmSampling_HardwareBuffer_AppendMode,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PmSampling_SetConfig_Params"]
        [::std::mem::size_of::<CUpti_PmSampling_SetConfig_Params>() - 64usize];
    ["Alignment of CUpti_PmSampling_SetConfig_Params"]
        [::std::mem::align_of::<CUpti_PmSampling_SetConfig_Params>() - 8usize];
    ["Offset of field: CUpti_PmSampling_SetConfig_Params::structSize"]
        [::std::mem::offset_of!(CUpti_PmSampling_SetConfig_Params, structSize) - 0usize];
    ["Offset of field: CUpti_PmSampling_SetConfig_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_PmSampling_SetConfig_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_PmSampling_SetConfig_Params::pPmSamplingObject"]
        [::std::mem::offset_of!(CUpti_PmSampling_SetConfig_Params, pPmSamplingObject) - 16usize];
    ["Offset of field: CUpti_PmSampling_SetConfig_Params::configSize"]
        [::std::mem::offset_of!(CUpti_PmSampling_SetConfig_Params, configSize) - 24usize];
    ["Offset of field: CUpti_PmSampling_SetConfig_Params::pConfig"]
        [::std::mem::offset_of!(CUpti_PmSampling_SetConfig_Params, pConfig) - 32usize];
    ["Offset of field: CUpti_PmSampling_SetConfig_Params::hardwareBufferSize"]
        [::std::mem::offset_of!(CUpti_PmSampling_SetConfig_Params, hardwareBufferSize) - 40usize];
    ["Offset of field: CUpti_PmSampling_SetConfig_Params::samplingInterval"]
        [::std::mem::offset_of!(CUpti_PmSampling_SetConfig_Params, samplingInterval) - 48usize];
    ["Offset of field: CUpti_PmSampling_SetConfig_Params::triggerMode"]
        [::std::mem::offset_of!(CUpti_PmSampling_SetConfig_Params, triggerMode) - 56usize];
    ["Offset of field: CUpti_PmSampling_SetConfig_Params::hwBufferAppendMode"]
        [::std::mem::offset_of!(CUpti_PmSampling_SetConfig_Params, hwBufferAppendMode) - 60usize];
};
impl Default for CUpti_PmSampling_SetConfig_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Set the configuration for PM sampling like sampling interval, maximum number of samples\n filled in HW buffer, trigger mode and the config image which has scheduling info for metric collection.\n\n \\param pParams A pointer to \\ref CUpti_PmSampling_SetConfig_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_NOT_SUPPORTED for config image which require multiple passes for data collection"]
    pub fn cuptiPmSamplingSetConfig(pParams: *mut CUpti_PmSampling_SetConfig_Params)
    -> CUptiResult;
}
#[doc = " \\brief Params for cuptiPmSamplingEnable"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_Enable_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Set to NULL."]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] Device index."]
    pub deviceIndex: usize,
    #[doc = " [out] PM sampling object."]
    pub pPmSamplingObject: *mut CUpti_PmSampling_Object,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PmSampling_Enable_Params"]
        [::std::mem::size_of::<CUpti_PmSampling_Enable_Params>() - 32usize];
    ["Alignment of CUpti_PmSampling_Enable_Params"]
        [::std::mem::align_of::<CUpti_PmSampling_Enable_Params>() - 8usize];
    ["Offset of field: CUpti_PmSampling_Enable_Params::structSize"]
        [::std::mem::offset_of!(CUpti_PmSampling_Enable_Params, structSize) - 0usize];
    ["Offset of field: CUpti_PmSampling_Enable_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_PmSampling_Enable_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_PmSampling_Enable_Params::deviceIndex"]
        [::std::mem::offset_of!(CUpti_PmSampling_Enable_Params, deviceIndex) - 16usize];
    ["Offset of field: CUpti_PmSampling_Enable_Params::pPmSamplingObject"]
        [::std::mem::offset_of!(CUpti_PmSampling_Enable_Params, pPmSamplingObject) - 24usize];
};
impl Default for CUpti_PmSampling_Enable_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Create a PM sampling object and enable PM sampling on the CUDA device.\n\n \\param pParams A pointer to \\ref CUpti_PmSampling_Enable_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_OUT_OF_MEMORY if memory allocation fails while creating the PM sampling object\n \\retval CUPTI_ERROR_INVALID_OPERATION if PM sampling is already enabled on the device\n \\retval CUPTI_ERROR_INSUFFICIENT_PRIVILEGES if the user does not have sufficient privileges to perform the operation\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiPmSamplingEnable(pParams: *mut CUpti_PmSampling_Enable_Params) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiPmSamplingDisable"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_Disable_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Set to NULL."]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] PM sampling object."]
    pub pPmSamplingObject: *mut CUpti_PmSampling_Object,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PmSampling_Disable_Params"]
        [::std::mem::size_of::<CUpti_PmSampling_Disable_Params>() - 24usize];
    ["Alignment of CUpti_PmSampling_Disable_Params"]
        [::std::mem::align_of::<CUpti_PmSampling_Disable_Params>() - 8usize];
    ["Offset of field: CUpti_PmSampling_Disable_Params::structSize"]
        [::std::mem::offset_of!(CUpti_PmSampling_Disable_Params, structSize) - 0usize];
    ["Offset of field: CUpti_PmSampling_Disable_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_PmSampling_Disable_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_PmSampling_Disable_Params::pPmSamplingObject"]
        [::std::mem::offset_of!(CUpti_PmSampling_Disable_Params, pPmSamplingObject) - 16usize];
};
impl Default for CUpti_PmSampling_Disable_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Disable PM sampling on the CUDA device and destroy the PM sampling object.\n\n \\param pParams A pointer to \\ref CUpti_PmSampling_Disable_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiPmSamplingDisable(pParams: *mut CUpti_PmSampling_Disable_Params) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiPmSamplingStart"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_Start_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Set to NULL."]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] PM sampling object."]
    pub pPmSamplingObject: *mut CUpti_PmSampling_Object,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PmSampling_Start_Params"]
        [::std::mem::size_of::<CUpti_PmSampling_Start_Params>() - 24usize];
    ["Alignment of CUpti_PmSampling_Start_Params"]
        [::std::mem::align_of::<CUpti_PmSampling_Start_Params>() - 8usize];
    ["Offset of field: CUpti_PmSampling_Start_Params::structSize"]
        [::std::mem::offset_of!(CUpti_PmSampling_Start_Params, structSize) - 0usize];
    ["Offset of field: CUpti_PmSampling_Start_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_PmSampling_Start_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_PmSampling_Start_Params::pPmSamplingObject"]
        [::std::mem::offset_of!(CUpti_PmSampling_Start_Params, pPmSamplingObject) - 16usize];
};
impl Default for CUpti_PmSampling_Start_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Start the PM sampling. The GPU will start collecting the metrics data\n periodically based on trigger type and sampling interval passed in CUpti_PmSampling_SetConfig_Params.\n The collected data will be stored in the hardware buffer.\n\n \\param pParams A pointer to \\ref CUpti_PmSampling_Start_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_INVALID_OPERATION if PM sampling Start is called without enabling PM sampling,\n and PM sampling is already started\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiPmSamplingStart(pParams: *mut CUpti_PmSampling_Start_Params) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiPmSamplingStop"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_Stop_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Set to NULL."]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] PM sampling object."]
    pub pPmSamplingObject: *mut CUpti_PmSampling_Object,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PmSampling_Stop_Params"]
        [::std::mem::size_of::<CUpti_PmSampling_Stop_Params>() - 24usize];
    ["Alignment of CUpti_PmSampling_Stop_Params"]
        [::std::mem::align_of::<CUpti_PmSampling_Stop_Params>() - 8usize];
    ["Offset of field: CUpti_PmSampling_Stop_Params::structSize"]
        [::std::mem::offset_of!(CUpti_PmSampling_Stop_Params, structSize) - 0usize];
    ["Offset of field: CUpti_PmSampling_Stop_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_PmSampling_Stop_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_PmSampling_Stop_Params::pPmSamplingObject"]
        [::std::mem::offset_of!(CUpti_PmSampling_Stop_Params, pPmSamplingObject) - 16usize];
};
impl Default for CUpti_PmSampling_Stop_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Stop the PM sampling. The GPU will stop collecting the metrics data.\n\n \\param pParams A pointer to \\ref CUpti_PmSampling_Stop_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_INVALID_OPERATION if PM sampling Stop is called without enabling PM sampling,\n and PM sampling is already stopped\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiPmSamplingStop(pParams: *mut CUpti_PmSampling_Stop_Params) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiPmSamplingDecodeData"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_DecodeData_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Set to NULL."]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] PM sampling object."]
    pub pPmSamplingObject: *mut CUpti_PmSampling_Object,
    #[doc = " [in] Counter data image."]
    pub pCounterDataImage: *mut u8,
    #[doc = " [in] Size of the counter data image."]
    pub counterDataImageSize: usize,
    #[doc = " [out] decode stop reason"]
    pub decodeStopReason: CUpti_PmSampling_DecodeStopReason,
    #[doc = " [out] overflow status for hardware buffer.\n To avoid overflow, either increase the maxSamples values in\n \\ref CUpti_PmSampling_SetConfig_Params or reduce the sampling interval."]
    pub overflow: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PmSampling_DecodeData_Params"]
        [::std::mem::size_of::<CUpti_PmSampling_DecodeData_Params>() - 48usize];
    ["Alignment of CUpti_PmSampling_DecodeData_Params"]
        [::std::mem::align_of::<CUpti_PmSampling_DecodeData_Params>() - 8usize];
    ["Offset of field: CUpti_PmSampling_DecodeData_Params::structSize"]
        [::std::mem::offset_of!(CUpti_PmSampling_DecodeData_Params, structSize) - 0usize];
    ["Offset of field: CUpti_PmSampling_DecodeData_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_PmSampling_DecodeData_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_PmSampling_DecodeData_Params::pPmSamplingObject"]
        [::std::mem::offset_of!(CUpti_PmSampling_DecodeData_Params, pPmSamplingObject) - 16usize];
    ["Offset of field: CUpti_PmSampling_DecodeData_Params::pCounterDataImage"]
        [::std::mem::offset_of!(CUpti_PmSampling_DecodeData_Params, pCounterDataImage) - 24usize];
    ["Offset of field: CUpti_PmSampling_DecodeData_Params::counterDataImageSize"][::std::mem::offset_of!(
        CUpti_PmSampling_DecodeData_Params,
        counterDataImageSize
    ) - 32usize];
    ["Offset of field: CUpti_PmSampling_DecodeData_Params::decodeStopReason"]
        [::std::mem::offset_of!(CUpti_PmSampling_DecodeData_Params, decodeStopReason) - 40usize];
    ["Offset of field: CUpti_PmSampling_DecodeData_Params::overflow"]
        [::std::mem::offset_of!(CUpti_PmSampling_DecodeData_Params, overflow) - 44usize];
};
impl Default for CUpti_PmSampling_DecodeData_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Decode the metrics data stored in the hardware buffer to the counter data image.\n\n\n \\param pParams A pointer to \\ref CUpti_PmSampling_DecodeData_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_INVALID_OPERATION if PM sampling DecodeData is called without enabling PM sampling\n \\retval CUPTI_ERROR_OUT_OF_MEMORY if there is record overflow in the hardware buffer\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiPmSamplingDecodeData(
        pParams: *mut CUpti_PmSampling_DecodeData_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiPmSamplingGetCounterData"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_GetCounterAvailability_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Set to NULL."]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] Device index."]
    pub deviceIndex: usize,
    #[doc = " [inout] Size of the counter availability image. When pCounterAvailabilityImage is NULL,\n this field is used to return the size of the counter availability image."]
    pub counterAvailabilityImageSize: usize,
    #[doc = " [out] Counter availability image."]
    pub pCounterAvailabilityImage: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PmSampling_GetCounterAvailability_Params"]
        [::std::mem::size_of::<CUpti_PmSampling_GetCounterAvailability_Params>() - 40usize];
    ["Alignment of CUpti_PmSampling_GetCounterAvailability_Params"]
        [::std::mem::align_of::<CUpti_PmSampling_GetCounterAvailability_Params>() - 8usize];
    ["Offset of field: CUpti_PmSampling_GetCounterAvailability_Params::structSize"][::std::mem::offset_of!(
        CUpti_PmSampling_GetCounterAvailability_Params,
        structSize
    ) - 0usize];
    ["Offset of field: CUpti_PmSampling_GetCounterAvailability_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_PmSampling_GetCounterAvailability_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_PmSampling_GetCounterAvailability_Params::deviceIndex"][::std::mem::offset_of!(
        CUpti_PmSampling_GetCounterAvailability_Params,
        deviceIndex
    ) - 16usize];
    [
        "Offset of field: CUpti_PmSampling_GetCounterAvailability_Params::counterAvailabilityImageSize",
    ][::std::mem::offset_of!(
        CUpti_PmSampling_GetCounterAvailability_Params,
        counterAvailabilityImageSize
    ) - 24usize];
    ["Offset of field: CUpti_PmSampling_GetCounterAvailability_Params::pCounterAvailabilityImage"]
        [::std::mem::offset_of!(
            CUpti_PmSampling_GetCounterAvailability_Params,
            pCounterAvailabilityImage
        ) - 32usize];
};
impl Default for CUpti_PmSampling_GetCounterAvailability_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Query counter availibility information in a buffer which can be used to filter unavailable raw metrics on host.\n Note: This API may fail, if any profiling or sampling session is active on the specified device.\n\n \\param pParams A pointer to \\ref CUpti_PmSampling_GetCounterAvailability_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_INSUFFICIENT_PRIVILEGES if the user does not have sufficient privileges to perform the operation\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiPmSamplingGetCounterAvailability(
        pParams: *mut CUpti_PmSampling_GetCounterAvailability_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiPmSamplingGetCounterDataSize"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_GetCounterDataSize_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Set to NULL."]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] PM sampling object."]
    pub pPmSamplingObject: *mut CUpti_PmSampling_Object,
    #[doc = " [in] Names of the metrics to be collected."]
    pub pMetricNames: *mut *const ::std::os::raw::c_char,
    #[doc = " [in] Number of metrics to be collected."]
    pub numMetrics: usize,
    #[doc = " [in] Maximum number of samples to be stored in the counter data image."]
    pub maxSamples: u32,
    #[doc = " [out] Size of the counter data image."]
    pub counterDataSize: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PmSampling_GetCounterDataSize_Params"]
        [::std::mem::size_of::<CUpti_PmSampling_GetCounterDataSize_Params>() - 56usize];
    ["Alignment of CUpti_PmSampling_GetCounterDataSize_Params"]
        [::std::mem::align_of::<CUpti_PmSampling_GetCounterDataSize_Params>() - 8usize];
    ["Offset of field: CUpti_PmSampling_GetCounterDataSize_Params::structSize"]
        [::std::mem::offset_of!(CUpti_PmSampling_GetCounterDataSize_Params, structSize) - 0usize];
    ["Offset of field: CUpti_PmSampling_GetCounterDataSize_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_PmSampling_GetCounterDataSize_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_PmSampling_GetCounterDataSize_Params::pPmSamplingObject"][::std::mem::offset_of!(
        CUpti_PmSampling_GetCounterDataSize_Params,
        pPmSamplingObject
    ) - 16usize];
    ["Offset of field: CUpti_PmSampling_GetCounterDataSize_Params::pMetricNames"][::std::mem::offset_of!(
        CUpti_PmSampling_GetCounterDataSize_Params,
        pMetricNames
    ) - 24usize];
    ["Offset of field: CUpti_PmSampling_GetCounterDataSize_Params::numMetrics"]
        [::std::mem::offset_of!(CUpti_PmSampling_GetCounterDataSize_Params, numMetrics) - 32usize];
    ["Offset of field: CUpti_PmSampling_GetCounterDataSize_Params::maxSamples"]
        [::std::mem::offset_of!(CUpti_PmSampling_GetCounterDataSize_Params, maxSamples) - 40usize];
    ["Offset of field: CUpti_PmSampling_GetCounterDataSize_Params::counterDataSize"][::std::mem::offset_of!(
        CUpti_PmSampling_GetCounterDataSize_Params,
        counterDataSize
    ) - 48usize];
};
impl Default for CUpti_PmSampling_GetCounterDataSize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Query the size of the counter data image which will be used to store the metrics data.\n User need to allocate the memory for the counter data image based on the size returned by this API.\n\n \\param pParams A pointer to \\ref CUpti_PmSampling_GetCounterDataSize_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_INVALID_OPERATION if PM sampling GetCounterDataSize is called without enabling PM sampling\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiPmSamplingGetCounterDataSize(
        pParams: *mut CUpti_PmSampling_GetCounterDataSize_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiPmSamplingCounterDataImageInitialize"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_CounterDataImage_Initialize_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Set to NULL."]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] PM sampling object."]
    pub pPmSamplingObject: *mut CUpti_PmSampling_Object,
    #[doc = " [in] Size of the counter data image."]
    pub counterDataSize: usize,
    #[doc = " [in] Counter data image."]
    pub pCounterData: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PmSampling_CounterDataImage_Initialize_Params"]
        [::std::mem::size_of::<CUpti_PmSampling_CounterDataImage_Initialize_Params>() - 40usize];
    ["Alignment of CUpti_PmSampling_CounterDataImage_Initialize_Params"]
        [::std::mem::align_of::<CUpti_PmSampling_CounterDataImage_Initialize_Params>() - 8usize];
    ["Offset of field: CUpti_PmSampling_CounterDataImage_Initialize_Params::structSize"][::std::mem::offset_of!(
        CUpti_PmSampling_CounterDataImage_Initialize_Params,
        structSize
    )
        - 0usize];
    ["Offset of field: CUpti_PmSampling_CounterDataImage_Initialize_Params::pPriv"][::std::mem::offset_of!(
        CUpti_PmSampling_CounterDataImage_Initialize_Params,
        pPriv
    ) - 8usize];
    ["Offset of field: CUpti_PmSampling_CounterDataImage_Initialize_Params::pPmSamplingObject"][::std::mem::offset_of!(
        CUpti_PmSampling_CounterDataImage_Initialize_Params,
        pPmSamplingObject
    )
        - 16usize];
    ["Offset of field: CUpti_PmSampling_CounterDataImage_Initialize_Params::counterDataSize"][::std::mem::offset_of!(
        CUpti_PmSampling_CounterDataImage_Initialize_Params,
        counterDataSize
    )
        - 24usize];
    ["Offset of field: CUpti_PmSampling_CounterDataImage_Initialize_Params::pCounterData"][::std::mem::offset_of!(
        CUpti_PmSampling_CounterDataImage_Initialize_Params,
        pCounterData
    )
        - 32usize];
};
impl Default for CUpti_PmSampling_CounterDataImage_Initialize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Initialize the counter data to CUPTI record format for storing the metric data.\n\n \\param pParams A pointer to \\ref CUpti_PmSampling_CounterDataImage_Initialize_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_INVALID_OPERATION if PM sampling CounterDataInitialize is called without enabling PM sampling\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiPmSamplingCounterDataImageInitialize(
        pParams: *mut CUpti_PmSampling_CounterDataImage_Initialize_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiPmSamplingGetCounterDataInfo"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_GetCounterDataInfo_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Set to NULL."]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] Counter data image."]
    pub pCounterDataImage: *const u8,
    #[doc = " [in] Size of the counter data image."]
    pub counterDataImageSize: usize,
    #[doc = " [out] Number of samples in the counter data image."]
    pub numTotalSamples: usize,
    #[doc = " [out] Number of populated samples."]
    pub numPopulatedSamples: usize,
    #[doc = " [out] Number of samples that have been completed."]
    pub numCompletedSamples: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PmSampling_GetCounterDataInfo_Params"]
        [::std::mem::size_of::<CUpti_PmSampling_GetCounterDataInfo_Params>() - 56usize];
    ["Alignment of CUpti_PmSampling_GetCounterDataInfo_Params"]
        [::std::mem::align_of::<CUpti_PmSampling_GetCounterDataInfo_Params>() - 8usize];
    ["Offset of field: CUpti_PmSampling_GetCounterDataInfo_Params::structSize"]
        [::std::mem::offset_of!(CUpti_PmSampling_GetCounterDataInfo_Params, structSize) - 0usize];
    ["Offset of field: CUpti_PmSampling_GetCounterDataInfo_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_PmSampling_GetCounterDataInfo_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_PmSampling_GetCounterDataInfo_Params::pCounterDataImage"][::std::mem::offset_of!(
        CUpti_PmSampling_GetCounterDataInfo_Params,
        pCounterDataImage
    ) - 16usize];
    ["Offset of field: CUpti_PmSampling_GetCounterDataInfo_Params::counterDataImageSize"][::std::mem::offset_of!(
        CUpti_PmSampling_GetCounterDataInfo_Params,
        counterDataImageSize
    )
        - 24usize];
    ["Offset of field: CUpti_PmSampling_GetCounterDataInfo_Params::numTotalSamples"][::std::mem::offset_of!(
        CUpti_PmSampling_GetCounterDataInfo_Params,
        numTotalSamples
    ) - 32usize];
    ["Offset of field: CUpti_PmSampling_GetCounterDataInfo_Params::numPopulatedSamples"][::std::mem::offset_of!(
        CUpti_PmSampling_GetCounterDataInfo_Params,
        numPopulatedSamples
    )
        - 40usize];
    ["Offset of field: CUpti_PmSampling_GetCounterDataInfo_Params::numCompletedSamples"][::std::mem::offset_of!(
        CUpti_PmSampling_GetCounterDataInfo_Params,
        numCompletedSamples
    )
        - 48usize];
};
impl Default for CUpti_PmSampling_GetCounterDataInfo_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Get the counter data info like number of samples, number of populated\n samples and number of completed samples in a counter data image.\n\n \\param pParams A pointer to \\ref CUpti_PmSampling_GetCounterDataInfo_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiPmSamplingGetCounterDataInfo(
        pParams: *mut CUpti_PmSampling_GetCounterDataInfo_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiPmSamplingCounterDataGetSampleInfo"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_PmSampling_CounterData_GetSampleInfo_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Set to NULL."]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] PM sampling object."]
    pub pPmSamplingObject: *mut CUpti_PmSampling_Object,
    #[doc = " [in] Counter data image."]
    pub pCounterDataImage: *const u8,
    #[doc = " [in] Size of the counter data image."]
    pub counterDataImageSize: usize,
    #[doc = " [in] Index of the sample."]
    pub sampleIndex: usize,
    #[doc = " [out] Start time of the sample."]
    pub startTimestamp: u64,
    #[doc = " [out] End time of the sample."]
    pub endTimestamp: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_PmSampling_CounterData_GetSampleInfo_Params"]
        [::std::mem::size_of::<CUpti_PmSampling_CounterData_GetSampleInfo_Params>() - 64usize];
    ["Alignment of CUpti_PmSampling_CounterData_GetSampleInfo_Params"]
        [::std::mem::align_of::<CUpti_PmSampling_CounterData_GetSampleInfo_Params>() - 8usize];
    ["Offset of field: CUpti_PmSampling_CounterData_GetSampleInfo_Params::structSize"][::std::mem::offset_of!(
        CUpti_PmSampling_CounterData_GetSampleInfo_Params,
        structSize
    ) - 0usize];
    ["Offset of field: CUpti_PmSampling_CounterData_GetSampleInfo_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_PmSampling_CounterData_GetSampleInfo_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_PmSampling_CounterData_GetSampleInfo_Params::pPmSamplingObject"][::std::mem::offset_of!(
        CUpti_PmSampling_CounterData_GetSampleInfo_Params,
        pPmSamplingObject
    )
        - 16usize];
    ["Offset of field: CUpti_PmSampling_CounterData_GetSampleInfo_Params::pCounterDataImage"][::std::mem::offset_of!(
        CUpti_PmSampling_CounterData_GetSampleInfo_Params,
        pCounterDataImage
    )
        - 24usize];
    ["Offset of field: CUpti_PmSampling_CounterData_GetSampleInfo_Params::counterDataImageSize"][::std::mem::offset_of!(
        CUpti_PmSampling_CounterData_GetSampleInfo_Params,
        counterDataImageSize
    )
        - 32usize];
    ["Offset of field: CUpti_PmSampling_CounterData_GetSampleInfo_Params::sampleIndex"][::std::mem::offset_of!(
        CUpti_PmSampling_CounterData_GetSampleInfo_Params,
        sampleIndex
    )
        - 40usize];
    ["Offset of field: CUpti_PmSampling_CounterData_GetSampleInfo_Params::startTimestamp"][::std::mem::offset_of!(
        CUpti_PmSampling_CounterData_GetSampleInfo_Params,
        startTimestamp
    )
        - 48usize];
    ["Offset of field: CUpti_PmSampling_CounterData_GetSampleInfo_Params::endTimestamp"][::std::mem::offset_of!(
        CUpti_PmSampling_CounterData_GetSampleInfo_Params,
        endTimestamp
    )
        - 56usize];
};
impl Default for CUpti_PmSampling_CounterData_GetSampleInfo_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Get the sample info (start and end time stamp) for the given sample index.\n Each sample is distinguished by the start and end time stamp.\n\n \\param pParams A pointer to \\ref CUpti_PmSampling_CounterData_GetSampleInfo_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiPmSamplingCounterDataGetSampleInfo(
        pParams: *mut CUpti_PmSampling_CounterData_GetSampleInfo_Params,
    ) -> CUptiResult;
}
pub const CUPTI_METRIC_TYPE_COUNTER: CUpti_MetricType = 0;
pub const CUPTI_METRIC_TYPE_RATIO: CUpti_MetricType = 1;
pub const CUPTI_METRIC_TYPE_THROUGHPUT: CUpti_MetricType = 2;
pub const CUPTI_METRIC_TYPE__COUNT: CUpti_MetricType = 3;
pub type CUpti_MetricType = ::std::os::raw::c_uint;
pub const CUPTI_PROFILER_TYPE_RANGE_PROFILER: CUpti_ProfilerType = 0;
pub const CUPTI_PROFILER_TYPE_PM_SAMPLING: CUpti_ProfilerType = 1;
pub const CUPTI_PROFILER_TYPE_PROFILER_INVALID: CUpti_ProfilerType = 2;
pub type CUpti_ProfilerType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_Object {
    _unused: [u8; 0],
}
#[doc = " \\brief Params for cuptiProfilerHostInitialize"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_Initialize_Params {
    #[doc = " [in] Size of the data structure.\n CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are\n available in the structure. Used to preserve backward compatibility."]
    pub structSize: usize,
    #[doc = " [in] Assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] the profiler kind one from CUpti_ProfilerType"]
    pub profilerType: CUpti_ProfilerType,
    #[doc = " [in] accepted for chips supported at the time-of-release."]
    pub pChipName: *const ::std::os::raw::c_char,
    #[doc = " [in] buffer with counter availability image - required for future chip support"]
    pub pCounterAvailabilityImage: *const u8,
    #[doc = " [out] binary blob allocated by CUPTI and operations associated with this object."]
    pub pHostObject: *mut CUpti_Profiler_Host_Object,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_Host_Initialize_Params"]
        [::std::mem::size_of::<CUpti_Profiler_Host_Initialize_Params>() - 48usize];
    ["Alignment of CUpti_Profiler_Host_Initialize_Params"]
        [::std::mem::align_of::<CUpti_Profiler_Host_Initialize_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_Host_Initialize_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_Initialize_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_Host_Initialize_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_Initialize_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_Host_Initialize_Params::profilerType"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_Initialize_Params, profilerType) - 16usize];
    ["Offset of field: CUpti_Profiler_Host_Initialize_Params::pChipName"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_Initialize_Params, pChipName) - 24usize];
    ["Offset of field: CUpti_Profiler_Host_Initialize_Params::pCounterAvailabilityImage"][::std::mem::offset_of!(
        CUpti_Profiler_Host_Initialize_Params,
        pCounterAvailabilityImage
    )
        - 32usize];
    ["Offset of field: CUpti_Profiler_Host_Initialize_Params::pHostObject"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_Initialize_Params, pHostObject) - 40usize];
};
impl Default for CUpti_Profiler_Host_Initialize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Create and initialize the profiler host object (CUpti_Profiler_Host_Object).\n\n \\param pParams A pointer to \\ref CUpti_Profiler_Host_Initialize_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiProfilerHostInitialize(
        pParams: *mut CUpti_Profiler_Host_Initialize_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiProfilerHostDeinitialize"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_Deinitialize_Params {
    #[doc = " [in] Size of the data structure.\n CUPTI client should set the size of the structure. It will be used in CUPTI to check what fields are\n available in the structure. Used to preserve backward compatibility."]
    pub structSize: usize,
    #[doc = " [in] Assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] reference to the profiler host object allocated by CUPTI in cuptiProfilerHostInitialize"]
    pub pHostObject: *mut CUpti_Profiler_Host_Object,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_Host_Deinitialize_Params"]
        [::std::mem::size_of::<CUpti_Profiler_Host_Deinitialize_Params>() - 24usize];
    ["Alignment of CUpti_Profiler_Host_Deinitialize_Params"]
        [::std::mem::align_of::<CUpti_Profiler_Host_Deinitialize_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_Host_Deinitialize_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_Deinitialize_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_Host_Deinitialize_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_Deinitialize_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_Host_Deinitialize_Params::pHostObject"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_Deinitialize_Params, pHostObject) - 16usize];
};
impl Default for CUpti_Profiler_Host_Deinitialize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Deinitialize and destroy the profiler host object (CUpti_Profiler_Host_Object).\n\n \\param pParams A pointer to \\ref CUpti_Profiler_Host_Deinitialize_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiProfilerHostDeinitialize(
        pParams: *mut CUpti_Profiler_Host_Deinitialize_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiProfilerHostGetSupportedChips"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_GetSupportedChips_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [out] number of supported chips"]
    pub numChips: usize,
    #[doc = " [out] list of supported chips"]
    pub ppChipNames: *const *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_Host_GetSupportedChips_Params"]
        [::std::mem::size_of::<CUpti_Profiler_Host_GetSupportedChips_Params>() - 32usize];
    ["Alignment of CUpti_Profiler_Host_GetSupportedChips_Params"]
        [::std::mem::align_of::<CUpti_Profiler_Host_GetSupportedChips_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_Host_GetSupportedChips_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetSupportedChips_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_Host_GetSupportedChips_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetSupportedChips_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_Host_GetSupportedChips_Params::numChips"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetSupportedChips_Params, numChips) - 16usize];
    ["Offset of field: CUpti_Profiler_Host_GetSupportedChips_Params::ppChipNames"][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetSupportedChips_Params,
        ppChipNames
    ) - 24usize];
};
impl Default for CUpti_Profiler_Host_GetSupportedChips_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Get the list of supported chips.\n\n \\param pParams A pointer to \\ref CUpti_Profiler_Host_GetSupportedChips_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiProfilerHostGetSupportedChips(
        pParams: *mut CUpti_Profiler_Host_GetSupportedChips_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiProfilerHostGetSupportedMetrics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_GetBaseMetrics_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] reference to the profiler host object allocated by CUPTI in cuptiProfilerHostInitialize"]
    pub pHostObject: *mut CUpti_Profiler_Host_Object,
    #[doc = " [in] metric type (counter, ratio, throughput)"]
    pub metricType: CUpti_MetricType,
    #[doc = " [out] list of base metrics supported of queried metric type for the chip"]
    pub ppMetricNames: *mut *const ::std::os::raw::c_char,
    #[doc = " [out] number of metrics"]
    pub numMetrics: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_Host_GetBaseMetrics_Params"]
        [::std::mem::size_of::<CUpti_Profiler_Host_GetBaseMetrics_Params>() - 48usize];
    ["Alignment of CUpti_Profiler_Host_GetBaseMetrics_Params"]
        [::std::mem::align_of::<CUpti_Profiler_Host_GetBaseMetrics_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_Host_GetBaseMetrics_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetBaseMetrics_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_Host_GetBaseMetrics_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetBaseMetrics_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_Host_GetBaseMetrics_Params::pHostObject"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetBaseMetrics_Params, pHostObject) - 16usize];
    ["Offset of field: CUpti_Profiler_Host_GetBaseMetrics_Params::metricType"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetBaseMetrics_Params, metricType) - 24usize];
    ["Offset of field: CUpti_Profiler_Host_GetBaseMetrics_Params::ppMetricNames"][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetBaseMetrics_Params,
        ppMetricNames
    ) - 32usize];
    ["Offset of field: CUpti_Profiler_Host_GetBaseMetrics_Params::numMetrics"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetBaseMetrics_Params, numMetrics) - 40usize];
};
impl Default for CUpti_Profiler_Host_GetBaseMetrics_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Get the list of supported base metrics for the chip.\n\n \\param pParams A pointer to \\ref CUpti_Profiler_Host_GetBaseMetrics_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiProfilerHostGetBaseMetrics(
        pParams: *mut CUpti_Profiler_Host_GetBaseMetrics_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiProfilerHostGetSubMetrics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_GetSubMetrics_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] reference to the profiler host object allocated by CUPTI in cuptiProfilerHostInitialize"]
    pub pHostObject: *mut CUpti_Profiler_Host_Object,
    #[doc = " [in] the metric type for queried metric"]
    pub metricType: CUpti_MetricType,
    #[doc = " [in] metric name for which sub-metric will be listed. Metric name can be with or without extension (rollup or submetric)"]
    pub pMetricName: *const ::std::os::raw::c_char,
    #[doc = " [out] number of submetrics supported"]
    pub numOfSubmetrics: usize,
    #[doc = " [out] list of submetrics supported for the metric."]
    pub ppSubMetrics: *mut *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_Host_GetSubMetrics_Params"]
        [::std::mem::size_of::<CUpti_Profiler_Host_GetSubMetrics_Params>() - 56usize];
    ["Alignment of CUpti_Profiler_Host_GetSubMetrics_Params"]
        [::std::mem::align_of::<CUpti_Profiler_Host_GetSubMetrics_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_Host_GetSubMetrics_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetSubMetrics_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_Host_GetSubMetrics_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetSubMetrics_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_Host_GetSubMetrics_Params::pHostObject"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetSubMetrics_Params, pHostObject) - 16usize];
    ["Offset of field: CUpti_Profiler_Host_GetSubMetrics_Params::metricType"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetSubMetrics_Params, metricType) - 24usize];
    ["Offset of field: CUpti_Profiler_Host_GetSubMetrics_Params::pMetricName"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetSubMetrics_Params, pMetricName) - 32usize];
    ["Offset of field: CUpti_Profiler_Host_GetSubMetrics_Params::numOfSubmetrics"][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetSubMetrics_Params,
        numOfSubmetrics
    ) - 40usize];
    ["Offset of field: CUpti_Profiler_Host_GetSubMetrics_Params::ppSubMetrics"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetSubMetrics_Params, ppSubMetrics) - 48usize];
};
impl Default for CUpti_Profiler_Host_GetSubMetrics_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Get the list of supported sub-metrics for the metric.\n\n \\param pParams A pointer to \\ref CUpti_Profiler_Host_GetSubMetrics_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_INVALID_METRIC_NAME if the metric name is not valid or not supported for the chip\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiProfilerHostGetSubMetrics(
        pParams: *mut CUpti_Profiler_Host_GetSubMetrics_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiProfilerHostGetMetricProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_GetMetricProperties_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] reference to the profiler host object allocated by CUPTI in cuptiProfilerHostInitialize"]
    pub pHostObject: *mut CUpti_Profiler_Host_Object,
    #[doc = " [in] metric name for which its properties will be listed. Metric name can be with or without extension (rollup or submetric)"]
    pub pMetricName: *const ::std::os::raw::c_char,
    #[doc = " [out] a short description about the metric"]
    pub pDescription: *const ::std::os::raw::c_char,
    #[doc = " [out] associated hw unit for the metric"]
    pub pHwUnit: *const ::std::os::raw::c_char,
    #[doc = " [out] the dimension of the metric values"]
    pub pDimUnit: *const ::std::os::raw::c_char,
    #[doc = " [out] the metric type (counter, ratio or throughput)"]
    pub metricType: CUpti_MetricType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_Host_GetMetricProperties_Params"]
        [::std::mem::size_of::<CUpti_Profiler_Host_GetMetricProperties_Params>() - 64usize];
    ["Alignment of CUpti_Profiler_Host_GetMetricProperties_Params"]
        [::std::mem::align_of::<CUpti_Profiler_Host_GetMetricProperties_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_Host_GetMetricProperties_Params::structSize"][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetMetricProperties_Params,
        structSize
    ) - 0usize];
    ["Offset of field: CUpti_Profiler_Host_GetMetricProperties_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetMetricProperties_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_Host_GetMetricProperties_Params::pHostObject"][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetMetricProperties_Params,
        pHostObject
    ) - 16usize];
    ["Offset of field: CUpti_Profiler_Host_GetMetricProperties_Params::pMetricName"][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetMetricProperties_Params,
        pMetricName
    ) - 24usize];
    ["Offset of field: CUpti_Profiler_Host_GetMetricProperties_Params::pDescription"][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetMetricProperties_Params,
        pDescription
    ) - 32usize];
    ["Offset of field: CUpti_Profiler_Host_GetMetricProperties_Params::pHwUnit"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetMetricProperties_Params, pHwUnit) - 40usize];
    ["Offset of field: CUpti_Profiler_Host_GetMetricProperties_Params::pDimUnit"][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetMetricProperties_Params,
        pDimUnit
    ) - 48usize];
    ["Offset of field: CUpti_Profiler_Host_GetMetricProperties_Params::metricType"][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetMetricProperties_Params,
        metricType
    ) - 56usize];
};
impl Default for CUpti_Profiler_Host_GetMetricProperties_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Get the properties of the metric.\n\n \\param pParams A pointer to \\ref CUpti_Profiler_Host_GetMetricProperties_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_INVALID_METRIC_NAME if the metric name is not valid or not supported for the chip\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiProfilerHostGetMetricProperties(
        pParams: *mut CUpti_Profiler_Host_GetMetricProperties_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiProfilerHostGetRangeName"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_GetRangeName_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] the counter data image where profiling data has been decoded"]
    pub pCounterDataImage: *const u8,
    #[doc = " [in] size of counter data image"]
    pub counterDataImageSize: usize,
    #[doc = " [in] range index for which the range name will be queried"]
    pub rangeIndex: usize,
    #[doc = " [in] used in case of nested ranges, default=\"/\". Range1<delimiter>Range2"]
    pub delimiter: *const ::std::os::raw::c_char,
    #[doc = " [out] the range name.\n Note: that the CUPTI allocate the memory internal and\n its user responsibility to free up the allocated memory"]
    pub pRangeName: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_Host_GetRangeName_Params"]
        [::std::mem::size_of::<CUpti_Profiler_Host_GetRangeName_Params>() - 56usize];
    ["Alignment of CUpti_Profiler_Host_GetRangeName_Params"]
        [::std::mem::align_of::<CUpti_Profiler_Host_GetRangeName_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_Host_GetRangeName_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetRangeName_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_Host_GetRangeName_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetRangeName_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_Host_GetRangeName_Params::pCounterDataImage"][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetRangeName_Params,
        pCounterDataImage
    ) - 16usize];
    ["Offset of field: CUpti_Profiler_Host_GetRangeName_Params::counterDataImageSize"][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetRangeName_Params,
        counterDataImageSize
    ) - 24usize];
    ["Offset of field: CUpti_Profiler_Host_GetRangeName_Params::rangeIndex"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetRangeName_Params, rangeIndex) - 32usize];
    ["Offset of field: CUpti_Profiler_Host_GetRangeName_Params::delimiter"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetRangeName_Params, delimiter) - 40usize];
    ["Offset of field: CUpti_Profiler_Host_GetRangeName_Params::pRangeName"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetRangeName_Params, pRangeName) - 48usize];
};
impl Default for CUpti_Profiler_Host_GetRangeName_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Get the range name for the range index stored in the counter data.\n In Range profiler, for Auto range mode the range name will be numeric value\n assigned to the kernel based on execution order. For user range mode, the\n name of range will be based on the range name provided by the user using\n Push range API.\n\n \\param pParams A pointer to \\ref CUpti_Profiler_Host_GetRangeName_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiProfilerHostGetRangeName(
        pParams: *mut CUpti_Profiler_Host_GetRangeName_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiProfilerHostEvaluateToGpuValues"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_EvaluateToGpuValues_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] reference to the profiler host object allocated by CUPTI in cuptiProfilerHostInitialize"]
    pub pHostObject: *mut CUpti_Profiler_Host_Object,
    #[doc = " [in] the counter data image where profiling data has been decoded"]
    pub pCounterDataImage: *const u8,
    #[doc = " [in] size of counter data image"]
    pub counterDataImageSize: usize,
    #[doc = " [in] range index for which the range name will be queried"]
    pub rangeIndex: usize,
    #[doc = " [in] the metrics for which GPU values will be evaluated for the range"]
    pub ppMetricNames: *mut *const ::std::os::raw::c_char,
    #[doc = " [in] number of metrics"]
    pub numMetrics: usize,
    #[doc = " [out] output value for given metric and range index"]
    pub pMetricValues: *mut f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_Host_EvaluateToGpuValues_Params"]
        [::std::mem::size_of::<CUpti_Profiler_Host_EvaluateToGpuValues_Params>() - 72usize];
    ["Alignment of CUpti_Profiler_Host_EvaluateToGpuValues_Params"]
        [::std::mem::align_of::<CUpti_Profiler_Host_EvaluateToGpuValues_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_Host_EvaluateToGpuValues_Params::structSize"][::std::mem::offset_of!(
        CUpti_Profiler_Host_EvaluateToGpuValues_Params,
        structSize
    ) - 0usize];
    ["Offset of field: CUpti_Profiler_Host_EvaluateToGpuValues_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_EvaluateToGpuValues_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_Host_EvaluateToGpuValues_Params::pHostObject"][::std::mem::offset_of!(
        CUpti_Profiler_Host_EvaluateToGpuValues_Params,
        pHostObject
    ) - 16usize];
    ["Offset of field: CUpti_Profiler_Host_EvaluateToGpuValues_Params::pCounterDataImage"][::std::mem::offset_of!(
        CUpti_Profiler_Host_EvaluateToGpuValues_Params,
        pCounterDataImage
    )
        - 24usize];
    ["Offset of field: CUpti_Profiler_Host_EvaluateToGpuValues_Params::counterDataImageSize"][::std::mem::offset_of!(
        CUpti_Profiler_Host_EvaluateToGpuValues_Params,
        counterDataImageSize
    )
        - 32usize];
    ["Offset of field: CUpti_Profiler_Host_EvaluateToGpuValues_Params::rangeIndex"][::std::mem::offset_of!(
        CUpti_Profiler_Host_EvaluateToGpuValues_Params,
        rangeIndex
    ) - 40usize];
    ["Offset of field: CUpti_Profiler_Host_EvaluateToGpuValues_Params::ppMetricNames"][::std::mem::offset_of!(
        CUpti_Profiler_Host_EvaluateToGpuValues_Params,
        ppMetricNames
    ) - 48usize];
    ["Offset of field: CUpti_Profiler_Host_EvaluateToGpuValues_Params::numMetrics"][::std::mem::offset_of!(
        CUpti_Profiler_Host_EvaluateToGpuValues_Params,
        numMetrics
    ) - 56usize];
    ["Offset of field: CUpti_Profiler_Host_EvaluateToGpuValues_Params::pMetricValues"][::std::mem::offset_of!(
        CUpti_Profiler_Host_EvaluateToGpuValues_Params,
        pMetricValues
    ) - 64usize];
};
impl Default for CUpti_Profiler_Host_EvaluateToGpuValues_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Evaluate the metric values for the range index stored in the counter data.\n\n \\param pParams A pointer to \\ref CUpti_Profiler_Host_EvaluateToGpuValues_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_INVALID_METRIC_NAME if the metric name is not valid or not supported for the chip\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiProfilerHostEvaluateToGpuValues(
        pParams: *mut CUpti_Profiler_Host_EvaluateToGpuValues_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiProfilerHostConfigAddMetrics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_ConfigAddMetrics_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] reference to the profiler host object allocated by CUPTI in cuptiProfilerHostInitialize"]
    pub pHostObject: *mut CUpti_Profiler_Host_Object,
    #[doc = " [in] metric names for which config image will be generated"]
    pub ppMetricNames: *mut *const ::std::os::raw::c_char,
    #[doc = " [in] number of metrics"]
    pub numMetrics: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_Host_ConfigAddMetrics_Params"]
        [::std::mem::size_of::<CUpti_Profiler_Host_ConfigAddMetrics_Params>() - 40usize];
    ["Alignment of CUpti_Profiler_Host_ConfigAddMetrics_Params"]
        [::std::mem::align_of::<CUpti_Profiler_Host_ConfigAddMetrics_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_Host_ConfigAddMetrics_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_ConfigAddMetrics_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_Host_ConfigAddMetrics_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_ConfigAddMetrics_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_Host_ConfigAddMetrics_Params::pHostObject"][::std::mem::offset_of!(
        CUpti_Profiler_Host_ConfigAddMetrics_Params,
        pHostObject
    ) - 16usize];
    ["Offset of field: CUpti_Profiler_Host_ConfigAddMetrics_Params::ppMetricNames"][::std::mem::offset_of!(
        CUpti_Profiler_Host_ConfigAddMetrics_Params,
        ppMetricNames
    ) - 24usize];
    ["Offset of field: CUpti_Profiler_Host_ConfigAddMetrics_Params::numMetrics"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_ConfigAddMetrics_Params, numMetrics) - 32usize];
};
impl Default for CUpti_Profiler_Host_ConfigAddMetrics_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Add the metrics to the profiler host object for generating the config image.\n The config image will have the required information to schedule the metrics for\n collecting the profiling data.\n Note: PM sampling only supports single pass config image.\n\n \\param pParams A pointer to \\ref CUpti_Profiler_Host_ConfigAddMetrics_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_INVALID_METRIC_NAME if the metric name is not valid or not supported for the chip\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiProfilerHostConfigAddMetrics(
        pParams: *mut CUpti_Profiler_Host_ConfigAddMetrics_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiProfilerHostGetConfigImageSize"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_GetConfigImageSize_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] reference to the profiler host object allocated by CUPTI in cuptiProfilerHostInitialize"]
    pub pHostObject: *mut CUpti_Profiler_Host_Object,
    #[doc = " [out] the size of config image, users need to allocate the buffer for storing"]
    pub configImageSize: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_Host_GetConfigImageSize_Params"]
        [::std::mem::size_of::<CUpti_Profiler_Host_GetConfigImageSize_Params>() - 32usize];
    ["Alignment of CUpti_Profiler_Host_GetConfigImageSize_Params"]
        [::std::mem::align_of::<CUpti_Profiler_Host_GetConfigImageSize_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_Host_GetConfigImageSize_Params::structSize"][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetConfigImageSize_Params,
        structSize
    ) - 0usize];
    ["Offset of field: CUpti_Profiler_Host_GetConfigImageSize_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetConfigImageSize_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_Host_GetConfigImageSize_Params::pHostObject"][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetConfigImageSize_Params,
        pHostObject
    ) - 16usize];
    ["Offset of field: CUpti_Profiler_Host_GetConfigImageSize_Params::configImageSize"][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetConfigImageSize_Params,
        configImageSize
    )
        - 24usize];
};
impl Default for CUpti_Profiler_Host_GetConfigImageSize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Get the size of the config image for the metrics added to the profiler host object.\n Users need to allocate the buffer for storing the config image.\n\n \\param pParams A pointer to \\ref CUpti_Profiler_Host_GetConfigImageSize_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiProfilerHostGetConfigImageSize(
        pParams: *mut CUpti_Profiler_Host_GetConfigImageSize_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiProfilerHostGetConfigImage"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_GetConfigImage_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] reference to the profiler host object allocated by CUPTI in cuptiProfilerHostInitialize"]
    pub pHostObject: *mut CUpti_Profiler_Host_Object,
    #[doc = " [in] Number of bytes allocated for pBuffer"]
    pub configImageSize: usize,
    #[doc = " [out] Buffer receiving the config image"]
    pub pConfigImage: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_Host_GetConfigImage_Params"]
        [::std::mem::size_of::<CUpti_Profiler_Host_GetConfigImage_Params>() - 40usize];
    ["Alignment of CUpti_Profiler_Host_GetConfigImage_Params"]
        [::std::mem::align_of::<CUpti_Profiler_Host_GetConfigImage_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_Host_GetConfigImage_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetConfigImage_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_Host_GetConfigImage_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetConfigImage_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_Host_GetConfigImage_Params::pHostObject"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetConfigImage_Params, pHostObject) - 16usize];
    ["Offset of field: CUpti_Profiler_Host_GetConfigImage_Params::configImageSize"][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetConfigImage_Params,
        configImageSize
    ) - 24usize];
    ["Offset of field: CUpti_Profiler_Host_GetConfigImage_Params::pConfigImage"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetConfigImage_Params, pConfigImage) - 32usize];
};
impl Default for CUpti_Profiler_Host_GetConfigImage_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Get the config image for the metrics added to the profiler host object.\n User will pass the allocated buffer to store the config image.\n\n \\param pParams A pointer to \\ref CUpti_Profiler_Host_GetConfigImage_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiProfilerHostGetConfigImage(
        pParams: *mut CUpti_Profiler_Host_GetConfigImage_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiProfilerHostGetNumOfPasses"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_GetNumOfPasses_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] Number of bytes allocated for pConfigImage"]
    pub configImageSize: usize,
    #[doc = " [in] the config image buffer"]
    pub pConfigImage: *mut u8,
    #[doc = " [out] number of passes required for profiling scheduled metrics in the config image"]
    pub numOfPasses: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_Host_GetNumOfPasses_Params"]
        [::std::mem::size_of::<CUpti_Profiler_Host_GetNumOfPasses_Params>() - 40usize];
    ["Alignment of CUpti_Profiler_Host_GetNumOfPasses_Params"]
        [::std::mem::align_of::<CUpti_Profiler_Host_GetNumOfPasses_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_Host_GetNumOfPasses_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetNumOfPasses_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_Host_GetNumOfPasses_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetNumOfPasses_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_Host_GetNumOfPasses_Params::configImageSize"][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetNumOfPasses_Params,
        configImageSize
    ) - 16usize];
    ["Offset of field: CUpti_Profiler_Host_GetNumOfPasses_Params::pConfigImage"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetNumOfPasses_Params, pConfigImage) - 24usize];
    ["Offset of field: CUpti_Profiler_Host_GetNumOfPasses_Params::numOfPasses"]
        [::std::mem::offset_of!(CUpti_Profiler_Host_GetNumOfPasses_Params, numOfPasses) - 32usize];
};
impl Default for CUpti_Profiler_Host_GetNumOfPasses_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Get the number of passes required for profiling the scheduled metrics in the config image.\n\n \\param pParams A pointer to \\ref CUpti_Profiler_Host_GetNumOfPasses_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiProfilerHostGetNumOfPasses(
        pParams: *mut CUpti_Profiler_Host_GetNumOfPasses_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiProfilerHostGetMaxNumHardwareMetricsPerPass"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] the profiler kind one from CUpti_ProfilerType"]
    pub profilerType: CUpti_ProfilerType,
    #[doc = " [in] accepted for chips supported at the time-of-release."]
    pub pChipName: *const ::std::os::raw::c_char,
    #[doc = " [in] buffer with counter availability image - required for future chip support"]
    pub pCounterAvailabilityImage: *mut u8,
    #[doc = " [out] maximum number of metrics that can be scheduled in a pass"]
    pub maxMetricsPerPass: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params"][::std::mem::size_of::<
        CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params,
    >() - 48usize];
    ["Alignment of CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params"][::std::mem::align_of::<
        CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params,
    >() - 8usize];
    ["Offset of field: CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params::structSize"][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params,
        structSize
    )
        - 0usize];
    ["Offset of field: CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params::pPriv"][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params,
        pPriv
    )
        - 8usize];
    ["Offset of field: CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params::profilerType"][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params,
        profilerType
    )
        - 16usize];
    ["Offset of field: CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params::pChipName"][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params,
        pChipName
    )
        - 24usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params::pCounterAvailabilityImage",
    ][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params,
        pCounterAvailabilityImage
    ) - 32usize];
    [
        "Offset of field: CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params::maxMetricsPerPass",
    ][::std::mem::offset_of!(
        CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params,
        maxMetricsPerPass
    ) - 40usize];
};
impl Default for CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Get the maximum number of hardware metrics (metric names which doesn't include _sass_ keyword)\n that can be scheduled in a single pass for a chip. While this represents a theoretical upper limit,\n practical constraints may prevent reaching this threshold for a specific set of metrics. Furthermore,\n the maximum achievable value is contingent upon the characteristics and architecture of the chip in question.\n\n Use cuptiProfilerHostGetNumOfPasses API for getting the actual number of passes required for the\n for collecting the profiling data for the scheduled metrics in a config image.\n\n \\param pParams A pointer to \\ref CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiProfilerHostGetMaxNumHardwareMetricsPerPass(
        pParams: *mut CUpti_Profiler_Host_GetMaxNumHardwareMetricsPerPass_Params,
    ) -> CUptiResult;
}
#[doc = " Invalid value"]
pub const CUPTI_Range_INVALID: CUpti_ProfilerRange = 0;
#[doc = " Ranges are auto defined around each kernel in a profiling session"]
pub const CUPTI_AutoRange: CUpti_ProfilerRange = 1;
#[doc = " A range in which metric data to be collected is defined by the user"]
pub const CUPTI_UserRange: CUpti_ProfilerRange = 2;
#[doc = " Range count"]
pub const CUPTI_Range_COUNT: CUpti_ProfilerRange = 3;
#[doc = " \\brief Profiler range attribute\n\n A metric enabled in the session's configuration is collected separately per unique range-stack in the pass.\n This is an attribute to collect metrics around each kernel in a profiling session or in an user defined range."]
pub type CUpti_ProfilerRange = ::std::os::raw::c_uint;
#[doc = " Invalid Value"]
pub const CUPTI_Replay_INVALID: CUpti_ProfilerReplayMode = 0;
#[doc = " Replay is done by CUPTI user around the process"]
pub const CUPTI_ApplicationReplay: CUpti_ProfilerReplayMode = 1;
#[doc = " Replay is done around kernel implicitly by CUPTI"]
pub const CUPTI_KernelReplay: CUpti_ProfilerReplayMode = 2;
#[doc = " Replay is done by CUPTI user within a process"]
pub const CUPTI_UserReplay: CUpti_ProfilerReplayMode = 3;
#[doc = " Replay count"]
pub const CUPTI_Replay_COUNT: CUpti_ProfilerReplayMode = 4;
#[doc = " \\brief Profiler replay attribute\n\n For metrics which require multipass collection, a replay of the GPU kernel(s) is required.\n This is an attribute which specify how the replay of the kernel(s) to be measured is done."]
pub type CUpti_ProfilerReplayMode = ::std::os::raw::c_uint;
#[doc = " \\brief Default parameter for cuptiProfilerInitialize"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_Initialize_Params {
    #[doc = "!< [in] CUpti_Profiler_Initialize_Params_STRUCT_SIZE"]
    pub structSize: usize,
    #[doc = "!< [in] assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_Initialize_Params"]
        [::std::mem::size_of::<CUpti_Profiler_Initialize_Params>() - 16usize];
    ["Alignment of CUpti_Profiler_Initialize_Params"]
        [::std::mem::align_of::<CUpti_Profiler_Initialize_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_Initialize_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_Initialize_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_Initialize_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_Initialize_Params, pPriv) - 8usize];
};
impl Default for CUpti_Profiler_Initialize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Default parameter for cuptiProfilerDeInitialize"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_DeInitialize_Params {
    #[doc = "!< [in] CUpti_Profiler_DeInitialize_Params_STRUCT_SIZE"]
    pub structSize: usize,
    #[doc = "!< [in] assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_DeInitialize_Params"]
        [::std::mem::size_of::<CUpti_Profiler_DeInitialize_Params>() - 16usize];
    ["Alignment of CUpti_Profiler_DeInitialize_Params"]
        [::std::mem::align_of::<CUpti_Profiler_DeInitialize_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_DeInitialize_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_DeInitialize_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_DeInitialize_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_DeInitialize_Params, pPriv) - 8usize];
};
impl Default for CUpti_Profiler_DeInitialize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Initializes the profiler interface\n\n Loads the required libraries in the process address space.\n Sets up the hooks with the CUDA driver."]
    pub fn cuptiProfilerInitialize(pParams: *mut CUpti_Profiler_Initialize_Params) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief DeInitializes the profiler interface"]
    pub fn cuptiProfilerDeInitialize(
        pParams: *mut CUpti_Profiler_DeInitialize_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Input parameter to define the counterDataImage"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_CounterDataImageOptions {
    #[doc = "!< [in] CUpti_Profiler_CounterDataImageOptions_Params_STRUCT_SIZE"]
    pub structSize: usize,
    #[doc = "!< [in] assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = "< [in] Address of CounterDataPrefix generated from NVPW_CounterDataBuilder_GetCounterDataPrefix().\nMust be align(8)."]
    pub pCounterDataPrefix: *const u8,
    #[doc = "!< [in] Size of CounterDataPrefix generated from NVPW_CounterDataBuilder_GetCounterDataPrefix()."]
    pub counterDataPrefixSize: usize,
    #[doc = "!< [in] Maximum number of ranges that can be profiled"]
    pub maxNumRanges: u32,
    #[doc = "!< [in] Maximum number of RangeTree nodes; must be >= maxNumRanges"]
    pub maxNumRangeTreeNodes: u32,
    #[doc = "!< [in] Maximum string length of each RangeName, including the trailing NULL character"]
    pub maxRangeNameLength: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_CounterDataImageOptions"]
        [::std::mem::size_of::<CUpti_Profiler_CounterDataImageOptions>() - 48usize];
    ["Alignment of CUpti_Profiler_CounterDataImageOptions"]
        [::std::mem::align_of::<CUpti_Profiler_CounterDataImageOptions>() - 8usize];
    ["Offset of field: CUpti_Profiler_CounterDataImageOptions::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_CounterDataImageOptions, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_CounterDataImageOptions::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_CounterDataImageOptions, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_CounterDataImageOptions::pCounterDataPrefix"][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImageOptions,
        pCounterDataPrefix
    ) - 16usize];
    ["Offset of field: CUpti_Profiler_CounterDataImageOptions::counterDataPrefixSize"][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImageOptions,
        counterDataPrefixSize
    ) - 24usize];
    ["Offset of field: CUpti_Profiler_CounterDataImageOptions::maxNumRanges"]
        [::std::mem::offset_of!(CUpti_Profiler_CounterDataImageOptions, maxNumRanges) - 32usize];
    ["Offset of field: CUpti_Profiler_CounterDataImageOptions::maxNumRangeTreeNodes"][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImageOptions,
        maxNumRangeTreeNodes
    ) - 36usize];
    ["Offset of field: CUpti_Profiler_CounterDataImageOptions::maxRangeNameLength"][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImageOptions,
        maxRangeNameLength
    ) - 40usize];
};
impl Default for CUpti_Profiler_CounterDataImageOptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Params for cuptiProfilerCounterDataImageCalculateSize"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_CounterDataImage_CalculateSize_Params {
    #[doc = "!< [in] CUpti_Profiler_CounterDataImage_CalculateSize_Params_STRUCT_SIZE"]
    pub structSize: usize,
    #[doc = "!< [in] assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = "!< [in] CUpti_Profiler_CounterDataImageOptions_STRUCT_SIZE"]
    pub sizeofCounterDataImageOptions: usize,
    #[doc = "!< [in] Pointer to Counter Data Image Options"]
    pub pOptions: *const CUpti_Profiler_CounterDataImageOptions,
    #[doc = "!< [out]"]
    pub counterDataImageSize: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_CounterDataImage_CalculateSize_Params"]
        [::std::mem::size_of::<CUpti_Profiler_CounterDataImage_CalculateSize_Params>() - 40usize];
    ["Alignment of CUpti_Profiler_CounterDataImage_CalculateSize_Params"]
        [::std::mem::align_of::<CUpti_Profiler_CounterDataImage_CalculateSize_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_CounterDataImage_CalculateSize_Params::structSize"][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_CalculateSize_Params,
        structSize
    )
        - 0usize];
    ["Offset of field: CUpti_Profiler_CounterDataImage_CalculateSize_Params::pPriv"][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_CalculateSize_Params,
        pPriv
    ) - 8usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_CalculateSize_Params::sizeofCounterDataImageOptions",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_CalculateSize_Params,
        sizeofCounterDataImageOptions
    ) - 16usize];
    ["Offset of field: CUpti_Profiler_CounterDataImage_CalculateSize_Params::pOptions"][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_CalculateSize_Params,
        pOptions
    )
        - 24usize];
    ["Offset of field: CUpti_Profiler_CounterDataImage_CalculateSize_Params::counterDataImageSize"]
        [::std::mem::offset_of!(
            CUpti_Profiler_CounterDataImage_CalculateSize_Params,
            counterDataImageSize
        ) - 32usize];
};
impl Default for CUpti_Profiler_CounterDataImage_CalculateSize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Params for cuptiProfilerCounterDataImageInitialize"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_CounterDataImage_Initialize_Params {
    #[doc = "!< [in] CUpti_Profiler_CounterDataImage_Initialize_Params_STRUCT_SIZE"]
    pub structSize: usize,
    #[doc = "!< [in] assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = "!< [in] CUpti_Profiler_CounterDataImageOptions_STRUCT_SIZE"]
    pub sizeofCounterDataImageOptions: usize,
    #[doc = "!< [in] Pointer to Counter Data Image Options"]
    pub pOptions: *const CUpti_Profiler_CounterDataImageOptions,
    #[doc = "!< [in] Size calculated from cuptiProfilerCounterDataImageCalculateSize"]
    pub counterDataImageSize: usize,
    #[doc = "!< [in] The buffer to be initialized."]
    pub pCounterDataImage: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_CounterDataImage_Initialize_Params"]
        [::std::mem::size_of::<CUpti_Profiler_CounterDataImage_Initialize_Params>() - 48usize];
    ["Alignment of CUpti_Profiler_CounterDataImage_Initialize_Params"]
        [::std::mem::align_of::<CUpti_Profiler_CounterDataImage_Initialize_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_CounterDataImage_Initialize_Params::structSize"][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_Initialize_Params,
        structSize
    ) - 0usize];
    ["Offset of field: CUpti_Profiler_CounterDataImage_Initialize_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_CounterDataImage_Initialize_Params, pPriv) - 8usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_Initialize_Params::sizeofCounterDataImageOptions",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_Initialize_Params,
        sizeofCounterDataImageOptions
    ) - 16usize];
    ["Offset of field: CUpti_Profiler_CounterDataImage_Initialize_Params::pOptions"][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_Initialize_Params,
        pOptions
    ) - 24usize];
    ["Offset of field: CUpti_Profiler_CounterDataImage_Initialize_Params::counterDataImageSize"][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_Initialize_Params,
        counterDataImageSize
    )
        - 32usize];
    ["Offset of field: CUpti_Profiler_CounterDataImage_Initialize_Params::pCounterDataImage"][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_Initialize_Params,
        pCounterDataImage
    )
        - 40usize];
};
impl Default for CUpti_Profiler_CounterDataImage_Initialize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief A CounterData image allocates space for values for each counter for each range.\n\n User borne the resposibility of managing the counterDataImage allocations.\n CounterDataPrefix contains meta data about the metrics that will be stored in counterDataImage.\n Use these APIs to calculate the allocation size and initialize counterData image.\n\n **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h."]
    pub fn cuptiProfilerCounterDataImageCalculateSize(
        pParams: *mut CUpti_Profiler_CounterDataImage_CalculateSize_Params,
    ) -> CUptiResult;
}
unsafe extern "C" {
    pub fn cuptiProfilerCounterDataImageInitialize(
        pParams: *mut CUpti_Profiler_CounterDataImage_Initialize_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiProfilerCounterDataImageCalculateScratchBufferSize"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params {
    #[doc = "!< [in] CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params_STRUCT_SIZE"]
    pub structSize: usize,
    #[doc = "!< [in] assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = "!< [in] size calculated from cuptiProfilerCounterDataImageCalculateSize"]
    pub counterDataImageSize: usize,
    #[doc = "!< [in]"]
    pub pCounterDataImage: *mut u8,
    #[doc = "!< [out]"]
    pub counterDataScratchBufferSize: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params"]
        [::std::mem::size_of::<CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params>(
        ) - 40usize];
    ["Alignment of CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params"]
        [::std::mem::align_of::<CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params>(
        ) - 8usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params::structSize",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params,
        structSize
    ) - 0usize];
    ["Offset of field: CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params::pPriv"][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params,
        pPriv
    )
        - 8usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params::counterDataImageSize",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params,
        counterDataImageSize
    ) - 16usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params::pCounterDataImage",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params,
        pCounterDataImage
    ) - 24usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params::counterDataScratchBufferSize",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params,
        counterDataScratchBufferSize
    ) - 32usize];
};
impl Default for CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Params for cuptiProfilerCounterDataImageInitializeScratchBuffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params {
    #[doc = "!< [in] CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params_STRUCT_SIZE"]
    pub structSize: usize,
    #[doc = "!< [in] assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = "!< [in] size calculated from cuptiProfilerCounterDataImageCalculateSize"]
    pub counterDataImageSize: usize,
    #[doc = "!< [in]"]
    pub pCounterDataImage: *mut u8,
    #[doc = "!< [in] size calculated using cuptiProfilerCounterDataImageCalculateScratchBufferSize"]
    pub counterDataScratchBufferSize: usize,
    #[doc = "!< [in] the scratch buffer to be initialized."]
    pub pCounterDataScratchBuffer: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params"][::std::mem::size_of::<
        CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params,
    >() - 48usize];
    ["Alignment of CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params"]
        [::std::mem::align_of::<CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params>()
            - 8usize];
    ["Offset of field: CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params::structSize"]
        [::std::mem::offset_of!(
            CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params,
            structSize
        ) - 0usize];
    ["Offset of field: CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params::pPriv"][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params,
        pPriv
    )
        - 8usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params::counterDataImageSize",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params,
        counterDataImageSize
    ) - 16usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params::pCounterDataImage",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params,
        pCounterDataImage
    ) - 24usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params::counterDataScratchBufferSize",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params,
        counterDataScratchBufferSize
    ) - 32usize];
    [
        "Offset of field: CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params::pCounterDataScratchBuffer",
    ][::std::mem::offset_of!(
        CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params,
        pCounterDataScratchBuffer
    ) - 40usize];
};
impl Default for CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief A temporary storage for CounterData image needed for internal operations\n\n Use these APIs to calculate the allocation size and initialize counterData image scratch buffer.\n\n **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h."]
    pub fn cuptiProfilerCounterDataImageCalculateScratchBufferSize(
        pParams: *mut CUpti_Profiler_CounterDataImage_CalculateScratchBufferSize_Params,
    ) -> CUptiResult;
}
unsafe extern "C" {
    pub fn cuptiProfilerCounterDataImageInitializeScratchBuffer(
        pParams: *mut CUpti_Profiler_CounterDataImage_InitializeScratchBuffer_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiProfilerBeginSession"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_BeginSession_Params {
    #[doc = "!< [in] CUpti_Profiler_BeginSession_Params_STRUCT_SIZE"]
    pub structSize: usize,
    #[doc = "!< [in] assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = "!< [in] if NULL, the current CUcontext is used"]
    pub ctx: CUcontext,
    #[doc = "!< [in] size calculated from cuptiProfilerCounterDataImageCalculateSize"]
    pub counterDataImageSize: usize,
    #[doc = "!< [in] address of CounterDataImage"]
    pub pCounterDataImage: *mut u8,
    #[doc = "!< [in] size calculated from cuptiProfilerCounterDataImageInitializeScratchBuffer"]
    pub counterDataScratchBufferSize: usize,
    #[doc = "!< [in] address of CounterDataImage scratch buffer"]
    pub pCounterDataScratchBuffer: *mut u8,
    #[doc = "!< [in] [optional]"]
    pub bDumpCounterDataInFile: u8,
    #[doc = "!< [in] [optional]"]
    pub pCounterDataFilePath: *const ::std::os::raw::c_char,
    #[doc = "!< [in] CUpti_ProfilerRange"]
    pub range: CUpti_ProfilerRange,
    #[doc = "!< [in] CUpti_ProfilerReplayMode"]
    pub replayMode: CUpti_ProfilerReplayMode,
    #[doc = "!< [in] Maximum number of ranges that can be recorded in a single pass."]
    pub maxRangesPerPass: usize,
    #[doc = "!< [in] Maximum number of kernel launches that can be recorded in a single pass; must be >= maxRangesPerPass."]
    pub maxLaunchesPerPass: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_BeginSession_Params"]
        [::std::mem::size_of::<CUpti_Profiler_BeginSession_Params>() - 96usize];
    ["Alignment of CUpti_Profiler_BeginSession_Params"]
        [::std::mem::align_of::<CUpti_Profiler_BeginSession_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_BeginSession_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_BeginSession_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_BeginSession_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_BeginSession_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_BeginSession_Params::ctx"]
        [::std::mem::offset_of!(CUpti_Profiler_BeginSession_Params, ctx) - 16usize];
    ["Offset of field: CUpti_Profiler_BeginSession_Params::counterDataImageSize"][::std::mem::offset_of!(
        CUpti_Profiler_BeginSession_Params,
        counterDataImageSize
    ) - 24usize];
    ["Offset of field: CUpti_Profiler_BeginSession_Params::pCounterDataImage"]
        [::std::mem::offset_of!(CUpti_Profiler_BeginSession_Params, pCounterDataImage) - 32usize];
    ["Offset of field: CUpti_Profiler_BeginSession_Params::counterDataScratchBufferSize"][::std::mem::offset_of!(
        CUpti_Profiler_BeginSession_Params,
        counterDataScratchBufferSize
    )
        - 40usize];
    ["Offset of field: CUpti_Profiler_BeginSession_Params::pCounterDataScratchBuffer"][::std::mem::offset_of!(
        CUpti_Profiler_BeginSession_Params,
        pCounterDataScratchBuffer
    ) - 48usize];
    ["Offset of field: CUpti_Profiler_BeginSession_Params::bDumpCounterDataInFile"][::std::mem::offset_of!(
        CUpti_Profiler_BeginSession_Params,
        bDumpCounterDataInFile
    ) - 56usize];
    ["Offset of field: CUpti_Profiler_BeginSession_Params::pCounterDataFilePath"][::std::mem::offset_of!(
        CUpti_Profiler_BeginSession_Params,
        pCounterDataFilePath
    ) - 64usize];
    ["Offset of field: CUpti_Profiler_BeginSession_Params::range"]
        [::std::mem::offset_of!(CUpti_Profiler_BeginSession_Params, range) - 72usize];
    ["Offset of field: CUpti_Profiler_BeginSession_Params::replayMode"]
        [::std::mem::offset_of!(CUpti_Profiler_BeginSession_Params, replayMode) - 76usize];
    ["Offset of field: CUpti_Profiler_BeginSession_Params::maxRangesPerPass"]
        [::std::mem::offset_of!(CUpti_Profiler_BeginSession_Params, maxRangesPerPass) - 80usize];
    ["Offset of field: CUpti_Profiler_BeginSession_Params::maxLaunchesPerPass"]
        [::std::mem::offset_of!(CUpti_Profiler_BeginSession_Params, maxLaunchesPerPass) - 88usize];
};
impl Default for CUpti_Profiler_BeginSession_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Params for cuptiProfilerEndSession"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_EndSession_Params {
    #[doc = "!< [in] CUpti_Profiler_EndSession_Params_STRUCT_SIZE"]
    pub structSize: usize,
    #[doc = "!< [in] assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = "!< [in] if NULL, the current CUcontext is used"]
    pub ctx: CUcontext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_EndSession_Params"]
        [::std::mem::size_of::<CUpti_Profiler_EndSession_Params>() - 24usize];
    ["Alignment of CUpti_Profiler_EndSession_Params"]
        [::std::mem::align_of::<CUpti_Profiler_EndSession_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_EndSession_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_EndSession_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_EndSession_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_EndSession_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_EndSession_Params::ctx"]
        [::std::mem::offset_of!(CUpti_Profiler_EndSession_Params, ctx) - 16usize];
};
impl Default for CUpti_Profiler_EndSession_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Begin profiling session sets up the profiling on the device\n\n Although, it doesn't start the profiling but GPU resources needed for profiling are allocated.\n Outside of a session, the GPU will return to its normal operating state.\n\n **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h."]
    pub fn cuptiProfilerBeginSession(
        pParams: *mut CUpti_Profiler_BeginSession_Params,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Ends profiling session\n\n Frees up the GPU resources acquired for profiling.\n Outside of a session, the GPU will return to it's normal operating state.\n\n **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h."]
    pub fn cuptiProfilerEndSession(pParams: *mut CUpti_Profiler_EndSession_Params) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiProfilerSetConfig"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_SetConfig_Params {
    #[doc = "!< [in] CUpti_Profiler_SetConfig_Params_STRUCT_SIZE"]
    pub structSize: usize,
    #[doc = "!< [in] assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = "!< [in] if NULL, the current CUcontext is used"]
    pub ctx: CUcontext,
    #[doc = "!< [in] Config created by NVPW_RawMetricsConfig_GetConfigImage(). Must be align(8)."]
    pub pConfig: *const u8,
    #[doc = "!< [in] size of config"]
    pub configSize: usize,
    #[doc = "!< [in] the lowest nesting level to be profiled; must be >= 1"]
    pub minNestingLevel: u16,
    #[doc = "!< [in] the number of nesting levels to profile; must be >= 1"]
    pub numNestingLevels: u16,
    #[doc = "!< [in] Set this to zero for in-app replay; set this to the output of EndPass() for application replay"]
    pub passIndex: usize,
    #[doc = "!< [in] Set this to minNestingLevel for in-app replay; set this to the output of EndPass() for application"]
    pub targetNestingLevel: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_SetConfig_Params"]
        [::std::mem::size_of::<CUpti_Profiler_SetConfig_Params>() - 64usize];
    ["Alignment of CUpti_Profiler_SetConfig_Params"]
        [::std::mem::align_of::<CUpti_Profiler_SetConfig_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_SetConfig_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_SetConfig_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_SetConfig_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_SetConfig_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_SetConfig_Params::ctx"]
        [::std::mem::offset_of!(CUpti_Profiler_SetConfig_Params, ctx) - 16usize];
    ["Offset of field: CUpti_Profiler_SetConfig_Params::pConfig"]
        [::std::mem::offset_of!(CUpti_Profiler_SetConfig_Params, pConfig) - 24usize];
    ["Offset of field: CUpti_Profiler_SetConfig_Params::configSize"]
        [::std::mem::offset_of!(CUpti_Profiler_SetConfig_Params, configSize) - 32usize];
    ["Offset of field: CUpti_Profiler_SetConfig_Params::minNestingLevel"]
        [::std::mem::offset_of!(CUpti_Profiler_SetConfig_Params, minNestingLevel) - 40usize];
    ["Offset of field: CUpti_Profiler_SetConfig_Params::numNestingLevels"]
        [::std::mem::offset_of!(CUpti_Profiler_SetConfig_Params, numNestingLevels) - 42usize];
    ["Offset of field: CUpti_Profiler_SetConfig_Params::passIndex"]
        [::std::mem::offset_of!(CUpti_Profiler_SetConfig_Params, passIndex) - 48usize];
    ["Offset of field: CUpti_Profiler_SetConfig_Params::targetNestingLevel"]
        [::std::mem::offset_of!(CUpti_Profiler_SetConfig_Params, targetNestingLevel) - 56usize];
};
impl Default for CUpti_Profiler_SetConfig_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Params for cuptiProfilerUnsetConfig"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_UnsetConfig_Params {
    #[doc = "!< [in] CUpti_Profiler_UnsetConfig_Params_STRUCT_SIZE"]
    pub structSize: usize,
    #[doc = "!< [in] assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = "!< [in] if NULL, the current CUcontext is used"]
    pub ctx: CUcontext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_UnsetConfig_Params"]
        [::std::mem::size_of::<CUpti_Profiler_UnsetConfig_Params>() - 24usize];
    ["Alignment of CUpti_Profiler_UnsetConfig_Params"]
        [::std::mem::align_of::<CUpti_Profiler_UnsetConfig_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_UnsetConfig_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_UnsetConfig_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_UnsetConfig_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_UnsetConfig_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_UnsetConfig_Params::ctx"]
        [::std::mem::offset_of!(CUpti_Profiler_UnsetConfig_Params, ctx) - 16usize];
};
impl Default for CUpti_Profiler_UnsetConfig_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Set metrics configuration to be profiled\n\n Use these APIs to set the config to profile in a session. It can be used for advanced cases such as where multiple\n configurations are collected into a single CounterData Image on the need basis, without restarting the session.\n\n **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h."]
    pub fn cuptiProfilerSetConfig(pParams: *mut CUpti_Profiler_SetConfig_Params) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Unset metrics configuration profiled\n\n **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h."]
    pub fn cuptiProfilerUnsetConfig(pParams: *mut CUpti_Profiler_UnsetConfig_Params)
    -> CUptiResult;
}
#[doc = " \\brief Params for cuptiProfilerBeginPass"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_BeginPass_Params {
    #[doc = "!< [in] CUpti_Profiler_BeginPass_Params_STRUCT_SIZE"]
    pub structSize: usize,
    #[doc = "!< [in] assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = "!< [in] if NULL, the current CUcontext is used"]
    pub ctx: CUcontext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_BeginPass_Params"]
        [::std::mem::size_of::<CUpti_Profiler_BeginPass_Params>() - 24usize];
    ["Alignment of CUpti_Profiler_BeginPass_Params"]
        [::std::mem::align_of::<CUpti_Profiler_BeginPass_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_BeginPass_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_BeginPass_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_BeginPass_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_BeginPass_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_BeginPass_Params::ctx"]
        [::std::mem::offset_of!(CUpti_Profiler_BeginPass_Params, ctx) - 16usize];
};
impl Default for CUpti_Profiler_BeginPass_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Params for cuptiProfilerEndPass"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_EndPass_Params {
    #[doc = "!< [in] CUpti_Profiler_EndPass_Params_STRUCT_SIZE"]
    pub structSize: usize,
    #[doc = "!< [in] assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = "!< [in] if NULL, the current CUcontext is used"]
    pub ctx: CUcontext,
    pub targetNestingLevel: u16,
    #[doc = "!< [out] The passIndex that will be collected by the *next* BeginPass"]
    pub passIndex: usize,
    #[doc = "!< [out] becomes true when the last pass has been queued to the GPU"]
    pub allPassesSubmitted: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_EndPass_Params"]
        [::std::mem::size_of::<CUpti_Profiler_EndPass_Params>() - 48usize];
    ["Alignment of CUpti_Profiler_EndPass_Params"]
        [::std::mem::align_of::<CUpti_Profiler_EndPass_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_EndPass_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_EndPass_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_EndPass_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_EndPass_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_EndPass_Params::ctx"]
        [::std::mem::offset_of!(CUpti_Profiler_EndPass_Params, ctx) - 16usize];
    ["Offset of field: CUpti_Profiler_EndPass_Params::targetNestingLevel"]
        [::std::mem::offset_of!(CUpti_Profiler_EndPass_Params, targetNestingLevel) - 24usize];
    ["Offset of field: CUpti_Profiler_EndPass_Params::passIndex"]
        [::std::mem::offset_of!(CUpti_Profiler_EndPass_Params, passIndex) - 32usize];
    ["Offset of field: CUpti_Profiler_EndPass_Params::allPassesSubmitted"]
        [::std::mem::offset_of!(CUpti_Profiler_EndPass_Params, allPassesSubmitted) - 40usize];
};
impl Default for CUpti_Profiler_EndPass_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Replay API: used for multipass collection.\n\n These APIs are used if user chooses to replay by itself \\ref CUPTI_UserReplay or \\ref CUPTI_ApplicationReplay\n for multipass collection of the metrics configurations.\n It's a no-op in case of \\ref CUPTI_KernelReplay.\n\n **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h."]
    pub fn cuptiProfilerBeginPass(pParams: *mut CUpti_Profiler_BeginPass_Params) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Replay API: used for multipass collection.\n\n These APIs are used if user chooses to replay by itself \\ref CUPTI_UserReplay or \\ref CUPTI_ApplicationReplay\n for multipass collection of the metrics configurations.\n Its a no-op in case of \\ref CUPTI_KernelReplay.\n Returns information for next pass.\n\n **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h."]
    pub fn cuptiProfilerEndPass(pParams: *mut CUpti_Profiler_EndPass_Params) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiProfilerEnableProfiling"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_EnableProfiling_Params {
    #[doc = "!< [in] CUpti_Profiler_EnableProfiling_Params_STRUCT_SIZE"]
    pub structSize: usize,
    #[doc = "!< [in] assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = "!< [in] if NULL, the current CUcontext is used"]
    pub ctx: CUcontext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_EnableProfiling_Params"]
        [::std::mem::size_of::<CUpti_Profiler_EnableProfiling_Params>() - 24usize];
    ["Alignment of CUpti_Profiler_EnableProfiling_Params"]
        [::std::mem::align_of::<CUpti_Profiler_EnableProfiling_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_EnableProfiling_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_EnableProfiling_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_EnableProfiling_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_EnableProfiling_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_EnableProfiling_Params::ctx"]
        [::std::mem::offset_of!(CUpti_Profiler_EnableProfiling_Params, ctx) - 16usize];
};
impl Default for CUpti_Profiler_EnableProfiling_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Params for cuptiProfilerDisableProfiling"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_DisableProfiling_Params {
    #[doc = "!< [in] CUpti_Profiler_DisableProfiling_Params_STRUCT_SIZE"]
    pub structSize: usize,
    #[doc = "!< [in] assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = "!< [in] if NULL, the current CUcontext is used"]
    pub ctx: CUcontext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_DisableProfiling_Params"]
        [::std::mem::size_of::<CUpti_Profiler_DisableProfiling_Params>() - 24usize];
    ["Alignment of CUpti_Profiler_DisableProfiling_Params"]
        [::std::mem::align_of::<CUpti_Profiler_DisableProfiling_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_DisableProfiling_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_DisableProfiling_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_DisableProfiling_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_DisableProfiling_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_DisableProfiling_Params::ctx"]
        [::std::mem::offset_of!(CUpti_Profiler_DisableProfiling_Params, ctx) - 16usize];
};
impl Default for CUpti_Profiler_DisableProfiling_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Enables Profiling\n\n In \\ref CUPTI_AutoRange, these APIs are used to enable/disable profiling for the kernels to be executed in\n a profiling session.\n\n **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h."]
    pub fn cuptiProfilerEnableProfiling(
        pParams: *mut CUpti_Profiler_EnableProfiling_Params,
    ) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Disable Profiling\n\n In \\ref CUPTI_AutoRange, these APIs are used to enable/disable profiling for the kernels to be executed in\n a profiling session.\n\n **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h."]
    pub fn cuptiProfilerDisableProfiling(
        pParams: *mut CUpti_Profiler_DisableProfiling_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiProfilerIsPassCollected"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_IsPassCollected_Params {
    #[doc = "!< [in] CUpti_Profiler_IsPassCollected_Params_STRUCT_SIZE"]
    pub structSize: usize,
    #[doc = "!< [in] assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = "!< [in] if NULL, the current CUcontext is used"]
    pub ctx: CUcontext,
    #[doc = "!< [out] number of ranges whose data was dropped in the processed pass"]
    pub numRangesDropped: usize,
    #[doc = "!< [out] number of bytes not written to TraceBuffer due to buffer full"]
    pub numTraceBytesDropped: usize,
    #[doc = "!< [out] true if a pass was successfully decoded"]
    pub onePassCollected: u8,
    #[doc = "!< [out] becomes true when the last pass has been decoded"]
    pub allPassesCollected: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_IsPassCollected_Params"]
        [::std::mem::size_of::<CUpti_Profiler_IsPassCollected_Params>() - 48usize];
    ["Alignment of CUpti_Profiler_IsPassCollected_Params"]
        [::std::mem::align_of::<CUpti_Profiler_IsPassCollected_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_IsPassCollected_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_IsPassCollected_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_IsPassCollected_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_IsPassCollected_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_IsPassCollected_Params::ctx"]
        [::std::mem::offset_of!(CUpti_Profiler_IsPassCollected_Params, ctx) - 16usize];
    ["Offset of field: CUpti_Profiler_IsPassCollected_Params::numRangesDropped"]
        [::std::mem::offset_of!(CUpti_Profiler_IsPassCollected_Params, numRangesDropped) - 24usize];
    ["Offset of field: CUpti_Profiler_IsPassCollected_Params::numTraceBytesDropped"][::std::mem::offset_of!(
        CUpti_Profiler_IsPassCollected_Params,
        numTraceBytesDropped
    ) - 32usize];
    ["Offset of field: CUpti_Profiler_IsPassCollected_Params::onePassCollected"]
        [::std::mem::offset_of!(CUpti_Profiler_IsPassCollected_Params, onePassCollected) - 40usize];
    ["Offset of field: CUpti_Profiler_IsPassCollected_Params::allPassesCollected"][::std::mem::offset_of!(
        CUpti_Profiler_IsPassCollected_Params,
        allPassesCollected
    ) - 41usize];
};
impl Default for CUpti_Profiler_IsPassCollected_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Asynchronous call to query if the submitted pass to GPU is collected\n\n **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h."]
    pub fn cuptiProfilerIsPassCollected(
        pParams: *mut CUpti_Profiler_IsPassCollected_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiProfilerFlushCounterData"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_FlushCounterData_Params {
    #[doc = "!< [in] CUpti_Profiler_FlushCounterData_Params_STRUCT_SIZE"]
    pub structSize: usize,
    #[doc = "!< [in] assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = "!< [in] if NULL, the current CUcontext is used"]
    pub ctx: CUcontext,
    #[doc = "!< [out] number of ranges whose data was dropped in the processed passes"]
    pub numRangesDropped: usize,
    #[doc = "!< [out] number of bytes not written to TraceBuffer due to buffer full"]
    pub numTraceBytesDropped: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_FlushCounterData_Params"]
        [::std::mem::size_of::<CUpti_Profiler_FlushCounterData_Params>() - 40usize];
    ["Alignment of CUpti_Profiler_FlushCounterData_Params"]
        [::std::mem::align_of::<CUpti_Profiler_FlushCounterData_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_FlushCounterData_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_FlushCounterData_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_FlushCounterData_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_FlushCounterData_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_FlushCounterData_Params::ctx"]
        [::std::mem::offset_of!(CUpti_Profiler_FlushCounterData_Params, ctx) - 16usize];
    ["Offset of field: CUpti_Profiler_FlushCounterData_Params::numRangesDropped"][::std::mem::offset_of!(
        CUpti_Profiler_FlushCounterData_Params,
        numRangesDropped
    ) - 24usize];
    ["Offset of field: CUpti_Profiler_FlushCounterData_Params::numTraceBytesDropped"][::std::mem::offset_of!(
        CUpti_Profiler_FlushCounterData_Params,
        numTraceBytesDropped
    ) - 32usize];
};
impl Default for CUpti_Profiler_FlushCounterData_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Decode all the submitted passes\n\n Flush Counter data API to ensure every pass is decoded into the counterDataImage passed at beginSession.\n This will cause the CPU/GPU sync to collect all the undecoded pass.\n\n **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h."]
    pub fn cuptiProfilerFlushCounterData(
        pParams: *mut CUpti_Profiler_FlushCounterData_Params,
    ) -> CUptiResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_PushRange_Params {
    #[doc = "!< [in] CUpti_Profiler_PushRange_Params_STRUCT_SIZE"]
    pub structSize: usize,
    #[doc = "!< [in] assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = "!< [in] if NULL, the current CUcontext is used"]
    pub ctx: CUcontext,
    #[doc = "!< [in] specifies the range for subsequent launches; must not be NULL"]
    pub pRangeName: *const ::std::os::raw::c_char,
    #[doc = "!< [in] assign to strlen(pRangeName) if known; if set to zero, the library will call strlen()"]
    pub rangeNameLength: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_PushRange_Params"]
        [::std::mem::size_of::<CUpti_Profiler_PushRange_Params>() - 40usize];
    ["Alignment of CUpti_Profiler_PushRange_Params"]
        [::std::mem::align_of::<CUpti_Profiler_PushRange_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_PushRange_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_PushRange_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_PushRange_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_PushRange_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_PushRange_Params::ctx"]
        [::std::mem::offset_of!(CUpti_Profiler_PushRange_Params, ctx) - 16usize];
    ["Offset of field: CUpti_Profiler_PushRange_Params::pRangeName"]
        [::std::mem::offset_of!(CUpti_Profiler_PushRange_Params, pRangeName) - 24usize];
    ["Offset of field: CUpti_Profiler_PushRange_Params::rangeNameLength"]
        [::std::mem::offset_of!(CUpti_Profiler_PushRange_Params, rangeNameLength) - 32usize];
};
impl Default for CUpti_Profiler_PushRange_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_PopRange_Params {
    #[doc = "!< [in] CUpti_Profiler_PopRange_Params_STRUCT_SIZE"]
    pub structSize: usize,
    #[doc = "!< [in] assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = "!< [in] if NULL, the current CUcontext is used"]
    pub ctx: CUcontext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_PopRange_Params"]
        [::std::mem::size_of::<CUpti_Profiler_PopRange_Params>() - 24usize];
    ["Alignment of CUpti_Profiler_PopRange_Params"]
        [::std::mem::align_of::<CUpti_Profiler_PopRange_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_PopRange_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_PopRange_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_PopRange_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_PopRange_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_PopRange_Params::ctx"]
        [::std::mem::offset_of!(CUpti_Profiler_PopRange_Params, ctx) - 16usize];
};
impl Default for CUpti_Profiler_PopRange_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Range API's : Push user range\n\n Counter data is collected per unique range-stack. Identified by a string label passsed by the user.\n It's an invalid operation in case of \\ref CUPTI_AutoRange.\n\n **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h."]
    pub fn cuptiProfilerPushRange(pParams: *mut CUpti_Profiler_PushRange_Params) -> CUptiResult;
}
unsafe extern "C" {
    #[doc = " \\brief Range API's : Pop user range\n\n Counter data is collected per unique range-stack. Identified by a string label passsed by the user.\n It's an invalid operation in case of \\ref CUPTI_AutoRange.\n\n **DEPRECATED** This function is deprecated as of CUDA 13.0 and will be removed in the future. It is recommended to use the Range Profiling API from the header cupti_range_profiler.h."]
    pub fn cuptiProfilerPopRange(pParams: *mut CUpti_Profiler_PopRange_Params) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiProfilerGetCounterAvailability"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_GetCounterAvailability_Params {
    #[doc = "!< [in] CUpti_Profiler_GetCounterAvailability_Params_STRUCT_SIZE"]
    pub structSize: usize,
    #[doc = "!< [in] assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = "!< [in] if NULL, the current CUcontext is used"]
    pub ctx: CUcontext,
    #[doc = "!< [in/out] If `pCounterAvailabilityImage` is NULL, then the required size is returned in\n!< `counterAvailabilityImageSize`, otherwise `counterAvailabilityImageSize` should be set to the size of\n!< `pCounterAvailabilityImage`, and on return it would be overwritten with number of actual bytes copied"]
    pub counterAvailabilityImageSize: usize,
    #[doc = "!< [in] buffer receiving counter availability image, may be NULL"]
    pub pCounterAvailabilityImage: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_GetCounterAvailability_Params"]
        [::std::mem::size_of::<CUpti_Profiler_GetCounterAvailability_Params>() - 40usize];
    ["Alignment of CUpti_Profiler_GetCounterAvailability_Params"]
        [::std::mem::align_of::<CUpti_Profiler_GetCounterAvailability_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_GetCounterAvailability_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_GetCounterAvailability_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_GetCounterAvailability_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_GetCounterAvailability_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_GetCounterAvailability_Params::ctx"]
        [::std::mem::offset_of!(CUpti_Profiler_GetCounterAvailability_Params, ctx) - 16usize];
    ["Offset of field: CUpti_Profiler_GetCounterAvailability_Params::counterAvailabilityImageSize"]
        [::std::mem::offset_of!(
            CUpti_Profiler_GetCounterAvailability_Params,
            counterAvailabilityImageSize
        ) - 24usize];
    ["Offset of field: CUpti_Profiler_GetCounterAvailability_Params::pCounterAvailabilityImage"][::std::mem::offset_of!(
        CUpti_Profiler_GetCounterAvailability_Params,
        pCounterAvailabilityImage
    )
        - 32usize];
};
impl Default for CUpti_Profiler_GetCounterAvailability_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Query counter availibility\n\n Use this API to query counter availability information in a buffer which can be used to filter unavailable raw metrics on host.\n Note: This API may fail, if any profiling or sampling session is active on the specified context or its device."]
    pub fn cuptiProfilerGetCounterAvailability(
        pParams: *mut CUpti_Profiler_GetCounterAvailability_Params,
    ) -> CUptiResult;
}
#[doc = "!< Configuration support level unknown - either detection code errored out before setting this value, or unable to determine it"]
pub const CUPTI_PROFILER_CONFIGURATION_UNKNOWN: CUpti_Profiler_Support_Level = 0;
#[doc = "!< Profiling is unavailable.  For specific feature fields, this means that the current configuration of this feature does not work with profiling.  For instance, SLI-enabled devices do not support profiling, and this value would be returned for SLI on an SLI-enabled device."]
pub const CUPTI_PROFILER_CONFIGURATION_UNSUPPORTED: CUpti_Profiler_Support_Level = 1;
#[doc = "!< Profiling would be available for this configuration, but was disabled by the system"]
pub const CUPTI_PROFILER_CONFIGURATION_DISABLED: CUpti_Profiler_Support_Level = 2;
#[doc = "!< Profiling is supported.  For specific feature fields, this means that the current configuration of this feature works with profiling.  For instance, SLI-enabled devices do not support profiling, and this value would only be returned for devices which are not SLI-enabled."]
pub const CUPTI_PROFILER_CONFIGURATION_SUPPORTED: CUpti_Profiler_Support_Level = 3;
#[doc = " Generic support level enum for CUPTI"]
pub type CUpti_Profiler_Support_Level = ::std::os::raw::c_uint;
#[doc = "!< CUPTI APIs for range based profiling (cuptiProfiler*)"]
pub const CUPTI_PROFILER_RANGE_PROFILING: CUpti_Profiler_API = 0;
#[doc = "!< CUPTI APIs collecting pc sampling data (cuptiPcSampling*)"]
pub const CUPTI_PROFILER_PC_SAMPLING: CUpti_Profiler_API = 1;
#[doc = "!< CUPTI APIs collecting SASS metrics data (cuptiSassMetrics*)"]
pub const CUPTI_PROFILER_SASS_METRICS: CUpti_Profiler_API = 2;
#[doc = "!< CUPTI APIs collecting PM Sampling data (cuptiPmSampling*)"]
pub const CUPTI_PROFILER_PM_SAMPLING: CUpti_Profiler_API = 3;
pub const CUPTI_PROFILER_UNKNOWN: CUpti_Profiler_API = 4;
#[doc = " \\brief Profiler API types"]
pub type CUpti_Profiler_API = ::std::os::raw::c_uint;
#[doc = " \\brief Params for cuptiProfilerDeviceSupported"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Profiler_DeviceSupported_Params {
    #[doc = "!< [in] Must be CUpti_Profiler_DeviceSupported_Params_STRUCT_SIZE"]
    pub structSize: usize,
    #[doc = "!< [in] assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = "!< [in] if NULL, the current CUcontext is used"]
    pub cuDevice: CUdevice,
    #[doc = "!< [out] overall SUPPORTED / UNSUPPORTED flag representing whether Profiling and PC Sampling APIs work on the given device and configuration. SUPPORTED if all following flags are SUPPORTED, UNSUPPORTED otherwise."]
    pub isSupported: CUpti_Profiler_Support_Level,
    #[doc = "!< [out] SUPPORTED if the device architecture level supports the Profiling API (Compute Capability >= 7.0), UNSUPPORTED otherwise"]
    pub architecture: CUpti_Profiler_Support_Level,
    #[doc = "!< [out] SUPPORTED if SLI is not enabled, UNSUPPORTED otherwise"]
    pub sli: CUpti_Profiler_Support_Level,
    #[doc = "!< [out] SUPPORTED if vGPU is supported and profiling is enabled, DISABLED if profiling is supported but not enabled, UNSUPPORTED otherwise"]
    pub vGpu: CUpti_Profiler_Support_Level,
    #[doc = "!< [out] SUPPORTED if confidential compute is not enabled, UNSUPPORTED otherwise"]
    pub confidentialCompute: CUpti_Profiler_Support_Level,
    #[doc = "!< [out] SUPPORTED if not NVIDIA Crypto Mining Processors (CMP), UNSUPPORTED otherwise"]
    pub cmp: CUpti_Profiler_Support_Level,
    #[doc = "!< [out] SUPPORTED if WSL supported, UNSUPPORTED otherwise"]
    pub wsl: CUpti_Profiler_Support_Level,
    #[doc = "!< [in] the CUPTI API type for which device support will be checked"]
    pub api: CUpti_Profiler_API,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Profiler_DeviceSupported_Params"]
        [::std::mem::size_of::<CUpti_Profiler_DeviceSupported_Params>() - 56usize];
    ["Alignment of CUpti_Profiler_DeviceSupported_Params"]
        [::std::mem::align_of::<CUpti_Profiler_DeviceSupported_Params>() - 8usize];
    ["Offset of field: CUpti_Profiler_DeviceSupported_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Profiler_DeviceSupported_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Profiler_DeviceSupported_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Profiler_DeviceSupported_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Profiler_DeviceSupported_Params::cuDevice"]
        [::std::mem::offset_of!(CUpti_Profiler_DeviceSupported_Params, cuDevice) - 16usize];
    ["Offset of field: CUpti_Profiler_DeviceSupported_Params::isSupported"]
        [::std::mem::offset_of!(CUpti_Profiler_DeviceSupported_Params, isSupported) - 20usize];
    ["Offset of field: CUpti_Profiler_DeviceSupported_Params::architecture"]
        [::std::mem::offset_of!(CUpti_Profiler_DeviceSupported_Params, architecture) - 24usize];
    ["Offset of field: CUpti_Profiler_DeviceSupported_Params::sli"]
        [::std::mem::offset_of!(CUpti_Profiler_DeviceSupported_Params, sli) - 28usize];
    ["Offset of field: CUpti_Profiler_DeviceSupported_Params::vGpu"]
        [::std::mem::offset_of!(CUpti_Profiler_DeviceSupported_Params, vGpu) - 32usize];
    ["Offset of field: CUpti_Profiler_DeviceSupported_Params::confidentialCompute"][::std::mem::offset_of!(
        CUpti_Profiler_DeviceSupported_Params,
        confidentialCompute
    ) - 36usize];
    ["Offset of field: CUpti_Profiler_DeviceSupported_Params::cmp"]
        [::std::mem::offset_of!(CUpti_Profiler_DeviceSupported_Params, cmp) - 40usize];
    ["Offset of field: CUpti_Profiler_DeviceSupported_Params::wsl"]
        [::std::mem::offset_of!(CUpti_Profiler_DeviceSupported_Params, wsl) - 44usize];
    ["Offset of field: CUpti_Profiler_DeviceSupported_Params::api"]
        [::std::mem::offset_of!(CUpti_Profiler_DeviceSupported_Params, api) - 48usize];
};
impl Default for CUpti_Profiler_DeviceSupported_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Query device compatibility with Profiling API\n\n Use this call to determine whether a compute device and configuration are compatible with the Profiling API.\n If the configuration does not support profiling, one of several flags will indicate why."]
    pub fn cuptiProfilerDeviceSupported(
        pParams: *mut CUpti_Profiler_DeviceSupported_Params,
    ) -> CUptiResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_Object {
    _unused: [u8; 0],
}
#[doc = " \\brief Params for cuptiRangeProfilerSetConfig"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_SetConfig_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Set to NULL."]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] Range Profiler Object."]
    pub pRangeProfilerObject: *mut CUpti_RangeProfiler_Object,
    #[doc = " [in] Size of the config image."]
    pub configSize: usize,
    #[doc = " [in] Config image."]
    pub pConfig: *const u8,
    #[doc = " [in] Size of the counter data image."]
    pub counterDataImageSize: usize,
    #[doc = " [in] Counter data image."]
    pub pCounterDataImage: *mut u8,
    #[doc = " [in] Profiling Range mode."]
    pub range: CUpti_ProfilerRange,
    #[doc = " [in] Replay mode."]
    pub replayMode: CUpti_ProfilerReplayMode,
    #[doc = " [in] Maximum number of ranges that can be profiled in a pass."]
    pub maxRangesPerPass: usize,
    #[doc = " [in] number of nesting level to be profiled. For Auto range mode, this should be set to 1."]
    pub numNestingLevels: u16,
    #[doc = " [in] minimum nesting level to be profiled."]
    pub minNestingLevel: u16,
    #[doc = " [in] Pass index for the replay session."]
    pub passIndex: usize,
    #[doc = " [in] Target nesting level for the replay session."]
    pub targetNestingLevel: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_RangeProfiler_SetConfig_Params"]
        [::std::mem::size_of::<CUpti_RangeProfiler_SetConfig_Params>() - 96usize];
    ["Alignment of CUpti_RangeProfiler_SetConfig_Params"]
        [::std::mem::align_of::<CUpti_RangeProfiler_SetConfig_Params>() - 8usize];
    ["Offset of field: CUpti_RangeProfiler_SetConfig_Params::structSize"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, structSize) - 0usize];
    ["Offset of field: CUpti_RangeProfiler_SetConfig_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_RangeProfiler_SetConfig_Params::pRangeProfilerObject"][::std::mem::offset_of!(
        CUpti_RangeProfiler_SetConfig_Params,
        pRangeProfilerObject
    ) - 16usize];
    ["Offset of field: CUpti_RangeProfiler_SetConfig_Params::configSize"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, configSize) - 24usize];
    ["Offset of field: CUpti_RangeProfiler_SetConfig_Params::pConfig"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, pConfig) - 32usize];
    ["Offset of field: CUpti_RangeProfiler_SetConfig_Params::counterDataImageSize"][::std::mem::offset_of!(
        CUpti_RangeProfiler_SetConfig_Params,
        counterDataImageSize
    ) - 40usize];
    ["Offset of field: CUpti_RangeProfiler_SetConfig_Params::pCounterDataImage"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, pCounterDataImage) - 48usize];
    ["Offset of field: CUpti_RangeProfiler_SetConfig_Params::range"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, range) - 56usize];
    ["Offset of field: CUpti_RangeProfiler_SetConfig_Params::replayMode"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, replayMode) - 60usize];
    ["Offset of field: CUpti_RangeProfiler_SetConfig_Params::maxRangesPerPass"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, maxRangesPerPass) - 64usize];
    ["Offset of field: CUpti_RangeProfiler_SetConfig_Params::numNestingLevels"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, numNestingLevels) - 72usize];
    ["Offset of field: CUpti_RangeProfiler_SetConfig_Params::minNestingLevel"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, minNestingLevel) - 74usize];
    ["Offset of field: CUpti_RangeProfiler_SetConfig_Params::passIndex"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_SetConfig_Params, passIndex) - 80usize];
    ["Offset of field: CUpti_RangeProfiler_SetConfig_Params::targetNestingLevel"][::std::mem::offset_of!(
        CUpti_RangeProfiler_SetConfig_Params,
        targetNestingLevel
    ) - 88usize];
};
impl Default for CUpti_RangeProfiler_SetConfig_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Set the configuration for range profiler like maximum number of ranges per pass, number of nesting levels,\n range and replay mode and the config image which has scheduling info for metric collection.\n\n \\param pParams A pointer to \\ref CUpti_RangeProfiler_SetConfig_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid"]
    pub fn cuptiRangeProfilerSetConfig(
        pParams: *mut CUpti_RangeProfiler_SetConfig_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiRangeProfilerEnable"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_Enable_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Set to NULL."]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] Context to be used for profiling."]
    pub ctx: CUcontext,
    #[doc = " [out] Range Profiler Object."]
    pub pRangeProfilerObject: *mut CUpti_RangeProfiler_Object,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_RangeProfiler_Enable_Params"]
        [::std::mem::size_of::<CUpti_RangeProfiler_Enable_Params>() - 32usize];
    ["Alignment of CUpti_RangeProfiler_Enable_Params"]
        [::std::mem::align_of::<CUpti_RangeProfiler_Enable_Params>() - 8usize];
    ["Offset of field: CUpti_RangeProfiler_Enable_Params::structSize"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_Enable_Params, structSize) - 0usize];
    ["Offset of field: CUpti_RangeProfiler_Enable_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_Enable_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_RangeProfiler_Enable_Params::ctx"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_Enable_Params, ctx) - 16usize];
    ["Offset of field: CUpti_RangeProfiler_Enable_Params::pRangeProfilerObject"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_Enable_Params, pRangeProfilerObject) - 24usize];
};
impl Default for CUpti_RangeProfiler_Enable_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Create a range profiler object and enable range profiling on the CUDA context.\n\n \\param pParams A pointer to \\ref CUpti_RangeProfiler_Enable_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_OUT_OF_MEMORY if memory allocation fails while creating the PM sampling object\n \\retval CUPTI_ERROR_INSUFFICIENT_PRIVILEGES if the user does not have sufficient privileges to perform the operation\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiRangeProfilerEnable(pParams: *mut CUpti_RangeProfiler_Enable_Params)
    -> CUptiResult;
}
#[doc = " \\brief Params for cuptiRangeProfilerDisable"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_Disable_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Set to NULL."]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] Range Profiler Object."]
    pub pRangeProfilerObject: *mut CUpti_RangeProfiler_Object,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_RangeProfiler_Disable_Params"]
        [::std::mem::size_of::<CUpti_RangeProfiler_Disable_Params>() - 24usize];
    ["Alignment of CUpti_RangeProfiler_Disable_Params"]
        [::std::mem::align_of::<CUpti_RangeProfiler_Disable_Params>() - 8usize];
    ["Offset of field: CUpti_RangeProfiler_Disable_Params::structSize"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_Disable_Params, structSize) - 0usize];
    ["Offset of field: CUpti_RangeProfiler_Disable_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_Disable_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_RangeProfiler_Disable_Params::pRangeProfilerObject"][::std::mem::offset_of!(
        CUpti_RangeProfiler_Disable_Params,
        pRangeProfilerObject
    ) - 16usize];
};
impl Default for CUpti_RangeProfiler_Disable_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Disable the range profiler on the CUDA context and destroy the range profiler object.\n\n \\param pParams A pointer to \\ref CUpti_RangeProfiler_Disable_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid"]
    pub fn cuptiRangeProfilerDisable(
        pParams: *mut CUpti_RangeProfiler_Disable_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiRangeProfilerStart"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_Start_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Set to NULL."]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] Range Profiler Object."]
    pub pRangeProfilerObject: *mut CUpti_RangeProfiler_Object,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_RangeProfiler_Start_Params"]
        [::std::mem::size_of::<CUpti_RangeProfiler_Start_Params>() - 24usize];
    ["Alignment of CUpti_RangeProfiler_Start_Params"]
        [::std::mem::align_of::<CUpti_RangeProfiler_Start_Params>() - 8usize];
    ["Offset of field: CUpti_RangeProfiler_Start_Params::structSize"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_Start_Params, structSize) - 0usize];
    ["Offset of field: CUpti_RangeProfiler_Start_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_Start_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_RangeProfiler_Start_Params::pRangeProfilerObject"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_Start_Params, pRangeProfilerObject) - 16usize];
};
impl Default for CUpti_RangeProfiler_Start_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Start the range profiler.\n\n \\param pParams A pointer to \\ref CUpti_RangeProfiler_Start_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_INVALID_OPERATION if range profiler Start is called without enabling range profiler\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiRangeProfilerStart(pParams: *mut CUpti_RangeProfiler_Start_Params) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiRangeProfilerStop"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_Stop_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Set to NULL."]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] Range Profiler Object."]
    pub pRangeProfilerObject: *mut CUpti_RangeProfiler_Object,
    #[doc = " [out] pass index for the replay session."]
    pub passIndex: usize,
    #[doc = " [out] target nesting level for the replay session."]
    pub targetNestingLevel: usize,
    #[doc = " [out] 1 if all passes are submitted to GPU for collection, 0 otherwise."]
    pub isAllPassSubmitted: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_RangeProfiler_Stop_Params"]
        [::std::mem::size_of::<CUpti_RangeProfiler_Stop_Params>() - 48usize];
    ["Alignment of CUpti_RangeProfiler_Stop_Params"]
        [::std::mem::align_of::<CUpti_RangeProfiler_Stop_Params>() - 8usize];
    ["Offset of field: CUpti_RangeProfiler_Stop_Params::structSize"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_Stop_Params, structSize) - 0usize];
    ["Offset of field: CUpti_RangeProfiler_Stop_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_Stop_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_RangeProfiler_Stop_Params::pRangeProfilerObject"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_Stop_Params, pRangeProfilerObject) - 16usize];
    ["Offset of field: CUpti_RangeProfiler_Stop_Params::passIndex"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_Stop_Params, passIndex) - 24usize];
    ["Offset of field: CUpti_RangeProfiler_Stop_Params::targetNestingLevel"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_Stop_Params, targetNestingLevel) - 32usize];
    ["Offset of field: CUpti_RangeProfiler_Stop_Params::isAllPassSubmitted"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_Stop_Params, isAllPassSubmitted) - 40usize];
};
impl Default for CUpti_RangeProfiler_Stop_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Stop the range profiler.\n\n \\param pParams A pointer to \\ref CUpti_RangeProfiler_Stop_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_INVALID_OPERATION if range profiler Stop is called without enabling range profiler\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiRangeProfilerStop(pParams: *mut CUpti_RangeProfiler_Stop_Params) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiRangeProfilerPushRange"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_PushRange_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Set to NULL."]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] Range Profiler Object."]
    pub pRangeProfilerObject: *mut CUpti_RangeProfiler_Object,
    #[doc = " [in] Name of the range to be profiled (only valid for User range mode)."]
    pub pRangeName: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_RangeProfiler_PushRange_Params"]
        [::std::mem::size_of::<CUpti_RangeProfiler_PushRange_Params>() - 32usize];
    ["Alignment of CUpti_RangeProfiler_PushRange_Params"]
        [::std::mem::align_of::<CUpti_RangeProfiler_PushRange_Params>() - 8usize];
    ["Offset of field: CUpti_RangeProfiler_PushRange_Params::structSize"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_PushRange_Params, structSize) - 0usize];
    ["Offset of field: CUpti_RangeProfiler_PushRange_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_PushRange_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_RangeProfiler_PushRange_Params::pRangeProfilerObject"][::std::mem::offset_of!(
        CUpti_RangeProfiler_PushRange_Params,
        pRangeProfilerObject
    ) - 16usize];
    ["Offset of field: CUpti_RangeProfiler_PushRange_Params::pRangeName"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_PushRange_Params, pRangeName) - 24usize];
};
impl Default for CUpti_RangeProfiler_PushRange_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Add a new range to the Range Profiler with a given range name.\n For nested ranges, this API should be called again for the innermost range. For profiling the nested\n range, users need to set the values for minNestingLevel and numNestingLevels in the SetConfig API.\n\n \\param pParams A pointer to \\ref CUpti_RangeProfiler_PushRange_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_INVALID_OPERATION if range profiler PushRange is called without enabling range profiler\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiRangeProfilerPushRange(
        pParams: *mut CUpti_RangeProfiler_PushRange_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiRangeProfilerPopRange"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_PopRange_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Set to NULL."]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] Range Profiler Object."]
    pub pRangeProfilerObject: *mut CUpti_RangeProfiler_Object,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_RangeProfiler_PopRange_Params"]
        [::std::mem::size_of::<CUpti_RangeProfiler_PopRange_Params>() - 24usize];
    ["Alignment of CUpti_RangeProfiler_PopRange_Params"]
        [::std::mem::align_of::<CUpti_RangeProfiler_PopRange_Params>() - 8usize];
    ["Offset of field: CUpti_RangeProfiler_PopRange_Params::structSize"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_PopRange_Params, structSize) - 0usize];
    ["Offset of field: CUpti_RangeProfiler_PopRange_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_PopRange_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_RangeProfiler_PopRange_Params::pRangeProfilerObject"][::std::mem::offset_of!(
        CUpti_RangeProfiler_PopRange_Params,
        pRangeProfilerObject
    ) - 16usize];
};
impl Default for CUpti_RangeProfiler_PopRange_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief pop the current range to the Range Profiler.\n The number of pop range API call should be same as number of push ranges in the same order.\n\n \\param pParams A pointer to \\ref CUpti_RangeProfiler_PopRange_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_INVALID_OPERATION if range profiler PopRange is called without enabling range profiler\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiRangeProfilerPopRange(
        pParams: *mut CUpti_RangeProfiler_PopRange_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiRangeProfilerDecodeData"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_DecodeData_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Set to NULL."]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] Range Profiler Object."]
    pub pRangeProfilerObject: *mut CUpti_RangeProfiler_Object,
    #[doc = " [out] Number of ranges dropped in the processed passes."]
    pub numOfRangeDropped: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_RangeProfiler_DecodeData_Params"]
        [::std::mem::size_of::<CUpti_RangeProfiler_DecodeData_Params>() - 32usize];
    ["Alignment of CUpti_RangeProfiler_DecodeData_Params"]
        [::std::mem::align_of::<CUpti_RangeProfiler_DecodeData_Params>() - 8usize];
    ["Offset of field: CUpti_RangeProfiler_DecodeData_Params::structSize"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_DecodeData_Params, structSize) - 0usize];
    ["Offset of field: CUpti_RangeProfiler_DecodeData_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_DecodeData_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_RangeProfiler_DecodeData_Params::pRangeProfilerObject"][::std::mem::offset_of!(
        CUpti_RangeProfiler_DecodeData_Params,
        pRangeProfilerObject
    ) - 16usize];
    ["Offset of field: CUpti_RangeProfiler_DecodeData_Params::numOfRangeDropped"][::std::mem::offset_of!(
        CUpti_RangeProfiler_DecodeData_Params,
        numOfRangeDropped
    ) - 24usize];
};
impl Default for CUpti_RangeProfiler_DecodeData_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Decode the profiling data stored in the hardware to the counter data image passed in the\n SetConfig API. This API should be called after cuptiRangeProfilerStop. The counter data image\n will be updated with the profiling data for the ranges profiled.\n\n For the cases where the number of ranges counter data image can store is less than the number of ranges\n profiled (= maxRangesPerPass in SetConfig API), the counter data image will report dropped ranges.\n\n \\param pParams A pointer to \\ref CUpti_RangeProfiler_DecodeData_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_INVALID_OPERATION if range profiler DecodeData is called without enabling range profiler\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiRangeProfilerDecodeData(
        pParams: *mut CUpti_RangeProfiler_DecodeData_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiRangeProfilerGetCounterDataSize"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_GetCounterDataSize_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Set to NULL."]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] Periodic sampler object."]
    pub pRangeProfilerObject: *mut CUpti_RangeProfiler_Object,
    #[doc = " [in] Names of the metrics to be collected."]
    pub pMetricNames: *mut *const ::std::os::raw::c_char,
    #[doc = " [in] Number of metrics to be collected."]
    pub numMetrics: usize,
    #[doc = " [in] Maximum number of ranges to be stored in the counter data image."]
    pub maxNumOfRanges: usize,
    #[doc = " [in] Maximum number of RangeTree nodes; must be >= maxNumOfRanges"]
    pub maxNumRangeTreeNodes: u32,
    #[doc = " [out] Size of the counter data image."]
    pub counterDataSize: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_RangeProfiler_GetCounterDataSize_Params"]
        [::std::mem::size_of::<CUpti_RangeProfiler_GetCounterDataSize_Params>() - 64usize];
    ["Alignment of CUpti_RangeProfiler_GetCounterDataSize_Params"]
        [::std::mem::align_of::<CUpti_RangeProfiler_GetCounterDataSize_Params>() - 8usize];
    ["Offset of field: CUpti_RangeProfiler_GetCounterDataSize_Params::structSize"][::std::mem::offset_of!(
        CUpti_RangeProfiler_GetCounterDataSize_Params,
        structSize
    ) - 0usize];
    ["Offset of field: CUpti_RangeProfiler_GetCounterDataSize_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_GetCounterDataSize_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_RangeProfiler_GetCounterDataSize_Params::pRangeProfilerObject"][::std::mem::offset_of!(
        CUpti_RangeProfiler_GetCounterDataSize_Params,
        pRangeProfilerObject
    )
        - 16usize];
    ["Offset of field: CUpti_RangeProfiler_GetCounterDataSize_Params::pMetricNames"][::std::mem::offset_of!(
        CUpti_RangeProfiler_GetCounterDataSize_Params,
        pMetricNames
    ) - 24usize];
    ["Offset of field: CUpti_RangeProfiler_GetCounterDataSize_Params::numMetrics"][::std::mem::offset_of!(
        CUpti_RangeProfiler_GetCounterDataSize_Params,
        numMetrics
    ) - 32usize];
    ["Offset of field: CUpti_RangeProfiler_GetCounterDataSize_Params::maxNumOfRanges"][::std::mem::offset_of!(
        CUpti_RangeProfiler_GetCounterDataSize_Params,
        maxNumOfRanges
    ) - 40usize];
    ["Offset of field: CUpti_RangeProfiler_GetCounterDataSize_Params::maxNumRangeTreeNodes"][::std::mem::offset_of!(
        CUpti_RangeProfiler_GetCounterDataSize_Params,
        maxNumRangeTreeNodes
    )
        - 48usize];
    ["Offset of field: CUpti_RangeProfiler_GetCounterDataSize_Params::counterDataSize"][::std::mem::offset_of!(
        CUpti_RangeProfiler_GetCounterDataSize_Params,
        counterDataSize
    )
        - 56usize];
};
impl Default for CUpti_RangeProfiler_GetCounterDataSize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Get the size of the counter data image required to store the profiling data for the ranges profiled.\n\n \\param pParams A pointer to \\ref CUpti_RangeProfiler_GetCounterDataSize_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_INVALID_OPERATION if range profiler GetCounterDataSize is called without enabling range profiler\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiRangeProfilerGetCounterDataSize(
        pParams: *mut CUpti_RangeProfiler_GetCounterDataSize_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiRangeProfilerCounterDataImageInitialize"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_CounterDataImage_Initialize_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Set to NULL."]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] Periodic sampler object."]
    pub pRangeProfilerObject: *mut CUpti_RangeProfiler_Object,
    #[doc = " [in] Size of the counter data image."]
    pub counterDataSize: usize,
    #[doc = " [in] Counter data image."]
    pub pCounterData: *mut u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_RangeProfiler_CounterDataImage_Initialize_Params"]
        [::std::mem::size_of::<CUpti_RangeProfiler_CounterDataImage_Initialize_Params>() - 40usize];
    ["Alignment of CUpti_RangeProfiler_CounterDataImage_Initialize_Params"]
        [::std::mem::align_of::<CUpti_RangeProfiler_CounterDataImage_Initialize_Params>() - 8usize];
    ["Offset of field: CUpti_RangeProfiler_CounterDataImage_Initialize_Params::structSize"][::std::mem::offset_of!(
        CUpti_RangeProfiler_CounterDataImage_Initialize_Params,
        structSize
    )
        - 0usize];
    ["Offset of field: CUpti_RangeProfiler_CounterDataImage_Initialize_Params::pPriv"][::std::mem::offset_of!(
        CUpti_RangeProfiler_CounterDataImage_Initialize_Params,
        pPriv
    ) - 8usize];
    [
        "Offset of field: CUpti_RangeProfiler_CounterDataImage_Initialize_Params::pRangeProfilerObject",
    ][::std::mem::offset_of!(
        CUpti_RangeProfiler_CounterDataImage_Initialize_Params,
        pRangeProfilerObject
    ) - 16usize];
    ["Offset of field: CUpti_RangeProfiler_CounterDataImage_Initialize_Params::counterDataSize"][::std::mem::offset_of!(
        CUpti_RangeProfiler_CounterDataImage_Initialize_Params,
        counterDataSize
    )
        - 24usize];
    ["Offset of field: CUpti_RangeProfiler_CounterDataImage_Initialize_Params::pCounterData"][::std::mem::offset_of!(
        CUpti_RangeProfiler_CounterDataImage_Initialize_Params,
        pCounterData
    )
        - 32usize];
};
impl Default for CUpti_RangeProfiler_CounterDataImage_Initialize_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Initialize the counter data image with the profiling data for the ranges profiled.\n\n \\param pParams A pointer to \\ref CUpti_RangeProfiler_CounterDataImage_Initialize_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_INVALID_OPERATION if range profiler CounterDataImageInitialize is called without enabling range profiler\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiRangeProfilerCounterDataImageInitialize(
        pParams: *mut CUpti_RangeProfiler_CounterDataImage_Initialize_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiRangeProfilerGetCounterDataInfo"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_GetCounterDataInfo_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Set to NULL."]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] Counter data image."]
    pub pCounterDataImage: *const u8,
    #[doc = " [in] Size of the counter data image."]
    pub counterDataImageSize: usize,
    #[doc = " [out] Number of ranges in the counter data image."]
    pub numTotalRanges: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_RangeProfiler_GetCounterDataInfo_Params"]
        [::std::mem::size_of::<CUpti_RangeProfiler_GetCounterDataInfo_Params>() - 40usize];
    ["Alignment of CUpti_RangeProfiler_GetCounterDataInfo_Params"]
        [::std::mem::align_of::<CUpti_RangeProfiler_GetCounterDataInfo_Params>() - 8usize];
    ["Offset of field: CUpti_RangeProfiler_GetCounterDataInfo_Params::structSize"][::std::mem::offset_of!(
        CUpti_RangeProfiler_GetCounterDataInfo_Params,
        structSize
    ) - 0usize];
    ["Offset of field: CUpti_RangeProfiler_GetCounterDataInfo_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_RangeProfiler_GetCounterDataInfo_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_RangeProfiler_GetCounterDataInfo_Params::pCounterDataImage"][::std::mem::offset_of!(
        CUpti_RangeProfiler_GetCounterDataInfo_Params,
        pCounterDataImage
    )
        - 16usize];
    ["Offset of field: CUpti_RangeProfiler_GetCounterDataInfo_Params::counterDataImageSize"][::std::mem::offset_of!(
        CUpti_RangeProfiler_GetCounterDataInfo_Params,
        counterDataImageSize
    )
        - 24usize];
    ["Offset of field: CUpti_RangeProfiler_GetCounterDataInfo_Params::numTotalRanges"][::std::mem::offset_of!(
        CUpti_RangeProfiler_GetCounterDataInfo_Params,
        numTotalRanges
    ) - 32usize];
};
impl Default for CUpti_RangeProfiler_GetCounterDataInfo_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Get the number of ranges stored in the counter data image.\n\n \\param pParams A pointer to \\ref CUpti_RangeProfiler_GetCounterDataInfo_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiRangeProfilerGetCounterDataInfo(
        pParams: *mut CUpti_RangeProfiler_GetCounterDataInfo_Params,
    ) -> CUptiResult;
}
#[doc = " \\brief Params for cuptiRangeProfilerCounterDataGetRangeInfo"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_RangeProfiler_CounterData_GetRangeInfo_Params {
    #[doc = " [in] Size of the data structure."]
    pub structSize: usize,
    #[doc = " [in] Set to NULL."]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = " [in] Counter data image."]
    pub pCounterDataImage: *const u8,
    #[doc = " [in] Size of the counter data image."]
    pub counterDataImageSize: usize,
    #[doc = " [in] Index of the sample."]
    pub rangeIndex: usize,
    #[doc = " [in] range delimiter."]
    pub rangeDelimiter: *const ::std::os::raw::c_char,
    #[doc = " [out] RangeName;"]
    pub rangeName: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_RangeProfiler_CounterData_GetRangeInfo_Params"]
        [::std::mem::size_of::<CUpti_RangeProfiler_CounterData_GetRangeInfo_Params>() - 56usize];
    ["Alignment of CUpti_RangeProfiler_CounterData_GetRangeInfo_Params"]
        [::std::mem::align_of::<CUpti_RangeProfiler_CounterData_GetRangeInfo_Params>() - 8usize];
    ["Offset of field: CUpti_RangeProfiler_CounterData_GetRangeInfo_Params::structSize"][::std::mem::offset_of!(
        CUpti_RangeProfiler_CounterData_GetRangeInfo_Params,
        structSize
    )
        - 0usize];
    ["Offset of field: CUpti_RangeProfiler_CounterData_GetRangeInfo_Params::pPriv"][::std::mem::offset_of!(
        CUpti_RangeProfiler_CounterData_GetRangeInfo_Params,
        pPriv
    ) - 8usize];
    ["Offset of field: CUpti_RangeProfiler_CounterData_GetRangeInfo_Params::pCounterDataImage"][::std::mem::offset_of!(
        CUpti_RangeProfiler_CounterData_GetRangeInfo_Params,
        pCounterDataImage
    )
        - 16usize];
    ["Offset of field: CUpti_RangeProfiler_CounterData_GetRangeInfo_Params::counterDataImageSize"]
        [::std::mem::offset_of!(
            CUpti_RangeProfiler_CounterData_GetRangeInfo_Params,
            counterDataImageSize
        ) - 24usize];
    ["Offset of field: CUpti_RangeProfiler_CounterData_GetRangeInfo_Params::rangeIndex"][::std::mem::offset_of!(
        CUpti_RangeProfiler_CounterData_GetRangeInfo_Params,
        rangeIndex
    )
        - 32usize];
    ["Offset of field: CUpti_RangeProfiler_CounterData_GetRangeInfo_Params::rangeDelimiter"][::std::mem::offset_of!(
        CUpti_RangeProfiler_CounterData_GetRangeInfo_Params,
        rangeDelimiter
    )
        - 40usize];
    ["Offset of field: CUpti_RangeProfiler_CounterData_GetRangeInfo_Params::rangeName"][::std::mem::offset_of!(
        CUpti_RangeProfiler_CounterData_GetRangeInfo_Params,
        rangeName
    )
        - 48usize];
};
impl Default for CUpti_RangeProfiler_CounterData_GetRangeInfo_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " \\brief Get the range name for the given range index.\n\n \\param pParams A pointer to \\ref CUpti_RangeProfiler_CounterData_GetRangeInfo_Params\n\n \\retval CUPTI_SUCCESS\n \\retval CUPTI_ERROR_INVALID_PARAMETER if any \\p pParams is not valid\n \\retval CUPTI_ERROR_UNKNOWN for any internal error"]
    pub fn cuptiRangeProfilerCounterDataGetRangeInfo(
        pParams: *mut CUpti_RangeProfiler_CounterData_GetRangeInfo_Params,
    ) -> CUptiResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUpti_Device_GetChipName_Params {
    #[doc = "!< [in]"]
    pub structSize: usize,
    #[doc = "!< [in] assign to NULL"]
    pub pPriv: *mut ::std::os::raw::c_void,
    #[doc = "!< [in]"]
    pub deviceIndex: usize,
    #[doc = "!< [out]"]
    pub pChipName: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of CUpti_Device_GetChipName_Params"]
        [::std::mem::size_of::<CUpti_Device_GetChipName_Params>() - 32usize];
    ["Alignment of CUpti_Device_GetChipName_Params"]
        [::std::mem::align_of::<CUpti_Device_GetChipName_Params>() - 8usize];
    ["Offset of field: CUpti_Device_GetChipName_Params::structSize"]
        [::std::mem::offset_of!(CUpti_Device_GetChipName_Params, structSize) - 0usize];
    ["Offset of field: CUpti_Device_GetChipName_Params::pPriv"]
        [::std::mem::offset_of!(CUpti_Device_GetChipName_Params, pPriv) - 8usize];
    ["Offset of field: CUpti_Device_GetChipName_Params::deviceIndex"]
        [::std::mem::offset_of!(CUpti_Device_GetChipName_Params, deviceIndex) - 16usize];
    ["Offset of field: CUpti_Device_GetChipName_Params::pChipName"]
        [::std::mem::offset_of!(CUpti_Device_GetChipName_Params, pChipName) - 24usize];
};
impl Default for CUpti_Device_GetChipName_Params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn cuptiDeviceGetChipName(pParams: *mut CUpti_Device_GetChipName_Params) -> CUptiResult;
}
